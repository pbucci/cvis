<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Bokeh Plot</title>
        
        <style>
            /* BEGIN /Users/bucci/anaconda/lib/python2.7/site-packages/bokeh/server/static/css/bokeh.css */
                /*! jQuery UI - v1.10.0 - 2013-01-17
                * http://jqueryui.com
                * Includes: jquery.ui.core.css, jquery.ui.accordion.css, jquery.ui.autocomplete.css, jquery.ui.button.css, jquery.ui.datepicker.css, jquery.ui.dialog.css, jquery.ui.menu.css, jquery.ui.progressbar.css, jquery.ui.resizable.css, jquery.ui.selectable.css, jquery.ui.slider.css, jquery.ui.spinner.css, jquery.ui.tabs.css, jquery.ui.tooltip.css, jquery.ui.theme.css
                * Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
                
                /* Layout helpers
                ----------------------------------*/
                .ui-helper-hidden {
                	display: none;
                }
                .ui-helper-hidden-accessible {
                	border: 0;
                	clip: rect(0 0 0 0);
                	height: 1px;
                	margin: -1px;
                	overflow: hidden;
                	padding: 0;
                	position: absolute;
                	width: 1px;
                }
                .ui-helper-reset {
                	margin: 0;
                	padding: 0;
                	border: 0;
                	outline: 0;
                	line-height: 1.3;
                	text-decoration: none;
                	font-size: 100%;
                	list-style: none;
                }
                .ui-helper-clearfix:before,
                .ui-helper-clearfix:after {
                	content: "";
                	display: table;
                }
                .ui-helper-clearfix:after {
                	clear: both;
                }
                .ui-helper-clearfix {
                	min-height: 0; /* support: IE7 */
                }
                .ui-helper-zfix {
                	width: 100%;
                	height: 100%;
                	top: 0;
                	left: 0;
                	position: absolute;
                	opacity: 0;
                	filter:Alpha(Opacity=0);
                }
                
                .ui-front {
                	z-index: 100;
                }
                
                
                /* Interaction Cues
                ----------------------------------*/
                .ui-state-disabled {
                	cursor: default !important;
                }
                
                
                /* Icons
                ----------------------------------*/
                
                /* states and images */
                .ui-icon {
                	display: block;
                	text-indent: -99999px;
                	overflow: hidden;
                	background-repeat: no-repeat;
                }
                
                
                /* Misc visuals
                ----------------------------------*/
                
                /* Overlays */
                .ui-widget-overlay {
                	position: fixed;
                	top: 0;
                	left: 0;
                	width: 100%;
                	height: 100%;
                }
                
                .ui-accordion .ui-accordion-header {
                	display: block;
                	cursor: pointer;
                	position: relative;
                	margin-top: 2px;
                	padding: .5em .5em .5em .7em;
                	min-height: 0; /* support: IE7 */
                }
                .ui-accordion .ui-accordion-icons {
                	padding-left: 2.2em;
                }
                .ui-accordion .ui-accordion-noicons {
                	padding-left: .7em;
                }
                .ui-accordion .ui-accordion-icons .ui-accordion-icons {
                	padding-left: 2.2em;
                }
                .ui-accordion .ui-accordion-header .ui-accordion-header-icon {
                	position: absolute;
                	left: .5em;
                	top: 50%;
                	margin-top: -8px;
                }
                .ui-accordion .ui-accordion-content {
                	padding: 1em 2.2em;
                	border-top: 0;
                	overflow: auto;
                }
                
                .ui-autocomplete {
                	position: absolute;
                	top: 0;
                	left: 0;
                	cursor: default;
                }
                
                .ui-button {
                	display: inline-block;
                	position: relative;
                	padding: 0;
                	line-height: normal;
                	margin-right: .1em;
                	cursor: pointer;
                	vertical-align: middle;
                	text-align: center;
                	overflow: visible; /* removes extra width in IE */
                }
                .ui-button,
                .ui-button:link,
                .ui-button:visited,
                .ui-button:hover,
                .ui-button:active {
                	text-decoration: none;
                }
                /* to make room for the icon, a width needs to be set here */
                .ui-button-icon-only {
                	width: 2.2em;
                }
                /* button elements seem to need a little more width */
                button.ui-button-icon-only {
                	width: 2.4em;
                }
                .ui-button-icons-only {
                	width: 3.4em;
                }
                button.ui-button-icons-only {
                	width: 3.7em;
                }
                
                /* button text element */
                .ui-button .ui-button-text {
                	display: block;
                	line-height: normal;
                }
                .ui-button-text-only .ui-button-text {
                	padding: .4em 1em;
                }
                .ui-button-icon-only .ui-button-text,
                .ui-button-icons-only .ui-button-text {
                	padding: .4em;
                	text-indent: -9999999px;
                }
                .ui-button-text-icon-primary .ui-button-text,
                .ui-button-text-icons .ui-button-text {
                	padding: .4em 1em .4em 2.1em;
                }
                .ui-button-text-icon-secondary .ui-button-text,
                .ui-button-text-icons .ui-button-text {
                	padding: .4em 2.1em .4em 1em;
                }
                .ui-button-text-icons .ui-button-text {
                	padding-left: 2.1em;
                	padding-right: 2.1em;
                }
                /* no icon support for input elements, provide padding by default */
                input.ui-button {
                	padding: .4em 1em;
                }
                
                /* button icon element(s) */
                .ui-button-icon-only .ui-icon,
                .ui-button-text-icon-primary .ui-icon,
                .ui-button-text-icon-secondary .ui-icon,
                .ui-button-text-icons .ui-icon,
                .ui-button-icons-only .ui-icon {
                	position: absolute;
                	top: 50%;
                	margin-top: -8px;
                }
                .ui-button-icon-only .ui-icon {
                	left: 50%;
                	margin-left: -8px;
                }
                .ui-button-text-icon-primary .ui-button-icon-primary,
                .ui-button-text-icons .ui-button-icon-primary,
                .ui-button-icons-only .ui-button-icon-primary {
                	left: .5em;
                }
                .ui-button-text-icon-secondary .ui-button-icon-secondary,
                .ui-button-text-icons .ui-button-icon-secondary,
                .ui-button-icons-only .ui-button-icon-secondary {
                	right: .5em;
                }
                
                /* button sets */
                .ui-buttonset {
                	margin-right: 7px;
                }
                .ui-buttonset .ui-button {
                	margin-left: 0;
                	margin-right: -.3em;
                }
                
                /* workarounds */
                /* reset extra padding in Firefox, see h5bp.com/l */
                input.ui-button::-moz-focus-inner,
                button.ui-button::-moz-focus-inner {
                	border: 0;
                	padding: 0;
                }
                
                .ui-datepicker {
                	width: 17em;
                	padding: .2em .2em 0;
                	display: none;
                }
                .ui-datepicker .ui-datepicker-header {
                	position: relative;
                	padding: .2em 0;
                }
                .ui-datepicker .ui-datepicker-prev,
                .ui-datepicker .ui-datepicker-next {
                	position: absolute;
                	top: 2px;
                	width: 1.8em;
                	height: 1.8em;
                }
                .ui-datepicker .ui-datepicker-prev-hover,
                .ui-datepicker .ui-datepicker-next-hover {
                	top: 1px;
                }
                .ui-datepicker .ui-datepicker-prev {
                	left: 2px;
                }
                .ui-datepicker .ui-datepicker-next {
                	right: 2px;
                }
                .ui-datepicker .ui-datepicker-prev-hover {
                	left: 1px;
                }
                .ui-datepicker .ui-datepicker-next-hover {
                	right: 1px;
                }
                .ui-datepicker .ui-datepicker-prev span,
                .ui-datepicker .ui-datepicker-next span {
                	display: block;
                	position: absolute;
                	left: 50%;
                	margin-left: -8px;
                	top: 50%;
                	margin-top: -8px;
                }
                .ui-datepicker .ui-datepicker-title {
                	margin: 0 2.3em;
                	line-height: 1.8em;
                	text-align: center;
                }
                .ui-datepicker .ui-datepicker-title select {
                	font-size: 1em;
                	margin: 1px 0;
                }
                .ui-datepicker select.ui-datepicker-month-year {
                	width: 100%;
                }
                .ui-datepicker select.ui-datepicker-month,
                .ui-datepicker select.ui-datepicker-year {
                	width: 49%;
                }
                .ui-datepicker table {
                	width: 100%;
                	font-size: .9em;
                	border-collapse: collapse;
                	margin: 0 0 .4em;
                }
                .ui-datepicker th {
                	padding: .7em .3em;
                	text-align: center;
                	font-weight: bold;
                	border: 0;
                }
                .ui-datepicker td {
                	border: 0;
                	padding: 1px;
                }
                .ui-datepicker td span,
                .ui-datepicker td a {
                	display: block;
                	padding: .2em;
                	text-align: right;
                	text-decoration: none;
                }
                .ui-datepicker .ui-datepicker-buttonpane {
                	background-image: none;
                	margin: .7em 0 0 0;
                	padding: 0 .2em;
                	border-left: 0;
                	border-right: 0;
                	border-bottom: 0;
                }
                .ui-datepicker .ui-datepicker-buttonpane button {
                	float: right;
                	margin: .5em .2em .4em;
                	cursor: pointer;
                	padding: .2em .6em .3em .6em;
                	width: auto;
                	overflow: visible;
                }
                .ui-datepicker .ui-datepicker-buttonpane button.ui-datepicker-current {
                	float: left;
                }
                
                /* with multiple calendars */
                .ui-datepicker.ui-datepicker-multi {
                	width: auto;
                }
                .ui-datepicker-multi .ui-datepicker-group {
                	float: left;
                }
                .ui-datepicker-multi .ui-datepicker-group table {
                	width: 95%;
                	margin: 0 auto .4em;
                }
                .ui-datepicker-multi-2 .ui-datepicker-group {
                	width: 50%;
                }
                .ui-datepicker-multi-3 .ui-datepicker-group {
                	width: 33.3%;
                }
                .ui-datepicker-multi-4 .ui-datepicker-group {
                	width: 25%;
                }
                .ui-datepicker-multi .ui-datepicker-group-last .ui-datepicker-header,
                .ui-datepicker-multi .ui-datepicker-group-middle .ui-datepicker-header {
                	border-left-width: 0;
                }
                .ui-datepicker-multi .ui-datepicker-buttonpane {
                	clear: left;
                }
                .ui-datepicker-row-break {
                	clear: both;
                	width: 100%;
                	font-size: 0;
                }
                
                /* RTL support */
                .ui-datepicker-rtl {
                	direction: rtl;
                }
                .ui-datepicker-rtl .ui-datepicker-prev {
                	right: 2px;
                	left: auto;
                }
                .ui-datepicker-rtl .ui-datepicker-next {
                	left: 2px;
                	right: auto;
                }
                .ui-datepicker-rtl .ui-datepicker-prev:hover {
                	right: 1px;
                	left: auto;
                }
                .ui-datepicker-rtl .ui-datepicker-next:hover {
                	left: 1px;
                	right: auto;
                }
                .ui-datepicker-rtl .ui-datepicker-buttonpane {
                	clear: right;
                }
                .ui-datepicker-rtl .ui-datepicker-buttonpane button {
                	float: left;
                }
                .ui-datepicker-rtl .ui-datepicker-buttonpane button.ui-datepicker-current,
                .ui-datepicker-rtl .ui-datepicker-group {
                	float: right;
                }
                .ui-datepicker-rtl .ui-datepicker-group-last .ui-datepicker-header,
                .ui-datepicker-rtl .ui-datepicker-group-middle .ui-datepicker-header {
                	border-right-width: 0;
                	border-left-width: 1px;
                }
                
                .ui-dialog {
                	position: absolute;
                	top: 0;
                	left: 0;
                	padding: .2em;
                	outline: 0;
                }
                .ui-dialog .ui-dialog-titlebar {
                	padding: .4em 1em;
                	position: relative;
                }
                .ui-dialog .ui-dialog-title {
                	float: left;
                	margin: .1em 0;
                	white-space: nowrap;
                	width: 90%;
                	overflow: hidden;
                	text-overflow: ellipsis;
                }
                .ui-dialog .ui-dialog-titlebar-close {
                	position: absolute;
                	right: .3em;
                	top: 50%;
                	width: 21px;
                	margin: -10px 0 0 0;
                	padding: 1px;
                	height: 20px;
                }
                .ui-dialog .ui-dialog-content {
                	position: relative;
                	border: 0;
                	padding: .5em 1em;
                	background: none;
                	overflow: auto;
                }
                .ui-dialog .ui-dialog-buttonpane {
                	text-align: left;
                	border-width: 1px 0 0 0;
                	background-image: none;
                	margin-top: .5em;
                	padding: .3em 1em .5em .4em;
                }
                .ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset {
                	float: right;
                }
                .ui-dialog .ui-dialog-buttonpane button {
                	margin: .5em .4em .5em 0;
                	cursor: pointer;
                }
                .ui-dialog .ui-resizable-se {
                	width: 12px;
                	height: 12px;
                	right: -5px;
                	bottom: -5px;
                	background-position: 16px 16px;
                }
                .ui-draggable .ui-dialog-titlebar {
                	cursor: move;
                }
                
                .ui-menu {
                	list-style: none;
                	padding: 2px;
                	margin: 0;
                	display: block;
                	outline: none;
                }
                .ui-menu .ui-menu {
                	margin-top: -3px;
                	position: absolute;
                }
                .ui-menu .ui-menu-item {
                	margin: 0;
                	padding: 0;
                	width: 100%;
                }
                .ui-menu .ui-menu-divider {
                	margin: 5px -2px 5px -2px;
                	height: 0;
                	font-size: 0;
                	line-height: 0;
                	border-width: 1px 0 0 0;
                }
                .ui-menu .ui-menu-item a {
                	text-decoration: none;
                	display: block;
                	padding: 2px .4em;
                	line-height: 1.5;
                	min-height: 0; /* support: IE7 */
                	font-weight: normal;
                }
                .ui-menu .ui-menu-item a.ui-state-focus,
                .ui-menu .ui-menu-item a.ui-state-active {
                	font-weight: normal;
                	margin: -1px;
                }
                
                .ui-menu .ui-state-disabled {
                	font-weight: normal;
                	margin: .4em 0 .2em;
                	line-height: 1.5;
                }
                .ui-menu .ui-state-disabled a {
                	cursor: default;
                }
                
                /* icon support */
                .ui-menu-icons {
                	position: relative;
                }
                .ui-menu-icons .ui-menu-item a {
                	position: relative;
                	padding-left: 2em;
                }
                
                /* left-aligned */
                .ui-menu .ui-icon {
                	position: absolute;
                	top: .2em;
                	left: .2em;
                }
                
                /* right-aligned */
                .ui-menu .ui-menu-icon {
                	position: static;
                	float: right;
                }
                
                .ui-progressbar {
                	height: 2em;
                	text-align: left;
                	overflow: hidden;
                }
                .ui-progressbar .ui-progressbar-value {
                	margin: -1px;
                	height: 100%;
                }
                .ui-progressbar .ui-progressbar-overlay {
                	background: url("images/animated-overlay.gif");
                	height: 100%;
                	filter: alpha(opacity=25);
                	opacity: 0.25;
                }
                .ui-progressbar-indeterminate .ui-progressbar-value {
                	background-image: none;
                }
                
                .ui-resizable {
                	position: relative;
                }
                .ui-resizable-handle {
                	position: absolute;
                	font-size: 0.1px;
                	display: block;
                }
                .ui-resizable-disabled .ui-resizable-handle,
                .ui-resizable-autohide .ui-resizable-handle {
                	display: none;
                }
                .ui-resizable-n {
                	cursor: n-resize;
                	height: 7px;
                	width: 100%;
                	top: -5px;
                	left: 0;
                }
                .ui-resizable-s {
                	cursor: s-resize;
                	height: 7px;
                	width: 100%;
                	bottom: -5px;
                	left: 0;
                }
                .ui-resizable-e {
                	cursor: e-resize;
                	width: 7px;
                	right: -5px;
                	top: 0;
                	height: 100%;
                }
                .ui-resizable-w {
                	cursor: w-resize;
                	width: 7px;
                	left: -5px;
                	top: 0;
                	height: 100%;
                }
                .ui-resizable-se {
                	cursor: se-resize;
                	width: 12px;
                	height: 12px;
                	right: 1px;
                	bottom: 1px;
                }
                .ui-resizable-sw {
                	cursor: sw-resize;
                	width: 9px;
                	height: 9px;
                	left: -5px;
                	bottom: -5px;
                }
                .ui-resizable-nw {
                	cursor: nw-resize;
                	width: 9px;
                	height: 9px;
                	left: -5px;
                	top: -5px;
                }
                .ui-resizable-ne {
                	cursor: ne-resize;
                	width: 9px;
                	height: 9px;
                	right: -5px;
                	top: -5px;
                }
                
                .ui-selectable-helper {
                	position: absolute;
                	z-index: 100;
                	border: 1px dotted black;
                }
                
                .ui-slider {
                	position: relative;
                	text-align: left;
                }
                .ui-slider .ui-slider-handle {
                	position: absolute;
                	z-index: 2;
                	width: 1.2em;
                	height: 1.2em;
                	cursor: default;
                }
                .ui-slider .ui-slider-range {
                	position: absolute;
                	z-index: 1;
                	font-size: .7em;
                	display: block;
                	border: 0;
                	background-position: 0 0;
                }
                
                /* For IE8 - See #6727 */
                .ui-slider.ui-state-disabled .ui-slider-handle,
                .ui-slider.ui-state-disabled .ui-slider-range {
                	filter: inherit;
                }
                
                .ui-slider-horizontal {
                	height: .8em;
                }
                .ui-slider-horizontal .ui-slider-handle {
                	top: -.3em;
                	margin-left: -.6em;
                }
                .ui-slider-horizontal .ui-slider-range {
                	top: 0;
                	height: 100%;
                }
                .ui-slider-horizontal .ui-slider-range-min {
                	left: 0;
                }
                .ui-slider-horizontal .ui-slider-range-max {
                	right: 0;
                }
                
                .ui-slider-vertical {
                	width: .8em;
                	height: 100px;
                }
                .ui-slider-vertical .ui-slider-handle {
                	left: -.3em;
                	margin-left: 0;
                	margin-bottom: -.6em;
                }
                .ui-slider-vertical .ui-slider-range {
                	left: 0;
                	width: 100%;
                }
                .ui-slider-vertical .ui-slider-range-min {
                	bottom: 0;
                }
                .ui-slider-vertical .ui-slider-range-max {
                	top: 0;
                }
                
                .ui-spinner {
                	position: relative;
                	display: inline-block;
                	overflow: hidden;
                	padding: 0;
                	vertical-align: middle;
                }
                .ui-spinner-input {
                	border: none;
                	background: none;
                	color: inherit;
                	padding: 0;
                	margin: .2em 0;
                	vertical-align: middle;
                	margin-left: .4em;
                	margin-right: 22px;
                }
                .ui-spinner-button {
                	width: 16px;
                	height: 50%;
                	font-size: .5em;
                	padding: 0;
                	margin: 0;
                	text-align: center;
                	position: absolute;
                	cursor: default;
                	display: block;
                	overflow: hidden;
                	right: 0;
                }
                /* more specificity required here to overide default borders */
                .ui-spinner a.ui-spinner-button {
                	border-top: none;
                	border-bottom: none;
                	border-right: none;
                }
                /* vertical centre icon */
                .ui-spinner .ui-icon {
                	position: absolute;
                	margin-top: -8px;
                	top: 50%;
                	left: 0;
                }
                .ui-spinner-up {
                	top: 0;
                }
                .ui-spinner-down {
                	bottom: 0;
                }
                
                /* TR overrides */
                .ui-spinner .ui-icon-triangle-1-s {
                	/* need to fix icons sprite */
                	background-position: -65px -16px;
                }
                
                .ui-tabs {
                	position: relative;/* position: relative prevents IE scroll bug (element with position: relative inside container with overflow: auto appear as "fixed") */
                	padding: .2em;
                }
                .ui-tabs .ui-tabs-nav {
                	margin: 0;
                	padding: .2em .2em 0;
                }
                .ui-tabs .ui-tabs-nav li {
                	list-style: none;
                	float: left;
                	position: relative;
                	top: 0;
                	margin: 1px .2em 0 0;
                	border-bottom: 0;
                	padding: 0;
                	white-space: nowrap;
                }
                .ui-tabs .ui-tabs-nav li a {
                	float: left;
                	padding: .5em 1em;
                	text-decoration: none;
                }
                .ui-tabs .ui-tabs-nav li.ui-tabs-active {
                	margin-bottom: -1px;
                	padding-bottom: 1px;
                }
                .ui-tabs .ui-tabs-nav li.ui-tabs-active a,
                .ui-tabs .ui-tabs-nav li.ui-state-disabled a,
                .ui-tabs .ui-tabs-nav li.ui-tabs-loading a {
                	cursor: text;
                }
                .ui-tabs .ui-tabs-nav li a, /* first selector in group seems obsolete, but required to overcome bug in Opera applying cursor: text overall if defined elsewhere... */
                .ui-tabs-collapsible .ui-tabs-nav li.ui-tabs-active a {
                	cursor: pointer;
                }
                .ui-tabs .ui-tabs-panel {
                	display: block;
                	border-width: 0;
                	padding: 1em 1.4em;
                	background: none;
                }
                
                .ui-tooltip {
                	padding: 8px;
                	position: absolute;
                	z-index: 9999;
                	max-width: 300px;
                	-webkit-box-shadow: 0 0 5px #aaa;
                	box-shadow: 0 0 5px #aaa;
                }
                body .ui-tooltip {
                	border-width: 2px;
                }
                
                /* Component containers
                ----------------------------------*/
                .ui-widget {
                	font-family: Verdana,Arial,sans-serif/*{ffDefault}*/;
                	font-size: 1.1em/*{fsDefault}*/;
                }
                .ui-widget .ui-widget {
                	font-size: 1em;
                }
                .ui-widget input,
                .ui-widget select,
                .ui-widget textarea,
                .ui-widget button {
                	font-family: Verdana,Arial,sans-serif/*{ffDefault}*/;
                	font-size: 1em;
                }
                .ui-widget-content {
                	border: 1px solid #aaaaaa/*{borderColorContent}*/;
                	background: #ffffff/*{bgColorContent}*/ url(images/ui-bg_flat_75_ffffff_40x100.png)/*{bgImgUrlContent}*/ 50%/*{bgContentXPos}*/ 50%/*{bgContentYPos}*/ repeat-x/*{bgContentRepeat}*/;
                	color: #222222/*{fcContent}*/;
                }
                .ui-widget-content a {
                	color: #222222/*{fcContent}*/;
                }
                .ui-widget-header {
                	border: 1px solid #aaaaaa/*{borderColorHeader}*/;
                	background: #cccccc/*{bgColorHeader}*/ url(images/ui-bg_highlight-soft_75_cccccc_1x100.png)/*{bgImgUrlHeader}*/ 50%/*{bgHeaderXPos}*/ 50%/*{bgHeaderYPos}*/ repeat-x/*{bgHeaderRepeat}*/;
                	color: #222222/*{fcHeader}*/;
                	font-weight: bold;
                }
                .ui-widget-header a {
                	color: #222222/*{fcHeader}*/;
                }
                
                /* Interaction states
                ----------------------------------*/
                .ui-state-default,
                .ui-widget-content .ui-state-default,
                .ui-widget-header .ui-state-default {
                	border: 1px solid #d3d3d3/*{borderColorDefault}*/;
                	background: #e6e6e6/*{bgColorDefault}*/ url(images/ui-bg_glass_75_e6e6e6_1x400.png)/*{bgImgUrlDefault}*/ 50%/*{bgDefaultXPos}*/ 50%/*{bgDefaultYPos}*/ repeat-x/*{bgDefaultRepeat}*/;
                	font-weight: normal/*{fwDefault}*/;
                	color: #555555/*{fcDefault}*/;
                }
                .ui-state-default a,
                .ui-state-default a:link,
                .ui-state-default a:visited {
                	color: #555555/*{fcDefault}*/;
                	text-decoration: none;
                }
                .ui-state-hover,
                .ui-widget-content .ui-state-hover,
                .ui-widget-header .ui-state-hover,
                .ui-state-focus,
                .ui-widget-content .ui-state-focus,
                .ui-widget-header .ui-state-focus {
                	border: 1px solid #999999/*{borderColorHover}*/;
                	background: #dadada/*{bgColorHover}*/ url(images/ui-bg_glass_75_dadada_1x400.png)/*{bgImgUrlHover}*/ 50%/*{bgHoverXPos}*/ 50%/*{bgHoverYPos}*/ repeat-x/*{bgHoverRepeat}*/;
                	font-weight: normal/*{fwDefault}*/;
                	color: #212121/*{fcHover}*/;
                }
                .ui-state-hover a,
                .ui-state-hover a:hover,
                .ui-state-hover a:link,
                .ui-state-hover a:visited {
                	color: #212121/*{fcHover}*/;
                	text-decoration: none;
                }
                .ui-state-active,
                .ui-widget-content .ui-state-active,
                .ui-widget-header .ui-state-active {
                	border: 1px solid #aaaaaa/*{borderColorActive}*/;
                	background: #ffffff/*{bgColorActive}*/ url(images/ui-bg_glass_65_ffffff_1x400.png)/*{bgImgUrlActive}*/ 50%/*{bgActiveXPos}*/ 50%/*{bgActiveYPos}*/ repeat-x/*{bgActiveRepeat}*/;
                	font-weight: normal/*{fwDefault}*/;
                	color: #212121/*{fcActive}*/;
                }
                .ui-state-active a,
                .ui-state-active a:link,
                .ui-state-active a:visited {
                	color: #212121/*{fcActive}*/;
                	text-decoration: none;
                }
                
                /* Interaction Cues
                ----------------------------------*/
                .ui-state-highlight,
                .ui-widget-content .ui-state-highlight,
                .ui-widget-header .ui-state-highlight {
                	border: 1px solid #fcefa1/*{borderColorHighlight}*/;
                	background: #fbf9ee/*{bgColorHighlight}*/ url(images/ui-bg_glass_55_fbf9ee_1x400.png)/*{bgImgUrlHighlight}*/ 50%/*{bgHighlightXPos}*/ 50%/*{bgHighlightYPos}*/ repeat-x/*{bgHighlightRepeat}*/;
                	color: #363636/*{fcHighlight}*/;
                }
                .ui-state-highlight a,
                .ui-widget-content .ui-state-highlight a,
                .ui-widget-header .ui-state-highlight a {
                	color: #363636/*{fcHighlight}*/;
                }
                .ui-state-error,
                .ui-widget-content .ui-state-error,
                .ui-widget-header .ui-state-error {
                	border: 1px solid #cd0a0a/*{borderColorError}*/;
                	background: #fef1ec/*{bgColorError}*/ url(images/ui-bg_glass_95_fef1ec_1x400.png)/*{bgImgUrlError}*/ 50%/*{bgErrorXPos}*/ 50%/*{bgErrorYPos}*/ repeat-x/*{bgErrorRepeat}*/;
                	color: #cd0a0a/*{fcError}*/;
                }
                .ui-state-error a,
                .ui-widget-content .ui-state-error a,
                .ui-widget-header .ui-state-error a {
                	color: #cd0a0a/*{fcError}*/;
                }
                .ui-state-error-text,
                .ui-widget-content .ui-state-error-text,
                .ui-widget-header .ui-state-error-text {
                	color: #cd0a0a/*{fcError}*/;
                }
                .ui-priority-primary,
                .ui-widget-content .ui-priority-primary,
                .ui-widget-header .ui-priority-primary {
                	font-weight: bold;
                }
                .ui-priority-secondary,
                .ui-widget-content .ui-priority-secondary,
                .ui-widget-header .ui-priority-secondary {
                	opacity: .7;
                	filter:Alpha(Opacity=70);
                	font-weight: normal;
                }
                .ui-state-disabled,
                .ui-widget-content .ui-state-disabled,
                .ui-widget-header .ui-state-disabled {
                	opacity: .35;
                	filter:Alpha(Opacity=35);
                	background-image: none;
                }
                .ui-state-disabled .ui-icon {
                	filter:Alpha(Opacity=35); /* For IE8 - See #6059 */
                }
                
                /* Icons
                ----------------------------------*/
                
                /* states and images */
                .ui-icon {
                	width: 16px;
                	height: 16px;
                	background-position: 16px 16px;
                }
                .ui-icon,
                .ui-widget-content .ui-icon {
                	background-image: url(images/ui-icons_222222_256x240.png)/*{iconsContent}*/;
                }
                .ui-widget-header .ui-icon {
                	background-image: url(images/ui-icons_222222_256x240.png)/*{iconsHeader}*/;
                }
                .ui-state-default .ui-icon {
                	background-image: url(images/ui-icons_888888_256x240.png)/*{iconsDefault}*/;
                }
                .ui-state-hover .ui-icon,
                .ui-state-focus .ui-icon {
                	background-image: url(images/ui-icons_454545_256x240.png)/*{iconsHover}*/;
                }
                .ui-state-active .ui-icon {
                	background-image: url(images/ui-icons_454545_256x240.png)/*{iconsActive}*/;
                }
                .ui-state-highlight .ui-icon {
                	background-image: url(images/ui-icons_2e83ff_256x240.png)/*{iconsHighlight}*/;
                }
                .ui-state-error .ui-icon,
                .ui-state-error-text .ui-icon {
                	background-image: url(images/ui-icons_cd0a0a_256x240.png)/*{iconsError}*/;
                }
                
                /* positioning */
                .ui-icon-carat-1-n { background-position: 0 0; }
                .ui-icon-carat-1-ne { background-position: -16px 0; }
                .ui-icon-carat-1-e { background-position: -32px 0; }
                .ui-icon-carat-1-se { background-position: -48px 0; }
                .ui-icon-carat-1-s { background-position: -64px 0; }
                .ui-icon-carat-1-sw { background-position: -80px 0; }
                .ui-icon-carat-1-w { background-position: -96px 0; }
                .ui-icon-carat-1-nw { background-position: -112px 0; }
                .ui-icon-carat-2-n-s { background-position: -128px 0; }
                .ui-icon-carat-2-e-w { background-position: -144px 0; }
                .ui-icon-triangle-1-n { background-position: 0 -16px; }
                .ui-icon-triangle-1-ne { background-position: -16px -16px; }
                .ui-icon-triangle-1-e { background-position: -32px -16px; }
                .ui-icon-triangle-1-se { background-position: -48px -16px; }
                .ui-icon-triangle-1-s { background-position: -64px -16px; }
                .ui-icon-triangle-1-sw { background-position: -80px -16px; }
                .ui-icon-triangle-1-w { background-position: -96px -16px; }
                .ui-icon-triangle-1-nw { background-position: -112px -16px; }
                .ui-icon-triangle-2-n-s { background-position: -128px -16px; }
                .ui-icon-triangle-2-e-w { background-position: -144px -16px; }
                .ui-icon-arrow-1-n { background-position: 0 -32px; }
                .ui-icon-arrow-1-ne { background-position: -16px -32px; }
                .ui-icon-arrow-1-e { background-position: -32px -32px; }
                .ui-icon-arrow-1-se { background-position: -48px -32px; }
                .ui-icon-arrow-1-s { background-position: -64px -32px; }
                .ui-icon-arrow-1-sw { background-position: -80px -32px; }
                .ui-icon-arrow-1-w { background-position: -96px -32px; }
                .ui-icon-arrow-1-nw { background-position: -112px -32px; }
                .ui-icon-arrow-2-n-s { background-position: -128px -32px; }
                .ui-icon-arrow-2-ne-sw { background-position: -144px -32px; }
                .ui-icon-arrow-2-e-w { background-position: -160px -32px; }
                .ui-icon-arrow-2-se-nw { background-position: -176px -32px; }
                .ui-icon-arrowstop-1-n { background-position: -192px -32px; }
                .ui-icon-arrowstop-1-e { background-position: -208px -32px; }
                .ui-icon-arrowstop-1-s { background-position: -224px -32px; }
                .ui-icon-arrowstop-1-w { background-position: -240px -32px; }
                .ui-icon-arrowthick-1-n { background-position: 0 -48px; }
                .ui-icon-arrowthick-1-ne { background-position: -16px -48px; }
                .ui-icon-arrowthick-1-e { background-position: -32px -48px; }
                .ui-icon-arrowthick-1-se { background-position: -48px -48px; }
                .ui-icon-arrowthick-1-s { background-position: -64px -48px; }
                .ui-icon-arrowthick-1-sw { background-position: -80px -48px; }
                .ui-icon-arrowthick-1-w { background-position: -96px -48px; }
                .ui-icon-arrowthick-1-nw { background-position: -112px -48px; }
                .ui-icon-arrowthick-2-n-s { background-position: -128px -48px; }
                .ui-icon-arrowthick-2-ne-sw { background-position: -144px -48px; }
                .ui-icon-arrowthick-2-e-w { background-position: -160px -48px; }
                .ui-icon-arrowthick-2-se-nw { background-position: -176px -48px; }
                .ui-icon-arrowthickstop-1-n { background-position: -192px -48px; }
                .ui-icon-arrowthickstop-1-e { background-position: -208px -48px; }
                .ui-icon-arrowthickstop-1-s { background-position: -224px -48px; }
                .ui-icon-arrowthickstop-1-w { background-position: -240px -48px; }
                .ui-icon-arrowreturnthick-1-w { background-position: 0 -64px; }
                .ui-icon-arrowreturnthick-1-n { background-position: -16px -64px; }
                .ui-icon-arrowreturnthick-1-e { background-position: -32px -64px; }
                .ui-icon-arrowreturnthick-1-s { background-position: -48px -64px; }
                .ui-icon-arrowreturn-1-w { background-position: -64px -64px; }
                .ui-icon-arrowreturn-1-n { background-position: -80px -64px; }
                .ui-icon-arrowreturn-1-e { background-position: -96px -64px; }
                .ui-icon-arrowreturn-1-s { background-position: -112px -64px; }
                .ui-icon-arrowrefresh-1-w { background-position: -128px -64px; }
                .ui-icon-arrowrefresh-1-n { background-position: -144px -64px; }
                .ui-icon-arrowrefresh-1-e { background-position: -160px -64px; }
                .ui-icon-arrowrefresh-1-s { background-position: -176px -64px; }
                .ui-icon-arrow-4 { background-position: 0 -80px; }
                .ui-icon-arrow-4-diag { background-position: -16px -80px; }
                .ui-icon-extlink { background-position: -32px -80px; }
                .ui-icon-newwin { background-position: -48px -80px; }
                .ui-icon-refresh { background-position: -64px -80px; }
                .ui-icon-shuffle { background-position: -80px -80px; }
                .ui-icon-transfer-e-w { background-position: -96px -80px; }
                .ui-icon-transferthick-e-w { background-position: -112px -80px; }
                .ui-icon-folder-collapsed { background-position: 0 -96px; }
                .ui-icon-folder-open { background-position: -16px -96px; }
                .ui-icon-document { background-position: -32px -96px; }
                .ui-icon-document-b { background-position: -48px -96px; }
                .ui-icon-note { background-position: -64px -96px; }
                .ui-icon-mail-closed { background-position: -80px -96px; }
                .ui-icon-mail-open { background-position: -96px -96px; }
                .ui-icon-suitcase { background-position: -112px -96px; }
                .ui-icon-comment { background-position: -128px -96px; }
                .ui-icon-person { background-position: -144px -96px; }
                .ui-icon-print { background-position: -160px -96px; }
                .ui-icon-trash { background-position: -176px -96px; }
                .ui-icon-locked { background-position: -192px -96px; }
                .ui-icon-unlocked { background-position: -208px -96px; }
                .ui-icon-bookmark { background-position: -224px -96px; }
                .ui-icon-tag { background-position: -240px -96px; }
                .ui-icon-home { background-position: 0 -112px; }
                .ui-icon-flag { background-position: -16px -112px; }
                .ui-icon-calendar { background-position: -32px -112px; }
                .ui-icon-cart { background-position: -48px -112px; }
                .ui-icon-pencil { background-position: -64px -112px; }
                .ui-icon-clock { background-position: -80px -112px; }
                .ui-icon-disk { background-position: -96px -112px; }
                .ui-icon-calculator { background-position: -112px -112px; }
                .ui-icon-zoomin { background-position: -128px -112px; }
                .ui-icon-zoomout { background-position: -144px -112px; }
                .ui-icon-search { background-position: -160px -112px; }
                .ui-icon-wrench { background-position: -176px -112px; }
                .ui-icon-gear { background-position: -192px -112px; }
                .ui-icon-heart { background-position: -208px -112px; }
                .ui-icon-star { background-position: -224px -112px; }
                .ui-icon-link { background-position: -240px -112px; }
                .ui-icon-cancel { background-position: 0 -128px; }
                .ui-icon-plus { background-position: -16px -128px; }
                .ui-icon-plusthick { background-position: -32px -128px; }
                .ui-icon-minus { background-position: -48px -128px; }
                .ui-icon-minusthick { background-position: -64px -128px; }
                .ui-icon-close { background-position: -80px -128px; }
                .ui-icon-closethick { background-position: -96px -128px; }
                .ui-icon-key { background-position: -112px -128px; }
                .ui-icon-lightbulb { background-position: -128px -128px; }
                .ui-icon-scissors { background-position: -144px -128px; }
                .ui-icon-clipboard { background-position: -160px -128px; }
                .ui-icon-copy { background-position: -176px -128px; }
                .ui-icon-contact { background-position: -192px -128px; }
                .ui-icon-image { background-position: -208px -128px; }
                .ui-icon-video { background-position: -224px -128px; }
                .ui-icon-script { background-position: -240px -128px; }
                .ui-icon-alert { background-position: 0 -144px; }
                .ui-icon-info { background-position: -16px -144px; }
                .ui-icon-notice { background-position: -32px -144px; }
                .ui-icon-help { background-position: -48px -144px; }
                .ui-icon-check { background-position: -64px -144px; }
                .ui-icon-bullet { background-position: -80px -144px; }
                .ui-icon-radio-on { background-position: -96px -144px; }
                .ui-icon-radio-off { background-position: -112px -144px; }
                .ui-icon-pin-w { background-position: -128px -144px; }
                .ui-icon-pin-s { background-position: -144px -144px; }
                .ui-icon-play { background-position: 0 -160px; }
                .ui-icon-pause { background-position: -16px -160px; }
                .ui-icon-seek-next { background-position: -32px -160px; }
                .ui-icon-seek-prev { background-position: -48px -160px; }
                .ui-icon-seek-end { background-position: -64px -160px; }
                .ui-icon-seek-start { background-position: -80px -160px; }
                /* ui-icon-seek-first is deprecated, use ui-icon-seek-start instead */
                .ui-icon-seek-first { background-position: -80px -160px; }
                .ui-icon-stop { background-position: -96px -160px; }
                .ui-icon-eject { background-position: -112px -160px; }
                .ui-icon-volume-off { background-position: -128px -160px; }
                .ui-icon-volume-on { background-position: -144px -160px; }
                .ui-icon-power { background-position: 0 -176px; }
                .ui-icon-signal-diag { background-position: -16px -176px; }
                .ui-icon-signal { background-position: -32px -176px; }
                .ui-icon-battery-0 { background-position: -48px -176px; }
                .ui-icon-battery-1 { background-position: -64px -176px; }
                .ui-icon-battery-2 { background-position: -80px -176px; }
                .ui-icon-battery-3 { background-position: -96px -176px; }
                .ui-icon-circle-plus { background-position: 0 -192px; }
                .ui-icon-circle-minus { background-position: -16px -192px; }
                .ui-icon-circle-close { background-position: -32px -192px; }
                .ui-icon-circle-triangle-e { background-position: -48px -192px; }
                .ui-icon-circle-triangle-s { background-position: -64px -192px; }
                .ui-icon-circle-triangle-w { background-position: -80px -192px; }
                .ui-icon-circle-triangle-n { background-position: -96px -192px; }
                .ui-icon-circle-arrow-e { background-position: -112px -192px; }
                .ui-icon-circle-arrow-s { background-position: -128px -192px; }
                .ui-icon-circle-arrow-w { background-position: -144px -192px; }
                .ui-icon-circle-arrow-n { background-position: -160px -192px; }
                .ui-icon-circle-zoomin { background-position: -176px -192px; }
                .ui-icon-circle-zoomout { background-position: -192px -192px; }
                .ui-icon-circle-check { background-position: -208px -192px; }
                .ui-icon-circlesmall-plus { background-position: 0 -208px; }
                .ui-icon-circlesmall-minus { background-position: -16px -208px; }
                .ui-icon-circlesmall-close { background-position: -32px -208px; }
                .ui-icon-squaresmall-plus { background-position: -48px -208px; }
                .ui-icon-squaresmall-minus { background-position: -64px -208px; }
                .ui-icon-squaresmall-close { background-position: -80px -208px; }
                .ui-icon-grip-dotted-vertical { background-position: 0 -224px; }
                .ui-icon-grip-dotted-horizontal { background-position: -16px -224px; }
                .ui-icon-grip-solid-vertical { background-position: -32px -224px; }
                .ui-icon-grip-solid-horizontal { background-position: -48px -224px; }
                .ui-icon-gripsmall-diagonal-se { background-position: -64px -224px; }
                .ui-icon-grip-diagonal-se { background-position: -80px -224px; }
                
                
                /* Misc visuals
                ----------------------------------*/
                
                /* Corner radius */
                .ui-corner-all,
                .ui-corner-top,
                .ui-corner-left,
                .ui-corner-tl {
                	border-top-left-radius: 4px/*{cornerRadius}*/;
                }
                .ui-corner-all,
                .ui-corner-top,
                .ui-corner-right,
                .ui-corner-tr {
                	border-top-right-radius: 4px/*{cornerRadius}*/;
                }
                .ui-corner-all,
                .ui-corner-bottom,
                .ui-corner-left,
                .ui-corner-bl {
                	border-bottom-left-radius: 4px/*{cornerRadius}*/;
                }
                .ui-corner-all,
                .ui-corner-bottom,
                .ui-corner-right,
                .ui-corner-br {
                	border-bottom-right-radius: 4px/*{cornerRadius}*/;
                }
                
                /* Overlays */
                .ui-widget-overlay {
                	background: #aaaaaa/*{bgColorOverlay}*/ url(images/ui-bg_flat_0_aaaaaa_40x100.png)/*{bgImgUrlOverlay}*/ 50%/*{bgOverlayXPos}*/ 50%/*{bgOverlayYPos}*/ repeat-x/*{bgOverlayRepeat}*/;
                	opacity: .3/*{opacityOverlay}*/;
                	filter: Alpha(Opacity=30)/*{opacityFilterOverlay}*/;
                }
                .ui-widget-shadow {
                	margin: -8px/*{offsetTopShadow}*/ 0 0 -8px/*{offsetLeftShadow}*/;
                	padding: 8px/*{thicknessShadow}*/;
                	background: #aaaaaa/*{bgColorShadow}*/ url(images/ui-bg_flat_0_aaaaaa_40x100.png)/*{bgImgUrlShadow}*/ 50%/*{bgShadowXPos}*/ 50%/*{bgShadowYPos}*/ repeat-x/*{bgShadowRepeat}*/;
                	opacity: .3/*{opacityShadow}*/;
                	filter: Alpha(Opacity=30)/*{opacityFilterShadow}*/;
                	border-radius: 8px/*{cornerRadiusShadow}*/;
                }
                
                /*!
                 * Handsontable 0.11.1
                 * Handsontable is a simple jQuery plugin for editable tables with basic copy-paste compatibility with Excel and Google Docs
                 *
                 * Copyright 2012-2014 Marcin Warpechowski
                 * Licensed under the MIT license.
                 * http://handsontable.com/
                 *
                 * Date: Fri Sep 05 2014 12:54:36 GMT+0200 (CEST)
                 */
                
                .handsontable {
                  position: relative;
                }
                
                .handsontable .relative {
                  position: relative;
                }
                
                .handsontable.htAutoColumnSize {
                  visibility: hidden;
                  left: 0;
                  position: absolute;
                  top: 0;
                }
                
                .handsontable table,
                .handsontable tbody,
                .handsontable thead,
                .handsontable td,
                .handsontable th,
                .handsontable div {
                  box-sizing: content-box;
                  -webkit-box-sizing: content-box;
                  -moz-box-sizing: content-box;
                }
                
                .handsontable table.htCore {
                  border-collapse: separate;
                  /*it must be separate, otherwise there are offset miscalculations in WebKit: http://stackoverflow.com/questions/2655987/border-collapse-differences-in-ff-and-webkit*/
                  position: relative;
                  /*this actually only changes appearance of user selection - does not make text unselectable
                  -webkit-user-select: none;
                  -khtml-user-select: none;
                  -moz-user-select: none;
                  -o-user-select: none;
                  -ms-user-select: none;
                  /*user-select: none; /*no browser supports unprefixed version*/
                  border-spacing: 0;
                  margin: 0;
                  border-width: 0;
                  table-layout: fixed;
                  width: 0;
                  outline-width: 0;
                  /* reset bootstrap table style. for more info see: https://github.com/handsontable/jquery-handsontable/issues/224 */
                  max-width: none;
                  max-height: none;
                }
                
                .handsontable col {
                  width: 50px;
                }
                
                .handsontable col.rowHeader {
                  width: 50px;
                }
                
                .handsontable th,
                .handsontable td {
                  border-right: 1px solid #CCC;
                  border-bottom: 1px solid #CCC;
                  height: 22px;
                  empty-cells: show;
                  line-height: 21px;
                  padding: 0 4px 0 4px;
                  /* top, bottom padding different than 0 is handled poorly by FF with HTML5 doctype */
                  background-color: #FFF;
                  vertical-align: top;
                  overflow: hidden;
                  outline-width: 0;
                  white-space: pre-line;
                  /* preserve new line character in cell */
                }
                
                .handsontable td.htInvalid {
                  -webkit-transition: background 0.75s ease;
                  transition: background 0.75s ease;
                  background-color: #ff4c42;
                }
                
                .handsontable td.htNoWrap {
                  white-space: nowrap;
                }
                
                .handsontable th:last-child {
                  /*Foundation framework fix*/
                  border-right: 1px solid #CCC;
                  border-bottom: 1px solid #CCC;
                }
                
                .handsontable tr:first-child th.htNoFrame,
                .handsontable th:first-child.htNoFrame,
                .handsontable th.htNoFrame {
                  border-left-width: 0;
                  background-color: white;
                  border-color: #FFF;
                }
                
                .handsontable th:first-child,
                .handsontable td:first-child,
                .handsontable .htNoFrame + th,
                .handsontable .htNoFrame + td {
                  border-left: 1px solid #CCC;
                }
                
                .handsontable tr:first-child th,
                .handsontable tr:first-child td {
                  border-top: 1px solid #CCC;
                }
                
                .handsontable thead tr:last-child th {
                  border-bottom-width: 0;
                }
                
                .handsontable thead tr.lastChild th {
                  border-bottom-width: 0;
                }
                
                .handsontable th {
                  background-color: #EEE;
                  color: #222;
                  text-align: center;
                  font-weight: normal;
                  white-space: nowrap;
                }
                
                .handsontable thead th {
                  padding: 0;
                }
                
                .handsontable th.active {
                  background-color: #CCC;
                }
                
                .handsontable thead th .relative {
                  padding: 2px 4px;
                }
                
                /* plugins */
                
                .handsontable .manualColumnMover {
                  position: fixed;
                  left: 0;
                  top: 0;
                  background-color: transparent;
                  width: 5px;
                  height: 25px;
                  z-index: 999;
                  cursor: move;
                }
                
                .handsontable .manualRowMover {
                  position: fixed;
                  left: -4px;
                  top: 0;
                  background-color: transparent;
                  height: 5px;
                  width: 50px;
                  z-index: 999;
                  cursor: move;
                }
                
                .handsontable .manualColumnMoverGuide,
                .handsontable .manualRowMoverGuide {
                  position: fixed;
                  left: 0;
                  top: 0;
                  background-color: #CCC;
                  width: 25px;
                  height: 25px;
                  opacity: 0.7;
                  display: none;
                }
                
                .handsontable .manualColumnMoverGuide.active,
                .handsontable .manualRowMoverGuide.active {
                  display: block;
                }
                
                .handsontable .manualColumnMover:hover,
                .handsontable .manualColumnMover.active,
                .handsontable .manualRowMover:hover,
                .handsontable .manualRowMover.active{
                  background-color: #88F;
                }
                
                /* row + column resizer*/
                
                .handsontable .manualColumnResizer {
                  position: fixed;
                  top: 0;
                  cursor: col-resize;
                  z-index: 110;
                  width: 5px;
                  height: 25px;
                }
                
                .handsontable .manualRowResizer {
                  position: fixed;
                  left: 0;
                  cursor: row-resize;
                  z-index: 110;
                  height: 5px;
                  width: 50px;
                }
                
                .handsontable .manualColumnResizer:hover,
                .handsontable .manualColumnResizer.active,
                .handsontable .manualRowResizer:hover,
                .handsontable .manualRowResizer.active {
                  background-color: #AAB;
                }
                
                .handsontable .manualColumnResizerGuide {
                  position: fixed;
                  right: 0;
                  top: 0;
                  background-color: #AAB;
                  display: none;
                  width: 0;
                  border-right: 1px dashed #777;
                  margin-left: 5px;
                }
                
                .handsontable .manualRowResizerGuide {
                  position: fixed;
                  left: 0;
                  bottom: 0;
                  background-color: #AAB;
                  display: none;
                  height: 0;
                  border-bottom: 1px dashed #777;
                  margin-top: 5px;
                }
                
                .handsontable .manualColumnResizerGuide.active,
                .handsontable .manualRowResizerGuide.active {
                  display: block;
                }
                
                .handsontable .columnSorting:hover {
                  text-decoration: underline;
                  cursor: pointer;
                }
                
                /* border line */
                
                .handsontable .wtBorder {
                  position: absolute;
                  font-size: 0;
                }
                .handsontable .wtBorder.hidden{
                  display:none !important;
                }
                
                .handsontable td.area {
                  background-color: #EEF4FF;
                }
                
                /* fill handle */
                
                .handsontable .wtBorder.corner {
                  font-size: 0;
                  cursor: crosshair;
                }
                
                .handsontable .htBorder.htFillBorder {
                  background: red;
                  width: 1px;
                  height: 1px;
                }
                
                .handsontableInput {
                  border: 2px solid #5292F7;
                  outline-width: 0;
                  margin: 0;
                  padding: 1px 4px 0 2px;
                  font-family: Arial, Helvetica, sans-serif;
                  /*repeat from .handsontable (inherit doesn't work with IE<8) */
                  line-height: 1.3em;
                  /*repeat from .handsontable (inherit doesn't work with IE<8) */
                  font-size: inherit;
                  -webkit-box-shadow: 1px 2px 5px rgba(0, 0, 0, 0.4);
                  box-shadow: 1px 2px 5px rgba(0, 0, 0, 0.4);
                  resize: none;
                  /*below are needed to overwrite stuff added by jQuery UI Bootstrap theme*/
                  display: inline-block;
                  color: #000;
                  border-radius: 0;
                  background-color: #FFF;
                  /*overwrite styles potentionally made by a framework*/
                }
                
                .handsontableInputHolder {
                  position: absolute;
                  top: 0;
                  left: 0;
                  z-index: 100;
                }
                
                .htSelectEditor {
                  -webkit-appearance: menulist-button !important;
                  position: absolute;
                }
                
                /*
                TextRenderer readOnly cell
                */
                
                .handsontable .htDimmed {
                  color: #777;
                }
                
                .handsontable .htSubmenu :after{
                    content: '▶';
                    color: #777;
                    position: absolute;
                    right: 5px;
                }
                
                
                /*
                TextRenderer horizontal alignment
                */
                .handsontable .htLeft{
                  text-align: left;
                }
                .handsontable .htCenter{
                  text-align: center;
                }
                .handsontable .htRight{
                  text-align: right;
                }
                .handsontable .htJustify{
                  text-align: justify;
                }
                /*
                TextRenderer vertical alignment
                */
                .handsontable .htTop{
                  vertical-align: top;
                }
                .handsontable .htMiddle{
                  vertical-align: middle;
                }
                .handsontable .htBottom{
                  vertical-align: bottom;
                }
                
                /*
                TextRenderer placeholder value
                */
                
                .handsontable .htPlaceholder {
                  color: #999;
                }
                
                /*
                AutocompleteRenderer down arrow
                */
                
                .handsontable .htAutocompleteArrow {
                  float: right;
                  font-size: 10px;
                  color: #EEE;
                  cursor: default;
                  width: 16px;
                  text-align: center;
                }
                
                .handsontable td .htAutocompleteArrow:hover {
                  color: #777;
                }
                
                /*
                CheckboxRenderer
                */
                
                .handsontable .htCheckboxRendererInput.noValue {
                  opacity: 0.5;
                }
                
                /*
                NumericRenderer
                */
                
                .handsontable .htNumeric {
                  text-align: right;
                }
                
                /*
                Comment For Cell
                */
                .htCommentCell{
                  position: relative;
                }
                .htCommentCell:after{
                  content: '';
                  position: absolute;
                  top: 0;
                  right: 0;
                  border-left: 6px solid transparent;
                  border-top: 6px solid red;
                }
                
                /**
                 * Handsontable in Handsontable
                 */
                
                .handsontable .handsontable .wtHider {
                  padding: 0 0 5px 0;
                }
                
                .handsontable .handsontable table {
                  -webkit-box-shadow: 1px 2px 5px rgba(0, 0, 0, 0.4);
                  box-shadow: 1px 2px 5px rgba(0, 0, 0, 0.4);
                }
                
                /**
                * Autocomplete Editor
                */
                .handsontable .autocompleteEditor.handsontable {
                  padding-right: 17px;
                }
                .handsontable .autocompleteEditor.handsontable.htMacScroll {
                  padding-right: 15px;
                }
                
                
                /**
                 * Handsontable listbox theme
                 */
                
                .handsontable.listbox {
                  margin: 0;
                }
                
                .handsontable.listbox .ht_master table {
                  border: 1px solid #ccc;
                  border-collapse: separate;
                  background: white;
                }
                
                .handsontable.listbox th,
                .handsontable.listbox tr:first-child th,
                .handsontable.listbox tr:last-child th,
                .handsontable.listbox tr:first-child td,
                .handsontable.listbox td {
                  border-width: 0;
                }
                
                .handsontable.listbox th,
                .handsontable.listbox td {
                  white-space: nowrap;
                  text-overflow: ellipsis;
                }
                
                .handsontable.listbox td.htDimmed {
                  cursor: default;
                  color: inherit;
                  font-style: inherit;
                }
                
                .handsontable.listbox .wtBorder {
                  visibility: hidden;
                }
                
                .handsontable.listbox tr td.current,
                .handsontable.listbox tr:hover td {
                  background: #eee;
                }
                
                .htContextMenu {
                  display: none;
                  position: absolute;
                  z-index: 1060; /*needs to be higher than 1050 - z-index for Twitter Bootstrap modal (#1569)*/
                }
                
                .htContextMenu .ht_clone_top,
                .htContextMenu .ht_clone_left,
                .htContextMenu .ht_clone_corner {
                  display: none;
                }
                
                .ht_clone_top {
                  z-index: 101;
                }
                
                .ht_clone_left {
                  z-index: 102;
                }
                
                .ht_clone_corner {
                  z-index: 103;
                }
                
                .htContextMenu table.htCore {
                  outline: 1px solid #bbb;
                }
                
                .htContextMenu .wtBorder {
                  visibility: hidden;
                }
                
                .htContextMenu table tbody tr td {
                  background: white;
                  border-width: 0;
                  padding: 4px 6px 0px 6px;
                  cursor: pointer;
                  overflow: hidden;
                  white-space: nowrap;
                  text-overflow: ellipsis;
                }
                
                .htContextMenu table tbody tr td:first-child {
                  border: 0;
                }
                
                .htContextMenu table tbody tr td.htDimmed{
                  font-style: normal;
                  color: #323232;
                }
                
                .htContextMenu table tbody tr td.current{
                  background: rgb(233, 233, 233);
                }
                
                .htContextMenu table tbody tr td.htSeparator {
                  border-top: 1px solid #bbb;
                  height: 0;
                  padding: 0;
                }
                
                .htContextMenu table tbody tr td.htDisabled {
                  color: #999;
                }
                
                .htContextMenu table tbody tr td.htDisabled:hover {
                  background: white;
                  color: #999;
                  cursor: default;
                }
                .htContextMenu table tbody tr td div{
                  padding-left: 10px;
                }
                .htContextMenu table tbody tr td div span.selected{
                  margin-top: -2px;
                  position: absolute;
                  left: 4px;
                }
                
                .handsontable td.htSearchResult {
                  background: #fcedd9;
                  color: #583707;
                }
                
                /*
                Cell borders
                */
                .htBordered{
                  /*box-sizing: border-box !important;*/
                  border-width: 1px;
                }
                .htBordered.htTopBorderSolid{
                  border-top-style: solid;
                  border-top-color: #000;
                }
                .htBordered.htRightBorderSolid{
                  border-right-style: solid;
                  border-right-color: #000;
                }
                .htBordered.htBottomBorderSolid{
                  border-bottom-style: solid;
                  border-bottom-color: #000;
                }
                .htBordered.htLeftBorderSolid{
                  border-left-style: solid;
                  border-left-color: #000;
                }
                
                .htCommentTextArea{
                  background-color: #FFFACD;
                  box-shadow: 1px 1px 2px #bbb;
                  font-family: 'Arial';
                  -webkit-box-shadow: 1px 1px 2px #bbb;
                  -moz-box-shadow: 1px 1px 2px #bbb;
                
                }
                
                /*WalkontableDebugOverlay*/
                
                .wtDebugHidden {
                  display: none;
                }
                
                .wtDebugVisible {
                  display: block;
                  -webkit-animation-duration: 0.5s;
                  -webkit-animation-name: wtFadeInFromNone;
                  animation-duration: 0.5s;
                  animation-name: wtFadeInFromNone;
                }
                
                @keyframes wtFadeInFromNone {
                  0% {
                    display: none;
                    opacity: 0;
                  }
                
                  1% {
                    display: block;
                    opacity: 0;
                  }
                
                  100% {
                    display: block;
                    opacity: 1;
                  }
                }
                
                @-webkit-keyframes wtFadeInFromNone {
                  0% {
                    display: none;
                    opacity: 0;
                  }
                
                  1% {
                    display: block;
                    opacity: 0;
                  }
                
                  100% {
                    display: block;
                    opacity: 1;
                  }
                }
                
                /**
                 * default development theme for jQRangeSlider
                 * Using fam fam icon set from Mark James, http://www.famfamfam.com/lab/icons/silk/ (Creative Commons Attribution 2.5 License)
                 */
                
                .ui-rangeSlider{
                	height:22px;
                }
                
                .ui-rangeSlider .ui-rangeSlider-innerBar{
                	height:16px;
                	margin:3px 6px;
                	background:#DDD;
                }
                
                .ui-rangeSlider .ui-rangeSlider-handle{
                	width:6px;
                	height:22px;
                	background:#AAA;
                	background:rgba(100,100,100, 0.3);
                	cursor:col-resize;
                }
                
                .ui-rangeSlider .ui-rangeSlider-bar{
                	margin: 1px 0;
                	background:#CCC;
                	background:rgba(100,100,150, 0.2);
                	height:20px;
                	cursor:move;
                	cursor:grab;
                	cursor: -moz-grab;
                }
                
                .ui-rangeSlider .ui-rangeSlider-bar.ui-draggable-dragging{
                	cursor:	-moz-grabbing;
                	cursor:grabbing;
                }
                
                .ui-rangeSlider-arrow{
                	height:16px;
                	margin:2px 0;
                	width:16px;
                	background-repeat:no-repeat;
                }
                
                .ui-rangeSlider-arrow.ui-rangeSlider-leftArrow{
                	background-image: url('icons-classic/resultset_previous.png');
                	background-position:center left;
                }
                
                .ui-rangeSlider-arrow.ui-rangeSlider-rightArrow{
                	background-image: url('icons-classic/resultset_next.png');
                	background-position:center right;
                }
                
                .ui-rangeSlider-arrow-inner{
                	display: none;
                }
                
                .ui-rangeSlider-container{
                	height:22px;
                }
                
                .ui-rangeSlider-withArrows .ui-rangeSlider-container{
                	margin:0 11px;
                }
                
                .ui-rangeSlider-noArrow .ui-rangeSlider-container{
                	margin:0;
                }
                
                .ui-rangeSlider-label{
                	margin:0 2px 2px;
                	background-image:url('icons-classic/label.png');
                	background-position:bottom center;
                	background-repeat:no-repeat;
                  white-space: nowrap;
                  bottom:20px;
                  padding:3px 6px 7px;
                  cursor:col-resize;
                }
                
                .ui-rangeSlider-label-inner{
                	display:none;
                }
                
                /*
                 * Edit slider
                 */
                
                input.ui-editRangeSlider-inputValue{
                	width:3em;
                	vertical-align: middle;
                	text-align:center;
                }
                
                .ui-rangeSlider-arrow.ui-rangeSlider-leftArrow {
                  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAPpJREFUeNrE0zFqhVAUBFCL7ElEEBQsXmErWtnZWImF2Gih6FNEfKCoBGMMUQhEULKjrCF1JjsI+j8kxbSnuDOXA8DdE+5PgLIsM0rp100ApTRL0/Q7DENcBpIkqfq+x3Ec8DzvGhBF0VPTNNj3Hdu2wbbt80AQBK+MMez7jnmesa4rTNM8B/i+/1mWJbZtwziOYIxhmiZomnYOcBznI45jLMuCtm2R5zm6rgMh5BxgGMaDruvvrutiGAZkWYa6rqGq6rUjEkLebNtGVVUoigKyLF+vUVGUF8uykCQJJEnCTUMSRfHZMAyIooibp8zz/KMgCPi/Z/otPwMAtKTYr7dLeeEAAAAASUVORK5CYII=");
                }
                .ui-rangeSlider-arrow.ui-rangeSlider-rightArrow {
                  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAPlJREFUeNrE0ztqhlAUBOC/yLoUfKBga2WpKBYKgp21+ncRuYrPK0FtxBRCQCwsXEvWkDqTLagJpJj2K+aceQB4/CaPPwcopV9t2z5vA13XoWmab0LI8xZQliWO48AwDAjD8PUykCQJ9n3Htm3Isgye53WXgDiOsa4r5nnGsiyIogiapo2ngSAIsCwL2rYFpRTjOML3fSiK8nkKcF0X0zSBEII8z0EpheM4kGX54xSg6zr6vkeapqiqCrZtQxTFd5ZlX04BqqqirmsURQHLsiAIwnSpREVRQAiBaZrgOK6/fEZJkmAYBliWfbv1SDzPg2GY5v/GdDU/AwDyYNzeUSg0WgAAAABJRU5ErkJggg==");
                }
                .ui-rangeSlider-label {
                  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARcAAAAwCAYAAAA7DT7uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAGapJREFUeNrsXUuuJNdxjTB6M1qCliGJ1B4FCvYyPPaIhgUQBASINkSZI0MjxvGg7ufE72ZW9SMly5WTfl2VlXk/8T0RN0J/+OEHyPt6X+/rfX3w9U/vJXhf7+t9vYXL+3pf7+stXN7X+3pfb+Hyvt7X+3pfb+Hyvt7X+3oLl/f1vt7X/+Prk0AE0kSjVYS/mv/lj1XH3xifq4hCBHwX/VDH7wD/8PAq+nR+h3ocxWvSFLQa3+FSFQHPoHjyuKceMa3PHOu6/fFJOd85zuLRh1+VP+axK63eXrvx6dgTtx86/kZDCrye1aRv0NLd7x97Vq91vRXVBl+tRk8zxwVIz2sIQAoaDcPc+ysFl+37xY0t31+NfXIRinV5jH7/e6Sv9TVubZ/+5S//DaaUNRBiK0lMvIcibuCHwWn4T0ksOgilompdQiYJN3TEOhZcJ/Pwdwg8qfTeiluCMJzvTVNO7NtvmSMS+PcqEQtOu+g5vSKkLSvyvdX4NInzYv5O2GkSp/W+xP1A+cb5bBUEZRClmniNIdV6ohTOji15fRRSy4rNGUy+3RqudZ/7pzoeDUc/jtKUSDMpTbcqXthERS9Ri+bRrbFJM/BEdLKe18jZtJf6/fffo6AuybJCk4Tkze4Y3PNxEA+VQdDYM5UFwtYQwkao4syUSbqfZHe5IK/IioPIqhlfWi3HP9He+rw0O+TCNI2386SK/ejYzT2ns7K2paJj8+pH8u8zd3jroFobz5kVZVemGAuaSF9RVKK1Q9QruGpdCn0crc2Kb8QJQlaESmOdEu2xxqhFl+cLVlRhhKUCnXP68/d/xpnBr5XmiV7lpiVc8ONxQM++qxdb93/piOvMzovjtHDobq/vEz7EDYfpvIfdfY2JdpJNtZV3dDLvz/rgPklyLTqp/8qLz79nSwRPuoKXowqWROViywv0LC/Q/zO/+wQzAXSZSdUg2web/wLEggBE14qrf9C6e7900i/SW+sZuY+iO6PVVHF+JI8zjAHpnUGwoHgnivsE4dfq3g/Vi4eGudAjEG6HVD76+Lt5Beizreis3P211+PFUH4U3MOBub5+Pdu5zQFouaSlFoLW1MvrcGaNZr3dOueXLxs+WqUotFLDPziNxU+A1nN/DnefNpw7fT+yRFSvB4u9thh/623hMpkAxEogN2C808iUUyX3xkQ0ugz6ID0Mk9eNim1JwA3W0/E2XbUSACwrlAh9riGwHDG/XSeq3QTjga6wbxU0E1T+Y+/gwO7oJz0EMIkbwE9Fec5jvcdvFpw4/PiH+b/nOP18dhcFWwqBLXPyzUFA5b7JHDYhZIk8cBEQiL83B857eYwxCnmniNZKjCdZAQ6Md2slUYkbtvXgGRVR/zDDLPphIYjlVmyWAAlVrFV70InuxZ7jt+2/T6rySkJpDcZzYY/7dK7DXlOd/GlMpXO6KHBFbBoZe7VoZNCXio3FsaRkFx8PKQ5eZ6XnBsBEv/vuPzFBVBdNWf+hAUeZGMw1HHBoGX7qlhEDQNWgF4crsQh44Q2F/8ULTejcBGY9MyxXU5z8pGcuTAgMMHsBgdpESVhBBAHZT4+40AbNdREIFl4gJUDscC7aq/X7uBMekzuaycoAHgtyJ/T8WkbsRR1OxbaOOustR/AiieZIIVtrTt86ga2bpktEgty0RWsIigAZ/3GwjUPRB+NtwHrjMkRj0LFG8HuDrFgdzsb8gsiDcY08NqMn3IqQ4G3RkEs/gOhpMHBkUZeSGvdJwKH+9Kc/4ZZ5ePoKAae6Zdp7sBOvvLdzZ8ZiaGGC3xsfCH5+9urN+ttr4hhBvWGlzw/l+nM8+eDGab5rM1cmfGkeam2f6/m5ypaZe1SgCZC0bVzici9eWLMVDZsKc8mX+8/p6fHg0ukVzff0quTIl/sSYI6I2n0CbNsXZCtPzcM6UyHZVwPFwACxFQGYmgDJnVsfTWlnLPFlWTh73ipqHqAjetlRnokdgc1y70/CadCApqhu92RYcwjh6m3GxxgiXDRI9TGvaVZL8PunlthW/9CQ6uctsKDLEc3LMudICk0iw52AQtTIfI+41ZIVYx8BZx3E0OCyUNUeVrV4jcumIsbmPayrbbku9Y0dRWJsatGE4LHPQIrdgtynqU2Xth8ut003ILpUhu3ykLvIlpqxQ6kigK0Q83R5tqXgGdCWW2gLbpl/qLMgppVLcx0PsU3wK4qjoNSDsc7q0EIKKSCG48m1Q7TuIbasM/L9g2eLtZ6yXSqIQEz0j3/8I6J01RZ06wCjC+kabtOalq+TcqQBv9jPvTOe1nrqwbz23UH7qkaWu2f9OA+i+OwY8bmp/FSSjBtun957RrdOp8jUNck8vV/lcwuVES2XS6t14B5o6EicinJZXiVQndzNBNofgNfDItUWRQfqHtb2OSO6gDAKvqbvPpklVTM0HlxuhkPIlybHjorohuyV75ufWEj8HBTC+MuOeqpPA1jWFFktTgrDRQQ4Z2GCzfxOxoOENJVIxhGWD8t+raqzbnbmsQoM29oCxGImZ5Or89DmQ7tD91rMXIRl6VCyXxwrYR1b427StzgOGRqdgdKJL2gAgudnxqjJxAbUAY6O/cCsqNtKkO3Tz8Vf2OWkBwYYgmckZL2wfW2CYGmoA5g3/6mz2uZHZqCEPuKmqd3nkGiNAXHsPpNBbfHQ4yGWghMMomM9l6OvWsSsoYQcEWi3sMEMRo312GDyskoN5A1M3lf62Zz3w3uAy/XZXoKIjucTRPLtt99CigkfoyqqNQjAv08hPG21RVINblMrK6UZm0bksZiLC+1pY4yBgDfWBvDjS3MgxBPiI24lLkNriZBercH3u6HRnAtYhv+rR/URFz9+9JkP8ExYAiPxfdGkcGODR25bnA0+CztiAT4k1q+911gBfzmsD9M3qnnwMyWkA4fETJVMW23qb8NHnJOkd7BA0hpa8ONpLVKCWoFRffPNNzjhY3U04WzY3TFxtY5KeqtjaUc5ny25GG9nsjtNc5UUF6M15byLzOB2DJspBNdj77/LubOdod2uQ5GKfkxrbwMPOVFOezjwmIxYnyrL9FPRTU51V2ddnOjlLl10CaBdFvWJIEKw02MazbpnHvVnplRwwRP5nmqN8zEHDcc0etr4BJgYfOC4cw9cqLLIRzdO8KdQsnM9RsjXsF0dc2DhzKkZT4NlTzMATcbgpbqof0p04vyTFS4Ucil46XSHdbfXpw9zl0KtNnMhxDboHUzqTTDkkkVB5FIAZh4BEx/lx6zQt7mwt1DOyRKG6pPdhFxeqI4F3xkmMzy68jYc0qDk6tHCYPhYiApC8jsDalAxprHhBCUQfApwde6MUJo/AkhsGo1Pda6gOwqgSnlDlvDrnAm8KQZNXInDxs7VoUTLFI5XbI+F9sonL/qzf9twZBd8umSet4Hi4G84oqIFCguXIhKVrbq10D/8xx+Ks0XwYlTEuyPR9K9cjmhSVRRUhS/TfdEVKWRxyjeoXCu/KQuPEe2zc93YTq5V4d4UWbRJvpch0DBHlIjiBdZeJJ/owTZF4L7q35gpCj2juOzWIeYrBBPdh/6KMyCarPetqWIYMuTha05Yq1UtMZE71BVdzuCasMkX3b2V/xFcZ5HCfQ7Yitv7wFPgJEwtXKOY0FTwjpOYWrsrUsgFt5Ma3HhvmHwy2M4AnGHC9RtjJI8yc2mxQIlJgcDTaVb4wSw5bIRvJP+T9CDzK/jAJHwmIzHvCpchgIMrTDtjlOYSqh5rYHscGy1ziWErJGh8qjYY1RYS8hzPnfIr4KNGEEqI0xzhQxHvt0GAFgDkRStk0VCI0iUtQvIhQRJIaoPYOVMY5pMRyTbKpzgxTJVA0E5Y7HvcfCMeNHPjbeyhRbMDBcY1o6gmRuvnD/zJGsd6Nz+DhO8O0c4Qt9+Xpd+xgx3xIKOz6di8M6ysaREC9wlv25UFdE8OfJzSUvTCgdiIRJeP8SAehyBgWAY96L9//TXkBubi3Zoa4/X+YcC6g5bSI7YTkse0PrpzCt4hhP9U7uAadTjTGzIImcM8vphdoNc4SIe/Jc9WgwC/F67UE0ZbKScOoldnj5rkMh98v5tGcP4870wMAe9ckHIPHBNoi41C76U8ME2q+gMlPpTt3ykXaQwaI2FNqsJVxgCOdJBTDvQI03tLXfXEc8VayAhFowEbyxg/xIXUIMWRofBXAs5DCvrcBnOnU4og1jU2loSVDQFjcj55zR50nF86rS4bQ8mFstg6yWCg0bhEsgeVhS3En7ph4w7l8f423rczB8rzf16RI8yZrXKkvA+h3+kNBYALgWgiTTmNokTDsGotkLg5WuvXqAKGKzUZabLKmjEgKMlK3ea0CeelBkA1jhNJFfQAs4WZiOTT23yvM8To2QYPQMd7K7D8keciRRw+MEQUObgi5FgfRSkknhhaZRqkFcIeU228BdkXAJpEaSKVDeCL/oS/DTmqwYCWBuKwq0hCjAq54lR5PViYpMiIanALgyPT1H/pK9z56IE/mBis8kL1xAognO9gFViuWWl0ghcFhGAp0rLfidrWaA+uV7CYZ17r4ccI8RUeQsUnLm9JqioEoZSC5rVy+THhGe68pHeOWuHeAetSRJlQgPHr3YQSD+GS0ziqGoxg5LjAU6FXloYHXhHimVYYV/HgGNeygPq0ZiUg2vnaC1wLc7TapCyJXCQxryeufUQiZNyv5DrEja6EqO4ImTsESOYRVlwumxaQnOqDSKS6Iy2uYFPBQHwPCmVTx13HCF1CGKer76iYSj5mUIVh0QQ+l9sDLPWkFR1Smr4EeuIyBH5vs2WgURHTsGyslS905R0TKeIAPuWG9t8tqY61QUozA1UcqMq/JtgwmUXqDrY6y28pU2RHj6LEa92NLReYz4fKx76S5F+hvTATmD8TkQRJGfTwK5WMPMoLYm3awp8jjoniLKy2tVU1JeDFcKkwEZo8wt/gEgCQeDYVIWNxAnDwNEPh3ogOBKE4Qs8oCNupchQCpXA4r1LzKrvKCYjwdQqcWEayrDj+V2lSHzodD2uSb/KRQm+Zbucxl8hk8s8CyyuJdLJeQnWAR4rvVjaUVZ5Mdqvq55b1LdPiIOx1Ve4jxlHUKByOnAMjjYEAOmEuXelStcUbjCN+sh+t1uIF4ULq8go7dGZeQ0V/QRqtDvHm6zE7h6IEyOZeucjO9AuQ4ynBIuYqDFtTJxGR7elM6Ynmh6P8rOFnzsqDyKwhjhChWXP3QqqHQhEsUjoYl3IzgiBoq5jTUQpBQyPZbt22lnWVU0lAPQ5BaioNQICHi2TYjqBV5eDUKLg5LW/y2RoTv4I9W7ddd8TR5bUU2YnrQGuHP/H5BamtqdIbsD61DQ4FguNbRL+z4Z8efZ/1Z3x+1ScDAvLFEvHaA8to6ta2sHhSgM6MBLQCDv8v4NY4+Si02qHSeZ345PQczU6RC4tbSiws01BUjmOtCASphslwFFO5+JDkGGBO3obEnCF2cIwStummdo4qalz3qdltnRtK/neJsdVWbIqQB2G63YYwgaIgVlU3MwU0qrq9JlLXXY1wrfVMWVkButM+auHgv5spjRn0ax/exKoQjATJh+26qAmZVxh+kTnLJR75VjpantITG1TQPAO6BYzM2fUs6T5wFsVFuCi2XCB5ga6aHA49VEwuAqjz+P12r2AMq586IniVjaI0RdJMqa+KuU3ncGPKVZELl5AFk11PWwpsQorDriCUZqEVbcHzK80cMRcr3IYgiJ+tzNMekceB3roK9dg+lZz64BT0fYzTc1mKLhaHQmkiZN/HvdAQo7fGzPT4kN8f3aHoUPJqnFq9tQtt9sPV/Zl4zr1pHPx9K7BZCT+5ddZD7GpDqb4I7mXQtBX4T8NnkM8CeBt9QZMnLipnCOsFxYVAvV+R+qK9RNmA6k6DqUrro7e2Up+cQsixe9M3AXKJlL2CtC6JpNdiPPeTxVuBW3f573bF7cMeNJCHkiXzyezHQMT2nGw4IvqFf3BnQker5oXrlVL/He7RZrB0B+cO8zmO6/bRuJrw8ErN9kIKq3hEsOeU8/DlGAf/mE1tG1p1ZfbPvX1aS6+0ZGLqvnW4QdNnhi1de5I+pN6z1nUrBL00SuKUx3AMAiil/1/SzMXiayNBLwHTq94Wcugp0fvVTwmoo3n7hAYtG3R9lNR75jd605R5sifM1TF3iJzP8+KsiU99Q/DsGtnHCKwnr4WDfO7zX5nCHcV1qwrbzR9fHOEfmMuTD/kcS+CV/Ta5Byr/HNepfWLrMz9bSOGK6c+J23eggOuOax9lNXZme9DQ1kS75K7AebFf7JXv/ILghTxDrzdfcLtE3xM/eElo3//BTqL7HC57euLv63XNeMa2nihy+KR6/DzzxrcmuYET/MSE74Xfz0GYrzLJDfzlZxnb8494Wbj8Y8mKJ81V/G1X6apvIX6uZfksK/+nWZu3DvuYFSoNwyeJ6zMsl59ZJf892Q7PtJ37vylCP29jLn9ydbZX/xEJ5++OFn5qgOEgXH6eTasq0t8Zzv3uAD+FVsOHBLSeL2n5IqM9sZW9U/OSeXXjhrYX7hNj7CJ3zzmJH8eIr/Q0unQqP4S+2s/KDgmfx0sXlgs+VGlUx+/tmYniJxJqLcE+q7HRVJab70A4QxLf/blW0WHMrpBWL7Dt5mPrfM9XmQo/oX77WzlJeFpIrdIGx6qB0tZjuVrAHmFLjdqfEyQFv2olXJ6WXLgvUKzwwdv3fSbQ3RVs/BCiPxC+b6V6pbGvraIPJepqw3AzqHS5H2jrenyWFfcBkeljhsOLNPKK8rKbmFSVyVD2nLqxb9eFuk9l0Ps1jCql+rnrW8TFl58y4Ysq4fz3R2RynI7rnFIknjVvT7VZOsLvik89G72/LTCr83kfbrm9tlFHgj9E69O/el0k7K5QuNPb4SXFeve+QzRdRJ6q0NfdcIoF3qErub2W5xMx/PtPZqZeEFy3JWil4GqeXrS6eIKau0W/amvQMeKqF9OVC7jYOU8kOwlQU4t0pE2VZtMlaQIS7F3z8+I9qa6zdEf55Zg9UHUP7s6ApVzVUM2iy1RJ7UhIUxu1q40NuK7G7mrS3CD6qBCZtu6W3Cyr+IUxWjf2KoufuK4sMtXkcnY8Ua75QdjHNvaPfdVU4d+Kde1kwieYBRzAenjNaZPJDKEaBbV5KA4Up82tqsLtSW7qw3EiXJi4ltyzgJQG9KNuWWKuD5HhpvWjm1HmET2hei1x/rG2sVBZAlsPlFDpXlLBJVSuCDGcyOlEgy+6xT+lGkqJy3bqhaq4asGhTOgo0gQqO6GuFxeXj5gFw6yoOTO6O4qvaKh0ZMUaM7Ys6UjEqdTeg6X1bN/CgotpxnQXjrckODUXao/MWwqvURcF1+7UqtTHVQMHvVmJ7tF8ijOEeEK5C72n0nSqIp/MsE6tLsYLzZxDo8pVzXzXYdknYkPtqdUXZ9bQiNXa/L8kLmjRZLGcUHlA3e0p1bxgGpu7W5P6uivrJC0RwSqhsVpZYvdiWputofA2AgPNMif2IDxqUZsq6rG3u6qymS82tWqaiKvoxocGNZQ3iNLbYv8igTw8YX8CkntNUS+n5E9w7525bLMVKPtqi/FGYa1dtV5XFwMu5sTlImydZR3jTXVOQbW9fD0gB527introOP4DlduloCSWiifuqswCtcqgi9V6jtmgeJVu+yH+B3Z83ZC0X+L0IZVXNG0rZxnPy1zjea3YMaksaU9kJrUlSVjlzFhziVQWIG6bcVKgO4kRAvtXkIp5knEGIu0Ks8RwSo12BotJlb/31ksu6xJOgtNbQHGBLvH9ShO86jqb9mxnZYCLx73czEub22rs4hy8RwKs4BObu9iTRR9WdXHBum4XsJcFNk3wtoSLVg21N9aU+8hBAtMHmahyWpyrq5HDpHamCQE3peZLZzTAWmVX//mN7/659///l9WSYfR3uNXj8+DsJtzYUvlIWBcq1FmeJBymKUo2QZy/XkslaJkxkk1cZQMfi6fSF3S9l5bMCuNLDvbDeKcdRyLifne00K0umkHIWg3lCRcfRLa21HCcyqwJYxiwTBdvZcmzzhH0YgWZougMR/jwvNjL21ZiurbDFF/Lh/JnbRlq4kdAbpURIjn6YrgmNMecJtGSm7B3rYmC2ps9WAQcUyzqnaCa40itH7YnfY2s88hWV2Z2tUunS8yImoavyH38mUT2fDQ6qsCslDdkN1YfbscZE1g1B5xzcCmBWDiGlfRWJ0VabT2zGEGsirE/y42cDN4QQmvtZ0uezz33379xRe//P1XX/3rDLV/8cWXvxSR/wIQiowXJSHA/ZmQm+uJcHHfvVdcCBfEuLR9650mrmHXEnS852rsI4/KjE39OUMoeyp7DKn1RWhgl1tP7Pev7c31XbAqq8XQMNdOZvLYi/AYplH9H/HFi1zxXOoRtaxfiKWT64P+uDdU7HXt9ny7LVPJ7Rq6JH1o3LQJwcyCi2+6viFKfWN2UHcLHrYAVxvWptsvCxd1ElmWyF10NBeL006o2QU5UiTghpu1ijUhES3r/1VUmpvCuU6T+/CbuvQBrMZbEhqYLcMXvi/R6pEk3KOHvo8An5lvQC9MQx6ZUaO1cIXOk0b+HxH57osvv/zFV7/73ddf/va3vxCRv4rIX+1Hc/3YU9sTkGWg1J4jxS7haSk2GJNNK8L9rIpQaJRb6tZs06Q5/jSJTYBl7YUXasuIhddlnraYjLBogXtyiecKuje4SyJUvTGGo5FLQK9ibyKx1hJbaQq/jkvpSujUEHqSaRL2vh4O0+z/DgDf5xFKOa+IogAAAABJRU5ErkJggg==");
                }
                .tableelem {
                  padding: 2px 10px;
                  border: 2px white;
                  background-color: #E0E0E0;
                }
                .tableheader {
                  background-color: #C0C0C0;
                }
                #notebook .bk-plot-wrapper table {
                  border: none !important;
                }
                #notebook .bk-plot-wrapper table tr {
                  border: none !important;
                }
                #notebook .bk-plot-wrapper table tr td {
                  border: none !important;
                  padding: 0 !important;
                  margin: 0 !important;
                }
                #notebook .bk-plot-wrapper table tr td.bk-plot-above {
                  border-bottom: 2px solid #efefef !important;
                }
                #notebook .bk-plot-wrapper table tr td.bk-plot-below {
                  border-top: 2px solid #efefef !important;
                }
                #notebook .bk-plot-wrapper table tr td.bk-plot-left {
                  border-right: 2px solid #efefef !important;
                }
                #notebook .bk-plot-wrapper table tr td.bk-plot-right {
                  border-left: 2px solid #efefef !important;
                }
                .bk-table table tr td {
                  padding: 2px;
                }
                .bk-table form table tr td {
                  padding: 2px;
                }
                .bk-table form table tr td input {
                  padding: 0;
                }
                .jsp:after,
                .bk-plot:after,
                .bk-canvas-wrapper:after,
                .bk-sidebar:after {
                  content: " ";
                  height: 0;
                  display: block;
                  clear: both;
                }
                .bk-canvas-wrapper .bk-resize-popup {
                  position: absolute;
                  right: 40px;
                  bottom: 40px;
                  width: 40px;
                  height: 40px;
                  padding: 10px 0 0 10px;
                  overflow: hidden;
                  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAEnSURBVEiJzZXBioQwDIb/XQuF6U3wCRSEvv8zeFOoB2++QD14aqHSOntYtthxdHesDptTk4Z+hKR/PqqquuNi+7wa8DYIWTplWSJN0yDBGAMhBJxzhyFBJY8AACCErGKv2u4L1lp0XRdVBfBLTwghuN1uUYBNiDHGn4uiQJZl50GmaYJSCm3bou/700BBT4QQAL57IaUEAOR57kEAMAxDHMRaG1wuQc45aK1fBqwgz+wHpJSCUuoayBJ01P6/djHG/jR1hzWDMQbOuZedvak7XAljzAMe/xGlFEmSeP9wJVv/SGsNzjmcc2iaJg6yBbLWghASqHf0dEkpAwl6thpOGWGl1O46iIZQSsE5Dxp9OsQ5h3meV/FxHP05erdaa1HX9W7OW2TlC31ceRWbb5+AAAAAAElFTkSuQmCC);
                  background-position: bottom right;
                  background-repeat: no-repeat;
                  cursor: se-resize;
                }
                .bk-canvas-wrapper:hover .bk-resize-popup {
                  display: block;
                }
                .bk-sidebar.bk-logo {
                  margin: 5px auto;
                }
                .bk-logo {
                  display: block;
                  background-repeat: no-repeat;
                }
                .bk-logo-notebook {
                  margin-right: 10px;
                }
                .bk-logo-small {
                  width: 26px;
                  height: 26px;
                  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAVkSURBVEiJlZZ9jFTVFcB/5743O9/srsuy7iLLhw3WooUFtUpbkab+UfsHxtAgtKVFq4QYRVJrJDTEpBsT0mojjSU2JNAGUhRb0CZNmhjb0jbGEldWKoXWCC4bhl32c3Z25s2bd+/pH+PgsFIWbvKSd2/Oub/zcc+5V7iWsW9VO0Z+DnwN2MG6w89Pp6KqAMhVQ168exnXNe3EN8up6jrgJaLEU6w/EE4H8v+fwBu9zDGO+Kws0QOHFnX1W/MynrQiAlVlAzxObHIu7ya/w7LSxJXs/IxHb/SyAtgGzAdiKV/sliNf6DheviFBewqsfipsLNiYY2BxD+XGfq6/bpJM5mOce401q9+r9+gS0B/e50ZV/gLcUFtL+UxseLOr72xD+yJaEhC5TyCVACe/o/8r8/BnfJnmLKRTNW8vABtZs/pQDWTqQZ5hXT0EwIMTuVKyl7hAzRkTfkQ4/F1OfyNPpm05HbMgk65BAFqBZ9j/Wuyi8/Wbjk0wZ2owY3Ayssnz+F41/bi3mJy5hpEnVjK7cRNtjYJnwLmpWWjHY8FlQScGieeL4Netpg3HiKcdngCum9h/v0nxB5ZW83Wy6XNE7nKQqo1CvDa55NR1RKazf9SRTVA1UiGwXh/JeBkJv8/aw78G4MCHJ2mZfQejhRSqs4xGHU7sHMS7FTE3o7IYISBVnKztLQDh3ozxlF2B0Q27MqXjDS1u6cKZUHFgHXfev4R3LmdybSzcc/aRsFjpCibLphJFzdYEn7fGztVQn5rYdufueo+etcKjSWfYNJY6tT1WONqcYOPMDHmn9F8JUo2vzcVT3q9izUlc5LBhEhc6wnLlp+07PziVe2LR3yTcm/k28BvAKNCgUioUzIYdt4zf1ZXlwY4WbrlrPkPTsW462LdF4AXxLgYKZxVn7Uci5j4J92ZOADfXK8WcnDmPPPCLpfnUHWWO3/8l8tN6BSx4/dzBWKmyunbERARFQTlqgLcRLinditF5s3A7nlvCP64Gsn357sTOxu8tn/vBu88GTeljuGo9qWqt9m43zrmtWO1BAU8++cD63BvuzTx3NZ7MT88w4wu++Mu7n//jtrwf/jjMpvPitF7kJybxUHHQDdmH3GAlpyMhOhFByUFFQdka7smunw50buhsKuE3ZOjoXLv+vh+t88fGXwnTSSfVTvHyyW91bjcAiaeDXntBHrfn/MGon3/b85Xfu+Hybkrll4Ry+3QgD1oiG83LJLKkZneu++rWF29LDI8FlVTiILAZ6jIztOK2Jv/60b8qdOKkF8sJjeS4+HpGGlwO1QGvKV50g0SNh05OAow0b1oVL/Yv3HHryqNJJ38WBARyA2cYakn37H+v+x4VJqCuM/gdIykgIdCE0RX4rJB4ndm+l4tGyyVtzG0E3hxpenSLavRCZMdfDbxYLukiFMWIobG5jfB83wWMTDD14lMIBexn4iKAMWhQabdu7BXeXjk8MqPzsIisUlcm1IFS0tklNXHnHMlYgta2zoCBOjtrP4HqcFKkn/qaMtXbNJooqC2P7/f+tOFVk/T30FBcDHGclgk0avIcbVPtyzSk++rnF/t0+4HTqmg3fNpyXBBRGS5gR/WY/86DkUmbfVWIIGIgmqRgEjd56O1T7tBh59y++oVLunfzb08fGVu74F6MrNVydKMdK2S0lG7z/7NymUSpLvyA2oYKaCVP4MU/h8pZoABEQA742TM9T/5zagauOIpoLMg+tgsvfLgmLmJAoTD5fmFYhx57femTfzdRxfjYytaeH35cr3/Nz62Rpke6gaeBGAiq0b8KwYeb55aPvHUlvWt/11VhDwPdQK910ebW/J5T0+nUQP8DlJ5h77VoIjIAAAAASUVORK5CYII=);
                }
                .bk-logo-medium {
                  width: 35px;
                  height: 35px;
                  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAjCAYAAAAe2bNZAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAf9SURBVFiFvZh7cFTVHcc/59y7793sJiFAwkvAYDRqFWwdraLVlj61diRYsDjqCFbFKrYo0CltlSq1tLaC2GprGIriGwqjFu10OlrGv8RiK/IICYECSWBDkt3s695zTv9IAtlHeOn0O7Mzu797z+/3Ob/z+p0VfBq9doNFljuABwAXw2PcvGHt6bgwxhz7Ls4YZNVXxxANLENwE2D1W9PAGmAhszZ0/X9gll5yCbHoOirLzmaQs0F6F8QMZq1v/8xgNm7DYwwjgXJLYL4witQ16+sv/U9HdDmV4WrKw6B06cZC/RMrM4MZ7xz61DAbtzEXmAvUAX4pMOVecg9/MFFu3j3Gz7gQBLygS2RGumBkL0cubiFRsR3LzVBV1UMk3IrW73PT9C2lYOwhQB4ClhX1AuKpjLcV27oEjyUpNUJCg1CvcejykWTCXyQgzic2HIIBjg3pS6+uRLKAhumZvD4U+tq0jTrgkVKQQtLekfTtxIPAkhTNF6G7kZm7aPp6M9myKVQEoaYaIhEQYvD781DML/RfBGNZXAl4irJiwBa07e/y7cQnBaJghIX6ENl2GR/fGCBoz6cm5qeyEqQA5ZYA5x5eeiV0Qph4gjFAUSwAr6QllQgcxS/Jm25Cr2Tmpsk03XI9NfI31FTZBEOgVOk51adqDBNPCNPSRlkiDXbBEwOU2WxH+I7itQZ62g56OjM33suq1YsZHVtGZSUI2QdyYgkgOthQNIF7BIGDnRAJgJSgj69cUx1gB8PkOGwL4E1gPrM27gIg7NlGKLQApc7BmEnAxP5g/rw4YqBrCDB5xHkw5rdR/1qTrN/hKNo6YUwVDNpFsnjYS8RbidBPcPXFP6R6yfExuOXmN4A3jv1+8ZUwgY9D2OWjUZE6lO88jDwHI8ZixGiMKSeYTBamCoDk6kDAb6y1OcH1a6KpD/fZesoFw5FlIXAVCIiH4PxrV+p2npVDToTBmtjY8t1swh2V61E9KqWiyuPEjM8dbfxuvfa49Zayf9R136Wr8mBSf/T7bNteA8zwaGEUbFpckWwq95n59dUIywKl2fbOIS5e8bWSu0tJ1a5redAYfqkdjesodFajcgaVNWhXo1C9SrkN3Usmv3UMJrc6/DDwkwEntkEJLe67tSLhvyzK8rHDQWleve5CGk4VZEB1r+5bg2E2si+Y0QatDK6jUVkX5eg2YYlp++ZM+rfMNYamAj8Y7MAVWFqaR1f/t2xzU4IHjybBtthzuiAASqv7jTF7jOqDMAakFHgDNsFyP+FhwZHBmH9F7cutIYkQCylYYv1AZSqsn1/+bX51OMMjPSl2nAnM7hnjOx2v53YgNWAzHM9Q/9l0lQWPSCBSyokAtOBC1Rj+w/1Xs+STDp4/E5g7Rs2zm2+oeVd7PUuHKDf6A4r5EsPT5K3gfCnBXNUYnvGzb+KcCczYYWOnLpy4eOXuG2oec0PBN8XQQAnpvS35AvAykr56rWhPBiV4MvtceGLxk5Mr6A1O8IfK7rl7xJ0r9kyumuP4fa0lMqTBLJIAJqEf1J3qE92lMBndlyfRD2YBghHC4hlny7ASqCeWo5zaoDdIWfnIefNGTb9fC73QDfhyBUCNOxrGPSUBfPem9us253YTV+3mcBbdkUYfzmHiLqZbYdIGHHON2ZlemXouaJUOO6TqtdHEQuXYY8Yt+EbDgmlS6RdzkaDTv2P9A3gICiq93sWhb5mc5wVhuU3Y7m5hOc3So7qFT3SLgOXHb/cyOfMn7xROegoC/PTcn3v8gbKPgDopJFk3R/uBPWQiwQ+2/GJevRMObLUzqe/saJjQUQTTftEVMW9tWxPgAocwcj9abNcZe7s+6t2R2xXZG7zyYLp8Q1PiRBBHym5bYuXi8Qt+/LvGu9f/5YDAxABsaRNPH6Xr4D4Sk87a897SOy9v/fKwjoF2eQel95yDESGEF6gEMwKhLwKus3wOVjTtes7qzgLdXTMnNCNoEpbcrtNuq6N7Xh/+eqcbj94xQkp7mdKpW5XbtbR8Z26kgMCAf2UU5YEovRUVRHbu2b3vK1UdDFkDCyMRQxbpdv8nhKAGIa7QaQedzT07fFPny53R738JoVYBdVrnsNx9XZ9v33UeGO+AA2MMUkgqQ5UcdDLZSFeVgONnXeHqSAC5Ew1BXwko0D1Zct3dT1duOjS3MzZnEUJtBuoQAq3SGOLR4ekjn9NC5nVOaYXf9lETrUkmOJy3pOz8OKIb2A1cWhJCCEzOxU2mUPror+2/L3yyM3pkM7jTjr1nBOgkGeyQ7erxpdJsMAS9wb2F9rzMxNY1K2PMU0WtZV82VU8Wp6vbKJVo9Lx/+4cydORdxCCQ/kDGTZCWsRpLu7VD7bfKqL8V2orKTp/PtzaXy42jr6TwAuisi+7JolUG4wY+8vyrISCMtRrLKWpvjAOqx/QGhp0rjRo5xD3x98CWQuOQN8qumRMmI7jKZPUEpzNVZsj4Zbaq1to5tZZsKIydLWojhIXrJnES79EaOzv3du2NytKuxzJKAA6wF8xqEE8s2jo/1wd/khslQGxd81Zg62Bbp31XBH+iETt7Y3ELA0iU6iGDlQ5mexe0VEx4a3x8V1AaYwFJgTiwaOsDmeK2J8nMUOqsnB1A+dcA04ucCYt0urkjmflk9iT2v30q/gZn5rQPvor4n9Ou634PeBzoznes/iot/7WnClKoM/+zCIjH5kwT8ChQjTHPIPTjFV3PpU/Hx+DM/A9U3IXI4SPCYAAAAABJRU5ErkJggg==);
                }
                .bk-logo-large {
                  width: 75px;
                  height: 75px;
                  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEsAAABLCAYAAAA4TnrqAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAABNHSURBVHiczZx5nFxVlce/576q6uqq6q7e0t0habIRgQScfEBAJ4MLo4gogY9CAkkIApElCqOCI8IAKriMg6MwoqiBgERMIJEECCoIKKIYWcImS9KEJCxJOr2kt1rfu2f+eN2d7qS7tu4Efp9Pf7rqvvvOOfV759577r3nPuG9hF/PmQXmZEQ/CkwEtqLyV8Q+yPz7nn03TFLVgc/ybhiwD+469WiQLwOfAmqHqbEb1bWo/JCFa148kKa9t8hafuqVGLkWCBVQuxvVy1mw9hf726x+vDfIOqMxzCdm3U4sPK/oe1V/wIK1X98PVg2j6t0m63uzx2O95YyLn0BlFKwtRcrPmb/morE2bW8MJsvsb2X74PsfmoToAwScEwgFAM17ywi4kLtO+78xtCwvDixZPzjuGMQ8CRxFwIFgALRksgC+xF2n/WyMrMuLMWmG9zxLRQjGIYxjGFc5tJLsOX8+/Ij1LbX/g2gDVqE8BI3VYEdFVj9uYf6ai8dC0N4Y3AwDpQpZs4GZYjgVmCNwEBAFIsPV3ZXFa4wmo2QDEMr6hcGSVe8L8S7il0sitM66l2Ci1S/UXqz2kEgYKmKdTJray+lzukejpmiLVz9NNBjgOoRLASdffQGs0tOTDbyO0WkDF8rGiCwnk6FnQged0xcRTC4aKPcdopfaWkNNdRtepouVq5pRfQbVFZw1d2Oxqorqs377DNXBIL9H+AoFENVvc9CwvTVV9iLSN+oZ6euvijV3L5hsM11Nt9F+pIs6DAi0FkSgujpK/bhygsGJwAxgDiLfwpiXWLnqTn5z96Si1BVacd0GAo7DauDfilEAINDd3FnxGkb9Dj3ggFMQ1yPDZO6h9cjraX//SYidgFhftrVQXg4NDVAV90nbdxAJAgsx5klWrPpowSoLregKF4vwsULrD4Zj2NKbLOtA1H/4AQeMKXUk9Ah2XcimT19BYuJ1ONnJgE+SMVBTA/XjIFzml+XWMR7ht6y458hCFBdE1r0bKBfhskLqDocywyuo+LpUIRQAp6SBeBOBnuP5+9V3E3bvx7hNA94UiUBjA8QrfW8qPNCtRmQZd63MO90qiCwHPgYU1b4HI2R4hUxwC4r/9EuJr1RvoXzzUTx30RYan38O0RkD3lTb503BYCHeNByOxphT8lUqrBkaPl2s9sEYF2ETGccftgUIOsV07i2ozmfB2ot5+gaoeesh0ElDvKmy0q85qgBXFuarURBZIkwZhRWp2nq2EvKCoOAU41n6R6x+hAVrf8MNP6qi+uUHsfYIHGcsvGkohKNZsbw8V5W8ZH34mwQzLvVSeqy/E2gj4AZR/P4qv7As8A3a3E+ycO2r/PDGCpQ/YPV4YrE93qQ6epL2oAYNTc9VIW9kOLOJirdaiU+q952iBNteF8Hlu24YFEJBvymOLOdFVJewYO0TACy5KkA2u5RQ6FiqqiAW9WuVtlKRC2WINOSqkNezGuLYzl681i4/liwWqmz1NXm9gBJ0GHlKqrcAsweIOuPcIJNqfkUsNpfGBqiIjbU3DUYAqMlXISdCIeJA3a5OqIxAtAy8Ih6qgL8M7Ho7CQVdAk5wnx+r+g7IpSxYu3qg7MabY4isJBY9mVjMLxt7b9obORXk9SwRykWIWgs7OsDT4pYqFPw5mKcOASME9oncH/Y78TWrh5QKh1MVL6eiYiOqqf3kTUUhr2dpX3dsDHQloLUTGqvALewhewov+Z8sOI7imP5lmTToNSTlBs6/b19pl37xKeAElq+qxrF1iEwGZoAciXA40AjUAZUFWTIGyEvWG0HKJmcJO/h9VstuiIUhEs7fKlR5Wyy7AD9iLws6fReeBZawYO36vBYuPL0D6AA2AQ8PlC//dTmB0DRgKiJTQN8HchjooSCNFDjRLwZ5yTq/I3Tc47EMGfG1uxa2d8DUhpHmqHsgwitzjiLha3KEsqBB9Zdk7OWce3/XqCxfuCCJ77UvDZQtXSZURCpQUw8cBnIEwmHAwYP+giMLzd3Wc5KVWhaZH0o5N0UwyTWxlDUQdQx0JWFXFzRUg+flUN3fXwGEAq9izGc4a826XDpHhcXnKtDV99cMPDDk+jNX19E2oZHuimNxAx9AZCb+wmUVSB0BN5NL/IhkpZZFFojIHR7qHJkKJjyrq1dVpY+PWaYYgZZOqCz3V4e9kZ/HawOfvvbEDmC/EHXQT1+emOnNzPLSWqtWRVURI2qMGHHMeFQCoiYrv5OsqHFVbJ2KdYCXbTDb7oYyh9hAts64gY92wX0j6RmWrNSyyJlGzJ2AKJAVjcxKBz+yrce7fkPEvb5MaHA92L4bJtePGGMqyhtjQ0duROJl4Ug8fKebtlVu2sXLeHiuxctarKeIKCoW6V/pGDSciw0QSgZADYj9cu33n9vYdsWsW4bTs0/okFoWWdBP1ODyrGHSnN7yU7Ien3LhZcdAZy+0dvmR/TDoPlBkNS+Y1uyEnEvClSFi4yLEJ1RQNaGCqgkx4uOjRGvKCUWCmIAgBtQq1lPUKqqKiqLGQ0UF5KfV39swZzg9QwhJLYvMM2LuIkf8FczKFytmdq+8so1/oEw1BqaPh7LQPqPj5myGmZ87htRYEFIIDl259XaEc6Av3hEZcHtVnxwvY3EzLm7a4mU9vIz/fwiEXuvZE3f/11F/G3ZHOn179GhB/gLknHkDGsw4x5w+uXPnB9I86lmmxyMwpWHorpYqT5w6i+NH+fuLwrTlr9cEQoH1wCEj1RERMH0bKZ5irWJdi5tyyaY9vIyHdS3W1R29HcmTkv993PP99xqA5K3hqKgsIz9RAJINeatXvVjX3g3HO8ITnYl9m6MIL5T6o0vF6wuntVu155Njmq6qqOc3QwQcxxAMByivClPZGKW6qZKqCRXED4o1jp9R99tD79l2UP+9BsAxznkIBa1D92FStib1s++ewk5VTjPCUzt3QzLjR/q+VRS91TQW2DRvyuOKfqegyoOap1qfRLWKE3QIRYOUxUJTQX/aX92kbi2vQuS8oq0SFqWXRRddeSptBj6RdvndO+0MPFPlwHtWP1Kkvqmqfyn1/sEECnLqoXdvXQhgjGOOB95filARuTF1W2z6FXPo3LaLOZ29rGjtBseQQXmrVGNHi21zD/Osp58Hdo+FPBG57JCVWyoMyL9SeoJIlRGWJW6NOUu/gHv1HSxo6+bB7iTJujitY2FoqWieP2Wzqn51jMTNckTOMKo0jUqMMNsxXAvAvdi3Wjm9tZPzurpIjoWVo8HGeZOXKXrnGImbJ+llsZtFWDIqMUpW0U+Undv75zEybMww7e7N1QGcZ2BUmy4Au4zAk6O2SAiKyM2p2yoO2NpSLnx1+lUnXdB0aRPA63OndljPfp48q6AFYJxR1T8B20YpCGCmiD2gmXgjoSZas7giXPH4/PrzDgfYdNaUx1X1+tFJ1S2m7LzetzTHTLsYiMiizO2x+WMhq1R8+7DrTNAJ1MXL45MrwhX3LWq8cBpAWtPXKTxRqlyFJ/rzD24CesfEWuVHqdvKp46JrBIQCEerrdpJZaEyqiPVh4QCwYcumHjJkVvPPNRV9EL8ta5i4aGy3ACUndu7yaq9CsEPIkaTPCnUG+Ms7bmtesyXdQs0oB5ostZSFa0iWhadaoXHvtB0yfGb5k5+2ap+pViJCus8Yx4ZiK/C5yZu1KS9R3usvx/cT1z/n1AMiR8LSuaA5KnvDRXbRN/6uyDUxGpwjKkVZM1F4y/60KZ5k29TkbuLEJlVa7/VfPpEd0gwmlqX+LzX4v7R25HFbs9iW1x0t4cmFXXVH0+MFESeiHw7fXvsgK469On9YP9nq5ZwIEx1eTWK1miw7KEl9ReeuvGMg+epSHMh8hS9fOO8yc/CXpF7/H4S6tqFePYFTSnaY7HtHnaAvCy21UW7PDRpwWMPaYM90Icjyi8SS8MHNJwQlSH5CopSFamiPFSOVRvzwuFV/xmcd+LbH2yai0g2j7ibXjtj0k39X/aZ5kSvd3ci+jkMu4YQ4OF7WKeLbfWwLS7eO1mfyA4P7bJoSsFlMHmHOcHATXvr2K8Qjhj8VVUREWqiNRg/ny7Q2djw4JKDP9vYW199lY6Qk6Dw89fmTvqPwWXDzgnLr3GbrbWfVHQXjgWjezzHkT13eYqmFN3tYXe52B1ZvB1ZvO1ZbKuH9lhI23NSS6N5c5/GAtf8y3fiDHOqzKqlPFhOdaQaqxZEnJ7xB635zJnfkGyk/A9qhtKg6E82zp20z1GXEXd3ot90N/ReFb5I02W/wrFtUpZ9XkLuDsAiqhjdLtCDNSG1EkQlgJIm472JxdFeD/XJDWrUvD56KvIj7JS/D6gf7pqqEo/ESWQSJLNJCARCgXTmO8f+4Pa7/vG1c94MpDNNxvUAfr5x7uRLhpORc9+w9+EjHg5N6ehEqEKZoWg9Vl5Q2KiJsiczOyu2jn96/bu2FNMSO3OWZ3sC4xMPPA0gKk0IZcPVVRQjhppYDdt3b0dR3HAoMO6lTXNnLF+3c9PnPo4XcH7W/NmJI86Tc5IVnLIrjHEEqESoFJiG0eMEoDJFeWWK3YdMfRNhm8JWVDcBL4C+qso7mUymu/Hed3Jsw5aO9qoLL7Re7w3JTMs3gacBVPRQyTFE9zfHqkgV7T3tiBGy5eHwwX96elKoJ3H/vfd/MeeCQu7teykguhKagCaB2Xsy+sSCdoTD4X/uPmtKM8g/VfUtYKOqt6Vm5baSF+VaK89vMMb8WOBMqxlct71i0OWcmXvge1g8EieRTpByUxgx2GCApseeeizfvWN4gGYIjIjUAh8G+TD07apAj0igveOsqTtR3Qg8L8Ir1upWYGfNyi0tuYS2Vy4+ESO3AFMQg+t1ASoA35v1Y+MnheSGquKIQ02shh2dO1AUQUhVV7bTk/ve/UXWSIgBMYGDETkGWABgjICwbffcKW96vdk7ate99cvBN7VULg4GhOsR+RoDni5Ym0Dpa+WiFcBhhRhh1RItixIvj9OeaMcRBwrg4kCTNTyMoGnvYLc3Hde099TgS23xxYeLyE+AE/aUCqoWz0tC3xaJhzvBIZAzzXEwrPpzx0QmQdpNI8g7ec3Mc33/Hgvu6+O8rjSZtsTr6fbEcfWPtjzXf7ktvvhiEfk7Q4jym7S1CaxNIQSMX2ZmFaNaVXGMQ22sFhFB0bz9aD7PSgBjP5r1ba1rxsXrzOBl3Dc81z1p4vrOZoC2qsUHifK/iIxw2NzB2hTWpkCc8SgIganFLoZaa4mEIsTL49rS1ZJ30yZnheoVW7sZo+2kAYiAgtedJtuWxGay3cDZBz3R4RNVef6JgvxpZKIAFGsT+ORI2JfLzFLMsWqpjlRnmmoO7shXt4CcUn1VkJIMGYI+b7IpF68ng2ZcUDoQTmt4bNdf34wsCkWCoWtF5Mr8wiyu1wsYHPUyAKo6odQ+w4jpriyL5T3lWsh+4SMl2jDYGt+butK47UmfKJGUBjKfqX+s9fG2qsVHRUNljxZGlN/feF4XIDh42VPmrI+P5siMopvTmeSOvD8jryTLOqC0s8VC30jnkm1L4HWn+z3Mw0kvaPhj59/a4ouX9GXvzC5UqGra79xFcHDTkzvfrkMZV5KNgCrPXv3SFfmWa/KTVb3yjW2qOmwmXE70901dKbJtCTTr9R/RyGhFy8k8vHtde+UF94jIzYxwEH14sQbP60HV9b+j1Q3d22YiMuycsDCZ+qtC6hW0be9lvWsV/WthmgEj2Ey/N2X6ksoEjEUj7fND913dFohf8AJGTy9I5hDxBtfrHSDLwxkX8tIfKPlIgfKHbzz71YL2Tgsiq271tqRm9GRFH80tTcAqbmfK75v2eBM4bkKtXBt85OIZWrlzPcL7CtE9FIJisV7vwHeLMSpOMelSg9FmxSs4H6LghJCa1Vu6rJc9GfQaVPdN+hDBJl0/HOjJDJQB4GRTdDTeF1w/bzah9LcRLXHnR7CaxbMp+s8EKMb05boXizbgs1c9e/nLhWsvAe1nTKoXx5wuIv8OTEWp83rStV5v1oJGh5wnFIvZNSVhNh/biZMd7+c/lwa/v0rR1f0U4GFU6Q3FNj4wc/5E1wQjRgsLSlV5CLVXXPncZRvy1x3Dtxy1njW13HSn49nWRFzKjMWYGCJRQGwo3eC0Ns1wmj/0rb7U6VHpEnHIZHbR0/s8IgEC6tISG88j00/rdU3AGLXD/R5L/0EC1ccVXX3lhst+X6jOMXm9Sj/qfrM5CSSBEeKUTtoqZjeL4y0v5Ahrbgie103/M/bEIZxJfNfDrnUFDQxHluJa67599fNf3zk63ft7ojwIbfHF80XkDkbxgESC9PQ+TyazE5GAp/Clafpq8WFNEXhX3p9V27n0LlV7dukSBNUsnpcASKnaM/Y3UXvjgL4/q7bz1hVW9WxKWMnoD0atzWxX7EnT2HjvfjAxJw74m9nqOpcuV9VFQLq4OxVV3exp4tOHsPldyTA88K+xw2+SKB/HP+ZWEKz1VgSdcbOn80be4X5/4V199eau+OJaB5YgcjbD78x4oH9W1VtqO2+950DbB++Ft0nuhfbKL0yyhk8JepIohwApFZ5BdVUy2f34xMzdRTbZscNgsv4fCI1BY5O1DJEAAAAASUVORK5CYII=);
                }
                .bk-sidebar {
                  box-sizing: border-box;
                }
                .bk-button-bar .bk-bs-dropdown {
                  padding: 10px 10px 0 5px;
                }
                .bk-button-bar .bk-bs-dropdown a {
                  color: transparent;
                  font-size: 0;
                  display: block;
                  float: left;
                  width: 16px;
                  height: 16px;
                  margin: 10px 5px 5px 5px;
                  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAHeSURBVDiNpZPPS1RRFMc/5z6FLLKlQQ1IQi0y0L/AsF+00rC6M3eQN61buDDatWoXuRBahs5zeM/uiCi0aTKE2ktSrttY0NoIFzpzWnTHxscQRF/4Ls453++5nHM5Qhcspv62GByqlwAjIp+0xXKlbDfyWukMqqkfAeZEGAe+Av2h9AM4p7CJMFsp2e22xxyZMz8hwpYIg8Dd2NkCsAasxc6eB0oCg6JsVTM/caxBkvphgXWgoeho7OxqqPcGEjv7StFRoCGwXk39MICpZT4CXgC7ik5VXHGvY6pTgQBUXHFP0SlUd0WYr2UrPaYJ1xHGgJmKK+7ndjQbSEeTfUQeAeNNWmOSpD5FuBY7eza/4b8hyfx3VBs9CBeBviTzS0AU6k9iZ7/kDBeApyFsAicQudz+Bf2X1zvxvyO8MSosAQNJ5u90EQ0lmR/qkr8PDKhIzUTwTuGDwvzLlXpfTjsXeISFev0k8FxhM8K8N9PONkV5KFDoPdDVBe/7O/Q/A3+b/fKZ6FBfAwVRZqbdvUMDEJftDqKTwK2oyXY19TZ4DgKppt6apvkIXEV0Mi7bHcgdU5L6ERWeCdwAvgGnQ6l9TBuiPI7Lf47pWIM2FjN/00AJuBJSn1uw/MDZt3ntLzC5tBIPCBGPAAAAAElFTkSuQmCC);
                }
                .bk-button-bar .bk-button-bar-list {
                  margin: 0;
                  padding: 0;
                }
                .bk-button-bar-list > li {
                  list-style-type: none;
                  float: left;
                  padding: 0;
                  margin: 0;
                  position: relative;
                  display: block;
                  overflow: visible;
                  background-color: transparent;
                }
                .bk-button-bar-list > li:last-child:after {
                  content: "|";
                  font-size: 90%;
                  color: lightgray;
                  display: inline-block;
                  float: left;
                  height: 36px;
                  line-height: 36px;
                  padding: 0 3px;
                }
                .bk-button-bar-list.bk-bs-dropdown:after {
                  content: "|";
                  font-size: 90%;
                  color: lightgray;
                  display: inline-block;
                  float: left;
                  height: 36px;
                  line-height: 36px;
                  padding: 0 3px;
                }
                .bk-button-bar-list[type='help'] li:after {
                  content: "" !important;
                  display: none;
                }
                .bk-button-bar-list > a:after {
                  content: "|";
                  font-size: 90%;
                  color: lightgray;
                  display: inline-block;
                  float: left;
                  height: 36px;
                  line-height: 36px;
                  padding: 0 3px;
                }
                .bk-button-bar .bk-button-bar-list .bk-bs-dropdown-menu {
                  padding: 10px 8px;
                }
                .bk-button-bar .bk-button-bar-list .bk-bs-dropdown-menu li {
                  float: none;
                  clear: both;
                  font-family: Helvetica, sans-serif;
                  line-height: 1.5em;
                }
                .bk-button-bar .bk-button-bar-list .bk-bs-dropdown-menu li input {
                  margin-right: 8px;
                }
                .bk-button-bar-list .bk-toolbar-button {
                  width: 30px;
                  height: 36px;
                  padding: 5px;
                  border: none;
                  border-radius: 0 !important;
                  -moz-border-radius: 0 !important;
                  -webkit-border-radius: 0 !important;
                  background: transparent !important;
                }
                .bk-button-bar-list .bk-toolbar-button .bk-btn-icon {
                  height: 16px;
                  margin: 0 !important;
                  border: none !important;
                  background: transparent !important;
                  display: block;
                  position: relative;
                  z-index: 10;
                }
                .bk-button-bar-list .bk-toolbar-button span.tip {
                  display: none;
                }
                .bk-button-bar-list .bk-toolbar-button span.tip:before {
                  display: none;
                  content: " ";
                  position: relative;
                  width: 100%;
                  background-position: top left;
                  background-repeat: no-repeat;
                }
                .bk-button-bar-list li::hover .bk-toolbar-button {
                  cursor: pointer;
                  background: transparent !important;
                }
                li:hover .bk-toolbar-button span.tip:before {
                  display: inline-block;
                }
                li:hover .bk-toolbar-button span.tip {
                  z-index: 100;
                  font-size: 100%;
                  color: #fff;
                  font-family: 'Open Sans', sans-serif;
                  white-space: nowrap;
                  background-color: #818789;
                  border-radius: 3px !important;
                  -moz-border-radius: 3px !important;
                  -webkit-border-radius: 3px !important;
                  display: inline-block;
                  position: relative;
                  top: 25px;
                  padding: 3px 5px;
                  transition: all 0.6s ease;
                  -webkit-transition: all 0.6s ease;
                  -moz-transition: all 0.6s ease;
                  -o-transition: all 0.6s ease;
                }
                li:hover .bk-toolbar-button span.tip > * {
                  display: block;
                  text-align: left;
                }
                .bk-button-bar-list .bk-toolbar-button.active {
                  background: #fff;
                  -box-shadow: none !important;
                  -webkit-box-shadow: none !important;
                  -moz-box-shadow: none !important;
                  outline: none !important;
                  border-bottom: 2px solid #26aae1;
                }
                .bk-plot-above.bk-toolbar-active {
                  border-bottom: 2px solid #e5e5e5;
                }
                .bk-plot-below.bk-toolbar-active {
                  border-top: 2px solid #e5e5e5;
                  padding-bottom: 45px;
                }
                .bk-plot-above.bk-toolbar-active,
                .bk-plot-below.bk-toolbar-active {
                  height: 36px;
                }
                .bk-plot-above.bk-toolbar-active .bk-logo,
                .bk-plot-below.bk-toolbar-active .bk-logo {
                  float: left;
                }
                .bk-plot-above.bk-toolbar-active .bk-button-bar,
                .bk-plot-below.bk-toolbar-active .bk-button-bar {
                  float: right;
                  position: relative;
                  top: 5px;
                }
                .bk-plot-above.bk-toolbar-active .bk-button-bar .bk-button-bar-list,
                .bk-plot-below.bk-toolbar-active .bk-button-bar .bk-button-bar-list {
                  float: left;
                }
                .bk-plot-above.bk-toolbar-active .bk-button-bar .bk-toolbar-button,
                .bk-plot-below.bk-toolbar-active .bk-button-bar .bk-toolbar-button {
                  float: left;
                }
                .bk-plot-above.bk-toolbar-active .bk-button-bar .bk-toolbar-button.help,
                .bk-plot-below.bk-toolbar-active .bk-button-bar .bk-toolbar-button.help {
                  float: right;
                }
                .bk-plot-above.bk-toolbar-active .bk-button-bar .bk-toolbar-button.help span.tip,
                .bk-plot-below.bk-toolbar-active .bk-button-bar .bk-toolbar-button.help span.tip {
                  width: 200px;
                  white-space: normal;
                }
                .bk-plot-above.bk-toolbar-active .bk-button-bar .bk-toolbar-button.help span.tip > *,
                .bk-plot-below.bk-toolbar-active .bk-button-bar .bk-toolbar-button.help span.tip > * {
                  margin-left: 0;
                  margin-right: 0;
                }
                .bk-plot-above.bk-toolbar-active .bk-button-bar .bk-toolbar-button span.tip,
                .bk-plot-below.bk-toolbar-active .bk-button-bar .bk-toolbar-button span.tip {
                  top: 41px;
                  left: 0;
                  z-index: 100;
                  position: absolute;
                  width: auto;
                  padding: 0 10px 5px 10px;
                }
                .bk-plot-above.bk-toolbar-active .bk-button-bar .bk-toolbar-button span.tip:before,
                .bk-plot-below.bk-toolbar-active .bk-button-bar .bk-toolbar-button span.tip:before {
                  top: -7px;
                  left: -5px;
                  width: 100%;
                  height: 9px;
                  padding: 0 10px;
                  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAJCAYAAAAGuM1UAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzIwRUFGMDYyMjE2ODExOTdBNUNBNjVEQTY5OTRDRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDQjA4MDBGRDQ3NjExMUU0QjI1NEVEQTlCODRBRDIyNiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDQjA4MDBGQzQ3NjExMUU0QjI1NEVEQTlCODRBRDIyNiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6N0Y0M0E0Nzk5NDIyNjgxMTk3QTVDQTY1REE2OTk0Q0UiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NzcyMEVBRjA2MjIxNjgxMTk3QTVDQTY1REE2OTk0Q0UiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4te1g5AAAAk0lEQVR42mL8//8/AymApamjC5dcJRBPBOJvyIJM2FQCbS0GUm1APAddDkPDv3//3BgZGTuh3Eig5lKcGv78+aPKxMS0HMhkhokBNbcDDfHApoGHmZl5HZAWQrOUGWQIyDBkDYxAqxcBTdPBEQACQMM2AGk+Jqgn64CKA/EFJ1BeC2QoE9B9AUBOPTFxAFTnDxBgAI5eL2ABBdyaAAAAAElFTkSuQmCC);
                  display: block !important;
                }
                .bk-plot-left.bk-toolbar-active {
                  border-right: 2px solid #e5e5e5;
                }
                .bk-plot-right.bk-toolbar-active {
                  border-left: 2px solid #e5e5e5;
                }
                .bk-plot-left,
                .bk-plot-right {
                  display: block;
                  margin: 45px 0 0 0;
                }
                .bk-plot-left .bk-logo,
                .bk-plot-right .bk-logo {
                  margin-bottom: 20px;
                }
                .bk-plot-left .bk-button-bar,
                .bk-plot-right .bk-button-bar {
                  position: relative;
                  left: 3px;
                }
                .bk-plot-left .bk-button-bar:before,
                .bk-plot-right .bk-button-bar:before,
                .bk-plot-left .bk-button-bar:after,
                .bk-plot-right .bk-button-bar:after {
                  content: " ";
                  display: block;
                  height: 0;
                  clear: both;
                }
                .bk-plot-left .bk-button-bar .bk-button-bar-list li,
                .bk-plot-right .bk-button-bar .bk-button-bar-list li {
                  clear: both;
                }
                .bk-plot-left .bk-button-bar .bk-button-bar-list li:last-child:after,
                .bk-plot-right .bk-button-bar .bk-button-bar-list li:last-child:after {
                  content: "-";
                  float: none;
                  clear: both;
                  display: block;
                  width: 30px;
                  height: 8px;
                  line-height: 8px;
                  padding: 3px 0;
                  text-align: center;
                }
                .bk-plot-left .bk-button-bar .bk-button-bar-list li .bk-toolbar-button.active,
                .bk-plot-right .bk-button-bar .bk-button-bar-list li .bk-toolbar-button.active {
                  border-bottom: none;
                  border-right: 2px solid #26aae1;
                }
                .bk-plot-left .bk-button-bar .bk-button-bar-list li .bk-toolbar-button span.tip,
                .bk-plot-right .bk-button-bar .bk-button-bar-list li .bk-toolbar-button span.tip {
                  top: 4px;
                  left: 40px;
                  padding: 5px 10px 5px 10px;
                }
                .bk-plot-left .bk-button-bar .bk-button-bar-list li .bk-toolbar-button span.tip:before,
                .bk-plot-right .bk-button-bar .bk-button-bar-list li .bk-toolbar-button span.tip:before {
                  top: 2px;
                  left: -19px;
                  width: 9px;
                  height: 15px;
                  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAPCAMAAAABFhU/AAAAA3NCSVQICAjb4U/gAAAAY1BMVEX////////8/Pz5+fn39/f19fX09PTv8fHv7+/t7e7s7Ozp6enn6Onm5ubj4+Ph4eHf39/X2drW1tfMzMzAw8S+wMGusbKorK6orK2nq6ufo6WcoaGYnZ+RlpiJj5GGjI6Bh4n1ho2QAAAAIXRSTlMA//////////////////////////////////////////9G9E6kAAAACXBIWXMAAAsSAAALEgHS3X78AAAAHHRFWHRTb2Z0d2FyZQBBZG9iZSBGaXJld29ya3MgQ1M26LyyjAAAABR0RVh0Q3JlYXRpb24gVGltZQA5LzUvMTTY+fXxAAAAUklEQVQImTXN2xZAIABE0VQUIfdLwvz/V1rL1DztpzOi4EoIQoekNoIaH1AL8EvvoExEUkBWfWZZvyWVzq/vL6kbP9/sKdtPF8vKdMPBN1m5AR+0BAnD6uP50QAAAABJRU5ErkJggg==);
                }
                .bk-toolbar-button.help > span.tip {
                  right: 0;
                  text-align: left;
                }
                .bk-button-bar > .bk-toolbar-button.active {
                  border-bottom: 2px solid #26aae1;
                }
                .bk-crossfilter-selector {
                  list-style-type: none;
                  -webkit-padding-start: 0;
                }
                .bk-crossfilter-selector li {
                  display: inline;
                  margin-bottom: 10px;
                  padding-left: 10px;
                  padding-right: 10px;
                }
                .bk-bs-container {
                  margin-right: auto;
                  margin-left: auto;
                  padding-left: 15px;
                  padding-right: 15px;
                }
                @media (min-width: 768px) {
                  .bk-bs-container {
                    width: 750px;
                  }
                }
                @media (min-width: 992px) {
                  .bk-bs-container {
                    width: 970px;
                  }
                }
                @media (min-width: 1200px) {
                  .bk-bs-container {
                    width: 1170px;
                  }
                }
                .bk-bs-container-fluid {
                  margin-right: auto;
                  margin-left: auto;
                  padding-left: 15px;
                  padding-right: 15px;
                }
                .bk-bs-row {
                  margin-left: -15px;
                  margin-right: -15px;
                }
                .bk-bs-col-xs-1, .bk-bs-col-sm-1, .bk-bs-col-md-1, .bk-bs-col-lg-1, .bk-bs-col-xs-2, .bk-bs-col-sm-2, .bk-bs-col-md-2, .bk-bs-col-lg-2, .bk-bs-col-xs-3, .bk-bs-col-sm-3, .bk-bs-col-md-3, .bk-bs-col-lg-3, .bk-bs-col-xs-4, .bk-bs-col-sm-4, .bk-bs-col-md-4, .bk-bs-col-lg-4, .bk-bs-col-xs-5, .bk-bs-col-sm-5, .bk-bs-col-md-5, .bk-bs-col-lg-5, .bk-bs-col-xs-6, .bk-bs-col-sm-6, .bk-bs-col-md-6, .bk-bs-col-lg-6, .bk-bs-col-xs-7, .bk-bs-col-sm-7, .bk-bs-col-md-7, .bk-bs-col-lg-7, .bk-bs-col-xs-8, .bk-bs-col-sm-8, .bk-bs-col-md-8, .bk-bs-col-lg-8, .bk-bs-col-xs-9, .bk-bs-col-sm-9, .bk-bs-col-md-9, .bk-bs-col-lg-9, .bk-bs-col-xs-10, .bk-bs-col-sm-10, .bk-bs-col-md-10, .bk-bs-col-lg-10, .bk-bs-col-xs-11, .bk-bs-col-sm-11, .bk-bs-col-md-11, .bk-bs-col-lg-11, .bk-bs-col-xs-12, .bk-bs-col-sm-12, .bk-bs-col-md-12, .bk-bs-col-lg-12 {
                  position: relative;
                  min-height: 1px;
                  padding-left: 15px;
                  padding-right: 15px;
                }
                .bk-bs-col-xs-1, .bk-bs-col-xs-2, .bk-bs-col-xs-3, .bk-bs-col-xs-4, .bk-bs-col-xs-5, .bk-bs-col-xs-6, .bk-bs-col-xs-7, .bk-bs-col-xs-8, .bk-bs-col-xs-9, .bk-bs-col-xs-10, .bk-bs-col-xs-11, .bk-bs-col-xs-12 {
                  float: left;
                }
                .bk-bs-col-xs-12 {
                  width: 100%;
                }
                .bk-bs-col-xs-11 {
                  width: 91.66666667%;
                }
                .bk-bs-col-xs-10 {
                  width: 83.33333333%;
                }
                .bk-bs-col-xs-9 {
                  width: 75%;
                }
                .bk-bs-col-xs-8 {
                  width: 66.66666667%;
                }
                .bk-bs-col-xs-7 {
                  width: 58.33333333%;
                }
                .bk-bs-col-xs-6 {
                  width: 50%;
                }
                .bk-bs-col-xs-5 {
                  width: 41.66666667%;
                }
                .bk-bs-col-xs-4 {
                  width: 33.33333333%;
                }
                .bk-bs-col-xs-3 {
                  width: 25%;
                }
                .bk-bs-col-xs-2 {
                  width: 16.66666667%;
                }
                .bk-bs-col-xs-1 {
                  width: 8.33333333%;
                }
                .bk-bs-col-xs-pull-12 {
                  right: 100%;
                }
                .bk-bs-col-xs-pull-11 {
                  right: 91.66666667%;
                }
                .bk-bs-col-xs-pull-10 {
                  right: 83.33333333%;
                }
                .bk-bs-col-xs-pull-9 {
                  right: 75%;
                }
                .bk-bs-col-xs-pull-8 {
                  right: 66.66666667%;
                }
                .bk-bs-col-xs-pull-7 {
                  right: 58.33333333%;
                }
                .bk-bs-col-xs-pull-6 {
                  right: 50%;
                }
                .bk-bs-col-xs-pull-5 {
                  right: 41.66666667%;
                }
                .bk-bs-col-xs-pull-4 {
                  right: 33.33333333%;
                }
                .bk-bs-col-xs-pull-3 {
                  right: 25%;
                }
                .bk-bs-col-xs-pull-2 {
                  right: 16.66666667%;
                }
                .bk-bs-col-xs-pull-1 {
                  right: 8.33333333%;
                }
                .bk-bs-col-xs-pull-0 {
                  right: 0%;
                }
                .bk-bs-col-xs-push-12 {
                  left: 100%;
                }
                .bk-bs-col-xs-push-11 {
                  left: 91.66666667%;
                }
                .bk-bs-col-xs-push-10 {
                  left: 83.33333333%;
                }
                .bk-bs-col-xs-push-9 {
                  left: 75%;
                }
                .bk-bs-col-xs-push-8 {
                  left: 66.66666667%;
                }
                .bk-bs-col-xs-push-7 {
                  left: 58.33333333%;
                }
                .bk-bs-col-xs-push-6 {
                  left: 50%;
                }
                .bk-bs-col-xs-push-5 {
                  left: 41.66666667%;
                }
                .bk-bs-col-xs-push-4 {
                  left: 33.33333333%;
                }
                .bk-bs-col-xs-push-3 {
                  left: 25%;
                }
                .bk-bs-col-xs-push-2 {
                  left: 16.66666667%;
                }
                .bk-bs-col-xs-push-1 {
                  left: 8.33333333%;
                }
                .bk-bs-col-xs-push-0 {
                  left: 0%;
                }
                .bk-bs-col-xs-offset-12 {
                  margin-left: 100%;
                }
                .bk-bs-col-xs-offset-11 {
                  margin-left: 91.66666667%;
                }
                .bk-bs-col-xs-offset-10 {
                  margin-left: 83.33333333%;
                }
                .bk-bs-col-xs-offset-9 {
                  margin-left: 75%;
                }
                .bk-bs-col-xs-offset-8 {
                  margin-left: 66.66666667%;
                }
                .bk-bs-col-xs-offset-7 {
                  margin-left: 58.33333333%;
                }
                .bk-bs-col-xs-offset-6 {
                  margin-left: 50%;
                }
                .bk-bs-col-xs-offset-5 {
                  margin-left: 41.66666667%;
                }
                .bk-bs-col-xs-offset-4 {
                  margin-left: 33.33333333%;
                }
                .bk-bs-col-xs-offset-3 {
                  margin-left: 25%;
                }
                .bk-bs-col-xs-offset-2 {
                  margin-left: 16.66666667%;
                }
                .bk-bs-col-xs-offset-1 {
                  margin-left: 8.33333333%;
                }
                .bk-bs-col-xs-offset-0 {
                  margin-left: 0%;
                }
                @media (min-width: 768px) {
                  .bk-bs-col-sm-1, .bk-bs-col-sm-2, .bk-bs-col-sm-3, .bk-bs-col-sm-4, .bk-bs-col-sm-5, .bk-bs-col-sm-6, .bk-bs-col-sm-7, .bk-bs-col-sm-8, .bk-bs-col-sm-9, .bk-bs-col-sm-10, .bk-bs-col-sm-11, .bk-bs-col-sm-12 {
                    float: left;
                  }
                  .bk-bs-col-sm-12 {
                    width: 100%;
                  }
                  .bk-bs-col-sm-11 {
                    width: 91.66666667%;
                  }
                  .bk-bs-col-sm-10 {
                    width: 83.33333333%;
                  }
                  .bk-bs-col-sm-9 {
                    width: 75%;
                  }
                  .bk-bs-col-sm-8 {
                    width: 66.66666667%;
                  }
                  .bk-bs-col-sm-7 {
                    width: 58.33333333%;
                  }
                  .bk-bs-col-sm-6 {
                    width: 50%;
                  }
                  .bk-bs-col-sm-5 {
                    width: 41.66666667%;
                  }
                  .bk-bs-col-sm-4 {
                    width: 33.33333333%;
                  }
                  .bk-bs-col-sm-3 {
                    width: 25%;
                  }
                  .bk-bs-col-sm-2 {
                    width: 16.66666667%;
                  }
                  .bk-bs-col-sm-1 {
                    width: 8.33333333%;
                  }
                  .bk-bs-col-sm-pull-12 {
                    right: 100%;
                  }
                  .bk-bs-col-sm-pull-11 {
                    right: 91.66666667%;
                  }
                  .bk-bs-col-sm-pull-10 {
                    right: 83.33333333%;
                  }
                  .bk-bs-col-sm-pull-9 {
                    right: 75%;
                  }
                  .bk-bs-col-sm-pull-8 {
                    right: 66.66666667%;
                  }
                  .bk-bs-col-sm-pull-7 {
                    right: 58.33333333%;
                  }
                  .bk-bs-col-sm-pull-6 {
                    right: 50%;
                  }
                  .bk-bs-col-sm-pull-5 {
                    right: 41.66666667%;
                  }
                  .bk-bs-col-sm-pull-4 {
                    right: 33.33333333%;
                  }
                  .bk-bs-col-sm-pull-3 {
                    right: 25%;
                  }
                  .bk-bs-col-sm-pull-2 {
                    right: 16.66666667%;
                  }
                  .bk-bs-col-sm-pull-1 {
                    right: 8.33333333%;
                  }
                  .bk-bs-col-sm-pull-0 {
                    right: 0%;
                  }
                  .bk-bs-col-sm-push-12 {
                    left: 100%;
                  }
                  .bk-bs-col-sm-push-11 {
                    left: 91.66666667%;
                  }
                  .bk-bs-col-sm-push-10 {
                    left: 83.33333333%;
                  }
                  .bk-bs-col-sm-push-9 {
                    left: 75%;
                  }
                  .bk-bs-col-sm-push-8 {
                    left: 66.66666667%;
                  }
                  .bk-bs-col-sm-push-7 {
                    left: 58.33333333%;
                  }
                  .bk-bs-col-sm-push-6 {
                    left: 50%;
                  }
                  .bk-bs-col-sm-push-5 {
                    left: 41.66666667%;
                  }
                  .bk-bs-col-sm-push-4 {
                    left: 33.33333333%;
                  }
                  .bk-bs-col-sm-push-3 {
                    left: 25%;
                  }
                  .bk-bs-col-sm-push-2 {
                    left: 16.66666667%;
                  }
                  .bk-bs-col-sm-push-1 {
                    left: 8.33333333%;
                  }
                  .bk-bs-col-sm-push-0 {
                    left: 0%;
                  }
                  .bk-bs-col-sm-offset-12 {
                    margin-left: 100%;
                  }
                  .bk-bs-col-sm-offset-11 {
                    margin-left: 91.66666667%;
                  }
                  .bk-bs-col-sm-offset-10 {
                    margin-left: 83.33333333%;
                  }
                  .bk-bs-col-sm-offset-9 {
                    margin-left: 75%;
                  }
                  .bk-bs-col-sm-offset-8 {
                    margin-left: 66.66666667%;
                  }
                  .bk-bs-col-sm-offset-7 {
                    margin-left: 58.33333333%;
                  }
                  .bk-bs-col-sm-offset-6 {
                    margin-left: 50%;
                  }
                  .bk-bs-col-sm-offset-5 {
                    margin-left: 41.66666667%;
                  }
                  .bk-bs-col-sm-offset-4 {
                    margin-left: 33.33333333%;
                  }
                  .bk-bs-col-sm-offset-3 {
                    margin-left: 25%;
                  }
                  .bk-bs-col-sm-offset-2 {
                    margin-left: 16.66666667%;
                  }
                  .bk-bs-col-sm-offset-1 {
                    margin-left: 8.33333333%;
                  }
                  .bk-bs-col-sm-offset-0 {
                    margin-left: 0%;
                  }
                }
                @media (min-width: 992px) {
                  .bk-bs-col-md-1, .bk-bs-col-md-2, .bk-bs-col-md-3, .bk-bs-col-md-4, .bk-bs-col-md-5, .bk-bs-col-md-6, .bk-bs-col-md-7, .bk-bs-col-md-8, .bk-bs-col-md-9, .bk-bs-col-md-10, .bk-bs-col-md-11, .bk-bs-col-md-12 {
                    float: left;
                  }
                  .bk-bs-col-md-12 {
                    width: 100%;
                  }
                  .bk-bs-col-md-11 {
                    width: 91.66666667%;
                  }
                  .bk-bs-col-md-10 {
                    width: 83.33333333%;
                  }
                  .bk-bs-col-md-9 {
                    width: 75%;
                  }
                  .bk-bs-col-md-8 {
                    width: 66.66666667%;
                  }
                  .bk-bs-col-md-7 {
                    width: 58.33333333%;
                  }
                  .bk-bs-col-md-6 {
                    width: 50%;
                  }
                  .bk-bs-col-md-5 {
                    width: 41.66666667%;
                  }
                  .bk-bs-col-md-4 {
                    width: 33.33333333%;
                  }
                  .bk-bs-col-md-3 {
                    width: 25%;
                  }
                  .bk-bs-col-md-2 {
                    width: 16.66666667%;
                  }
                  .bk-bs-col-md-1 {
                    width: 8.33333333%;
                  }
                  .bk-bs-col-md-pull-12 {
                    right: 100%;
                  }
                  .bk-bs-col-md-pull-11 {
                    right: 91.66666667%;
                  }
                  .bk-bs-col-md-pull-10 {
                    right: 83.33333333%;
                  }
                  .bk-bs-col-md-pull-9 {
                    right: 75%;
                  }
                  .bk-bs-col-md-pull-8 {
                    right: 66.66666667%;
                  }
                  .bk-bs-col-md-pull-7 {
                    right: 58.33333333%;
                  }
                  .bk-bs-col-md-pull-6 {
                    right: 50%;
                  }
                  .bk-bs-col-md-pull-5 {
                    right: 41.66666667%;
                  }
                  .bk-bs-col-md-pull-4 {
                    right: 33.33333333%;
                  }
                  .bk-bs-col-md-pull-3 {
                    right: 25%;
                  }
                  .bk-bs-col-md-pull-2 {
                    right: 16.66666667%;
                  }
                  .bk-bs-col-md-pull-1 {
                    right: 8.33333333%;
                  }
                  .bk-bs-col-md-pull-0 {
                    right: 0%;
                  }
                  .bk-bs-col-md-push-12 {
                    left: 100%;
                  }
                  .bk-bs-col-md-push-11 {
                    left: 91.66666667%;
                  }
                  .bk-bs-col-md-push-10 {
                    left: 83.33333333%;
                  }
                  .bk-bs-col-md-push-9 {
                    left: 75%;
                  }
                  .bk-bs-col-md-push-8 {
                    left: 66.66666667%;
                  }
                  .bk-bs-col-md-push-7 {
                    left: 58.33333333%;
                  }
                  .bk-bs-col-md-push-6 {
                    left: 50%;
                  }
                  .bk-bs-col-md-push-5 {
                    left: 41.66666667%;
                  }
                  .bk-bs-col-md-push-4 {
                    left: 33.33333333%;
                  }
                  .bk-bs-col-md-push-3 {
                    left: 25%;
                  }
                  .bk-bs-col-md-push-2 {
                    left: 16.66666667%;
                  }
                  .bk-bs-col-md-push-1 {
                    left: 8.33333333%;
                  }
                  .bk-bs-col-md-push-0 {
                    left: 0%;
                  }
                  .bk-bs-col-md-offset-12 {
                    margin-left: 100%;
                  }
                  .bk-bs-col-md-offset-11 {
                    margin-left: 91.66666667%;
                  }
                  .bk-bs-col-md-offset-10 {
                    margin-left: 83.33333333%;
                  }
                  .bk-bs-col-md-offset-9 {
                    margin-left: 75%;
                  }
                  .bk-bs-col-md-offset-8 {
                    margin-left: 66.66666667%;
                  }
                  .bk-bs-col-md-offset-7 {
                    margin-left: 58.33333333%;
                  }
                  .bk-bs-col-md-offset-6 {
                    margin-left: 50%;
                  }
                  .bk-bs-col-md-offset-5 {
                    margin-left: 41.66666667%;
                  }
                  .bk-bs-col-md-offset-4 {
                    margin-left: 33.33333333%;
                  }
                  .bk-bs-col-md-offset-3 {
                    margin-left: 25%;
                  }
                  .bk-bs-col-md-offset-2 {
                    margin-left: 16.66666667%;
                  }
                  .bk-bs-col-md-offset-1 {
                    margin-left: 8.33333333%;
                  }
                  .bk-bs-col-md-offset-0 {
                    margin-left: 0%;
                  }
                }
                @media (min-width: 1200px) {
                  .bk-bs-col-lg-1, .bk-bs-col-lg-2, .bk-bs-col-lg-3, .bk-bs-col-lg-4, .bk-bs-col-lg-5, .bk-bs-col-lg-6, .bk-bs-col-lg-7, .bk-bs-col-lg-8, .bk-bs-col-lg-9, .bk-bs-col-lg-10, .bk-bs-col-lg-11, .bk-bs-col-lg-12 {
                    float: left;
                  }
                  .bk-bs-col-lg-12 {
                    width: 100%;
                  }
                  .bk-bs-col-lg-11 {
                    width: 91.66666667%;
                  }
                  .bk-bs-col-lg-10 {
                    width: 83.33333333%;
                  }
                  .bk-bs-col-lg-9 {
                    width: 75%;
                  }
                  .bk-bs-col-lg-8 {
                    width: 66.66666667%;
                  }
                  .bk-bs-col-lg-7 {
                    width: 58.33333333%;
                  }
                  .bk-bs-col-lg-6 {
                    width: 50%;
                  }
                  .bk-bs-col-lg-5 {
                    width: 41.66666667%;
                  }
                  .bk-bs-col-lg-4 {
                    width: 33.33333333%;
                  }
                  .bk-bs-col-lg-3 {
                    width: 25%;
                  }
                  .bk-bs-col-lg-2 {
                    width: 16.66666667%;
                  }
                  .bk-bs-col-lg-1 {
                    width: 8.33333333%;
                  }
                  .bk-bs-col-lg-pull-12 {
                    right: 100%;
                  }
                  .bk-bs-col-lg-pull-11 {
                    right: 91.66666667%;
                  }
                  .bk-bs-col-lg-pull-10 {
                    right: 83.33333333%;
                  }
                  .bk-bs-col-lg-pull-9 {
                    right: 75%;
                  }
                  .bk-bs-col-lg-pull-8 {
                    right: 66.66666667%;
                  }
                  .bk-bs-col-lg-pull-7 {
                    right: 58.33333333%;
                  }
                  .bk-bs-col-lg-pull-6 {
                    right: 50%;
                  }
                  .bk-bs-col-lg-pull-5 {
                    right: 41.66666667%;
                  }
                  .bk-bs-col-lg-pull-4 {
                    right: 33.33333333%;
                  }
                  .bk-bs-col-lg-pull-3 {
                    right: 25%;
                  }
                  .bk-bs-col-lg-pull-2 {
                    right: 16.66666667%;
                  }
                  .bk-bs-col-lg-pull-1 {
                    right: 8.33333333%;
                  }
                  .bk-bs-col-lg-pull-0 {
                    right: 0%;
                  }
                  .bk-bs-col-lg-push-12 {
                    left: 100%;
                  }
                  .bk-bs-col-lg-push-11 {
                    left: 91.66666667%;
                  }
                  .bk-bs-col-lg-push-10 {
                    left: 83.33333333%;
                  }
                  .bk-bs-col-lg-push-9 {
                    left: 75%;
                  }
                  .bk-bs-col-lg-push-8 {
                    left: 66.66666667%;
                  }
                  .bk-bs-col-lg-push-7 {
                    left: 58.33333333%;
                  }
                  .bk-bs-col-lg-push-6 {
                    left: 50%;
                  }
                  .bk-bs-col-lg-push-5 {
                    left: 41.66666667%;
                  }
                  .bk-bs-col-lg-push-4 {
                    left: 33.33333333%;
                  }
                  .bk-bs-col-lg-push-3 {
                    left: 25%;
                  }
                  .bk-bs-col-lg-push-2 {
                    left: 16.66666667%;
                  }
                  .bk-bs-col-lg-push-1 {
                    left: 8.33333333%;
                  }
                  .bk-bs-col-lg-push-0 {
                    left: 0%;
                  }
                  .bk-bs-col-lg-offset-12 {
                    margin-left: 100%;
                  }
                  .bk-bs-col-lg-offset-11 {
                    margin-left: 91.66666667%;
                  }
                  .bk-bs-col-lg-offset-10 {
                    margin-left: 83.33333333%;
                  }
                  .bk-bs-col-lg-offset-9 {
                    margin-left: 75%;
                  }
                  .bk-bs-col-lg-offset-8 {
                    margin-left: 66.66666667%;
                  }
                  .bk-bs-col-lg-offset-7 {
                    margin-left: 58.33333333%;
                  }
                  .bk-bs-col-lg-offset-6 {
                    margin-left: 50%;
                  }
                  .bk-bs-col-lg-offset-5 {
                    margin-left: 41.66666667%;
                  }
                  .bk-bs-col-lg-offset-4 {
                    margin-left: 33.33333333%;
                  }
                  .bk-bs-col-lg-offset-3 {
                    margin-left: 25%;
                  }
                  .bk-bs-col-lg-offset-2 {
                    margin-left: 16.66666667%;
                  }
                  .bk-bs-col-lg-offset-1 {
                    margin-left: 8.33333333%;
                  }
                  .bk-bs-col-lg-offset-0 {
                    margin-left: 0%;
                  }
                }
                table {
                  max-width: 100%;
                  background-color: transparent;
                }
                th {
                  text-align: left;
                }
                .bk-bs-table {
                  width: 100%;
                  margin-bottom: 20px;
                }
                .bk-bs-table > thead > tr > th,
                .bk-bs-table > tbody > tr > th,
                .bk-bs-table > tfoot > tr > th,
                .bk-bs-table > thead > tr > td,
                .bk-bs-table > tbody > tr > td,
                .bk-bs-table > tfoot > tr > td {
                  padding: 8px;
                  line-height: 1.42857143;
                  vertical-align: top;
                  border-top: 1px solid #dddddd;
                }
                .bk-bs-table > thead > tr > th {
                  vertical-align: bottom;
                  border-bottom: 2px solid #dddddd;
                }
                .bk-bs-table > caption + thead > tr:first-child > th,
                .bk-bs-table > colgroup + thead > tr:first-child > th,
                .bk-bs-table > thead:first-child > tr:first-child > th,
                .bk-bs-table > caption + thead > tr:first-child > td,
                .bk-bs-table > colgroup + thead > tr:first-child > td,
                .bk-bs-table > thead:first-child > tr:first-child > td {
                  border-top: 0;
                }
                .bk-bs-table > tbody + tbody {
                  border-top: 2px solid #dddddd;
                }
                .bk-bs-table .bk-bs-table {
                  background-color: #ffffff;
                }
                .bk-bs-table-condensed > thead > tr > th,
                .bk-bs-table-condensed > tbody > tr > th,
                .bk-bs-table-condensed > tfoot > tr > th,
                .bk-bs-table-condensed > thead > tr > td,
                .bk-bs-table-condensed > tbody > tr > td,
                .bk-bs-table-condensed > tfoot > tr > td {
                  padding: 5px;
                }
                .bk-bs-table-bordered {
                  border: 1px solid #dddddd;
                }
                .bk-bs-table-bordered > thead > tr > th,
                .bk-bs-table-bordered > tbody > tr > th,
                .bk-bs-table-bordered > tfoot > tr > th,
                .bk-bs-table-bordered > thead > tr > td,
                .bk-bs-table-bordered > tbody > tr > td,
                .bk-bs-table-bordered > tfoot > tr > td {
                  border: 1px solid #dddddd;
                }
                .bk-bs-table-bordered > thead > tr > th,
                .bk-bs-table-bordered > thead > tr > td {
                  border-bottom-width: 2px;
                }
                .bk-bs-table-striped > tbody > tr:nth-child(odd) > td,
                .bk-bs-table-striped > tbody > tr:nth-child(odd) > th {
                  background-color: #f9f9f9;
                }
                .bk-bs-table-hover > tbody > tr:hover > td,
                .bk-bs-table-hover > tbody > tr:hover > th {
                  background-color: #f5f5f5;
                }
                table col[class*="col-"] {
                  position: static;
                  float: none;
                  display: table-column;
                }
                table td[class*="col-"],
                table th[class*="col-"] {
                  position: static;
                  float: none;
                  display: table-cell;
                }
                .bk-bs-table > thead > tr > td.active,
                .bk-bs-table > tbody > tr > td.active,
                .bk-bs-table > tfoot > tr > td.active,
                .bk-bs-table > thead > tr > th.active,
                .bk-bs-table > tbody > tr > th.active,
                .bk-bs-table > tfoot > tr > th.active,
                .bk-bs-table > thead > tr.active > td,
                .bk-bs-table > tbody > tr.active > td,
                .bk-bs-table > tfoot > tr.active > td,
                .bk-bs-table > thead > tr.active > th,
                .bk-bs-table > tbody > tr.active > th,
                .bk-bs-table > tfoot > tr.active > th {
                  background-color: #f5f5f5;
                }
                .bk-bs-table-hover > tbody > tr > td.active:hover,
                .bk-bs-table-hover > tbody > tr > th.active:hover,
                .bk-bs-table-hover > tbody > tr.active:hover > td,
                .bk-bs-table-hover > tbody > tr.active:hover > th {
                  background-color: #e8e8e8;
                }
                .bk-bs-table > thead > tr > td.success,
                .bk-bs-table > tbody > tr > td.success,
                .bk-bs-table > tfoot > tr > td.success,
                .bk-bs-table > thead > tr > th.success,
                .bk-bs-table > tbody > tr > th.success,
                .bk-bs-table > tfoot > tr > th.success,
                .bk-bs-table > thead > tr.success > td,
                .bk-bs-table > tbody > tr.success > td,
                .bk-bs-table > tfoot > tr.success > td,
                .bk-bs-table > thead > tr.success > th,
                .bk-bs-table > tbody > tr.success > th,
                .bk-bs-table > tfoot > tr.success > th {
                  background-color: #dff0d8;
                }
                .bk-bs-table-hover > tbody > tr > td.success:hover,
                .bk-bs-table-hover > tbody > tr > th.success:hover,
                .bk-bs-table-hover > tbody > tr.success:hover > td,
                .bk-bs-table-hover > tbody > tr.success:hover > th {
                  background-color: #d0e9c6;
                }
                .bk-bs-table > thead > tr > td.info,
                .bk-bs-table > tbody > tr > td.info,
                .bk-bs-table > tfoot > tr > td.info,
                .bk-bs-table > thead > tr > th.info,
                .bk-bs-table > tbody > tr > th.info,
                .bk-bs-table > tfoot > tr > th.info,
                .bk-bs-table > thead > tr.info > td,
                .bk-bs-table > tbody > tr.info > td,
                .bk-bs-table > tfoot > tr.info > td,
                .bk-bs-table > thead > tr.info > th,
                .bk-bs-table > tbody > tr.info > th,
                .bk-bs-table > tfoot > tr.info > th {
                  background-color: #d9edf7;
                }
                .bk-bs-table-hover > tbody > tr > td.info:hover,
                .bk-bs-table-hover > tbody > tr > th.info:hover,
                .bk-bs-table-hover > tbody > tr.info:hover > td,
                .bk-bs-table-hover > tbody > tr.info:hover > th {
                  background-color: #c4e3f3;
                }
                .bk-bs-table > thead > tr > td.warning,
                .bk-bs-table > tbody > tr > td.warning,
                .bk-bs-table > tfoot > tr > td.warning,
                .bk-bs-table > thead > tr > th.warning,
                .bk-bs-table > tbody > tr > th.warning,
                .bk-bs-table > tfoot > tr > th.warning,
                .bk-bs-table > thead > tr.warning > td,
                .bk-bs-table > tbody > tr.warning > td,
                .bk-bs-table > tfoot > tr.warning > td,
                .bk-bs-table > thead > tr.warning > th,
                .bk-bs-table > tbody > tr.warning > th,
                .bk-bs-table > tfoot > tr.warning > th {
                  background-color: #fcf8e3;
                }
                .bk-bs-table-hover > tbody > tr > td.warning:hover,
                .bk-bs-table-hover > tbody > tr > th.warning:hover,
                .bk-bs-table-hover > tbody > tr.warning:hover > td,
                .bk-bs-table-hover > tbody > tr.warning:hover > th {
                  background-color: #faf2cc;
                }
                .bk-bs-table > thead > tr > td.danger,
                .bk-bs-table > tbody > tr > td.danger,
                .bk-bs-table > tfoot > tr > td.danger,
                .bk-bs-table > thead > tr > th.danger,
                .bk-bs-table > tbody > tr > th.danger,
                .bk-bs-table > tfoot > tr > th.danger,
                .bk-bs-table > thead > tr.danger > td,
                .bk-bs-table > tbody > tr.danger > td,
                .bk-bs-table > tfoot > tr.danger > td,
                .bk-bs-table > thead > tr.danger > th,
                .bk-bs-table > tbody > tr.danger > th,
                .bk-bs-table > tfoot > tr.danger > th {
                  background-color: #f2dede;
                }
                .bk-bs-table-hover > tbody > tr > td.danger:hover,
                .bk-bs-table-hover > tbody > tr > th.danger:hover,
                .bk-bs-table-hover > tbody > tr.danger:hover > td,
                .bk-bs-table-hover > tbody > tr.danger:hover > th {
                  background-color: #ebcccc;
                }
                @media (max-width: 767px) {
                  .bk-bs-table-responsive {
                    width: 100%;
                    margin-bottom: 15px;
                    overflow-y: hidden;
                    overflow-x: scroll;
                    -ms-overflow-style: -ms-autohiding-scrollbar;
                    border: 1px solid #dddddd;
                    -webkit-overflow-scrolling: touch;
                  }
                  .bk-bs-table-responsive > .bk-bs-table {
                    margin-bottom: 0;
                  }
                  .bk-bs-table-responsive > .bk-bs-table > thead > tr > th,
                  .bk-bs-table-responsive > .bk-bs-table > tbody > tr > th,
                  .bk-bs-table-responsive > .bk-bs-table > tfoot > tr > th,
                  .bk-bs-table-responsive > .bk-bs-table > thead > tr > td,
                  .bk-bs-table-responsive > .bk-bs-table > tbody > tr > td,
                  .bk-bs-table-responsive > .bk-bs-table > tfoot > tr > td {
                    white-space: nowrap;
                  }
                  .bk-bs-table-responsive > .bk-bs-table-bordered {
                    border: 0;
                  }
                  .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr > th:first-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr > th:first-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr > th:first-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr > td:first-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr > td:first-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr > td:first-child {
                    border-left: 0;
                  }
                  .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr > th:last-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr > th:last-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr > th:last-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr > td:last-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr > td:last-child,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr > td:last-child {
                    border-right: 0;
                  }
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr:last-child > th,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr:last-child > th,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr:last-child > td,
                  .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr:last-child > td {
                    border-bottom: 0;
                  }
                }
                fieldset {
                  padding: 0;
                  margin: 0;
                  border: 0;
                  min-width: 0;
                }
                legend {
                  display: block;
                  width: 100%;
                  padding: 0;
                  margin-bottom: 20px;
                  font-size: 21px;
                  line-height: inherit;
                  color: #333333;
                  border: 0;
                  border-bottom: 1px solid #e5e5e5;
                }
                label {
                  display: inline-block;
                  margin-bottom: 5px;
                  font-weight: bold;
                }
                input[type="search"] {
                  -webkit-box-sizing: border-box;
                  -moz-box-sizing: border-box;
                  box-sizing: border-box;
                }
                input[type="radio"],
                input[type="checkbox"] {
                  margin: 4px 0 0;
                  margin-top: 1px \9;
                  /* IE8-9 */
                  line-height: normal;
                }
                input[type="file"] {
                  display: block;
                }
                input[type="range"] {
                  display: block;
                  width: 100%;
                }
                select[multiple],
                select[size] {
                  height: auto;
                }
                input[type="file"]:focus,
                input[type="radio"]:focus,
                input[type="checkbox"]:focus {
                  outline: thin dotted;
                  outline: 5px auto -webkit-focus-ring-color;
                  outline-offset: -2px;
                }
                output {
                  display: block;
                  padding-top: 7px;
                  font-size: 14px;
                  line-height: 1.42857143;
                  color: #555555;
                }
                .bk-bs-form-control {
                  display: block;
                  width: 100%;
                  height: 34px;
                  padding: 6px 12px;
                  font-size: 14px;
                  line-height: 1.42857143;
                  color: #555555;
                  background-color: #ffffff;
                  background-image: none;
                  border: 1px solid #cccccc;
                  border-radius: 4px;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                  -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
                  transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
                }
                .bk-bs-form-control:focus {
                  border-color: #66afe9;
                  outline: 0;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
                  box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
                }
                .bk-bs-form-control::-moz-placeholder {
                  color: #999999;
                  opacity: 1;
                }
                .bk-bs-form-control:-ms-input-placeholder {
                  color: #999999;
                }
                .bk-bs-form-control::-webkit-input-placeholder {
                  color: #999999;
                }
                .bk-bs-form-control[disabled],
                .bk-bs-form-control[readonly],
                fieldset[disabled] .bk-bs-form-control {
                  cursor: not-allowed;
                  background-color: #eeeeee;
                  opacity: 1;
                }
                textarea.bk-bs-form-control {
                  height: auto;
                }
                input[type="search"] {
                  -webkit-appearance: none;
                }
                input[type="date"] {
                  line-height: 34px;
                }
                .bk-bs-form-group {
                  margin-bottom: 15px;
                }
                .bk-bs-radio,
                .bk-bs-checkbox {
                  display: block;
                  min-height: 20px;
                  margin-top: 10px;
                  margin-bottom: 10px;
                  padding-left: 20px;
                }
                .bk-bs-radio label,
                .bk-bs-checkbox label {
                  display: inline;
                  font-weight: normal;
                  cursor: pointer;
                }
                .bk-bs-radio input[type="radio"],
                .bk-bs-radio-inline input[type="radio"],
                .bk-bs-checkbox input[type="checkbox"],
                .bk-bs-checkbox-inline input[type="checkbox"] {
                  float: left;
                  margin-left: -20px;
                }
                .bk-bs-radio + .bk-bs-radio,
                .bk-bs-checkbox + .bk-bs-checkbox {
                  margin-top: -5px;
                }
                .bk-bs-radio-inline,
                .bk-bs-checkbox-inline {
                  display: inline-block;
                  padding-left: 20px;
                  margin-bottom: 0;
                  vertical-align: middle;
                  font-weight: normal;
                  cursor: pointer;
                }
                .bk-bs-radio-inline + .bk-bs-radio-inline,
                .bk-bs-checkbox-inline + .bk-bs-checkbox-inline {
                  margin-top: 0;
                  margin-left: 10px;
                }
                input[type="radio"][disabled],
                input[type="checkbox"][disabled],
                .bk-bs-radio[disabled],
                .bk-bs-radio-inline[disabled],
                .bk-bs-checkbox[disabled],
                .bk-bs-checkbox-inline[disabled],
                fieldset[disabled] input[type="radio"],
                fieldset[disabled] input[type="checkbox"],
                fieldset[disabled] .bk-bs-radio,
                fieldset[disabled] .bk-bs-radio-inline,
                fieldset[disabled] .bk-bs-checkbox,
                fieldset[disabled] .bk-bs-checkbox-inline {
                  cursor: not-allowed;
                }
                .bk-bs-input-sm {
                  height: 30px;
                  padding: 5px 10px;
                  font-size: 12px;
                  line-height: 1.5;
                  border-radius: 3px;
                }
                select.bk-bs-input-sm {
                  height: 30px;
                  line-height: 30px;
                }
                textarea.bk-bs-input-sm,
                select[multiple].bk-bs-input-sm {
                  height: auto;
                }
                .bk-bs-input-lg {
                  height: 46px;
                  padding: 10px 16px;
                  font-size: 18px;
                  line-height: 1.33;
                  border-radius: 6px;
                }
                select.bk-bs-input-lg {
                  height: 46px;
                  line-height: 46px;
                }
                textarea.bk-bs-input-lg,
                select[multiple].bk-bs-input-lg {
                  height: auto;
                }
                .bk-bs-has-feedback {
                  position: relative;
                }
                .bk-bs-has-feedback .bk-bs-form-control {
                  padding-right: 42.5px;
                }
                .bk-bs-has-feedback .bk-bs-form-control-feedback {
                  position: absolute;
                  top: 25px;
                  right: 0;
                  display: block;
                  width: 34px;
                  height: 34px;
                  line-height: 34px;
                  text-align: center;
                }
                .bk-bs-has-success .bk-bs-help-block,
                .bk-bs-has-success .bk-bs-control-label,
                .bk-bs-has-success .bk-bs-radio,
                .bk-bs-has-success .bk-bs-checkbox,
                .bk-bs-has-success .bk-bs-radio-inline,
                .bk-bs-has-success .bk-bs-checkbox-inline {
                  color: #3c763d;
                }
                .bk-bs-has-success .bk-bs-form-control {
                  border-color: #3c763d;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                }
                .bk-bs-has-success .bk-bs-form-control:focus {
                  border-color: #2b542c;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #67b168;
                  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #67b168;
                }
                .bk-bs-has-success .bk-bs-input-group-addon {
                  color: #3c763d;
                  border-color: #3c763d;
                  background-color: #dff0d8;
                }
                .bk-bs-has-success .bk-bs-form-control-feedback {
                  color: #3c763d;
                }
                .bk-bs-has-warning .bk-bs-help-block,
                .bk-bs-has-warning .bk-bs-control-label,
                .bk-bs-has-warning .bk-bs-radio,
                .bk-bs-has-warning .bk-bs-checkbox,
                .bk-bs-has-warning .bk-bs-radio-inline,
                .bk-bs-has-warning .bk-bs-checkbox-inline {
                  color: #8a6d3b;
                }
                .bk-bs-has-warning .bk-bs-form-control {
                  border-color: #8a6d3b;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                }
                .bk-bs-has-warning .bk-bs-form-control:focus {
                  border-color: #66512c;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #c0a16b;
                  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #c0a16b;
                }
                .bk-bs-has-warning .bk-bs-input-group-addon {
                  color: #8a6d3b;
                  border-color: #8a6d3b;
                  background-color: #fcf8e3;
                }
                .bk-bs-has-warning .bk-bs-form-control-feedback {
                  color: #8a6d3b;
                }
                .bk-bs-has-error .bk-bs-help-block,
                .bk-bs-has-error .bk-bs-control-label,
                .bk-bs-has-error .bk-bs-radio,
                .bk-bs-has-error .bk-bs-checkbox,
                .bk-bs-has-error .bk-bs-radio-inline,
                .bk-bs-has-error .bk-bs-checkbox-inline {
                  color: #a94442;
                }
                .bk-bs-has-error .bk-bs-form-control {
                  border-color: #a94442;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                }
                .bk-bs-has-error .bk-bs-form-control:focus {
                  border-color: #843534;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #ce8483;
                  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #ce8483;
                }
                .bk-bs-has-error .bk-bs-input-group-addon {
                  color: #a94442;
                  border-color: #a94442;
                  background-color: #f2dede;
                }
                .bk-bs-has-error .bk-bs-form-control-feedback {
                  color: #a94442;
                }
                .bk-bs-form-control-static {
                  margin-bottom: 0;
                }
                .bk-bs-help-block {
                  display: block;
                  margin-top: 5px;
                  margin-bottom: 10px;
                  color: #737373;
                }
                @media (min-width: 768px) {
                  .bk-bs-form-inline .bk-bs-form-group {
                    display: inline-block;
                    margin-bottom: 0;
                    vertical-align: middle;
                  }
                  .bk-bs-form-inline .bk-bs-form-control {
                    display: inline-block;
                    width: auto;
                    vertical-align: middle;
                  }
                  .bk-bs-form-inline .bk-bs-input-group > .bk-bs-form-control {
                    width: 100%;
                  }
                  .bk-bs-form-inline .bk-bs-control-label {
                    margin-bottom: 0;
                    vertical-align: middle;
                  }
                  .bk-bs-form-inline .bk-bs-radio,
                  .bk-bs-form-inline .bk-bs-checkbox {
                    display: inline-block;
                    margin-top: 0;
                    margin-bottom: 0;
                    padding-left: 0;
                    vertical-align: middle;
                  }
                  .bk-bs-form-inline .bk-bs-radio input[type="radio"],
                  .bk-bs-form-inline .bk-bs-checkbox input[type="checkbox"] {
                    float: none;
                    margin-left: 0;
                  }
                  .bk-bs-form-inline .bk-bs-has-feedback .bk-bs-form-control-feedback {
                    top: 0;
                  }
                }
                .bk-bs-form-horizontal .bk-bs-control-label,
                .bk-bs-form-horizontal .bk-bs-radio,
                .bk-bs-form-horizontal .bk-bs-checkbox,
                .bk-bs-form-horizontal .bk-bs-radio-inline,
                .bk-bs-form-horizontal .bk-bs-checkbox-inline {
                  margin-top: 0;
                  margin-bottom: 0;
                  padding-top: 7px;
                }
                .bk-bs-form-horizontal .bk-bs-radio,
                .bk-bs-form-horizontal .bk-bs-checkbox {
                  min-height: 27px;
                }
                .bk-bs-form-horizontal .bk-bs-form-group {
                  margin-left: -15px;
                  margin-right: -15px;
                }
                .bk-bs-form-horizontal .bk-bs-form-control-static {
                  padding-top: 7px;
                }
                @media (min-width: 768px) {
                  .bk-bs-form-horizontal .bk-bs-control-label {
                    text-align: right;
                  }
                }
                .bk-bs-form-horizontal .bk-bs-has-feedback .bk-bs-form-control-feedback {
                  top: 0;
                  right: 15px;
                }
                .bk-bs-btn {
                  display: inline-block;
                  margin-bottom: 0;
                  font-weight: normal;
                  text-align: center;
                  vertical-align: middle;
                  cursor: pointer;
                  background-image: none;
                  border: 1px solid transparent;
                  white-space: nowrap;
                  padding: 6px 12px;
                  font-size: 14px;
                  line-height: 1.42857143;
                  border-radius: 4px;
                  -webkit-user-select: none;
                  -moz-user-select: none;
                  -ms-user-select: none;
                  user-select: none;
                }
                .bk-bs-btn:focus,
                .bk-bs-btn:active:focus,
                .bk-bs-btn.bk-bs-active:focus {
                  outline: thin dotted;
                  outline: 5px auto -webkit-focus-ring-color;
                  outline-offset: -2px;
                }
                .bk-bs-btn:hover,
                .bk-bs-btn:focus {
                  color: #333333;
                  text-decoration: none;
                }
                .bk-bs-btn:active,
                .bk-bs-btn.bk-bs-active {
                  outline: 0;
                  background-image: none;
                  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                }
                .bk-bs-btn.bk-bs-disabled,
                .bk-bs-btn[disabled],
                fieldset[disabled] .bk-bs-btn {
                  cursor: not-allowed;
                  pointer-events: none;
                  opacity: 0.65;
                  filter: alpha(opacity=65);
                  -webkit-box-shadow: none;
                  box-shadow: none;
                }
                .bk-bs-btn-default {
                  color: #333333;
                  background-color: #ffffff;
                  border-color: #cccccc;
                }
                .bk-bs-btn-default:hover,
                .bk-bs-btn-default:focus,
                .bk-bs-btn-default:active,
                .bk-bs-btn-default.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-default {
                  color: #333333;
                  background-color: #ebebeb;
                  border-color: #adadad;
                }
                .bk-bs-btn-default:active,
                .bk-bs-btn-default.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-default {
                  background-image: none;
                }
                .bk-bs-btn-default.bk-bs-disabled,
                .bk-bs-btn-default[disabled],
                fieldset[disabled] .bk-bs-btn-default,
                .bk-bs-btn-default.bk-bs-disabled:hover,
                .bk-bs-btn-default[disabled]:hover,
                fieldset[disabled] .bk-bs-btn-default:hover,
                .bk-bs-btn-default.bk-bs-disabled:focus,
                .bk-bs-btn-default[disabled]:focus,
                fieldset[disabled] .bk-bs-btn-default:focus,
                .bk-bs-btn-default.bk-bs-disabled:active,
                .bk-bs-btn-default[disabled]:active,
                fieldset[disabled] .bk-bs-btn-default:active,
                .bk-bs-btn-default.bk-bs-disabled.bk-bs-active,
                .bk-bs-btn-default[disabled].bk-bs-active,
                fieldset[disabled] .bk-bs-btn-default.bk-bs-active {
                  background-color: #ffffff;
                  border-color: #cccccc;
                }
                .bk-bs-btn-default .bk-bs-badge {
                  color: #ffffff;
                  background-color: #333333;
                }
                .bk-bs-btn-primary {
                  color: #ffffff;
                  background-color: #428bca;
                  border-color: #357ebd;
                }
                .bk-bs-btn-primary:hover,
                .bk-bs-btn-primary:focus,
                .bk-bs-btn-primary:active,
                .bk-bs-btn-primary.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-primary {
                  color: #ffffff;
                  background-color: #3276b1;
                  border-color: #285e8e;
                }
                .bk-bs-btn-primary:active,
                .bk-bs-btn-primary.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-primary {
                  background-image: none;
                }
                .bk-bs-btn-primary.bk-bs-disabled,
                .bk-bs-btn-primary[disabled],
                fieldset[disabled] .bk-bs-btn-primary,
                .bk-bs-btn-primary.bk-bs-disabled:hover,
                .bk-bs-btn-primary[disabled]:hover,
                fieldset[disabled] .bk-bs-btn-primary:hover,
                .bk-bs-btn-primary.bk-bs-disabled:focus,
                .bk-bs-btn-primary[disabled]:focus,
                fieldset[disabled] .bk-bs-btn-primary:focus,
                .bk-bs-btn-primary.bk-bs-disabled:active,
                .bk-bs-btn-primary[disabled]:active,
                fieldset[disabled] .bk-bs-btn-primary:active,
                .bk-bs-btn-primary.bk-bs-disabled.bk-bs-active,
                .bk-bs-btn-primary[disabled].bk-bs-active,
                fieldset[disabled] .bk-bs-btn-primary.bk-bs-active {
                  background-color: #428bca;
                  border-color: #357ebd;
                }
                .bk-bs-btn-primary .bk-bs-badge {
                  color: #428bca;
                  background-color: #ffffff;
                }
                .bk-bs-btn-success {
                  color: #ffffff;
                  background-color: #5cb85c;
                  border-color: #4cae4c;
                }
                .bk-bs-btn-success:hover,
                .bk-bs-btn-success:focus,
                .bk-bs-btn-success:active,
                .bk-bs-btn-success.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-success {
                  color: #ffffff;
                  background-color: #47a447;
                  border-color: #398439;
                }
                .bk-bs-btn-success:active,
                .bk-bs-btn-success.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-success {
                  background-image: none;
                }
                .bk-bs-btn-success.bk-bs-disabled,
                .bk-bs-btn-success[disabled],
                fieldset[disabled] .bk-bs-btn-success,
                .bk-bs-btn-success.bk-bs-disabled:hover,
                .bk-bs-btn-success[disabled]:hover,
                fieldset[disabled] .bk-bs-btn-success:hover,
                .bk-bs-btn-success.bk-bs-disabled:focus,
                .bk-bs-btn-success[disabled]:focus,
                fieldset[disabled] .bk-bs-btn-success:focus,
                .bk-bs-btn-success.bk-bs-disabled:active,
                .bk-bs-btn-success[disabled]:active,
                fieldset[disabled] .bk-bs-btn-success:active,
                .bk-bs-btn-success.bk-bs-disabled.bk-bs-active,
                .bk-bs-btn-success[disabled].bk-bs-active,
                fieldset[disabled] .bk-bs-btn-success.bk-bs-active {
                  background-color: #5cb85c;
                  border-color: #4cae4c;
                }
                .bk-bs-btn-success .bk-bs-badge {
                  color: #5cb85c;
                  background-color: #ffffff;
                }
                .bk-bs-btn-info {
                  color: #ffffff;
                  background-color: #5bc0de;
                  border-color: #46b8da;
                }
                .bk-bs-btn-info:hover,
                .bk-bs-btn-info:focus,
                .bk-bs-btn-info:active,
                .bk-bs-btn-info.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-info {
                  color: #ffffff;
                  background-color: #39b3d7;
                  border-color: #269abc;
                }
                .bk-bs-btn-info:active,
                .bk-bs-btn-info.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-info {
                  background-image: none;
                }
                .bk-bs-btn-info.bk-bs-disabled,
                .bk-bs-btn-info[disabled],
                fieldset[disabled] .bk-bs-btn-info,
                .bk-bs-btn-info.bk-bs-disabled:hover,
                .bk-bs-btn-info[disabled]:hover,
                fieldset[disabled] .bk-bs-btn-info:hover,
                .bk-bs-btn-info.bk-bs-disabled:focus,
                .bk-bs-btn-info[disabled]:focus,
                fieldset[disabled] .bk-bs-btn-info:focus,
                .bk-bs-btn-info.bk-bs-disabled:active,
                .bk-bs-btn-info[disabled]:active,
                fieldset[disabled] .bk-bs-btn-info:active,
                .bk-bs-btn-info.bk-bs-disabled.bk-bs-active,
                .bk-bs-btn-info[disabled].bk-bs-active,
                fieldset[disabled] .bk-bs-btn-info.bk-bs-active {
                  background-color: #5bc0de;
                  border-color: #46b8da;
                }
                .bk-bs-btn-info .bk-bs-badge {
                  color: #5bc0de;
                  background-color: #ffffff;
                }
                .bk-bs-btn-warning {
                  color: #ffffff;
                  background-color: #f0ad4e;
                  border-color: #eea236;
                }
                .bk-bs-btn-warning:hover,
                .bk-bs-btn-warning:focus,
                .bk-bs-btn-warning:active,
                .bk-bs-btn-warning.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-warning {
                  color: #ffffff;
                  background-color: #ed9c28;
                  border-color: #d58512;
                }
                .bk-bs-btn-warning:active,
                .bk-bs-btn-warning.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-warning {
                  background-image: none;
                }
                .bk-bs-btn-warning.bk-bs-disabled,
                .bk-bs-btn-warning[disabled],
                fieldset[disabled] .bk-bs-btn-warning,
                .bk-bs-btn-warning.bk-bs-disabled:hover,
                .bk-bs-btn-warning[disabled]:hover,
                fieldset[disabled] .bk-bs-btn-warning:hover,
                .bk-bs-btn-warning.bk-bs-disabled:focus,
                .bk-bs-btn-warning[disabled]:focus,
                fieldset[disabled] .bk-bs-btn-warning:focus,
                .bk-bs-btn-warning.bk-bs-disabled:active,
                .bk-bs-btn-warning[disabled]:active,
                fieldset[disabled] .bk-bs-btn-warning:active,
                .bk-bs-btn-warning.bk-bs-disabled.bk-bs-active,
                .bk-bs-btn-warning[disabled].bk-bs-active,
                fieldset[disabled] .bk-bs-btn-warning.bk-bs-active {
                  background-color: #f0ad4e;
                  border-color: #eea236;
                }
                .bk-bs-btn-warning .bk-bs-badge {
                  color: #f0ad4e;
                  background-color: #ffffff;
                }
                .bk-bs-btn-danger {
                  color: #ffffff;
                  background-color: #d9534f;
                  border-color: #d43f3a;
                }
                .bk-bs-btn-danger:hover,
                .bk-bs-btn-danger:focus,
                .bk-bs-btn-danger:active,
                .bk-bs-btn-danger.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-danger {
                  color: #ffffff;
                  background-color: #d2322d;
                  border-color: #ac2925;
                }
                .bk-bs-btn-danger:active,
                .bk-bs-btn-danger.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-danger {
                  background-image: none;
                }
                .bk-bs-btn-danger.bk-bs-disabled,
                .bk-bs-btn-danger[disabled],
                fieldset[disabled] .bk-bs-btn-danger,
                .bk-bs-btn-danger.bk-bs-disabled:hover,
                .bk-bs-btn-danger[disabled]:hover,
                fieldset[disabled] .bk-bs-btn-danger:hover,
                .bk-bs-btn-danger.bk-bs-disabled:focus,
                .bk-bs-btn-danger[disabled]:focus,
                fieldset[disabled] .bk-bs-btn-danger:focus,
                .bk-bs-btn-danger.bk-bs-disabled:active,
                .bk-bs-btn-danger[disabled]:active,
                fieldset[disabled] .bk-bs-btn-danger:active,
                .bk-bs-btn-danger.bk-bs-disabled.bk-bs-active,
                .bk-bs-btn-danger[disabled].bk-bs-active,
                fieldset[disabled] .bk-bs-btn-danger.bk-bs-active {
                  background-color: #d9534f;
                  border-color: #d43f3a;
                }
                .bk-bs-btn-danger .bk-bs-badge {
                  color: #d9534f;
                  background-color: #ffffff;
                }
                .bk-bs-btn-link {
                  color: #428bca;
                  font-weight: normal;
                  cursor: pointer;
                  border-radius: 0;
                }
                .bk-bs-btn-link,
                .bk-bs-btn-link:active,
                .bk-bs-btn-link[disabled],
                fieldset[disabled] .bk-bs-btn-link {
                  background-color: transparent;
                  -webkit-box-shadow: none;
                  box-shadow: none;
                }
                .bk-bs-btn-link,
                .bk-bs-btn-link:hover,
                .bk-bs-btn-link:focus,
                .bk-bs-btn-link:active {
                  border-color: transparent;
                }
                .bk-bs-btn-link:hover,
                .bk-bs-btn-link:focus {
                  color: #2a6496;
                  text-decoration: underline;
                  background-color: transparent;
                }
                .bk-bs-btn-link[disabled]:hover,
                fieldset[disabled] .bk-bs-btn-link:hover,
                .bk-bs-btn-link[disabled]:focus,
                fieldset[disabled] .bk-bs-btn-link:focus {
                  color: #999999;
                  text-decoration: none;
                }
                .bk-bs-btn-lg,
                .bk-bs-btn-group-lg > .bk-bs-btn {
                  padding: 10px 16px;
                  font-size: 18px;
                  line-height: 1.33;
                  border-radius: 6px;
                }
                .bk-bs-btn-sm,
                .bk-bs-btn-group-sm > .bk-bs-btn {
                  padding: 5px 10px;
                  font-size: 12px;
                  line-height: 1.5;
                  border-radius: 3px;
                }
                .bk-bs-btn-xs,
                .bk-bs-btn-group-xs > .bk-bs-btn {
                  padding: 1px 5px;
                  font-size: 12px;
                  line-height: 1.5;
                  border-radius: 3px;
                }
                .bk-bs-btn-block {
                  display: block;
                  width: 100%;
                  padding-left: 0;
                  padding-right: 0;
                }
                .bk-bs-btn-block + .bk-bs-btn-block {
                  margin-top: 5px;
                }
                input[type="submit"].bk-bs-btn-block,
                input[type="reset"].bk-bs-btn-block,
                input[type="button"].bk-bs-btn-block {
                  width: 100%;
                }
                .bk-bs-caret {
                  display: inline-block;
                  width: 0;
                  height: 0;
                  margin-left: 2px;
                  vertical-align: middle;
                  border-top: 4px solid;
                  border-right: 4px solid transparent;
                  border-left: 4px solid transparent;
                }
                .bk-bs-dropdown {
                  position: relative;
                }
                .bk-bs-dropdown-toggle:focus {
                  outline: 0;
                }
                .bk-bs-dropdown-menu {
                  position: absolute;
                  top: 100%;
                  left: 0;
                  z-index: 1000;
                  display: none;
                  float: left;
                  min-width: 160px;
                  padding: 5px 0;
                  margin: 2px 0 0;
                  list-style: none;
                  font-size: 14px;
                  background-color: #ffffff;
                  border: 1px solid #cccccc;
                  border: 1px solid rgba(0, 0, 0, 0.15);
                  border-radius: 4px;
                  -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);
                  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);
                  background-clip: padding-box;
                }
                .bk-bs-dropdown-menu.bk-bs-pull-right {
                  right: 0;
                  left: auto;
                }
                .bk-bs-dropdown-menu .bk-bs-divider {
                  height: 1px;
                  margin: 9px 0;
                  overflow: hidden;
                  background-color: #e5e5e5;
                }
                .bk-bs-dropdown-menu > li > a {
                  display: block;
                  padding: 3px 20px;
                  clear: both;
                  font-weight: normal;
                  line-height: 1.42857143;
                  color: #333333;
                  white-space: nowrap;
                }
                .bk-bs-dropdown-menu > li > a:hover,
                .bk-bs-dropdown-menu > li > a:focus {
                  text-decoration: none;
                  color: #262626;
                  background-color: #f5f5f5;
                }
                .bk-bs-dropdown-menu > .bk-bs-active > a,
                .bk-bs-dropdown-menu > .bk-bs-active > a:hover,
                .bk-bs-dropdown-menu > .bk-bs-active > a:focus {
                  color: #ffffff;
                  text-decoration: none;
                  outline: 0;
                  background-color: #428bca;
                }
                .bk-bs-dropdown-menu > .bk-bs-disabled > a,
                .bk-bs-dropdown-menu > .bk-bs-disabled > a:hover,
                .bk-bs-dropdown-menu > .bk-bs-disabled > a:focus {
                  color: #999999;
                }
                .bk-bs-dropdown-menu > .bk-bs-disabled > a:hover,
                .bk-bs-dropdown-menu > .bk-bs-disabled > a:focus {
                  text-decoration: none;
                  background-color: transparent;
                  background-image: none;
                  filter: progid:DXImageTransform.bk-bs-Microsoft.bk-bs-gradient(enabled = false);
                  cursor: not-allowed;
                }
                .bk-bs-open > .bk-bs-dropdown-menu {
                  display: block;
                }
                .bk-bs-open > a {
                  outline: 0;
                }
                .bk-bs-dropdown-menu-right {
                  left: auto;
                  right: 0;
                }
                .bk-bs-dropdown-menu-left {
                  left: 0;
                  right: auto;
                }
                .bk-bs-dropdown-header {
                  display: block;
                  padding: 3px 20px;
                  font-size: 12px;
                  line-height: 1.42857143;
                  color: #999999;
                }
                .bk-bs-dropdown-backdrop {
                  position: fixed;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  top: 0;
                  z-index: 990;
                }
                .bk-bs-pull-right > .bk-bs-dropdown-menu {
                  right: 0;
                  left: auto;
                }
                .bk-bs-dropup .bk-bs-caret,
                .bk-bs-navbar-fixed-bottom .bk-bs-dropdown .bk-bs-caret {
                  border-top: 0;
                  border-bottom: 4px solid;
                  content: "";
                }
                .bk-bs-dropup .bk-bs-dropdown-menu,
                .bk-bs-navbar-fixed-bottom .bk-bs-dropdown .bk-bs-dropdown-menu {
                  top: auto;
                  bottom: 100%;
                  margin-bottom: 1px;
                }
                @media (min-width: 768px) {
                  .bk-bs-navbar-right .bk-bs-dropdown-menu {
                    left: auto;
                    right: 0;
                  }
                  .bk-bs-navbar-right .bk-bs-dropdown-menu-left {
                    left: 0;
                    right: auto;
                  }
                }
                .bk-bs-btn-group,
                .bk-bs-btn-group-vertical {
                  position: relative;
                  display: inline-block;
                  vertical-align: middle;
                }
                .bk-bs-btn-group > .bk-bs-btn,
                .bk-bs-btn-group-vertical > .bk-bs-btn {
                  position: relative;
                  float: left;
                }
                .bk-bs-btn-group > .bk-bs-btn:hover,
                .bk-bs-btn-group-vertical > .bk-bs-btn:hover,
                .bk-bs-btn-group > .bk-bs-btn:focus,
                .bk-bs-btn-group-vertical > .bk-bs-btn:focus,
                .bk-bs-btn-group > .bk-bs-btn:active,
                .bk-bs-btn-group-vertical > .bk-bs-btn:active,
                .bk-bs-btn-group > .bk-bs-btn.bk-bs-active,
                .bk-bs-btn-group-vertical > .bk-bs-btn.bk-bs-active {
                  z-index: 2;
                }
                .bk-bs-btn-group > .bk-bs-btn:focus,
                .bk-bs-btn-group-vertical > .bk-bs-btn:focus {
                  outline: none;
                }
                .bk-bs-btn-group .bk-bs-btn + .bk-bs-btn,
                .bk-bs-btn-group .bk-bs-btn + .bk-bs-btn-group,
                .bk-bs-btn-group .bk-bs-btn-group + .bk-bs-btn,
                .bk-bs-btn-group .bk-bs-btn-group + .bk-bs-btn-group {
                  margin-left: -1px;
                }
                .bk-bs-btn-toolbar {
                  margin-left: -5px;
                }
                .bk-bs-btn-toolbar .bk-bs-btn-group,
                .bk-bs-btn-toolbar .bk-bs-input-group {
                  float: left;
                }
                .bk-bs-btn-toolbar > .bk-bs-btn,
                .bk-bs-btn-toolbar > .bk-bs-btn-group,
                .bk-bs-btn-toolbar > .bk-bs-input-group {
                  margin-left: 5px;
                }
                .bk-bs-btn-group > .bk-bs-btn:not(:first-child):not(:last-child):not(.bk-bs-dropdown-toggle) {
                  border-radius: 0;
                }
                .bk-bs-btn-group > .bk-bs-btn:first-child {
                  margin-left: 0;
                }
                .bk-bs-btn-group > .bk-bs-btn:first-child:not(:last-child):not(.bk-bs-dropdown-toggle) {
                  border-bottom-right-radius: 0;
                  border-top-right-radius: 0;
                }
                .bk-bs-btn-group > .bk-bs-btn:last-child:not(:first-child),
                .bk-bs-btn-group > .bk-bs-dropdown-toggle:not(:first-child) {
                  border-bottom-left-radius: 0;
                  border-top-left-radius: 0;
                }
                .bk-bs-btn-group > .bk-bs-btn-group {
                  float: left;
                }
                .bk-bs-btn-group > .bk-bs-btn-group:not(:first-child):not(:last-child) > .bk-bs-btn {
                  border-radius: 0;
                }
                .bk-bs-btn-group > .bk-bs-btn-group:first-child > .bk-bs-btn:last-child,
                .bk-bs-btn-group > .bk-bs-btn-group:first-child > .bk-bs-dropdown-toggle {
                  border-bottom-right-radius: 0;
                  border-top-right-radius: 0;
                }
                .bk-bs-btn-group > .bk-bs-btn-group:last-child > .bk-bs-btn:first-child {
                  border-bottom-left-radius: 0;
                  border-top-left-radius: 0;
                }
                .bk-bs-btn-group .bk-bs-dropdown-toggle:active,
                .bk-bs-btn-group.bk-bs-open .bk-bs-dropdown-toggle {
                  outline: 0;
                }
                .bk-bs-btn-group > .bk-bs-btn + .bk-bs-dropdown-toggle {
                  padding-left: 8px;
                  padding-right: 8px;
                }
                .bk-bs-btn-group > .bk-bs-btn-lg + .bk-bs-dropdown-toggle {
                  padding-left: 12px;
                  padding-right: 12px;
                }
                .bk-bs-btn-group.bk-bs-open .bk-bs-dropdown-toggle {
                  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                }
                .bk-bs-btn-group.bk-bs-open .bk-bs-dropdown-toggle.bk-bs-btn-link {
                  -webkit-box-shadow: none;
                  box-shadow: none;
                }
                .bk-bs-btn .bk-bs-caret {
                  margin-left: 0;
                }
                .bk-bs-btn-lg .bk-bs-caret {
                  border-width: 5px 5px 0;
                  border-bottom-width: 0;
                }
                .bk-bs-dropup .bk-bs-btn-lg .bk-bs-caret {
                  border-width: 0 5px 5px;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn,
                .bk-bs-btn-group-vertical > .bk-bs-btn-group,
                .bk-bs-btn-group-vertical > .bk-bs-btn-group > .bk-bs-btn {
                  display: block;
                  float: none;
                  width: 100%;
                  max-width: 100%;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn-group > .bk-bs-btn {
                  float: none;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn + .bk-bs-btn,
                .bk-bs-btn-group-vertical > .bk-bs-btn + .bk-bs-btn-group,
                .bk-bs-btn-group-vertical > .bk-bs-btn-group + .bk-bs-btn,
                .bk-bs-btn-group-vertical > .bk-bs-btn-group + .bk-bs-btn-group {
                  margin-top: -1px;
                  margin-left: 0;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn:not(:first-child):not(:last-child) {
                  border-radius: 0;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn:first-child:not(:last-child) {
                  border-top-right-radius: 4px;
                  border-bottom-right-radius: 0;
                  border-bottom-left-radius: 0;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn:last-child:not(:first-child) {
                  border-bottom-left-radius: 4px;
                  border-top-right-radius: 0;
                  border-top-left-radius: 0;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn-group:not(:first-child):not(:last-child) > .bk-bs-btn {
                  border-radius: 0;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn-group:first-child:not(:last-child) > .bk-bs-btn:last-child,
                .bk-bs-btn-group-vertical > .bk-bs-btn-group:first-child:not(:last-child) > .bk-bs-dropdown-toggle {
                  border-bottom-right-radius: 0;
                  border-bottom-left-radius: 0;
                }
                .bk-bs-btn-group-vertical > .bk-bs-btn-group:last-child:not(:first-child) > .bk-bs-btn:first-child {
                  border-top-right-radius: 0;
                  border-top-left-radius: 0;
                }
                .bk-bs-btn-group-justified {
                  display: table;
                  width: 100%;
                  table-layout: fixed;
                  border-collapse: separate;
                }
                .bk-bs-btn-group-justified > .bk-bs-btn,
                .bk-bs-btn-group-justified > .bk-bs-btn-group {
                  float: none;
                  display: table-cell;
                  width: 1%;
                }
                .bk-bs-btn-group-justified > .bk-bs-btn-group .bk-bs-btn {
                  width: 100%;
                }
                [data-bk-bs-toggle="buttons"] > .bk-bs-btn > input[type="radio"],
                [data-bk-bs-toggle="buttons"] > .bk-bs-btn > input[type="checkbox"] {
                  display: none;
                }
                .bk-bs-input-group {
                  position: relative;
                  display: table;
                  border-collapse: separate;
                }
                .bk-bs-input-group[class*="col-"] {
                  float: none;
                  padding-left: 0;
                  padding-right: 0;
                }
                .bk-bs-input-group .bk-bs-form-control {
                  position: relative;
                  z-index: 2;
                  float: left;
                  width: 100%;
                  margin-bottom: 0;
                }
                .bk-bs-input-group-lg > .bk-bs-form-control,
                .bk-bs-input-group-lg > .bk-bs-input-group-addon,
                .bk-bs-input-group-lg > .bk-bs-input-group-btn > .bk-bs-btn {
                  height: 46px;
                  padding: 10px 16px;
                  font-size: 18px;
                  line-height: 1.33;
                  border-radius: 6px;
                }
                select.bk-bs-input-group-lg > .bk-bs-form-control,
                select.bk-bs-input-group-lg > .bk-bs-input-group-addon,
                select.bk-bs-input-group-lg > .bk-bs-input-group-btn > .bk-bs-btn {
                  height: 46px;
                  line-height: 46px;
                }
                textarea.bk-bs-input-group-lg > .bk-bs-form-control,
                textarea.bk-bs-input-group-lg > .bk-bs-input-group-addon,
                textarea.bk-bs-input-group-lg > .bk-bs-input-group-btn > .bk-bs-btn,
                select[multiple].bk-bs-input-group-lg > .bk-bs-form-control,
                select[multiple].bk-bs-input-group-lg > .bk-bs-input-group-addon,
                select[multiple].bk-bs-input-group-lg > .bk-bs-input-group-btn > .bk-bs-btn {
                  height: auto;
                }
                .bk-bs-input-group-sm > .bk-bs-form-control,
                .bk-bs-input-group-sm > .bk-bs-input-group-addon,
                .bk-bs-input-group-sm > .bk-bs-input-group-btn > .bk-bs-btn {
                  height: 30px;
                  padding: 5px 10px;
                  font-size: 12px;
                  line-height: 1.5;
                  border-radius: 3px;
                }
                select.bk-bs-input-group-sm > .bk-bs-form-control,
                select.bk-bs-input-group-sm > .bk-bs-input-group-addon,
                select.bk-bs-input-group-sm > .bk-bs-input-group-btn > .bk-bs-btn {
                  height: 30px;
                  line-height: 30px;
                }
                textarea.bk-bs-input-group-sm > .bk-bs-form-control,
                textarea.bk-bs-input-group-sm > .bk-bs-input-group-addon,
                textarea.bk-bs-input-group-sm > .bk-bs-input-group-btn > .bk-bs-btn,
                select[multiple].bk-bs-input-group-sm > .bk-bs-form-control,
                select[multiple].bk-bs-input-group-sm > .bk-bs-input-group-addon,
                select[multiple].bk-bs-input-group-sm > .bk-bs-input-group-btn > .bk-bs-btn {
                  height: auto;
                }
                .bk-bs-input-group-addon,
                .bk-bs-input-group-btn,
                .bk-bs-input-group .bk-bs-form-control {
                  display: table-cell;
                }
                .bk-bs-input-group-addon:not(:first-child):not(:last-child),
                .bk-bs-input-group-btn:not(:first-child):not(:last-child),
                .bk-bs-input-group .bk-bs-form-control:not(:first-child):not(:last-child) {
                  border-radius: 0;
                }
                .bk-bs-input-group-addon,
                .bk-bs-input-group-btn {
                  width: 1%;
                  white-space: nowrap;
                  vertical-align: middle;
                }
                .bk-bs-input-group-addon {
                  padding: 6px 12px;
                  font-size: 14px;
                  font-weight: normal;
                  line-height: 1;
                  color: #555555;
                  text-align: center;
                  background-color: #eeeeee;
                  border: 1px solid #cccccc;
                  border-radius: 4px;
                }
                .bk-bs-input-group-addon.bk-bs-input-sm {
                  padding: 5px 10px;
                  font-size: 12px;
                  border-radius: 3px;
                }
                .bk-bs-input-group-addon.bk-bs-input-lg {
                  padding: 10px 16px;
                  font-size: 18px;
                  border-radius: 6px;
                }
                .bk-bs-input-group-addon input[type="radio"],
                .bk-bs-input-group-addon input[type="checkbox"] {
                  margin-top: 0;
                }
                .bk-bs-input-group .bk-bs-form-control:first-child,
                .bk-bs-input-group-addon:first-child,
                .bk-bs-input-group-btn:first-child > .bk-bs-btn,
                .bk-bs-input-group-btn:first-child > .bk-bs-btn-group > .bk-bs-btn,
                .bk-bs-input-group-btn:first-child > .bk-bs-dropdown-toggle,
                .bk-bs-input-group-btn:last-child > .bk-bs-btn:not(:last-child):not(.bk-bs-dropdown-toggle),
                .bk-bs-input-group-btn:last-child > .bk-bs-btn-group:not(:last-child) > .bk-bs-btn {
                  border-bottom-right-radius: 0;
                  border-top-right-radius: 0;
                }
                .bk-bs-input-group-addon:first-child {
                  border-right: 0;
                }
                .bk-bs-input-group .bk-bs-form-control:last-child,
                .bk-bs-input-group-addon:last-child,
                .bk-bs-input-group-btn:last-child > .bk-bs-btn,
                .bk-bs-input-group-btn:last-child > .bk-bs-btn-group > .bk-bs-btn,
                .bk-bs-input-group-btn:last-child > .bk-bs-dropdown-toggle,
                .bk-bs-input-group-btn:first-child > .bk-bs-btn:not(:first-child),
                .bk-bs-input-group-btn:first-child > .bk-bs-btn-group:not(:first-child) > .bk-bs-btn {
                  border-bottom-left-radius: 0;
                  border-top-left-radius: 0;
                }
                .bk-bs-input-group-addon:last-child {
                  border-left: 0;
                }
                .bk-bs-input-group-btn {
                  position: relative;
                  font-size: 0;
                  white-space: nowrap;
                }
                .bk-bs-input-group-btn > .bk-bs-btn {
                  position: relative;
                }
                .bk-bs-input-group-btn > .bk-bs-btn + .bk-bs-btn {
                  margin-left: -1px;
                }
                .bk-bs-input-group-btn > .bk-bs-btn:hover,
                .bk-bs-input-group-btn > .bk-bs-btn:focus,
                .bk-bs-input-group-btn > .bk-bs-btn:active {
                  z-index: 2;
                }
                .bk-bs-input-group-btn:first-child > .bk-bs-btn,
                .bk-bs-input-group-btn:first-child > .bk-bs-btn-group {
                  margin-right: -1px;
                }
                .bk-bs-input-group-btn:last-child > .bk-bs-btn,
                .bk-bs-input-group-btn:last-child > .bk-bs-btn-group {
                  margin-left: -1px;
                }
                .bk-bs-nav {
                  margin-bottom: 0;
                  padding-left: 0;
                  list-style: none;
                }
                .bk-bs-nav > li {
                  position: relative;
                  display: block;
                }
                .bk-bs-nav > li > a {
                  position: relative;
                  display: block;
                  padding: 10px 15px;
                }
                .bk-bs-nav > li > a:hover,
                .bk-bs-nav > li > a:focus {
                  text-decoration: none;
                  background-color: #eeeeee;
                }
                .bk-bs-nav > li.bk-bs-disabled > a {
                  color: #999999;
                }
                .bk-bs-nav > li.bk-bs-disabled > a:hover,
                .bk-bs-nav > li.bk-bs-disabled > a:focus {
                  color: #999999;
                  text-decoration: none;
                  background-color: transparent;
                  cursor: not-allowed;
                }
                .bk-bs-nav .bk-bs-open > a,
                .bk-bs-nav .bk-bs-open > a:hover,
                .bk-bs-nav .bk-bs-open > a:focus {
                  background-color: #eeeeee;
                  border-color: #428bca;
                }
                .bk-bs-nav .bk-bs-nav-divider {
                  height: 1px;
                  margin: 9px 0;
                  overflow: hidden;
                  background-color: #e5e5e5;
                }
                .bk-bs-nav > li > a > img {
                  max-width: none;
                }
                .bk-bs-nav-tabs {
                  border-bottom: 1px solid #dddddd;
                }
                .bk-bs-nav-tabs > li {
                  float: left;
                  margin-bottom: -1px;
                }
                .bk-bs-nav-tabs > li > a {
                  margin-right: 2px;
                  line-height: 1.42857143;
                  border: 1px solid transparent;
                  border-radius: 4px 4px 0 0;
                }
                .bk-bs-nav-tabs > li > a:hover {
                  border-color: #eeeeee #eeeeee #dddddd;
                }
                .bk-bs-nav-tabs > li.bk-bs-active > a,
                .bk-bs-nav-tabs > li.bk-bs-active > a:hover,
                .bk-bs-nav-tabs > li.bk-bs-active > a:focus {
                  color: #555555;
                  background-color: #ffffff;
                  border: 1px solid #dddddd;
                  border-bottom-color: transparent;
                  cursor: default;
                }
                .bk-bs-nav-tabs.bk-bs-nav-justified {
                  width: 100%;
                  border-bottom: 0;
                }
                .bk-bs-nav-tabs.bk-bs-nav-justified > li {
                  float: none;
                }
                .bk-bs-nav-tabs.bk-bs-nav-justified > li > a {
                  text-align: center;
                  margin-bottom: 5px;
                }
                .bk-bs-nav-tabs.bk-bs-nav-justified > .bk-bs-dropdown .bk-bs-dropdown-menu {
                  top: auto;
                  left: auto;
                }
                @media (min-width: 768px) {
                  .bk-bs-nav-tabs.bk-bs-nav-justified > li {
                    display: table-cell;
                    width: 1%;
                  }
                  .bk-bs-nav-tabs.bk-bs-nav-justified > li > a {
                    margin-bottom: 0;
                  }
                }
                .bk-bs-nav-tabs.bk-bs-nav-justified > li > a {
                  margin-right: 0;
                  border-radius: 4px;
                }
                .bk-bs-nav-tabs.bk-bs-nav-justified > .bk-bs-active > a,
                .bk-bs-nav-tabs.bk-bs-nav-justified > .bk-bs-active > a:hover,
                .bk-bs-nav-tabs.bk-bs-nav-justified > .bk-bs-active > a:focus {
                  border: 1px solid #dddddd;
                }
                @media (min-width: 768px) {
                  .bk-bs-nav-tabs.bk-bs-nav-justified > li > a {
                    border-bottom: 1px solid #dddddd;
                    border-radius: 4px 4px 0 0;
                  }
                  .bk-bs-nav-tabs.bk-bs-nav-justified > .bk-bs-active > a,
                  .bk-bs-nav-tabs.bk-bs-nav-justified > .bk-bs-active > a:hover,
                  .bk-bs-nav-tabs.bk-bs-nav-justified > .bk-bs-active > a:focus {
                    border-bottom-color: #ffffff;
                  }
                }
                .bk-bs-nav-pills > li {
                  float: left;
                }
                .bk-bs-nav-pills > li > a {
                  border-radius: 4px;
                }
                .bk-bs-nav-pills > li + li {
                  margin-left: 2px;
                }
                .bk-bs-nav-pills > li.bk-bs-active > a,
                .bk-bs-nav-pills > li.bk-bs-active > a:hover,
                .bk-bs-nav-pills > li.bk-bs-active > a:focus {
                  color: #ffffff;
                  background-color: #428bca;
                }
                .bk-bs-nav-stacked > li {
                  float: none;
                }
                .bk-bs-nav-stacked > li + li {
                  margin-top: 2px;
                  margin-left: 0;
                }
                .bk-bs-nav-justified {
                  width: 100%;
                }
                .bk-bs-nav-justified > li {
                  float: none;
                }
                .bk-bs-nav-justified > li > a {
                  text-align: center;
                  margin-bottom: 5px;
                }
                .bk-bs-nav-justified > .bk-bs-dropdown .bk-bs-dropdown-menu {
                  top: auto;
                  left: auto;
                }
                @media (min-width: 768px) {
                  .bk-bs-nav-justified > li {
                    display: table-cell;
                    width: 1%;
                  }
                  .bk-bs-nav-justified > li > a {
                    margin-bottom: 0;
                  }
                }
                .bk-bs-nav-tabs-justified {
                  border-bottom: 0;
                }
                .bk-bs-nav-tabs-justified > li > a {
                  margin-right: 0;
                  border-radius: 4px;
                }
                .bk-bs-nav-tabs-justified > .bk-bs-active > a,
                .bk-bs-nav-tabs-justified > .bk-bs-active > a:hover,
                .bk-bs-nav-tabs-justified > .bk-bs-active > a:focus {
                  border: 1px solid #dddddd;
                }
                @media (min-width: 768px) {
                  .bk-bs-nav-tabs-justified > li > a {
                    border-bottom: 1px solid #dddddd;
                    border-radius: 4px 4px 0 0;
                  }
                  .bk-bs-nav-tabs-justified > .bk-bs-active > a,
                  .bk-bs-nav-tabs-justified > .bk-bs-active > a:hover,
                  .bk-bs-nav-tabs-justified > .bk-bs-active > a:focus {
                    border-bottom-color: #ffffff;
                  }
                }
                .bk-bs-tab-content > .bk-bs-tab-pane {
                  display: none;
                }
                .bk-bs-tab-content > .bk-bs-active {
                  display: block;
                }
                .bk-bs-nav-tabs .bk-bs-dropdown-menu {
                  margin-top: -1px;
                  border-top-right-radius: 0;
                  border-top-left-radius: 0;
                }
                .bk-bs-label {
                  display: inline;
                  padding: .2em .6em .3em;
                  font-size: 75%;
                  font-weight: bold;
                  line-height: 1;
                  color: #ffffff;
                  text-align: center;
                  white-space: nowrap;
                  vertical-align: baseline;
                  border-radius: .25em;
                }
                .bk-bs-label[href]:hover,
                .bk-bs-label[href]:focus {
                  color: #ffffff;
                  text-decoration: none;
                  cursor: pointer;
                }
                .bk-bs-label:empty {
                  display: none;
                }
                .bk-bs-btn .bk-bs-label {
                  position: relative;
                  top: -1px;
                }
                .bk-bs-label-default {
                  background-color: #999999;
                }
                .bk-bs-label-default[href]:hover,
                .bk-bs-label-default[href]:focus {
                  background-color: #808080;
                }
                .bk-bs-label-primary {
                  background-color: #428bca;
                }
                .bk-bs-label-primary[href]:hover,
                .bk-bs-label-primary[href]:focus {
                  background-color: #3071a9;
                }
                .bk-bs-label-success {
                  background-color: #5cb85c;
                }
                .bk-bs-label-success[href]:hover,
                .bk-bs-label-success[href]:focus {
                  background-color: #449d44;
                }
                .bk-bs-label-info {
                  background-color: #5bc0de;
                }
                .bk-bs-label-info[href]:hover,
                .bk-bs-label-info[href]:focus {
                  background-color: #31b0d5;
                }
                .bk-bs-label-warning {
                  background-color: #f0ad4e;
                }
                .bk-bs-label-warning[href]:hover,
                .bk-bs-label-warning[href]:focus {
                  background-color: #ec971f;
                }
                .bk-bs-label-danger {
                  background-color: #d9534f;
                }
                .bk-bs-label-danger[href]:hover,
                .bk-bs-label-danger[href]:focus {
                  background-color: #c9302c;
                }
                .bk-bs-panel {
                  margin-bottom: 20px;
                  background-color: #ffffff;
                  border: 1px solid transparent;
                  border-radius: 4px;
                  -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
                  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
                }
                .bk-bs-panel-body {
                  padding: 15px;
                }
                .bk-bs-panel-heading {
                  padding: 10px 15px;
                  border-bottom: 1px solid transparent;
                  border-top-right-radius: 3px;
                  border-top-left-radius: 3px;
                }
                .bk-bs-panel-heading > .bk-bs-dropdown .bk-bs-dropdown-toggle {
                  color: inherit;
                }
                .bk-bs-panel-title {
                  margin-top: 0;
                  margin-bottom: 0;
                  font-size: 16px;
                  color: inherit;
                }
                .bk-bs-panel-title > a {
                  color: inherit;
                }
                .bk-bs-panel-footer {
                  padding: 10px 15px;
                  background-color: #f5f5f5;
                  border-top: 1px solid #dddddd;
                  border-bottom-right-radius: 3px;
                  border-bottom-left-radius: 3px;
                }
                .bk-bs-panel > .bk-bs-list-group {
                  margin-bottom: 0;
                }
                .bk-bs-panel > .bk-bs-list-group .bk-bs-list-group-item {
                  border-width: 1px 0;
                  border-radius: 0;
                }
                .bk-bs-panel > .bk-bs-list-group:first-child .bk-bs-list-group-item:first-child {
                  border-top: 0;
                  border-top-right-radius: 3px;
                  border-top-left-radius: 3px;
                }
                .bk-bs-panel > .bk-bs-list-group:last-child .bk-bs-list-group-item:last-child {
                  border-bottom: 0;
                  border-bottom-right-radius: 3px;
                  border-bottom-left-radius: 3px;
                }
                .bk-bs-panel-heading + .bk-bs-list-group .bk-bs-list-group-item:first-child {
                  border-top-width: 0;
                }
                .bk-bs-panel > .bk-bs-table,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table {
                  margin-bottom: 0;
                }
                .bk-bs-panel > .bk-bs-table:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child {
                  border-top-right-radius: 3px;
                  border-top-left-radius: 3px;
                }
                .bk-bs-panel > .bk-bs-table:first-child > thead:first-child > tr:first-child td:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child > thead:first-child > tr:first-child td:first-child,
                .bk-bs-panel > .bk-bs-table:first-child > tbody:first-child > tr:first-child td:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child > tbody:first-child > tr:first-child td:first-child,
                .bk-bs-panel > .bk-bs-table:first-child > thead:first-child > tr:first-child th:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child > thead:first-child > tr:first-child th:first-child,
                .bk-bs-panel > .bk-bs-table:first-child > tbody:first-child > tr:first-child th:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child > tbody:first-child > tr:first-child th:first-child {
                  border-top-left-radius: 3px;
                }
                .bk-bs-panel > .bk-bs-table:first-child > thead:first-child > tr:first-child td:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child > thead:first-child > tr:first-child td:last-child,
                .bk-bs-panel > .bk-bs-table:first-child > tbody:first-child > tr:first-child td:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child > tbody:first-child > tr:first-child td:last-child,
                .bk-bs-panel > .bk-bs-table:first-child > thead:first-child > tr:first-child th:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child > thead:first-child > tr:first-child th:last-child,
                .bk-bs-panel > .bk-bs-table:first-child > tbody:first-child > tr:first-child th:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:first-child > .bk-bs-table:first-child > tbody:first-child > tr:first-child th:last-child {
                  border-top-right-radius: 3px;
                }
                .bk-bs-panel > .bk-bs-table:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child {
                  border-bottom-right-radius: 3px;
                  border-bottom-left-radius: 3px;
                }
                .bk-bs-panel > .bk-bs-table:last-child > tbody:last-child > tr:last-child td:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child > tbody:last-child > tr:last-child td:first-child,
                .bk-bs-panel > .bk-bs-table:last-child > tfoot:last-child > tr:last-child td:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child > tfoot:last-child > tr:last-child td:first-child,
                .bk-bs-panel > .bk-bs-table:last-child > tbody:last-child > tr:last-child th:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child > tbody:last-child > tr:last-child th:first-child,
                .bk-bs-panel > .bk-bs-table:last-child > tfoot:last-child > tr:last-child th:first-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child > tfoot:last-child > tr:last-child th:first-child {
                  border-bottom-left-radius: 3px;
                }
                .bk-bs-panel > .bk-bs-table:last-child > tbody:last-child > tr:last-child td:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child > tbody:last-child > tr:last-child td:last-child,
                .bk-bs-panel > .bk-bs-table:last-child > tfoot:last-child > tr:last-child td:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child > tfoot:last-child > tr:last-child td:last-child,
                .bk-bs-panel > .bk-bs-table:last-child > tbody:last-child > tr:last-child th:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child > tbody:last-child > tr:last-child th:last-child,
                .bk-bs-panel > .bk-bs-table:last-child > tfoot:last-child > tr:last-child th:last-child,
                .bk-bs-panel > .bk-bs-table-responsive:last-child > .bk-bs-table:last-child > tfoot:last-child > tr:last-child th:last-child {
                  border-bottom-right-radius: 3px;
                }
                .bk-bs-panel > .bk-bs-panel-body + .bk-bs-table,
                .bk-bs-panel > .bk-bs-panel-body + .bk-bs-table-responsive {
                  border-top: 1px solid #dddddd;
                }
                .bk-bs-panel > .bk-bs-table > tbody:first-child > tr:first-child th,
                .bk-bs-panel > .bk-bs-table > tbody:first-child > tr:first-child td {
                  border-top: 0;
                }
                .bk-bs-panel > .bk-bs-table-bordered,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered {
                  border: 0;
                }
                .bk-bs-panel > .bk-bs-table-bordered > thead > tr > th:first-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr > th:first-child,
                .bk-bs-panel > .bk-bs-table-bordered > tbody > tr > th:first-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr > th:first-child,
                .bk-bs-panel > .bk-bs-table-bordered > tfoot > tr > th:first-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr > th:first-child,
                .bk-bs-panel > .bk-bs-table-bordered > thead > tr > td:first-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr > td:first-child,
                .bk-bs-panel > .bk-bs-table-bordered > tbody > tr > td:first-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr > td:first-child,
                .bk-bs-panel > .bk-bs-table-bordered > tfoot > tr > td:first-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr > td:first-child {
                  border-left: 0;
                }
                .bk-bs-panel > .bk-bs-table-bordered > thead > tr > th:last-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr > th:last-child,
                .bk-bs-panel > .bk-bs-table-bordered > tbody > tr > th:last-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr > th:last-child,
                .bk-bs-panel > .bk-bs-table-bordered > tfoot > tr > th:last-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr > th:last-child,
                .bk-bs-panel > .bk-bs-table-bordered > thead > tr > td:last-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr > td:last-child,
                .bk-bs-panel > .bk-bs-table-bordered > tbody > tr > td:last-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr > td:last-child,
                .bk-bs-panel > .bk-bs-table-bordered > tfoot > tr > td:last-child,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr > td:last-child {
                  border-right: 0;
                }
                .bk-bs-panel > .bk-bs-table-bordered > thead > tr:first-child > td,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr:first-child > td,
                .bk-bs-panel > .bk-bs-table-bordered > tbody > tr:first-child > td,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr:first-child > td,
                .bk-bs-panel > .bk-bs-table-bordered > thead > tr:first-child > th,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > thead > tr:first-child > th,
                .bk-bs-panel > .bk-bs-table-bordered > tbody > tr:first-child > th,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr:first-child > th {
                  border-bottom: 0;
                }
                .bk-bs-panel > .bk-bs-table-bordered > tbody > tr:last-child > td,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr:last-child > td,
                .bk-bs-panel > .bk-bs-table-bordered > tfoot > tr:last-child > td,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr:last-child > td,
                .bk-bs-panel > .bk-bs-table-bordered > tbody > tr:last-child > th,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tbody > tr:last-child > th,
                .bk-bs-panel > .bk-bs-table-bordered > tfoot > tr:last-child > th,
                .bk-bs-panel > .bk-bs-table-responsive > .bk-bs-table-bordered > tfoot > tr:last-child > th {
                  border-bottom: 0;
                }
                .bk-bs-panel > .bk-bs-table-responsive {
                  border: 0;
                  margin-bottom: 0;
                }
                .bk-bs-panel-group {
                  margin-bottom: 20px;
                }
                .bk-bs-panel-group .bk-bs-panel {
                  margin-bottom: 0;
                  border-radius: 4px;
                  overflow: hidden;
                }
                .bk-bs-panel-group .bk-bs-panel + .bk-bs-panel {
                  margin-top: 5px;
                }
                .bk-bs-panel-group .bk-bs-panel-heading {
                  border-bottom: 0;
                }
                .bk-bs-panel-group .bk-bs-panel-heading + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-top: 1px solid #dddddd;
                }
                .bk-bs-panel-group .bk-bs-panel-footer {
                  border-top: 0;
                }
                .bk-bs-panel-group .bk-bs-panel-footer + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-bottom: 1px solid #dddddd;
                }
                .bk-bs-panel-default {
                  border-color: #dddddd;
                }
                .bk-bs-panel-default > .bk-bs-panel-heading {
                  color: #333333;
                  background-color: #f5f5f5;
                  border-color: #dddddd;
                }
                .bk-bs-panel-default > .bk-bs-panel-heading + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-top-color: #dddddd;
                }
                .bk-bs-panel-default > .bk-bs-panel-footer + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-bottom-color: #dddddd;
                }
                .bk-bs-panel-primary {
                  border-color: #428bca;
                }
                .bk-bs-panel-primary > .bk-bs-panel-heading {
                  color: #ffffff;
                  background-color: #428bca;
                  border-color: #428bca;
                }
                .bk-bs-panel-primary > .bk-bs-panel-heading + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-top-color: #428bca;
                }
                .bk-bs-panel-primary > .bk-bs-panel-footer + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-bottom-color: #428bca;
                }
                .bk-bs-panel-success {
                  border-color: #d6e9c6;
                }
                .bk-bs-panel-success > .bk-bs-panel-heading {
                  color: #3c763d;
                  background-color: #dff0d8;
                  border-color: #d6e9c6;
                }
                .bk-bs-panel-success > .bk-bs-panel-heading + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-top-color: #d6e9c6;
                }
                .bk-bs-panel-success > .bk-bs-panel-footer + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-bottom-color: #d6e9c6;
                }
                .bk-bs-panel-info {
                  border-color: #bce8f1;
                }
                .bk-bs-panel-info > .bk-bs-panel-heading {
                  color: #31708f;
                  background-color: #d9edf7;
                  border-color: #bce8f1;
                }
                .bk-bs-panel-info > .bk-bs-panel-heading + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-top-color: #bce8f1;
                }
                .bk-bs-panel-info > .bk-bs-panel-footer + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-bottom-color: #bce8f1;
                }
                .bk-bs-panel-warning {
                  border-color: #faebcc;
                }
                .bk-bs-panel-warning > .bk-bs-panel-heading {
                  color: #8a6d3b;
                  background-color: #fcf8e3;
                  border-color: #faebcc;
                }
                .bk-bs-panel-warning > .bk-bs-panel-heading + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-top-color: #faebcc;
                }
                .bk-bs-panel-warning > .bk-bs-panel-footer + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-bottom-color: #faebcc;
                }
                .bk-bs-panel-danger {
                  border-color: #ebccd1;
                }
                .bk-bs-panel-danger > .bk-bs-panel-heading {
                  color: #a94442;
                  background-color: #f2dede;
                  border-color: #ebccd1;
                }
                .bk-bs-panel-danger > .bk-bs-panel-heading + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-top-color: #ebccd1;
                }
                .bk-bs-panel-danger > .bk-bs-panel-footer + .bk-bs-panel-collapse .bk-bs-panel-body {
                  border-bottom-color: #ebccd1;
                }
                .bk-bs-close {
                  float: right;
                  font-size: 21px;
                  font-weight: bold;
                  line-height: 1;
                  color: #000000;
                  text-shadow: 0 1px 0 #ffffff;
                  opacity: 0.2;
                  filter: alpha(opacity=20);
                }
                .bk-bs-close:hover,
                .bk-bs-close:focus {
                  color: #000000;
                  text-decoration: none;
                  cursor: pointer;
                  opacity: 0.5;
                  filter: alpha(opacity=50);
                }
                button.bk-bs-close {
                  padding: 0;
                  cursor: pointer;
                  background: transparent;
                  border: 0;
                  -webkit-appearance: none;
                }
                .bk-bs-modal-open {
                  overflow: hidden;
                }
                .bk-bs-modal {
                  display: none;
                  overflow: auto;
                  overflow-y: scroll;
                  position: fixed;
                  top: 0;
                  right: 0;
                  bottom: 0;
                  left: 0;
                  z-index: 1050;
                  -webkit-overflow-scrolling: touch;
                  outline: 0;
                }
                .bk-bs-modal.bk-bs-fade .bk-bs-modal-dialog {
                  -webkit-transform: translate(0, -25%);
                  -ms-transform: translate(0, -25%);
                  transform: translate(0, -25%);
                  -webkit-transition: -webkit-transform 0.3s ease-out;
                  -moz-transition: -moz-transform 0.3s ease-out;
                  -o-transition: -o-transform 0.3s ease-out;
                  transition: transform 0.3s ease-out;
                }
                .bk-bs-modal.bk-bs-in .bk-bs-modal-dialog {
                  -webkit-transform: translate(0, 0);
                  -ms-transform: translate(0, 0);
                  transform: translate(0, 0);
                }
                .bk-bs-modal-dialog {
                  position: relative;
                  width: auto;
                  margin: 10px;
                }
                .bk-bs-modal-content {
                  position: relative;
                  background-color: #ffffff;
                  border: 1px solid #999999;
                  border: 1px solid rgba(0, 0, 0, 0.2);
                  border-radius: 6px;
                  -webkit-box-shadow: 0 3px 9px rgba(0, 0, 0, 0.5);
                  box-shadow: 0 3px 9px rgba(0, 0, 0, 0.5);
                  background-clip: padding-box;
                  outline: none;
                }
                .bk-bs-modal-backdrop {
                  position: fixed;
                  top: 0;
                  right: 0;
                  bottom: 0;
                  left: 0;
                  z-index: 1040;
                  background-color: #000000;
                }
                .bk-bs-modal-backdrop.bk-bs-fade {
                  opacity: 0;
                  filter: alpha(opacity=0);
                }
                .bk-bs-modal-backdrop.bk-bs-in {
                  opacity: 0.5;
                  filter: alpha(opacity=50);
                }
                .bk-bs-modal-header {
                  padding: 15px;
                  border-bottom: 1px solid #e5e5e5;
                  min-height: 16.42857143px;
                }
                .bk-bs-modal-header .bk-bs-close {
                  margin-top: -2px;
                }
                .bk-bs-modal-title {
                  margin: 0;
                  line-height: 1.42857143;
                }
                .bk-bs-modal-body {
                  position: relative;
                  padding: 20px;
                }
                .bk-bs-modal-footer {
                  margin-top: 15px;
                  padding: 19px 20px 20px;
                  text-align: right;
                  border-top: 1px solid #e5e5e5;
                }
                .bk-bs-modal-footer .bk-bs-btn + .bk-bs-btn {
                  margin-left: 5px;
                  margin-bottom: 0;
                }
                .bk-bs-modal-footer .bk-bs-btn-group .bk-bs-btn + .bk-bs-btn {
                  margin-left: -1px;
                }
                .bk-bs-modal-footer .bk-bs-btn-block + .bk-bs-btn-block {
                  margin-left: 0;
                }
                @media (min-width: 768px) {
                  .bk-bs-modal-dialog {
                    width: 600px;
                    margin: 30px auto;
                  }
                  .bk-bs-modal-content {
                    -webkit-box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
                  }
                  .bk-bs-modal-sm {
                    width: 300px;
                  }
                }
                @media (min-width: 992px) {
                  .bk-bs-modal-lg {
                    width: 900px;
                  }
                }
                .bk-bs-clearfix:before,
                .bk-bs-clearfix:after,
                .bk-bs-container:before,
                .bk-bs-container:after,
                .bk-bs-container-fluid:before,
                .bk-bs-container-fluid:after,
                .bk-bs-row:before,
                .bk-bs-row:after,
                .bk-bs-form-horizontal .bk-bs-form-group:before,
                .bk-bs-form-horizontal .bk-bs-form-group:after,
                .bk-bs-btn-toolbar:before,
                .bk-bs-btn-toolbar:after,
                .bk-bs-btn-group-vertical > .bk-bs-btn-group:before,
                .bk-bs-btn-group-vertical > .bk-bs-btn-group:after,
                .bk-bs-nav:before,
                .bk-bs-nav:after,
                .bk-bs-panel-body:before,
                .bk-bs-panel-body:after,
                .bk-bs-modal-footer:before,
                .bk-bs-modal-footer:after,
                .bk-crossfilter-row:before,
                .bk-crossfilter-row:after {
                  content: " ";
                  display: table;
                }
                .bk-bs-clearfix:after,
                .bk-bs-container:after,
                .bk-bs-container-fluid:after,
                .bk-bs-row:after,
                .bk-bs-form-horizontal .bk-bs-form-group:after,
                .bk-bs-btn-toolbar:after,
                .bk-bs-btn-group-vertical > .bk-bs-btn-group:after,
                .bk-bs-nav:after,
                .bk-bs-panel-body:after,
                .bk-bs-modal-footer:after,
                .bk-crossfilter-row:after {
                  clear: both;
                }
                .bk-bs-center-block {
                  display: block;
                  margin-left: auto;
                  margin-right: auto;
                }
                .bk-bs-pull-right {
                  float: right !important;
                }
                .bk-bs-pull-left {
                  float: left !important;
                }
                .bk-bs-hide {
                  display: none !important;
                }
                .bk-bs-show {
                  display: block !important;
                }
                .bk-bs-invisible {
                  visibility: hidden;
                }
                .bk-bs-text-hide {
                  font: 0/0 a;
                  color: transparent;
                  text-shadow: none;
                  background-color: transparent;
                  border: 0;
                }
                .bk-bs-hidden {
                  display: none !important;
                  visibility: hidden !important;
                }
                .bk-bs-affix {
                  position: fixed;
                }
                /* FONT PATH
                 * -------------------------- */
                @font-face {
                  font-family: 'FontAwesome';
                  src: url('/bokehjs/static/js/vendor/font-awesome-4.2.0/fonts/fontawesome-webfont.eot?v=4.2.0');
                  src: url('/bokehjs/static/js/vendor/font-awesome-4.2.0/fonts/fontawesome-webfont.eot?#iefix&v=4.2.0') format('embedded-opentype'), url('/bokehjs/static/js/vendor/font-awesome-4.2.0/fonts/fontawesome-webfont.woff?v=4.2.0') format('woff'), url('/bokehjs/static/js/vendor/font-awesome-4.2.0/fonts/fontawesome-webfont.ttf?v=4.2.0') format('truetype'), url('/bokehjs/static/js/vendor/font-awesome-4.2.0/fonts/fontawesome-webfont.svg?v=4.2.0#fontawesomeregular') format('svg');
                  font-weight: normal;
                  font-style: normal;
                }
                .bk-fa {
                  display: inline-block;
                  font: normal normal normal 14px/1 FontAwesome;
                  font-size: inherit;
                  text-rendering: auto;
                  -webkit-font-smoothing: antialiased;
                  -moz-osx-font-smoothing: grayscale;
                }
                /* makes the font 33% larger relative to the icon container */
                .bk-fa-lg {
                  font-size: 1.33333333em;
                  line-height: 0.75em;
                  vertical-align: -15%;
                }
                .bk-fa-2x {
                  font-size: 2em;
                }
                .bk-fa-3x {
                  font-size: 3em;
                }
                .bk-fa-4x {
                  font-size: 4em;
                }
                .bk-fa-5x {
                  font-size: 5em;
                }
                .bk-fa-fw {
                  width: 1.28571429em;
                  text-align: center;
                }
                .bk-fa-ul {
                  padding-left: 0;
                  margin-left: 2.14285714em;
                  list-style-type: none;
                }
                .bk-fa-ul > li {
                  position: relative;
                }
                .bk-fa-li {
                  position: absolute;
                  left: -2.14285714em;
                  width: 2.14285714em;
                  top: 0.14285714em;
                  text-align: center;
                }
                .bk-fa-li.bk-fa-lg {
                  left: -1.85714286em;
                }
                .bk-fa-border {
                  padding: .2em .25em .15em;
                  border: solid 0.08em #eeeeee;
                  border-radius: .1em;
                }
                .pull-right {
                  float: right;
                }
                .pull-left {
                  float: left;
                }
                .bk-fa.pull-left {
                  margin-right: .3em;
                }
                .bk-fa.pull-right {
                  margin-left: .3em;
                }
                .bk-fa-spin {
                  -webkit-animation: fa-spin 2s infinite linear;
                  animation: fa-spin 2s infinite linear;
                }
                @-webkit-keyframes fa-spin {
                  0% {
                    -webkit-transform: rotate(0deg);
                    transform: rotate(0deg);
                  }
                  100% {
                    -webkit-transform: rotate(359deg);
                    transform: rotate(359deg);
                  }
                }
                @keyframes fa-spin {
                  0% {
                    -webkit-transform: rotate(0deg);
                    transform: rotate(0deg);
                  }
                  100% {
                    -webkit-transform: rotate(359deg);
                    transform: rotate(359deg);
                  }
                }
                .bk-fa-rotate-90 {
                  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
                  -webkit-transform: rotate(90deg);
                  -ms-transform: rotate(90deg);
                  transform: rotate(90deg);
                }
                .bk-fa-rotate-180 {
                  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2);
                  -webkit-transform: rotate(180deg);
                  -ms-transform: rotate(180deg);
                  transform: rotate(180deg);
                }
                .bk-fa-rotate-270 {
                  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
                  -webkit-transform: rotate(270deg);
                  -ms-transform: rotate(270deg);
                  transform: rotate(270deg);
                }
                .bk-fa-flip-horizontal {
                  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);
                  -webkit-transform: scale(-1, 1);
                  -ms-transform: scale(-1, 1);
                  transform: scale(-1, 1);
                }
                .bk-fa-flip-vertical {
                  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);
                  -webkit-transform: scale(1, -1);
                  -ms-transform: scale(1, -1);
                  transform: scale(1, -1);
                }
                :root .bk-fa-rotate-90,
                :root .bk-fa-rotate-180,
                :root .bk-fa-rotate-270,
                :root .bk-fa-flip-horizontal,
                :root .bk-fa-flip-vertical {
                  filter: none;
                }
                .bk-fa-stack {
                  position: relative;
                  display: inline-block;
                  width: 2em;
                  height: 2em;
                  line-height: 2em;
                  vertical-align: middle;
                }
                .bk-fa-stack-1x,
                .bk-fa-stack-2x {
                  position: absolute;
                  left: 0;
                  width: 100%;
                  text-align: center;
                }
                .bk-fa-stack-1x {
                  line-height: inherit;
                }
                .bk-fa-stack-2x {
                  font-size: 2em;
                }
                .bk-fa-inverse {
                  color: #ffffff;
                }
                /* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
                   readers do not read off random characters that represent icons */
                .bk-fa-glass:before {
                  content: "\f000";
                }
                .bk-fa-music:before {
                  content: "\f001";
                }
                .bk-fa-search:before {
                  content: "\f002";
                }
                .bk-fa-envelope-o:before {
                  content: "\f003";
                }
                .bk-fa-heart:before {
                  content: "\f004";
                }
                .bk-fa-star:before {
                  content: "\f005";
                }
                .bk-fa-star-o:before {
                  content: "\f006";
                }
                .bk-fa-user:before {
                  content: "\f007";
                }
                .bk-fa-film:before {
                  content: "\f008";
                }
                .bk-fa-th-large:before {
                  content: "\f009";
                }
                .bk-fa-th:before {
                  content: "\f00a";
                }
                .bk-fa-th-list:before {
                  content: "\f00b";
                }
                .bk-fa-check:before {
                  content: "\f00c";
                }
                .bk-fa-remove:before,
                .bk-fa-close:before,
                .bk-fa-times:before {
                  content: "\f00d";
                }
                .bk-fa-search-plus:before {
                  content: "\f00e";
                }
                .bk-fa-search-minus:before {
                  content: "\f010";
                }
                .bk-fa-power-off:before {
                  content: "\f011";
                }
                .bk-fa-signal:before {
                  content: "\f012";
                }
                .bk-fa-gear:before,
                .bk-fa-cog:before {
                  content: "\f013";
                }
                .bk-fa-trash-o:before {
                  content: "\f014";
                }
                .bk-fa-home:before {
                  content: "\f015";
                }
                .bk-fa-file-o:before {
                  content: "\f016";
                }
                .bk-fa-clock-o:before {
                  content: "\f017";
                }
                .bk-fa-road:before {
                  content: "\f018";
                }
                .bk-fa-download:before {
                  content: "\f019";
                }
                .bk-fa-arrow-circle-o-down:before {
                  content: "\f01a";
                }
                .bk-fa-arrow-circle-o-up:before {
                  content: "\f01b";
                }
                .bk-fa-inbox:before {
                  content: "\f01c";
                }
                .bk-fa-play-circle-o:before {
                  content: "\f01d";
                }
                .bk-fa-rotate-right:before,
                .bk-fa-repeat:before {
                  content: "\f01e";
                }
                .bk-fa-refresh:before {
                  content: "\f021";
                }
                .bk-fa-list-alt:before {
                  content: "\f022";
                }
                .bk-fa-lock:before {
                  content: "\f023";
                }
                .bk-fa-flag:before {
                  content: "\f024";
                }
                .bk-fa-headphones:before {
                  content: "\f025";
                }
                .bk-fa-volume-off:before {
                  content: "\f026";
                }
                .bk-fa-volume-down:before {
                  content: "\f027";
                }
                .bk-fa-volume-up:before {
                  content: "\f028";
                }
                .bk-fa-qrcode:before {
                  content: "\f029";
                }
                .bk-fa-barcode:before {
                  content: "\f02a";
                }
                .bk-fa-tag:before {
                  content: "\f02b";
                }
                .bk-fa-tags:before {
                  content: "\f02c";
                }
                .bk-fa-book:before {
                  content: "\f02d";
                }
                .bk-fa-bookmark:before {
                  content: "\f02e";
                }
                .bk-fa-print:before {
                  content: "\f02f";
                }
                .bk-fa-camera:before {
                  content: "\f030";
                }
                .bk-fa-font:before {
                  content: "\f031";
                }
                .bk-fa-bold:before {
                  content: "\f032";
                }
                .bk-fa-italic:before {
                  content: "\f033";
                }
                .bk-fa-text-height:before {
                  content: "\f034";
                }
                .bk-fa-text-width:before {
                  content: "\f035";
                }
                .bk-fa-align-left:before {
                  content: "\f036";
                }
                .bk-fa-align-center:before {
                  content: "\f037";
                }
                .bk-fa-align-right:before {
                  content: "\f038";
                }
                .bk-fa-align-justify:before {
                  content: "\f039";
                }
                .bk-fa-list:before {
                  content: "\f03a";
                }
                .bk-fa-dedent:before,
                .bk-fa-outdent:before {
                  content: "\f03b";
                }
                .bk-fa-indent:before {
                  content: "\f03c";
                }
                .bk-fa-video-camera:before {
                  content: "\f03d";
                }
                .bk-fa-photo:before,
                .bk-fa-image:before,
                .bk-fa-picture-o:before {
                  content: "\f03e";
                }
                .bk-fa-pencil:before {
                  content: "\f040";
                }
                .bk-fa-map-marker:before {
                  content: "\f041";
                }
                .bk-fa-adjust:before {
                  content: "\f042";
                }
                .bk-fa-tint:before {
                  content: "\f043";
                }
                .bk-fa-edit:before,
                .bk-fa-pencil-square-o:before {
                  content: "\f044";
                }
                .bk-fa-share-square-o:before {
                  content: "\f045";
                }
                .bk-fa-check-square-o:before {
                  content: "\f046";
                }
                .bk-fa-arrows:before {
                  content: "\f047";
                }
                .bk-fa-step-backward:before {
                  content: "\f048";
                }
                .bk-fa-fast-backward:before {
                  content: "\f049";
                }
                .bk-fa-backward:before {
                  content: "\f04a";
                }
                .bk-fa-play:before {
                  content: "\f04b";
                }
                .bk-fa-pause:before {
                  content: "\f04c";
                }
                .bk-fa-stop:before {
                  content: "\f04d";
                }
                .bk-fa-forward:before {
                  content: "\f04e";
                }
                .bk-fa-fast-forward:before {
                  content: "\f050";
                }
                .bk-fa-step-forward:before {
                  content: "\f051";
                }
                .bk-fa-eject:before {
                  content: "\f052";
                }
                .bk-fa-chevron-left:before {
                  content: "\f053";
                }
                .bk-fa-chevron-right:before {
                  content: "\f054";
                }
                .bk-fa-plus-circle:before {
                  content: "\f055";
                }
                .bk-fa-minus-circle:before {
                  content: "\f056";
                }
                .bk-fa-times-circle:before {
                  content: "\f057";
                }
                .bk-fa-check-circle:before {
                  content: "\f058";
                }
                .bk-fa-question-circle:before {
                  content: "\f059";
                }
                .bk-fa-info-circle:before {
                  content: "\f05a";
                }
                .bk-fa-crosshairs:before {
                  content: "\f05b";
                }
                .bk-fa-times-circle-o:before {
                  content: "\f05c";
                }
                .bk-fa-check-circle-o:before {
                  content: "\f05d";
                }
                .bk-fa-ban:before {
                  content: "\f05e";
                }
                .bk-fa-arrow-left:before {
                  content: "\f060";
                }
                .bk-fa-arrow-right:before {
                  content: "\f061";
                }
                .bk-fa-arrow-up:before {
                  content: "\f062";
                }
                .bk-fa-arrow-down:before {
                  content: "\f063";
                }
                .bk-fa-mail-forward:before,
                .bk-fa-share:before {
                  content: "\f064";
                }
                .bk-fa-expand:before {
                  content: "\f065";
                }
                .bk-fa-compress:before {
                  content: "\f066";
                }
                .bk-fa-plus:before {
                  content: "\f067";
                }
                .bk-fa-minus:before {
                  content: "\f068";
                }
                .bk-fa-asterisk:before {
                  content: "\f069";
                }
                .bk-fa-exclamation-circle:before {
                  content: "\f06a";
                }
                .bk-fa-gift:before {
                  content: "\f06b";
                }
                .bk-fa-leaf:before {
                  content: "\f06c";
                }
                .bk-fa-fire:before {
                  content: "\f06d";
                }
                .bk-fa-eye:before {
                  content: "\f06e";
                }
                .bk-fa-eye-slash:before {
                  content: "\f070";
                }
                .bk-fa-warning:before,
                .bk-fa-exclamation-triangle:before {
                  content: "\f071";
                }
                .bk-fa-plane:before {
                  content: "\f072";
                }
                .bk-fa-calendar:before {
                  content: "\f073";
                }
                .bk-fa-random:before {
                  content: "\f074";
                }
                .bk-fa-comment:before {
                  content: "\f075";
                }
                .bk-fa-magnet:before {
                  content: "\f076";
                }
                .bk-fa-chevron-up:before {
                  content: "\f077";
                }
                .bk-fa-chevron-down:before {
                  content: "\f078";
                }
                .bk-fa-retweet:before {
                  content: "\f079";
                }
                .bk-fa-shopping-cart:before {
                  content: "\f07a";
                }
                .bk-fa-folder:before {
                  content: "\f07b";
                }
                .bk-fa-folder-open:before {
                  content: "\f07c";
                }
                .bk-fa-arrows-v:before {
                  content: "\f07d";
                }
                .bk-fa-arrows-h:before {
                  content: "\f07e";
                }
                .bk-fa-bar-chart-o:before,
                .bk-fa-bar-chart:before {
                  content: "\f080";
                }
                .bk-fa-twitter-square:before {
                  content: "\f081";
                }
                .bk-fa-facebook-square:before {
                  content: "\f082";
                }
                .bk-fa-camera-retro:before {
                  content: "\f083";
                }
                .bk-fa-key:before {
                  content: "\f084";
                }
                .bk-fa-gears:before,
                .bk-fa-cogs:before {
                  content: "\f085";
                }
                .bk-fa-comments:before {
                  content: "\f086";
                }
                .bk-fa-thumbs-o-up:before {
                  content: "\f087";
                }
                .bk-fa-thumbs-o-down:before {
                  content: "\f088";
                }
                .bk-fa-star-half:before {
                  content: "\f089";
                }
                .bk-fa-heart-o:before {
                  content: "\f08a";
                }
                .bk-fa-sign-out:before {
                  content: "\f08b";
                }
                .bk-fa-linkedin-square:before {
                  content: "\f08c";
                }
                .bk-fa-thumb-tack:before {
                  content: "\f08d";
                }
                .bk-fa-external-link:before {
                  content: "\f08e";
                }
                .bk-fa-sign-in:before {
                  content: "\f090";
                }
                .bk-fa-trophy:before {
                  content: "\f091";
                }
                .bk-fa-github-square:before {
                  content: "\f092";
                }
                .bk-fa-upload:before {
                  content: "\f093";
                }
                .bk-fa-lemon-o:before {
                  content: "\f094";
                }
                .bk-fa-phone:before {
                  content: "\f095";
                }
                .bk-fa-square-o:before {
                  content: "\f096";
                }
                .bk-fa-bookmark-o:before {
                  content: "\f097";
                }
                .bk-fa-phone-square:before {
                  content: "\f098";
                }
                .bk-fa-twitter:before {
                  content: "\f099";
                }
                .bk-fa-facebook:before {
                  content: "\f09a";
                }
                .bk-fa-github:before {
                  content: "\f09b";
                }
                .bk-fa-unlock:before {
                  content: "\f09c";
                }
                .bk-fa-credit-card:before {
                  content: "\f09d";
                }
                .bk-fa-rss:before {
                  content: "\f09e";
                }
                .bk-fa-hdd-o:before {
                  content: "\f0a0";
                }
                .bk-fa-bullhorn:before {
                  content: "\f0a1";
                }
                .bk-fa-bell:before {
                  content: "\f0f3";
                }
                .bk-fa-certificate:before {
                  content: "\f0a3";
                }
                .bk-fa-hand-o-right:before {
                  content: "\f0a4";
                }
                .bk-fa-hand-o-left:before {
                  content: "\f0a5";
                }
                .bk-fa-hand-o-up:before {
                  content: "\f0a6";
                }
                .bk-fa-hand-o-down:before {
                  content: "\f0a7";
                }
                .bk-fa-arrow-circle-left:before {
                  content: "\f0a8";
                }
                .bk-fa-arrow-circle-right:before {
                  content: "\f0a9";
                }
                .bk-fa-arrow-circle-up:before {
                  content: "\f0aa";
                }
                .bk-fa-arrow-circle-down:before {
                  content: "\f0ab";
                }
                .bk-fa-globe:before {
                  content: "\f0ac";
                }
                .bk-fa-wrench:before {
                  content: "\f0ad";
                }
                .bk-fa-tasks:before {
                  content: "\f0ae";
                }
                .bk-fa-filter:before {
                  content: "\f0b0";
                }
                .bk-fa-briefcase:before {
                  content: "\f0b1";
                }
                .bk-fa-arrows-alt:before {
                  content: "\f0b2";
                }
                .bk-fa-group:before,
                .bk-fa-users:before {
                  content: "\f0c0";
                }
                .bk-fa-chain:before,
                .bk-fa-link:before {
                  content: "\f0c1";
                }
                .bk-fa-cloud:before {
                  content: "\f0c2";
                }
                .bk-fa-flask:before {
                  content: "\f0c3";
                }
                .bk-fa-cut:before,
                .bk-fa-scissors:before {
                  content: "\f0c4";
                }
                .bk-fa-copy:before,
                .bk-fa-files-o:before {
                  content: "\f0c5";
                }
                .bk-fa-paperclip:before {
                  content: "\f0c6";
                }
                .bk-fa-save:before,
                .bk-fa-floppy-o:before {
                  content: "\f0c7";
                }
                .bk-fa-square:before {
                  content: "\f0c8";
                }
                .bk-fa-navicon:before,
                .bk-fa-reorder:before,
                .bk-fa-bars:before {
                  content: "\f0c9";
                }
                .bk-fa-list-ul:before {
                  content: "\f0ca";
                }
                .bk-fa-list-ol:before {
                  content: "\f0cb";
                }
                .bk-fa-strikethrough:before {
                  content: "\f0cc";
                }
                .bk-fa-underline:before {
                  content: "\f0cd";
                }
                .bk-fa-table:before {
                  content: "\f0ce";
                }
                .bk-fa-magic:before {
                  content: "\f0d0";
                }
                .bk-fa-truck:before {
                  content: "\f0d1";
                }
                .bk-fa-pinterest:before {
                  content: "\f0d2";
                }
                .bk-fa-pinterest-square:before {
                  content: "\f0d3";
                }
                .bk-fa-google-plus-square:before {
                  content: "\f0d4";
                }
                .bk-fa-google-plus:before {
                  content: "\f0d5";
                }
                .bk-fa-money:before {
                  content: "\f0d6";
                }
                .bk-fa-caret-down:before {
                  content: "\f0d7";
                }
                .bk-fa-caret-up:before {
                  content: "\f0d8";
                }
                .bk-fa-caret-left:before {
                  content: "\f0d9";
                }
                .bk-fa-caret-right:before {
                  content: "\f0da";
                }
                .bk-fa-columns:before {
                  content: "\f0db";
                }
                .bk-fa-unsorted:before,
                .bk-fa-sort:before {
                  content: "\f0dc";
                }
                .bk-fa-sort-down:before,
                .bk-fa-sort-desc:before {
                  content: "\f0dd";
                }
                .bk-fa-sort-up:before,
                .bk-fa-sort-asc:before {
                  content: "\f0de";
                }
                .bk-fa-envelope:before {
                  content: "\f0e0";
                }
                .bk-fa-linkedin:before {
                  content: "\f0e1";
                }
                .bk-fa-rotate-left:before,
                .bk-fa-undo:before {
                  content: "\f0e2";
                }
                .bk-fa-legal:before,
                .bk-fa-gavel:before {
                  content: "\f0e3";
                }
                .bk-fa-dashboard:before,
                .bk-fa-tachometer:before {
                  content: "\f0e4";
                }
                .bk-fa-comment-o:before {
                  content: "\f0e5";
                }
                .bk-fa-comments-o:before {
                  content: "\f0e6";
                }
                .bk-fa-flash:before,
                .bk-fa-bolt:before {
                  content: "\f0e7";
                }
                .bk-fa-sitemap:before {
                  content: "\f0e8";
                }
                .bk-fa-umbrella:before {
                  content: "\f0e9";
                }
                .bk-fa-paste:before,
                .bk-fa-clipboard:before {
                  content: "\f0ea";
                }
                .bk-fa-lightbulb-o:before {
                  content: "\f0eb";
                }
                .bk-fa-exchange:before {
                  content: "\f0ec";
                }
                .bk-fa-cloud-download:before {
                  content: "\f0ed";
                }
                .bk-fa-cloud-upload:before {
                  content: "\f0ee";
                }
                .bk-fa-user-md:before {
                  content: "\f0f0";
                }
                .bk-fa-stethoscope:before {
                  content: "\f0f1";
                }
                .bk-fa-suitcase:before {
                  content: "\f0f2";
                }
                .bk-fa-bell-o:before {
                  content: "\f0a2";
                }
                .bk-fa-coffee:before {
                  content: "\f0f4";
                }
                .bk-fa-cutlery:before {
                  content: "\f0f5";
                }
                .bk-fa-file-text-o:before {
                  content: "\f0f6";
                }
                .bk-fa-building-o:before {
                  content: "\f0f7";
                }
                .bk-fa-hospital-o:before {
                  content: "\f0f8";
                }
                .bk-fa-ambulance:before {
                  content: "\f0f9";
                }
                .bk-fa-medkit:before {
                  content: "\f0fa";
                }
                .bk-fa-fighter-jet:before {
                  content: "\f0fb";
                }
                .bk-fa-beer:before {
                  content: "\f0fc";
                }
                .bk-fa-h-square:before {
                  content: "\f0fd";
                }
                .bk-fa-plus-square:before {
                  content: "\f0fe";
                }
                .bk-fa-angle-double-left:before {
                  content: "\f100";
                }
                .bk-fa-angle-double-right:before {
                  content: "\f101";
                }
                .bk-fa-angle-double-up:before {
                  content: "\f102";
                }
                .bk-fa-angle-double-down:before {
                  content: "\f103";
                }
                .bk-fa-angle-left:before {
                  content: "\f104";
                }
                .bk-fa-angle-right:before {
                  content: "\f105";
                }
                .bk-fa-angle-up:before {
                  content: "\f106";
                }
                .bk-fa-angle-down:before {
                  content: "\f107";
                }
                .bk-fa-desktop:before {
                  content: "\f108";
                }
                .bk-fa-laptop:before {
                  content: "\f109";
                }
                .bk-fa-tablet:before {
                  content: "\f10a";
                }
                .bk-fa-mobile-phone:before,
                .bk-fa-mobile:before {
                  content: "\f10b";
                }
                .bk-fa-circle-o:before {
                  content: "\f10c";
                }
                .bk-fa-quote-left:before {
                  content: "\f10d";
                }
                .bk-fa-quote-right:before {
                  content: "\f10e";
                }
                .bk-fa-spinner:before {
                  content: "\f110";
                }
                .bk-fa-circle:before {
                  content: "\f111";
                }
                .bk-fa-mail-reply:before,
                .bk-fa-reply:before {
                  content: "\f112";
                }
                .bk-fa-github-alt:before {
                  content: "\f113";
                }
                .bk-fa-folder-o:before {
                  content: "\f114";
                }
                .bk-fa-folder-open-o:before {
                  content: "\f115";
                }
                .bk-fa-smile-o:before {
                  content: "\f118";
                }
                .bk-fa-frown-o:before {
                  content: "\f119";
                }
                .bk-fa-meh-o:before {
                  content: "\f11a";
                }
                .bk-fa-gamepad:before {
                  content: "\f11b";
                }
                .bk-fa-keyboard-o:before {
                  content: "\f11c";
                }
                .bk-fa-flag-o:before {
                  content: "\f11d";
                }
                .bk-fa-flag-checkered:before {
                  content: "\f11e";
                }
                .bk-fa-terminal:before {
                  content: "\f120";
                }
                .bk-fa-code:before {
                  content: "\f121";
                }
                .bk-fa-mail-reply-all:before,
                .bk-fa-reply-all:before {
                  content: "\f122";
                }
                .bk-fa-star-half-empty:before,
                .bk-fa-star-half-full:before,
                .bk-fa-star-half-o:before {
                  content: "\f123";
                }
                .bk-fa-location-arrow:before {
                  content: "\f124";
                }
                .bk-fa-crop:before {
                  content: "\f125";
                }
                .bk-fa-code-fork:before {
                  content: "\f126";
                }
                .bk-fa-unlink:before,
                .bk-fa-chain-broken:before {
                  content: "\f127";
                }
                .bk-fa-question:before {
                  content: "\f128";
                }
                .bk-fa-info:before {
                  content: "\f129";
                }
                .bk-fa-exclamation:before {
                  content: "\f12a";
                }
                .bk-fa-superscript:before {
                  content: "\f12b";
                }
                .bk-fa-subscript:before {
                  content: "\f12c";
                }
                .bk-fa-eraser:before {
                  content: "\f12d";
                }
                .bk-fa-puzzle-piece:before {
                  content: "\f12e";
                }
                .bk-fa-microphone:before {
                  content: "\f130";
                }
                .bk-fa-microphone-slash:before {
                  content: "\f131";
                }
                .bk-fa-shield:before {
                  content: "\f132";
                }
                .bk-fa-calendar-o:before {
                  content: "\f133";
                }
                .bk-fa-fire-extinguisher:before {
                  content: "\f134";
                }
                .bk-fa-rocket:before {
                  content: "\f135";
                }
                .bk-fa-maxcdn:before {
                  content: "\f136";
                }
                .bk-fa-chevron-circle-left:before {
                  content: "\f137";
                }
                .bk-fa-chevron-circle-right:before {
                  content: "\f138";
                }
                .bk-fa-chevron-circle-up:before {
                  content: "\f139";
                }
                .bk-fa-chevron-circle-down:before {
                  content: "\f13a";
                }
                .bk-fa-html5:before {
                  content: "\f13b";
                }
                .bk-fa-css3:before {
                  content: "\f13c";
                }
                .bk-fa-anchor:before {
                  content: "\f13d";
                }
                .bk-fa-unlock-alt:before {
                  content: "\f13e";
                }
                .bk-fa-bullseye:before {
                  content: "\f140";
                }
                .bk-fa-ellipsis-h:before {
                  content: "\f141";
                }
                .bk-fa-ellipsis-v:before {
                  content: "\f142";
                }
                .bk-fa-rss-square:before {
                  content: "\f143";
                }
                .bk-fa-play-circle:before {
                  content: "\f144";
                }
                .bk-fa-ticket:before {
                  content: "\f145";
                }
                .bk-fa-minus-square:before {
                  content: "\f146";
                }
                .bk-fa-minus-square-o:before {
                  content: "\f147";
                }
                .bk-fa-level-up:before {
                  content: "\f148";
                }
                .bk-fa-level-down:before {
                  content: "\f149";
                }
                .bk-fa-check-square:before {
                  content: "\f14a";
                }
                .bk-fa-pencil-square:before {
                  content: "\f14b";
                }
                .bk-fa-external-link-square:before {
                  content: "\f14c";
                }
                .bk-fa-share-square:before {
                  content: "\f14d";
                }
                .bk-fa-compass:before {
                  content: "\f14e";
                }
                .bk-fa-toggle-down:before,
                .bk-fa-caret-square-o-down:before {
                  content: "\f150";
                }
                .bk-fa-toggle-up:before,
                .bk-fa-caret-square-o-up:before {
                  content: "\f151";
                }
                .bk-fa-toggle-right:before,
                .bk-fa-caret-square-o-right:before {
                  content: "\f152";
                }
                .bk-fa-euro:before,
                .bk-fa-eur:before {
                  content: "\f153";
                }
                .bk-fa-gbp:before {
                  content: "\f154";
                }
                .bk-fa-dollar:before,
                .bk-fa-usd:before {
                  content: "\f155";
                }
                .bk-fa-rupee:before,
                .bk-fa-inr:before {
                  content: "\f156";
                }
                .bk-fa-cny:before,
                .bk-fa-rmb:before,
                .bk-fa-yen:before,
                .bk-fa-jpy:before {
                  content: "\f157";
                }
                .bk-fa-ruble:before,
                .bk-fa-rouble:before,
                .bk-fa-rub:before {
                  content: "\f158";
                }
                .bk-fa-won:before,
                .bk-fa-krw:before {
                  content: "\f159";
                }
                .bk-fa-bitcoin:before,
                .bk-fa-btc:before {
                  content: "\f15a";
                }
                .bk-fa-file:before {
                  content: "\f15b";
                }
                .bk-fa-file-text:before {
                  content: "\f15c";
                }
                .bk-fa-sort-alpha-asc:before {
                  content: "\f15d";
                }
                .bk-fa-sort-alpha-desc:before {
                  content: "\f15e";
                }
                .bk-fa-sort-amount-asc:before {
                  content: "\f160";
                }
                .bk-fa-sort-amount-desc:before {
                  content: "\f161";
                }
                .bk-fa-sort-numeric-asc:before {
                  content: "\f162";
                }
                .bk-fa-sort-numeric-desc:before {
                  content: "\f163";
                }
                .bk-fa-thumbs-up:before {
                  content: "\f164";
                }
                .bk-fa-thumbs-down:before {
                  content: "\f165";
                }
                .bk-fa-youtube-square:before {
                  content: "\f166";
                }
                .bk-fa-youtube:before {
                  content: "\f167";
                }
                .bk-fa-xing:before {
                  content: "\f168";
                }
                .bk-fa-xing-square:before {
                  content: "\f169";
                }
                .bk-fa-youtube-play:before {
                  content: "\f16a";
                }
                .bk-fa-dropbox:before {
                  content: "\f16b";
                }
                .bk-fa-stack-overflow:before {
                  content: "\f16c";
                }
                .bk-fa-instagram:before {
                  content: "\f16d";
                }
                .bk-fa-flickr:before {
                  content: "\f16e";
                }
                .bk-fa-adn:before {
                  content: "\f170";
                }
                .bk-fa-bitbucket:before {
                  content: "\f171";
                }
                .bk-fa-bitbucket-square:before {
                  content: "\f172";
                }
                .bk-fa-tumblr:before {
                  content: "\f173";
                }
                .bk-fa-tumblr-square:before {
                  content: "\f174";
                }
                .bk-fa-long-arrow-down:before {
                  content: "\f175";
                }
                .bk-fa-long-arrow-up:before {
                  content: "\f176";
                }
                .bk-fa-long-arrow-left:before {
                  content: "\f177";
                }
                .bk-fa-long-arrow-right:before {
                  content: "\f178";
                }
                .bk-fa-apple:before {
                  content: "\f179";
                }
                .bk-fa-windows:before {
                  content: "\f17a";
                }
                .bk-fa-android:before {
                  content: "\f17b";
                }
                .bk-fa-linux:before {
                  content: "\f17c";
                }
                .bk-fa-dribbble:before {
                  content: "\f17d";
                }
                .bk-fa-skype:before {
                  content: "\f17e";
                }
                .bk-fa-foursquare:before {
                  content: "\f180";
                }
                .bk-fa-trello:before {
                  content: "\f181";
                }
                .bk-fa-female:before {
                  content: "\f182";
                }
                .bk-fa-male:before {
                  content: "\f183";
                }
                .bk-fa-gittip:before {
                  content: "\f184";
                }
                .bk-fa-sun-o:before {
                  content: "\f185";
                }
                .bk-fa-moon-o:before {
                  content: "\f186";
                }
                .bk-fa-archive:before {
                  content: "\f187";
                }
                .bk-fa-bug:before {
                  content: "\f188";
                }
                .bk-fa-vk:before {
                  content: "\f189";
                }
                .bk-fa-weibo:before {
                  content: "\f18a";
                }
                .bk-fa-renren:before {
                  content: "\f18b";
                }
                .bk-fa-pagelines:before {
                  content: "\f18c";
                }
                .bk-fa-stack-exchange:before {
                  content: "\f18d";
                }
                .bk-fa-arrow-circle-o-right:before {
                  content: "\f18e";
                }
                .bk-fa-arrow-circle-o-left:before {
                  content: "\f190";
                }
                .bk-fa-toggle-left:before,
                .bk-fa-caret-square-o-left:before {
                  content: "\f191";
                }
                .bk-fa-dot-circle-o:before {
                  content: "\f192";
                }
                .bk-fa-wheelchair:before {
                  content: "\f193";
                }
                .bk-fa-vimeo-square:before {
                  content: "\f194";
                }
                .bk-fa-turkish-lira:before,
                .bk-fa-try:before {
                  content: "\f195";
                }
                .bk-fa-plus-square-o:before {
                  content: "\f196";
                }
                .bk-fa-space-shuttle:before {
                  content: "\f197";
                }
                .bk-fa-slack:before {
                  content: "\f198";
                }
                .bk-fa-envelope-square:before {
                  content: "\f199";
                }
                .bk-fa-wordpress:before {
                  content: "\f19a";
                }
                .bk-fa-openid:before {
                  content: "\f19b";
                }
                .bk-fa-institution:before,
                .bk-fa-bank:before,
                .bk-fa-university:before {
                  content: "\f19c";
                }
                .bk-fa-mortar-board:before,
                .bk-fa-graduation-cap:before {
                  content: "\f19d";
                }
                .bk-fa-yahoo:before {
                  content: "\f19e";
                }
                .bk-fa-google:before {
                  content: "\f1a0";
                }
                .bk-fa-reddit:before {
                  content: "\f1a1";
                }
                .bk-fa-reddit-square:before {
                  content: "\f1a2";
                }
                .bk-fa-stumbleupon-circle:before {
                  content: "\f1a3";
                }
                .bk-fa-stumbleupon:before {
                  content: "\f1a4";
                }
                .bk-fa-delicious:before {
                  content: "\f1a5";
                }
                .bk-fa-digg:before {
                  content: "\f1a6";
                }
                .bk-fa-pied-piper:before {
                  content: "\f1a7";
                }
                .bk-fa-pied-piper-alt:before {
                  content: "\f1a8";
                }
                .bk-fa-drupal:before {
                  content: "\f1a9";
                }
                .bk-fa-joomla:before {
                  content: "\f1aa";
                }
                .bk-fa-language:before {
                  content: "\f1ab";
                }
                .bk-fa-fax:before {
                  content: "\f1ac";
                }
                .bk-fa-building:before {
                  content: "\f1ad";
                }
                .bk-fa-child:before {
                  content: "\f1ae";
                }
                .bk-fa-paw:before {
                  content: "\f1b0";
                }
                .bk-fa-spoon:before {
                  content: "\f1b1";
                }
                .bk-fa-cube:before {
                  content: "\f1b2";
                }
                .bk-fa-cubes:before {
                  content: "\f1b3";
                }
                .bk-fa-behance:before {
                  content: "\f1b4";
                }
                .bk-fa-behance-square:before {
                  content: "\f1b5";
                }
                .bk-fa-steam:before {
                  content: "\f1b6";
                }
                .bk-fa-steam-square:before {
                  content: "\f1b7";
                }
                .bk-fa-recycle:before {
                  content: "\f1b8";
                }
                .bk-fa-automobile:before,
                .bk-fa-car:before {
                  content: "\f1b9";
                }
                .bk-fa-cab:before,
                .bk-fa-taxi:before {
                  content: "\f1ba";
                }
                .bk-fa-tree:before {
                  content: "\f1bb";
                }
                .bk-fa-spotify:before {
                  content: "\f1bc";
                }
                .bk-fa-deviantart:before {
                  content: "\f1bd";
                }
                .bk-fa-soundcloud:before {
                  content: "\f1be";
                }
                .bk-fa-database:before {
                  content: "\f1c0";
                }
                .bk-fa-file-pdf-o:before {
                  content: "\f1c1";
                }
                .bk-fa-file-word-o:before {
                  content: "\f1c2";
                }
                .bk-fa-file-excel-o:before {
                  content: "\f1c3";
                }
                .bk-fa-file-powerpoint-o:before {
                  content: "\f1c4";
                }
                .bk-fa-file-photo-o:before,
                .bk-fa-file-picture-o:before,
                .bk-fa-file-image-o:before {
                  content: "\f1c5";
                }
                .bk-fa-file-zip-o:before,
                .bk-fa-file-archive-o:before {
                  content: "\f1c6";
                }
                .bk-fa-file-sound-o:before,
                .bk-fa-file-audio-o:before {
                  content: "\f1c7";
                }
                .bk-fa-file-movie-o:before,
                .bk-fa-file-video-o:before {
                  content: "\f1c8";
                }
                .bk-fa-file-code-o:before {
                  content: "\f1c9";
                }
                .bk-fa-vine:before {
                  content: "\f1ca";
                }
                .bk-fa-codepen:before {
                  content: "\f1cb";
                }
                .bk-fa-jsfiddle:before {
                  content: "\f1cc";
                }
                .bk-fa-life-bouy:before,
                .bk-fa-life-buoy:before,
                .bk-fa-life-saver:before,
                .bk-fa-support:before,
                .bk-fa-life-ring:before {
                  content: "\f1cd";
                }
                .bk-fa-circle-o-notch:before {
                  content: "\f1ce";
                }
                .bk-fa-ra:before,
                .bk-fa-rebel:before {
                  content: "\f1d0";
                }
                .bk-fa-ge:before,
                .bk-fa-empire:before {
                  content: "\f1d1";
                }
                .bk-fa-git-square:before {
                  content: "\f1d2";
                }
                .bk-fa-git:before {
                  content: "\f1d3";
                }
                .bk-fa-hacker-news:before {
                  content: "\f1d4";
                }
                .bk-fa-tencent-weibo:before {
                  content: "\f1d5";
                }
                .bk-fa-qq:before {
                  content: "\f1d6";
                }
                .bk-fa-wechat:before,
                .bk-fa-weixin:before {
                  content: "\f1d7";
                }
                .bk-fa-send:before,
                .bk-fa-paper-plane:before {
                  content: "\f1d8";
                }
                .bk-fa-send-o:before,
                .bk-fa-paper-plane-o:before {
                  content: "\f1d9";
                }
                .bk-fa-history:before {
                  content: "\f1da";
                }
                .bk-fa-circle-thin:before {
                  content: "\f1db";
                }
                .bk-fa-header:before {
                  content: "\f1dc";
                }
                .bk-fa-paragraph:before {
                  content: "\f1dd";
                }
                .bk-fa-sliders:before {
                  content: "\f1de";
                }
                .bk-fa-share-alt:before {
                  content: "\f1e0";
                }
                .bk-fa-share-alt-square:before {
                  content: "\f1e1";
                }
                .bk-fa-bomb:before {
                  content: "\f1e2";
                }
                .bk-fa-soccer-ball-o:before,
                .bk-fa-futbol-o:before {
                  content: "\f1e3";
                }
                .bk-fa-tty:before {
                  content: "\f1e4";
                }
                .bk-fa-binoculars:before {
                  content: "\f1e5";
                }
                .bk-fa-plug:before {
                  content: "\f1e6";
                }
                .bk-fa-slideshare:before {
                  content: "\f1e7";
                }
                .bk-fa-twitch:before {
                  content: "\f1e8";
                }
                .bk-fa-yelp:before {
                  content: "\f1e9";
                }
                .bk-fa-newspaper-o:before {
                  content: "\f1ea";
                }
                .bk-fa-wifi:before {
                  content: "\f1eb";
                }
                .bk-fa-calculator:before {
                  content: "\f1ec";
                }
                .bk-fa-paypal:before {
                  content: "\f1ed";
                }
                .bk-fa-google-wallet:before {
                  content: "\f1ee";
                }
                .bk-fa-cc-visa:before {
                  content: "\f1f0";
                }
                .bk-fa-cc-mastercard:before {
                  content: "\f1f1";
                }
                .bk-fa-cc-discover:before {
                  content: "\f1f2";
                }
                .bk-fa-cc-amex:before {
                  content: "\f1f3";
                }
                .bk-fa-cc-paypal:before {
                  content: "\f1f4";
                }
                .bk-fa-cc-stripe:before {
                  content: "\f1f5";
                }
                .bk-fa-bell-slash:before {
                  content: "\f1f6";
                }
                .bk-fa-bell-slash-o:before {
                  content: "\f1f7";
                }
                .bk-fa-trash:before {
                  content: "\f1f8";
                }
                .bk-fa-copyright:before {
                  content: "\f1f9";
                }
                .bk-fa-at:before {
                  content: "\f1fa";
                }
                .bk-fa-eyedropper:before {
                  content: "\f1fb";
                }
                .bk-fa-paint-brush:before {
                  content: "\f1fc";
                }
                .bk-fa-birthday-cake:before {
                  content: "\f1fd";
                }
                .bk-fa-area-chart:before {
                  content: "\f1fe";
                }
                .bk-fa-pie-chart:before {
                  content: "\f200";
                }
                .bk-fa-line-chart:before {
                  content: "\f201";
                }
                .bk-fa-lastfm:before {
                  content: "\f202";
                }
                .bk-fa-lastfm-square:before {
                  content: "\f203";
                }
                .bk-fa-toggle-off:before {
                  content: "\f204";
                }
                .bk-fa-toggle-on:before {
                  content: "\f205";
                }
                .bk-fa-bicycle:before {
                  content: "\f206";
                }
                .bk-fa-bus:before {
                  content: "\f207";
                }
                .bk-fa-ioxhost:before {
                  content: "\f208";
                }
                .bk-fa-angellist:before {
                  content: "\f209";
                }
                .bk-fa-cc:before {
                  content: "\f20a";
                }
                .bk-fa-shekel:before,
                .bk-fa-sheqel:before,
                .bk-fa-ils:before {
                  content: "\f20b";
                }
                .bk-fa-meanpath:before {
                  content: "\f20c";
                }
                .bk-pivot {
                  font-family: arial;
                  font-size: 8pt;
                }
                .bk-wait {
                  font-weight: bold;
                  font-size: 18px;
                }
                .bk-pivot-toolbox {
                  min-width: 200px;
                  width: 250px;
                }
                .bk-pivot-toolbox ul {
                  padding: 0;
                }
                .bk-pivot-toolbox li {
                  padding: 5px;
                  list-style-type: none;
                }
                .bk-pivot-toolbox li:before,
                .bk-pivot-toolbox li:after {
                  content: " ";
                  display: table;
                }
                .bk-pivot-toolbox li:after {
                  clear: both;
                }
                .bk-pivot-toolbox li:before,
                .bk-pivot-toolbox li:after {
                  content: " ";
                  display: table;
                }
                .bk-pivot-toolbox li:after {
                  clear: both;
                }
                .bk-pivot-toolbox .bk-pivot-box {
                  border: 1px solid #cccccc;
                  border-radius: 5px;
                  margin-top: 5px;
                  background-color: white;
                }
                .bk-pivot-toolbox .bk-pivot-box > li:first-child {
                  background-color: #e6e6e6;
                }
                .bk-pivot-toolbox .bk-pivot-box .bk-pivot-box-header {
                  cursor: move;
                }
                .bk-pivot-toolbox .bk-pivot-box .bk-pivot-box-header .bk-field {
                  font-weight: bold;
                }
                .bk-pivot-toolbox .bk-pivot-box .bk-pivot-box-header .bk-dtype {
                  color: #999999;
                }
                .bk-pivot-toolbox .bk-pivot-box .bk-pivot-box-header .bk-bs-close {
                  font-size: 16px;
                }
                table.pvtTable {
                  text-align: left;
                  border-collapse: collapse;
                }
                table.pvtTable tr th {
                  background-color: #e6e6e6;
                  border: 1px solid #cccccc;
                  font-size: 8pt;
                  padding: 5px;
                }
                table.pvtTable .pvtColLabel {
                  text-align: center;
                }
                table.pvtTable .pvtTotalLabel {
                  text-align: right;
                }
                table.pvtTable tr td {
                  padding: 5px;
                  border: 1px solid #cccccc;
                  vertical-align: top;
                  text-align: right;
                }
                .pvtTotal,
                .pvtGrandTotal {
                  font-weight: bold;
                }
                .bk-hbox {
                  display: -webkit-box;
                  -webkit-box-orient: horizontal;
                  -webkit-box-align: stretch;
                  display: -moz-box;
                  -moz-box-orient: horizontal;
                  -moz-box-align: stretch;
                  display: box;
                  box-orient: horizontal;
                  box-align: stretch;
                }
                .bk-vbox {
                  display: -webkit-box;
                  -webkit-box-orient: vertical;
                  -webkit-box-align: stretch;
                  display: -moz-box;
                  -moz-box-orient: vertical;
                  -moz-box-align: stretch;
                  display: box;
                  box-orient: vertical;
                  box-align: stretch;
                  /* width must be 100% to force FF to behave like webkit */
                  width: 100%;
                  width: auto;
                }
                .bk-widget-form {
                  padding: 30px 30px 30px 30px;
                  overflow: hidden;
                }
                .bk-widget-form-group {
                  margin-bottom: 15px;
                }
                .bk-widget-form-input {
                  display: block;
                  width: 100%;
                  height: 34px;
                  padding: 6px 12px;
                  font-size: 14px;
                  line-height: 1.42857143;
                  color: #555555;
                  background-color: #ffffff;
                  background-image: none;
                  border: 1px solid #cccccc;
                  border-radius: 4px;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
                  -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
                  transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
                }
                .bk-widget-form-input:focus {
                  border-color: #66afe9;
                  outline: 0;
                  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
                  box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
                }
                .bk-widget-form-input::-moz-placeholder {
                  color: #999999;
                  opacity: 1;
                }
                .bk-widget-form-input:-ms-input-placeholder {
                  color: #999999;
                }
                .bk-widget-form-input::-webkit-input-placeholder {
                  color: #999999;
                }
                .bk-widget-form-input[disabled],
                .bk-widget-form-input[readonly],
                fieldset[disabled] .bk-widget-form-input {
                  cursor: not-allowed;
                  background-color: #eeeeee;
                  opacity: 1;
                }
                textarea.bk-widget-form-input {
                  height: auto;
                }
                .bk-slider-horizontal {
                  width: 100%;
                  height: 50px;
                  min-width: 200px;
                }
                .bk-slider-vertical {
                  height: 100%;
                  width: 50px;
                  min-height: 200px;
                }
                .bk-crossfilter-row {
                  margin-left: -15px;
                  margin-right: -15px;
                  height: 100%;
                  width: 100%;
                  margin: 0;
                }
                .bk-crossfilter-panel-heading {
                  padding-top: 5px;
                  padding-bottom: 5px;
                }
                .bk-crossfilter-panel-continuous-heading {
                  background-color: #396285 !important;
                }
                .bk-crossfilter-panel-factor-heading {
                  background-color: #CE603D !important;
                }
                .aligntable {
                  vertical-align: top;
                }
                .bk-crossfilter-container {
                  height: 100%;
                  width: 100%;
                  whitespace: nowrap;
                  display: inline-block;
                  overflow: auto;
                }
                .bk-crossfilter-configuration {
                  overflow: auto;
                  float: left;
                  padding-right: 0 !important;
                  padding-left: 15px !important;
                  margin-left: 0 !important;
                  margin-right: 0 !important;
                }
                .bk-crossfilter-configuration .bk-bs-panel-body {
                  padding: 0 !important;
                }
                .bk-column-list {
                  overflow-y: auto;
                  height: 100%;
                  padding-right: 0;
                  padding-left: 0;
                }
                .bk-table {
                  width: 100%;
                  margin-bottom: 20px;
                  border-top: none;
                  margin-bottom: 0;
                  text-align: left;
                }
                .bk-table > thead > tr > th,
                .bk-table > tbody > tr > th,
                .bk-table > tfoot > tr > th,
                .bk-table > thead > tr > td,
                .bk-table > tbody > tr > td,
                .bk-table > tfoot > tr > td {
                  padding: 8px;
                  line-height: 1.42857143;
                  vertical-align: top;
                  border-top: 1px solid #dddddd;
                }
                .bk-table > thead > tr > th {
                  vertical-align: bottom;
                  border-bottom: 2px solid #dddddd;
                }
                .bk-table > caption + thead > tr:first-child > th,
                .bk-table > colgroup + thead > tr:first-child > th,
                .bk-table > thead:first-child > tr:first-child > th,
                .bk-table > caption + thead > tr:first-child > td,
                .bk-table > colgroup + thead > tr:first-child > td,
                .bk-table > thead:first-child > tr:first-child > td {
                  border-top: 0;
                }
                .bk-table > tbody + tbody {
                  border-top: 2px solid #dddddd;
                }
                .bk-table .bk-bs-table {
                  background-color: #ffffff;
                }
                .bk-table > thead > tr > th,
                .bk-table > tbody > tr > th,
                .bk-table > tfoot > tr > th,
                .bk-table > thead > tr > td,
                .bk-table > tbody > tr > td,
                .bk-table > tfoot > tr > td {
                  padding: 5px;
                }
                .bk-table tr:nth-child(odd) {
                  background: #efefef;
                }
                .bk-table tr td {
                  padding: 1px 5px !important;
                  border: none !important;
                }
                .bk-filters-facets {
                  height: 100%;
                  padding-left: 0;
                  padding-right: 0;
                }
                .bk-filters {
                  height: 45%;
                  overflow: hidden;
                  position: relative;
                }
                .bk-filters-selections {
                  position: absolute;
                  top: 30px;
                  left: 0;
                  right: 0;
                  bottom: 0;
                  overflow-y: auto;
                  padding-top: 0;
                  padding-bottom: 0;
                  padding: 5px !important;
                }
                .bk-facet {
                  height: 14%;
                  position: relative;
                }
                .bk-facets-selections {
                  position: absolute;
                  top: 30px;
                  left: 0;
                  right: 0;
                  bottom: 0;
                }
                .bk-plot-selection {
                  padding-right: 0;
                  padding-left: 0;
                }
                .bk-plot {
                  float: left;
                  display: inline-block;
                }
                .bk-facet-label {
                  display: inline;
                  padding: .2em .6em .3em;
                  font-size: 75%;
                  font-weight: bold;
                  line-height: 1;
                  color: #ffffff;
                  text-align: center;
                  white-space: nowrap;
                  vertical-align: baseline;
                  border-radius: .25em;
                  background-color: #5bc0de;
                  margin-left: 5px;
                  display: inline-block;
                  cursor: pointer;
                }
                .bk-facet-label[href]:hover,
                .bk-facet-label[href]:focus {
                  color: #ffffff;
                  text-decoration: none;
                  cursor: pointer;
                }
                .bk-facet-label:empty {
                  display: none;
                }
                .bk-bs-btn .bk-facet-label {
                  position: relative;
                  top: -1px;
                }
                .bk-facet-label[href]:hover,
                .bk-facet-label[href]:focus {
                  background-color: #31b0d5;
                }
                .bk-filters-selections .bk-sidebar {
                  -webkit-transform: scale(0.5, 0.5) !important;
                  transform: scale(0.5, 0.5) !important;
                }
                .bk-crossfilter .bk-widget-form {
                  padding: 5px;
                }
                .ui-dialog-titlebar {
                  height: 16px;
                }
                .bk-button-bar {
                  margin-top: 0;
                  margin-bottom: 0;
                  padding-top: 0;
                  padding-bottom: 2px;
                  position: relative;
                  display: inline-block;
                  vertical-align: middle;
                }
                .bk-button-bar > .bk-bs-btn {
                  position: relative;
                  float: left;
                }
                .bk-button-bar > .bk-bs-btn:hover,
                .bk-button-bar > .bk-bs-btn:focus,
                .bk-button-bar > .bk-bs-btn:active,
                .bk-button-bar > .bk-bs-btn.bk-bs-active {
                  z-index: 2;
                }
                .bk-button-bar > .bk-bs-btn:focus {
                  outline: none;
                }
                .bk-button-bar .bk-bs-btn + .bk-bs-btn,
                .bk-button-bar .bk-bs-btn + .bk-bs-btn-group,
                .bk-button-bar .bk-bs-btn-group + .bk-bs-btn,
                .bk-button-bar .bk-bs-btn-group + .bk-bs-btn-group {
                  margin-left: -1px;
                }
                .bk-toolbar-button {
                  display: inline-block;
                  margin-bottom: 0;
                  font-weight: normal;
                  text-align: center;
                  vertical-align: middle;
                  cursor: pointer;
                  background-image: none;
                  border: 1px solid transparent;
                  white-space: nowrap;
                  padding: 6px 12px;
                  font-size: 14px;
                  line-height: 1.42857143;
                  border-radius: 4px;
                  -webkit-user-select: none;
                  -moz-user-select: none;
                  -ms-user-select: none;
                  user-select: none;
                  padding: 5px 10px;
                  font-size: 12px;
                  line-height: 1.5;
                  border-radius: 3px;
                  color: #333333;
                  background-color: #ffffff;
                  border-color: #cccccc;
                }
                .bk-toolbar-button:focus,
                .bk-toolbar-button:active:focus,
                .bk-toolbar-button.bk-bs-active:focus {
                  outline: thin dotted;
                  outline: 5px auto -webkit-focus-ring-color;
                  outline-offset: -2px;
                }
                .bk-toolbar-button:hover,
                .bk-toolbar-button:focus {
                  color: #333333;
                  text-decoration: none;
                }
                .bk-toolbar-button:active,
                .bk-toolbar-button.bk-bs-active {
                  outline: 0;
                  background-image: none;
                  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                }
                .bk-toolbar-button.bk-bs-disabled,
                .bk-toolbar-button[disabled],
                fieldset[disabled] .bk-toolbar-button {
                  cursor: not-allowed;
                  pointer-events: none;
                  opacity: 0.65;
                  filter: alpha(opacity=65);
                  -webkit-box-shadow: none;
                  box-shadow: none;
                }
                .bk-toolbar-button:hover,
                .bk-toolbar-button:focus,
                .bk-toolbar-button:active,
                .bk-toolbar-button.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-toolbar-button {
                  color: #333333;
                  background-color: #ebebeb;
                  border-color: #adadad;
                }
                .bk-toolbar-button:active,
                .bk-toolbar-button.bk-bs-active,
                .bk-bs-open .bk-bs-dropdown-toggle.bk-toolbar-button {
                  background-image: none;
                }
                .bk-toolbar-button.bk-bs-disabled,
                .bk-toolbar-button[disabled],
                fieldset[disabled] .bk-toolbar-button,
                .bk-toolbar-button.bk-bs-disabled:hover,
                .bk-toolbar-button[disabled]:hover,
                fieldset[disabled] .bk-toolbar-button:hover,
                .bk-toolbar-button.bk-bs-disabled:focus,
                .bk-toolbar-button[disabled]:focus,
                fieldset[disabled] .bk-toolbar-button:focus,
                .bk-toolbar-button.bk-bs-disabled:active,
                .bk-toolbar-button[disabled]:active,
                fieldset[disabled] .bk-toolbar-button:active,
                .bk-toolbar-button.bk-bs-disabled.bk-bs-active,
                .bk-toolbar-button[disabled].bk-bs-active,
                fieldset[disabled] .bk-toolbar-button.bk-bs-active {
                  background-color: #ffffff;
                  border-color: #cccccc;
                }
                .bk-toolbar-button .bk-bs-badge {
                  color: #ffffff;
                  background-color: #333333;
                }
                .bk-canvas-wrapper {
                  position: relative;
                  font-size: 12pt;
                  float: left;
                }
                .bk-canvas {
                  clear: both;
                  position: absolute;
                  font-size: 12pt;
                }
                .bk-canvas-wrapper .bk-canvas-map {
                  position: absolute !important;
                  z-index: -5;
                }
                .bk-tooltip.left::before {
                  position: absolute;
                  top: 40%;
                  width: 0;
                  height: 0;
                  left: -9px;
                  border-style: solid;
                  border-width: 7px 10px 7px 0;
                  border-color: transparent #1e4B6c transparent transparent;
                  content: " ";
                  display: block;
                }
                .bk-tooltip.right::after {
                  position: absolute;
                  top: 40%;
                  width: 0;
                  height: 0;
                  right: -9px;
                  border-style: solid;
                  border-width: 7px 0 7px 10px;
                  border-color: transparent transparent transparent #1e4B6c;
                  content: " ";
                  display: block;
                }
                .bk-tooltip {
                  position: absolute;
                  padding: 5px;
                  background-color: #1e4B6c;
                  border-radius: 10px;
                  pointer-events: none;
                }
                .bk-tooltip-row-label {
                  color: #9ab9b1;
                  font-family: Helvetica, sans-serif;
                  text-align: right;
                }
                .bk-tooltip-row-value {
                  color: #e2ddbd;
                  font-family: Helvetica, sans-serif;
                }
                .bk-tooltip-color-block {
                  width: 12px;
                  height: 12px;
                  margin-left: 5px;
                  margin-right: 5px;
                  outline: #dddddd solid 1px;
                  display: inline-block;
                }
                .bk-canvas-map {
                  position: absolute;
                  border: 0;
                  z-index: -5;
                }
                .shading {
                  position: absolute;
                  display: block;
                  border: 1px dashed green;
                  z-index: 100;
                }
                .gridplot_container {
                  position: relative;
                }
                .gridplot_container .gp_plotwrapper {
                  position: absolute;
                }
                .table_wrap table {
                  display: block;
                  margin: 5px;
                  height: 300px;
                  overflow-y: scroll;
                }
                .plot_wrap .button_bar {
                  height: 30px;
                }
                .plot_wrap .button_bar * {
                  display: none;
                }
                .plot_wrap:hover .button_bar * {
                  display: inherit;
                }
                .maximize {
                  display: none;
                  float: right;
                }
                .plotclose {
                  float: right;
                }
                .plotsidebar {
                  float: left;
                  width: 350px;
                  overflow-x: auto;
                }
                .maxplot {
                  float: left;
                }
                .bk-table {
                  overflow: auto;
                }
                .pandassize,
                .pandasoffset {
                  width: 30px !important;
                  height: 20px !important;
                  padding: 1px !important;
                }
                .pandasicons {
                  position: relative;
                  top: 5px;
                }
                .bokehdocheading {
                  background-color: #ccc;
                }
                .bokehdocheading:hover > .bokehdelete {
                  display: none;
                  float: right;
                }
                .bokehdelete {
                  float: right;
                }
                .pandasgroup {
                  width: auto;
                  height: 20px !important;
                  padding: 1px !important;
                }
                .pandasagg {
                  width: auto;
                  height: 20px !important;
                  padding: 1px !important;
                }
                .tablecontrolstate {
                  width: auto;
                  height: 20px !important;
                  padding: 1px !important;
                }
                .paginatedisplay {
                  overflow: hidden;
                }
                .pagination {
                  margin: 0 !important;
                }
                .tablecontrolform {
                  margin: 0;
                }
                .computedtxtbox,
                .computedname,
                .search {
                  height: 20px !important;
                  padding: 1px !important;
                }
                .plottitle {
                  padding-left: 50px;
                  padding-bottom: 10px;
                }
                .maxlabel,
                .minlabel {
                  margin-top: 10px;
                  margin-bottom: 10px;
                }
                
                /* END /Users/bucci/anaconda/lib/python2.7/site-packages/bokeh/server/static/css/bokeh.css */
        </style>
        <script type="text/javascript">
            /* BEGIN /Users/bucci/anaconda/lib/python2.7/site-packages/bokeh/server/static/js/bokeh.js */
                (function (root, factory) {
                  root.Bokeh = factory();
                }(this, function () {
                  //almond, and your modules will be inlined here
                
                /**
                 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
                 * Available via the MIT or new BSD license.
                 * see: http://github.com/jrburke/almond for details
                 */
                //Going sloppy to avoid 'use strict' string cost, but strict practices should
                //be followed.
                /*jslint sloppy: true */
                /*global setTimeout: false */
                
                var requirejs, require, define;
                (function (undef) {
                    var main, req, makeMap, handlers,
                        defined = {},
                        waiting = {},
                        config = {},
                        defining = {},
                        hasOwn = Object.prototype.hasOwnProperty,
                        aps = [].slice,
                        jsSuffixRegExp = /\.js$/;
                
                    function hasProp(obj, prop) {
                        return hasOwn.call(obj, prop);
                    }
                
                    /**
                     * Given a relative module name, like ./something, normalize it to
                     * a real name that can be mapped to a path.
                     * @param {String} name the relative name
                     * @param {String} baseName a real name that the name arg is relative
                     * to.
                     * @returns {String} normalized name
                     */
                    function normalize(name, baseName) {
                        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
                            foundI, foundStarMap, starI, i, j, part,
                            baseParts = baseName && baseName.split("/"),
                            map = config.map,
                            starMap = (map && map['*']) || {};
                
                        //Adjust any relative paths.
                        if (name && name.charAt(0) === ".") {
                            //If have a base name, try to normalize against it,
                            //otherwise, assume it is a top-level require that will
                            //be relative to baseUrl in the end.
                            if (baseName) {
                                //Convert baseName to array, and lop off the last part,
                                //so that . matches that "directory" and not name of the baseName's
                                //module. For instance, baseName of "one/two/three", maps to
                                //"one/two/three.js", but we want the directory, "one/two" for
                                //this normalization.
                                baseParts = baseParts.slice(0, baseParts.length - 1);
                                name = name.split('/');
                                lastIndex = name.length - 1;
                
                                // Node .js allowance:
                                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                                }
                
                                name = baseParts.concat(name);
                
                                //start trimDots
                                for (i = 0; i < name.length; i += 1) {
                                    part = name[i];
                                    if (part === ".") {
                                        name.splice(i, 1);
                                        i -= 1;
                                    } else if (part === "..") {
                                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                                            //End of the line. Keep at least one non-dot
                                            //path segment at the front so it can be mapped
                                            //correctly to disk. Otherwise, there is likely
                                            //no path mapping for a path starting with '..'.
                                            //This can still fail, but catches the most reasonable
                                            //uses of ..
                                            break;
                                        } else if (i > 0) {
                                            name.splice(i - 1, 2);
                                            i -= 2;
                                        }
                                    }
                                }
                                //end trimDots
                
                                name = name.join("/");
                            } else if (name.indexOf('./') === 0) {
                                // No baseName, so this is ID is resolved relative
                                // to baseUrl, pull off the leading dot.
                                name = name.substring(2);
                            }
                        }
                
                        //Apply map config if available.
                        if ((baseParts || starMap) && map) {
                            nameParts = name.split('/');
                
                            for (i = nameParts.length; i > 0; i -= 1) {
                                nameSegment = nameParts.slice(0, i).join("/");
                
                                if (baseParts) {
                                    //Find the longest baseName segment match in the config.
                                    //So, do joins on the biggest to smallest lengths of baseParts.
                                    for (j = baseParts.length; j > 0; j -= 1) {
                                        mapValue = map[baseParts.slice(0, j).join('/')];
                
                                        //baseName segment has  config, find if it has one for
                                        //this name.
                                        if (mapValue) {
                                            mapValue = mapValue[nameSegment];
                                            if (mapValue) {
                                                //Match, update name to the new value.
                                                foundMap = mapValue;
                                                foundI = i;
                                                break;
                                            }
                                        }
                                    }
                                }
                
                                if (foundMap) {
                                    break;
                                }
                
                                //Check for a star map match, but just hold on to it,
                                //if there is a shorter segment match later in a matching
                                //config, then favor over this star map.
                                if (!foundStarMap && starMap && starMap[nameSegment]) {
                                    foundStarMap = starMap[nameSegment];
                                    starI = i;
                                }
                            }
                
                            if (!foundMap && foundStarMap) {
                                foundMap = foundStarMap;
                                foundI = starI;
                            }
                
                            if (foundMap) {
                                nameParts.splice(0, foundI, foundMap);
                                name = nameParts.join('/');
                            }
                        }
                
                        return name;
                    }
                
                    function makeRequire(relName, forceSync) {
                        return function () {
                            //A version of a require function that passes a moduleName
                            //value for items that may need to
                            //look up paths relative to the moduleName
                            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
                        };
                    }
                
                    function makeNormalize(relName) {
                        return function (name) {
                            return normalize(name, relName);
                        };
                    }
                
                    function makeLoad(depName) {
                        return function (value) {
                            defined[depName] = value;
                        };
                    }
                
                    function callDep(name) {
                        if (hasProp(waiting, name)) {
                            var args = waiting[name];
                            delete waiting[name];
                            defining[name] = true;
                            main.apply(undef, args);
                        }
                
                        if (!hasProp(defined, name) && !hasProp(defining, name)) {
                            throw new Error('No ' + name);
                        }
                        return defined[name];
                    }
                
                    //Turns a plugin!resource to [plugin, resource]
                    //with the plugin being undefined if the name
                    //did not have a plugin prefix.
                    function splitPrefix(name) {
                        var prefix,
                            index = name ? name.indexOf('!') : -1;
                        if (index > -1) {
                            prefix = name.substring(0, index);
                            name = name.substring(index + 1, name.length);
                        }
                        return [prefix, name];
                    }
                
                    /**
                     * Makes a name map, normalizing the name, and using a plugin
                     * for normalization if necessary. Grabs a ref to plugin
                     * too, as an optimization.
                     */
                    makeMap = function (name, relName) {
                        var plugin,
                            parts = splitPrefix(name),
                            prefix = parts[0];
                
                        name = parts[1];
                
                        if (prefix) {
                            prefix = normalize(prefix, relName);
                            plugin = callDep(prefix);
                        }
                
                        //Normalize according
                        if (prefix) {
                            if (plugin && plugin.normalize) {
                                name = plugin.normalize(name, makeNormalize(relName));
                            } else {
                                name = normalize(name, relName);
                            }
                        } else {
                            name = normalize(name, relName);
                            parts = splitPrefix(name);
                            prefix = parts[0];
                            name = parts[1];
                            if (prefix) {
                                plugin = callDep(prefix);
                            }
                        }
                
                        //Using ridiculous property names for space reasons
                        return {
                            f: prefix ? prefix + '!' + name : name, //fullName
                            n: name,
                            pr: prefix,
                            p: plugin
                        };
                    };
                
                    function makeConfig(name) {
                        return function () {
                            return (config && config.config && config.config[name]) || {};
                        };
                    }
                
                    handlers = {
                        require: function (name) {
                            return makeRequire(name);
                        },
                        exports: function (name) {
                            var e = defined[name];
                            if (typeof e !== 'undefined') {
                                return e;
                            } else {
                                return (defined[name] = {});
                            }
                        },
                        module: function (name) {
                            return {
                                id: name,
                                uri: '',
                                exports: defined[name],
                                config: makeConfig(name)
                            };
                        }
                    };
                
                    main = function (name, deps, callback, relName) {
                        var cjsModule, depName, ret, map, i,
                            args = [],
                            callbackType = typeof callback,
                            usingExports;
                
                        //Use name if no relName
                        relName = relName || name;
                
                        //Call the callback to define the module, if necessary.
                        if (callbackType === 'undefined' || callbackType === 'function') {
                            //Pull out the defined dependencies and pass the ordered
                            //values to the callback.
                            //Default to [require, exports, module] if no deps
                            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
                            for (i = 0; i < deps.length; i += 1) {
                                map = makeMap(deps[i], relName);
                                depName = map.f;
                
                                //Fast path CommonJS standard dependencies.
                                if (depName === "require") {
                                    args[i] = handlers.require(name);
                                } else if (depName === "exports") {
                                    //CommonJS module spec 1.1
                                    args[i] = handlers.exports(name);
                                    usingExports = true;
                                } else if (depName === "module") {
                                    //CommonJS module spec 1.1
                                    cjsModule = args[i] = handlers.module(name);
                                } else if (hasProp(defined, depName) ||
                                           hasProp(waiting, depName) ||
                                           hasProp(defining, depName)) {
                                    args[i] = callDep(depName);
                                } else if (map.p) {
                                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                                    args[i] = defined[depName];
                                } else {
                                    throw new Error(name + ' missing ' + depName);
                                }
                            }
                
                            ret = callback ? callback.apply(defined[name], args) : undefined;
                
                            if (name) {
                                //If setting exports via "module" is in play,
                                //favor that over return value and exports. After that,
                                //favor a non-undefined return value over exports use.
                                if (cjsModule && cjsModule.exports !== undef &&
                                        cjsModule.exports !== defined[name]) {
                                    defined[name] = cjsModule.exports;
                                } else if (ret !== undef || !usingExports) {
                                    //Use the return value from the function.
                                    defined[name] = ret;
                                }
                            }
                        } else if (name) {
                            //May just be an object definition for the module. Only
                            //worry about defining if have a module name.
                            defined[name] = callback;
                        }
                    };
                
                    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
                        if (typeof deps === "string") {
                            if (handlers[deps]) {
                                //callback in this case is really relName
                                return handlers[deps](callback);
                            }
                            //Just return the module wanted. In this scenario, the
                            //deps arg is the module name, and second arg (if passed)
                            //is just the relName.
                            //Normalize module name, if it contains . or ..
                            return callDep(makeMap(deps, callback).f);
                        } else if (!deps.splice) {
                            //deps is a config object, not an array.
                            config = deps;
                            if (config.deps) {
                                req(config.deps, config.callback);
                            }
                            if (!callback) {
                                return;
                            }
                
                            if (callback.splice) {
                                //callback is an array, which means it is a dependency list.
                                //Adjust args if there are dependencies
                                deps = callback;
                                callback = relName;
                                relName = null;
                            } else {
                                deps = undef;
                            }
                        }
                
                        //Support require(['a'])
                        callback = callback || function () {};
                
                        //If relName is a function, it is an errback handler,
                        //so remove it.
                        if (typeof relName === 'function') {
                            relName = forceSync;
                            forceSync = alt;
                        }
                
                        //Simulate async callback;
                        if (forceSync) {
                            main(undef, deps, callback, relName);
                        } else {
                            //Using a non-zero value because of concern for what old browsers
                            //do, and latest browsers "upgrade" to 4 if lower value is used:
                            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
                            //If want a value immediately, use require('id') instead -- something
                            //that works in almond on the global level, but not guaranteed and
                            //unlikely to work in other AMD implementations.
                            setTimeout(function () {
                                main(undef, deps, callback, relName);
                            }, 4);
                        }
                
                        return req;
                    };
                
                    /**
                     * Just drops the config on the floor, but returns req in case
                     * the config return value is used.
                     */
                    req.config = function (cfg) {
                        return req(cfg);
                    };
                
                    /**
                     * Expose module registry for debugging and tooling
                     */
                    requirejs._defined = defined;
                
                    define = function (name, deps, callback) {
                
                        //This module may not have dependencies
                        if (!deps.splice) {
                            //deps is not an array, so probably means
                            //an object literal or factory function for
                            //the value. Adjust args.
                            callback = deps;
                            deps = [];
                        }
                
                        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                            waiting[name] = [name, deps, callback];
                        }
                    };
                
                    define.amd = {
                        jQuery: true
                    };
                }());
                
                define("vendor/almond/almond", function(){});
                
                //     Underscore.js 1.5.2
                //     http://underscorejs.org
                //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                //     Underscore may be freely distributed under the MIT license.
                
                (function() {
                
                  // Baseline setup
                  // --------------
                
                  // Establish the root object, `window` in the browser, or `exports` on the server.
                  var root = this;
                
                  // Save the previous value of the `_` variable.
                  var previousUnderscore = root._;
                
                  // Establish the object that gets returned to break out of a loop iteration.
                  var breaker = {};
                
                  // Save bytes in the minified (but not gzipped) version:
                  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
                
                  // Create quick reference variables for speed access to core prototypes.
                  var
                    push             = ArrayProto.push,
                    slice            = ArrayProto.slice,
                    concat           = ArrayProto.concat,
                    toString         = ObjProto.toString,
                    hasOwnProperty   = ObjProto.hasOwnProperty;
                
                  // All **ECMAScript 5** native function implementations that we hope to use
                  // are declared here.
                  var
                    nativeForEach      = ArrayProto.forEach,
                    nativeMap          = ArrayProto.map,
                    nativeReduce       = ArrayProto.reduce,
                    nativeReduceRight  = ArrayProto.reduceRight,
                    nativeFilter       = ArrayProto.filter,
                    nativeEvery        = ArrayProto.every,
                    nativeSome         = ArrayProto.some,
                    nativeIndexOf      = ArrayProto.indexOf,
                    nativeLastIndexOf  = ArrayProto.lastIndexOf,
                    nativeIsArray      = Array.isArray,
                    nativeKeys         = Object.keys,
                    nativeBind         = FuncProto.bind;
                
                  // Create a safe reference to the Underscore object for use below.
                  var _ = function(obj) {
                    if (obj instanceof _) return obj;
                    if (!(this instanceof _)) return new _(obj);
                    this._wrapped = obj;
                  };
                
                  // Export the Underscore object for **Node.js**, with
                  // backwards-compatibility for the old `require()` API. If we're in
                  // the browser, add `_` as a global object via a string identifier,
                  // for Closure Compiler "advanced" mode.
                  if (typeof exports !== 'undefined') {
                    if (typeof module !== 'undefined' && module.exports) {
                      exports = module.exports = _;
                    }
                    exports._ = _;
                  } else {
                    root._ = _;
                  }
                
                  // Current version.
                  _.VERSION = '1.5.2';
                
                  // Collection Functions
                  // --------------------
                
                  // The cornerstone, an `each` implementation, aka `forEach`.
                  // Handles objects with the built-in `forEach`, arrays, and raw objects.
                  // Delegates to **ECMAScript 5**'s native `forEach` if available.
                  var each = _.each = _.forEach = function(obj, iterator, context) {
                    if (obj == null) return;
                    if (nativeForEach && obj.forEach === nativeForEach) {
                      obj.forEach(iterator, context);
                    } else if (obj.length === +obj.length) {
                      for (var i = 0, length = obj.length; i < length; i++) {
                        if (iterator.call(context, obj[i], i, obj) === breaker) return;
                      }
                    } else {
                      var keys = _.keys(obj);
                      for (var i = 0, length = keys.length; i < length; i++) {
                        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
                      }
                    }
                  };
                
                  // Return the results of applying the iterator to each element.
                  // Delegates to **ECMAScript 5**'s native `map` if available.
                  _.map = _.collect = function(obj, iterator, context) {
                    var results = [];
                    if (obj == null) return results;
                    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
                    each(obj, function(value, index, list) {
                      results.push(iterator.call(context, value, index, list));
                    });
                    return results;
                  };
                
                  var reduceError = 'Reduce of empty array with no initial value';
                
                  // **Reduce** builds up a single result from a list of values, aka `inject`,
                  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
                  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
                    var initial = arguments.length > 2;
                    if (obj == null) obj = [];
                    if (nativeReduce && obj.reduce === nativeReduce) {
                      if (context) iterator = _.bind(iterator, context);
                      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
                    }
                    each(obj, function(value, index, list) {
                      if (!initial) {
                        memo = value;
                        initial = true;
                      } else {
                        memo = iterator.call(context, memo, value, index, list);
                      }
                    });
                    if (!initial) throw new TypeError(reduceError);
                    return memo;
                  };
                
                  // The right-associative version of reduce, also known as `foldr`.
                  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
                  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
                    var initial = arguments.length > 2;
                    if (obj == null) obj = [];
                    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
                      if (context) iterator = _.bind(iterator, context);
                      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
                    }
                    var length = obj.length;
                    if (length !== +length) {
                      var keys = _.keys(obj);
                      length = keys.length;
                    }
                    each(obj, function(value, index, list) {
                      index = keys ? keys[--length] : --length;
                      if (!initial) {
                        memo = obj[index];
                        initial = true;
                      } else {
                        memo = iterator.call(context, memo, obj[index], index, list);
                      }
                    });
                    if (!initial) throw new TypeError(reduceError);
                    return memo;
                  };
                
                  // Return the first value which passes a truth test. Aliased as `detect`.
                  _.find = _.detect = function(obj, iterator, context) {
                    var result;
                    any(obj, function(value, index, list) {
                      if (iterator.call(context, value, index, list)) {
                        result = value;
                        return true;
                      }
                    });
                    return result;
                  };
                
                  // Return all the elements that pass a truth test.
                  // Delegates to **ECMAScript 5**'s native `filter` if available.
                  // Aliased as `select`.
                  _.filter = _.select = function(obj, iterator, context) {
                    var results = [];
                    if (obj == null) return results;
                    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
                    each(obj, function(value, index, list) {
                      if (iterator.call(context, value, index, list)) results.push(value);
                    });
                    return results;
                  };
                
                  // Return all the elements for which a truth test fails.
                  _.reject = function(obj, iterator, context) {
                    return _.filter(obj, function(value, index, list) {
                      return !iterator.call(context, value, index, list);
                    }, context);
                  };
                
                  // Determine whether all of the elements match a truth test.
                  // Delegates to **ECMAScript 5**'s native `every` if available.
                  // Aliased as `all`.
                  _.every = _.all = function(obj, iterator, context) {
                    iterator || (iterator = _.identity);
                    var result = true;
                    if (obj == null) return result;
                    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
                    each(obj, function(value, index, list) {
                      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
                    });
                    return !!result;
                  };
                
                  // Determine if at least one element in the object matches a truth test.
                  // Delegates to **ECMAScript 5**'s native `some` if available.
                  // Aliased as `any`.
                  var any = _.some = _.any = function(obj, iterator, context) {
                    iterator || (iterator = _.identity);
                    var result = false;
                    if (obj == null) return result;
                    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
                    each(obj, function(value, index, list) {
                      if (result || (result = iterator.call(context, value, index, list))) return breaker;
                    });
                    return !!result;
                  };
                
                  // Determine if the array or object contains a given value (using `===`).
                  // Aliased as `include`.
                  _.contains = _.include = function(obj, target) {
                    if (obj == null) return false;
                    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
                    return any(obj, function(value) {
                      return value === target;
                    });
                  };
                
                  // Invoke a method (with arguments) on every item in a collection.
                  _.invoke = function(obj, method) {
                    var args = slice.call(arguments, 2);
                    var isFunc = _.isFunction(method);
                    return _.map(obj, function(value) {
                      return (isFunc ? method : value[method]).apply(value, args);
                    });
                  };
                
                  // Convenience version of a common use case of `map`: fetching a property.
                  _.pluck = function(obj, key) {
                    return _.map(obj, function(value){ return value[key]; });
                  };
                
                  // Convenience version of a common use case of `filter`: selecting only objects
                  // containing specific `key:value` pairs.
                  _.where = function(obj, attrs, first) {
                    if (_.isEmpty(attrs)) return first ? void 0 : [];
                    return _[first ? 'find' : 'filter'](obj, function(value) {
                      for (var key in attrs) {
                        if (attrs[key] !== value[key]) return false;
                      }
                      return true;
                    });
                  };
                
                  // Convenience version of a common use case of `find`: getting the first object
                  // containing specific `key:value` pairs.
                  _.findWhere = function(obj, attrs) {
                    return _.where(obj, attrs, true);
                  };
                
                  // Return the maximum element or (element-based computation).
                  // Can't optimize arrays of integers longer than 65,535 elements.
                  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
                  _.max = function(obj, iterator, context) {
                    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                      return Math.max.apply(Math, obj);
                    }
                    if (!iterator && _.isEmpty(obj)) return -Infinity;
                    var result = {computed : -Infinity, value: -Infinity};
                    each(obj, function(value, index, list) {
                      var computed = iterator ? iterator.call(context, value, index, list) : value;
                      computed > result.computed && (result = {value : value, computed : computed});
                    });
                    return result.value;
                  };
                
                  // Return the minimum element (or element-based computation).
                  _.min = function(obj, iterator, context) {
                    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                      return Math.min.apply(Math, obj);
                    }
                    if (!iterator && _.isEmpty(obj)) return Infinity;
                    var result = {computed : Infinity, value: Infinity};
                    each(obj, function(value, index, list) {
                      var computed = iterator ? iterator.call(context, value, index, list) : value;
                      computed < result.computed && (result = {value : value, computed : computed});
                    });
                    return result.value;
                  };
                
                  // Shuffle an array, using the modern version of the 
                  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
                  _.shuffle = function(obj) {
                    var rand;
                    var index = 0;
                    var shuffled = [];
                    each(obj, function(value) {
                      rand = _.random(index++);
                      shuffled[index - 1] = shuffled[rand];
                      shuffled[rand] = value;
                    });
                    return shuffled;
                  };
                
                  // Sample **n** random values from an array.
                  // If **n** is not specified, returns a single random element from the array.
                  // The internal `guard` argument allows it to work with `map`.
                  _.sample = function(obj, n, guard) {
                    if (arguments.length < 2 || guard) {
                      return obj[_.random(obj.length - 1)];
                    }
                    return _.shuffle(obj).slice(0, Math.max(0, n));
                  };
                
                  // An internal function to generate lookup iterators.
                  var lookupIterator = function(value) {
                    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
                  };
                
                  // Sort the object's values by a criterion produced by an iterator.
                  _.sortBy = function(obj, value, context) {
                    var iterator = lookupIterator(value);
                    return _.pluck(_.map(obj, function(value, index, list) {
                      return {
                        value: value,
                        index: index,
                        criteria: iterator.call(context, value, index, list)
                      };
                    }).sort(function(left, right) {
                      var a = left.criteria;
                      var b = right.criteria;
                      if (a !== b) {
                        if (a > b || a === void 0) return 1;
                        if (a < b || b === void 0) return -1;
                      }
                      return left.index - right.index;
                    }), 'value');
                  };
                
                  // An internal function used for aggregate "group by" operations.
                  var group = function(behavior) {
                    return function(obj, value, context) {
                      var result = {};
                      var iterator = value == null ? _.identity : lookupIterator(value);
                      each(obj, function(value, index) {
                        var key = iterator.call(context, value, index, obj);
                        behavior(result, key, value);
                      });
                      return result;
                    };
                  };
                
                  // Groups the object's values by a criterion. Pass either a string attribute
                  // to group by, or a function that returns the criterion.
                  _.groupBy = group(function(result, key, value) {
                    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
                  });
                
                  // Indexes the object's values by a criterion, similar to `groupBy`, but for
                  // when you know that your index values will be unique.
                  _.indexBy = group(function(result, key, value) {
                    result[key] = value;
                  });
                
                  // Counts instances of an object that group by a certain criterion. Pass
                  // either a string attribute to count by, or a function that returns the
                  // criterion.
                  _.countBy = group(function(result, key) {
                    _.has(result, key) ? result[key]++ : result[key] = 1;
                  });
                
                  // Use a comparator function to figure out the smallest index at which
                  // an object should be inserted so as to maintain order. Uses binary search.
                  _.sortedIndex = function(array, obj, iterator, context) {
                    iterator = iterator == null ? _.identity : lookupIterator(iterator);
                    var value = iterator.call(context, obj);
                    var low = 0, high = array.length;
                    while (low < high) {
                      var mid = (low + high) >>> 1;
                      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
                    }
                    return low;
                  };
                
                  // Safely create a real, live array from anything iterable.
                  _.toArray = function(obj) {
                    if (!obj) return [];
                    if (_.isArray(obj)) return slice.call(obj);
                    if (obj.length === +obj.length) return _.map(obj, _.identity);
                    return _.values(obj);
                  };
                
                  // Return the number of elements in an object.
                  _.size = function(obj) {
                    if (obj == null) return 0;
                    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
                  };
                
                  // Array Functions
                  // ---------------
                
                  // Get the first element of an array. Passing **n** will return the first N
                  // values in the array. Aliased as `head` and `take`. The **guard** check
                  // allows it to work with `_.map`.
                  _.first = _.head = _.take = function(array, n, guard) {
                    if (array == null) return void 0;
                    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
                  };
                
                  // Returns everything but the last entry of the array. Especially useful on
                  // the arguments object. Passing **n** will return all the values in
                  // the array, excluding the last N. The **guard** check allows it to work with
                  // `_.map`.
                  _.initial = function(array, n, guard) {
                    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
                  };
                
                  // Get the last element of an array. Passing **n** will return the last N
                  // values in the array. The **guard** check allows it to work with `_.map`.
                  _.last = function(array, n, guard) {
                    if (array == null) return void 0;
                    if ((n == null) || guard) {
                      return array[array.length - 1];
                    } else {
                      return slice.call(array, Math.max(array.length - n, 0));
                    }
                  };
                
                  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
                  // Especially useful on the arguments object. Passing an **n** will return
                  // the rest N values in the array. The **guard**
                  // check allows it to work with `_.map`.
                  _.rest = _.tail = _.drop = function(array, n, guard) {
                    return slice.call(array, (n == null) || guard ? 1 : n);
                  };
                
                  // Trim out all falsy values from an array.
                  _.compact = function(array) {
                    return _.filter(array, _.identity);
                  };
                
                  // Internal implementation of a recursive `flatten` function.
                  var flatten = function(input, shallow, output) {
                    if (shallow && _.every(input, _.isArray)) {
                      return concat.apply(output, input);
                    }
                    each(input, function(value) {
                      if (_.isArray(value) || _.isArguments(value)) {
                        shallow ? push.apply(output, value) : flatten(value, shallow, output);
                      } else {
                        output.push(value);
                      }
                    });
                    return output;
                  };
                
                  // Flatten out an array, either recursively (by default), or just one level.
                  _.flatten = function(array, shallow) {
                    return flatten(array, shallow, []);
                  };
                
                  // Return a version of the array that does not contain the specified value(s).
                  _.without = function(array) {
                    return _.difference(array, slice.call(arguments, 1));
                  };
                
                  // Produce a duplicate-free version of the array. If the array has already
                  // been sorted, you have the option of using a faster algorithm.
                  // Aliased as `unique`.
                  _.uniq = _.unique = function(array, isSorted, iterator, context) {
                    if (_.isFunction(isSorted)) {
                      context = iterator;
                      iterator = isSorted;
                      isSorted = false;
                    }
                    var initial = iterator ? _.map(array, iterator, context) : array;
                    var results = [];
                    var seen = [];
                    each(initial, function(value, index) {
                      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
                        seen.push(value);
                        results.push(array[index]);
                      }
                    });
                    return results;
                  };
                
                  // Produce an array that contains the union: each distinct element from all of
                  // the passed-in arrays.
                  _.union = function() {
                    return _.uniq(_.flatten(arguments, true));
                  };
                
                  // Produce an array that contains every item shared between all the
                  // passed-in arrays.
                  _.intersection = function(array) {
                    var rest = slice.call(arguments, 1);
                    return _.filter(_.uniq(array), function(item) {
                      return _.every(rest, function(other) {
                        return _.indexOf(other, item) >= 0;
                      });
                    });
                  };
                
                  // Take the difference between one array and a number of other arrays.
                  // Only the elements present in just the first array will remain.
                  _.difference = function(array) {
                    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
                    return _.filter(array, function(value){ return !_.contains(rest, value); });
                  };
                
                  // Zip together multiple lists into a single array -- elements that share
                  // an index go together.
                  _.zip = function() {
                    var length = _.max(_.pluck(arguments, "length").concat(0));
                    var results = new Array(length);
                    for (var i = 0; i < length; i++) {
                      results[i] = _.pluck(arguments, '' + i);
                    }
                    return results;
                  };
                
                  // Converts lists into objects. Pass either a single array of `[key, value]`
                  // pairs, or two parallel arrays of the same length -- one of keys, and one of
                  // the corresponding values.
                  _.object = function(list, values) {
                    if (list == null) return {};
                    var result = {};
                    for (var i = 0, length = list.length; i < length; i++) {
                      if (values) {
                        result[list[i]] = values[i];
                      } else {
                        result[list[i][0]] = list[i][1];
                      }
                    }
                    return result;
                  };
                
                  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
                  // we need this function. Return the position of the first occurrence of an
                  // item in an array, or -1 if the item is not included in the array.
                  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
                  // If the array is large and already in sort order, pass `true`
                  // for **isSorted** to use binary search.
                  _.indexOf = function(array, item, isSorted) {
                    if (array == null) return -1;
                    var i = 0, length = array.length;
                    if (isSorted) {
                      if (typeof isSorted == 'number') {
                        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
                      } else {
                        i = _.sortedIndex(array, item);
                        return array[i] === item ? i : -1;
                      }
                    }
                    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
                    for (; i < length; i++) if (array[i] === item) return i;
                    return -1;
                  };
                
                  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
                  _.lastIndexOf = function(array, item, from) {
                    if (array == null) return -1;
                    var hasIndex = from != null;
                    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
                      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
                    }
                    var i = (hasIndex ? from : array.length);
                    while (i--) if (array[i] === item) return i;
                    return -1;
                  };
                
                  // Generate an integer Array containing an arithmetic progression. A port of
                  // the native Python `range()` function. See
                  // [the Python documentation](http://docs.python.org/library/functions.html#range).
                  _.range = function(start, stop, step) {
                    if (arguments.length <= 1) {
                      stop = start || 0;
                      start = 0;
                    }
                    step = arguments[2] || 1;
                
                    var length = Math.max(Math.ceil((stop - start) / step), 0);
                    var idx = 0;
                    var range = new Array(length);
                
                    while(idx < length) {
                      range[idx++] = start;
                      start += step;
                    }
                
                    return range;
                  };
                
                  // Function (ahem) Functions
                  // ------------------
                
                  // Reusable constructor function for prototype setting.
                  var ctor = function(){};
                
                  // Create a function bound to a given object (assigning `this`, and arguments,
                  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
                  // available.
                  _.bind = function(func, context) {
                    var args, bound;
                    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
                    if (!_.isFunction(func)) throw new TypeError;
                    args = slice.call(arguments, 2);
                    return bound = function() {
                      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
                      ctor.prototype = func.prototype;
                      var self = new ctor;
                      ctor.prototype = null;
                      var result = func.apply(self, args.concat(slice.call(arguments)));
                      if (Object(result) === result) return result;
                      return self;
                    };
                  };
                
                  // Partially apply a function by creating a version that has had some of its
                  // arguments pre-filled, without changing its dynamic `this` context.
                  _.partial = function(func) {
                    var args = slice.call(arguments, 1);
                    return function() {
                      return func.apply(this, args.concat(slice.call(arguments)));
                    };
                  };
                
                  // Bind all of an object's methods to that object. Useful for ensuring that
                  // all callbacks defined on an object belong to it.
                  _.bindAll = function(obj) {
                    var funcs = slice.call(arguments, 1);
                    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
                    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
                    return obj;
                  };
                
                  // Memoize an expensive function by storing its results.
                  _.memoize = function(func, hasher) {
                    var memo = {};
                    hasher || (hasher = _.identity);
                    return function() {
                      var key = hasher.apply(this, arguments);
                      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
                    };
                  };
                
                  // Delays a function for the given number of milliseconds, and then calls
                  // it with the arguments supplied.
                  _.delay = function(func, wait) {
                    var args = slice.call(arguments, 2);
                    return setTimeout(function(){ return func.apply(null, args); }, wait);
                  };
                
                  // Defers a function, scheduling it to run after the current call stack has
                  // cleared.
                  _.defer = function(func) {
                    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
                  };
                
                  // Returns a function, that, when invoked, will only be triggered at most once
                  // during a given window of time. Normally, the throttled function will run
                  // as much as it can, without ever going more than once per `wait` duration;
                  // but if you'd like to disable the execution on the leading edge, pass
                  // `{leading: false}`. To disable execution on the trailing edge, ditto.
                  _.throttle = function(func, wait, options) {
                    var context, args, result;
                    var timeout = null;
                    var previous = 0;
                    options || (options = {});
                    var later = function() {
                      previous = options.leading === false ? 0 : new Date;
                      timeout = null;
                      result = func.apply(context, args);
                    };
                    return function() {
                      var now = new Date;
                      if (!previous && options.leading === false) previous = now;
                      var remaining = wait - (now - previous);
                      context = this;
                      args = arguments;
                      if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                      } else if (!timeout && options.trailing !== false) {
                        timeout = setTimeout(later, remaining);
                      }
                      return result;
                    };
                  };
                
                  // Returns a function, that, as long as it continues to be invoked, will not
                  // be triggered. The function will be called after it stops being called for
                  // N milliseconds. If `immediate` is passed, trigger the function on the
                  // leading edge, instead of the trailing.
                  _.debounce = function(func, wait, immediate) {
                    var timeout, args, context, timestamp, result;
                    return function() {
                      context = this;
                      args = arguments;
                      timestamp = new Date();
                      var later = function() {
                        var last = (new Date()) - timestamp;
                        if (last < wait) {
                          timeout = setTimeout(later, wait - last);
                        } else {
                          timeout = null;
                          if (!immediate) result = func.apply(context, args);
                        }
                      };
                      var callNow = immediate && !timeout;
                      if (!timeout) {
                        timeout = setTimeout(later, wait);
                      }
                      if (callNow) result = func.apply(context, args);
                      return result;
                    };
                  };
                
                  // Returns a function that will be executed at most one time, no matter how
                  // often you call it. Useful for lazy initialization.
                  _.once = function(func) {
                    var ran = false, memo;
                    return function() {
                      if (ran) return memo;
                      ran = true;
                      memo = func.apply(this, arguments);
                      func = null;
                      return memo;
                    };
                  };
                
                  // Returns the first function passed as an argument to the second,
                  // allowing you to adjust arguments, run code before and after, and
                  // conditionally execute the original function.
                  _.wrap = function(func, wrapper) {
                    return function() {
                      var args = [func];
                      push.apply(args, arguments);
                      return wrapper.apply(this, args);
                    };
                  };
                
                  // Returns a function that is the composition of a list of functions, each
                  // consuming the return value of the function that follows.
                  _.compose = function() {
                    var funcs = arguments;
                    return function() {
                      var args = arguments;
                      for (var i = funcs.length - 1; i >= 0; i--) {
                        args = [funcs[i].apply(this, args)];
                      }
                      return args[0];
                    };
                  };
                
                  // Returns a function that will only be executed after being called N times.
                  _.after = function(times, func) {
                    return function() {
                      if (--times < 1) {
                        return func.apply(this, arguments);
                      }
                    };
                  };
                
                  // Object Functions
                  // ----------------
                
                  // Retrieve the names of an object's properties.
                  // Delegates to **ECMAScript 5**'s native `Object.keys`
                  _.keys = nativeKeys || function(obj) {
                    if (obj !== Object(obj)) throw new TypeError('Invalid object');
                    var keys = [];
                    for (var key in obj) if (_.has(obj, key)) keys.push(key);
                    return keys;
                  };
                
                  // Retrieve the values of an object's properties.
                  _.values = function(obj) {
                    var keys = _.keys(obj);
                    var length = keys.length;
                    var values = new Array(length);
                    for (var i = 0; i < length; i++) {
                      values[i] = obj[keys[i]];
                    }
                    return values;
                  };
                
                  // Convert an object into a list of `[key, value]` pairs.
                  _.pairs = function(obj) {
                    var keys = _.keys(obj);
                    var length = keys.length;
                    var pairs = new Array(length);
                    for (var i = 0; i < length; i++) {
                      pairs[i] = [keys[i], obj[keys[i]]];
                    }
                    return pairs;
                  };
                
                  // Invert the keys and values of an object. The values must be serializable.
                  _.invert = function(obj) {
                    var result = {};
                    var keys = _.keys(obj);
                    for (var i = 0, length = keys.length; i < length; i++) {
                      result[obj[keys[i]]] = keys[i];
                    }
                    return result;
                  };
                
                  // Return a sorted list of the function names available on the object.
                  // Aliased as `methods`
                  _.functions = _.methods = function(obj) {
                    var names = [];
                    for (var key in obj) {
                      if (_.isFunction(obj[key])) names.push(key);
                    }
                    return names.sort();
                  };
                
                  // Extend a given object with all the properties in passed-in object(s).
                  _.extend = function(obj) {
                    each(slice.call(arguments, 1), function(source) {
                      if (source) {
                        for (var prop in source) {
                          obj[prop] = source[prop];
                        }
                      }
                    });
                    return obj;
                  };
                
                  // Return a copy of the object only containing the whitelisted properties.
                  _.pick = function(obj) {
                    var copy = {};
                    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
                    each(keys, function(key) {
                      if (key in obj) copy[key] = obj[key];
                    });
                    return copy;
                  };
                
                   // Return a copy of the object without the blacklisted properties.
                  _.omit = function(obj) {
                    var copy = {};
                    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
                    for (var key in obj) {
                      if (!_.contains(keys, key)) copy[key] = obj[key];
                    }
                    return copy;
                  };
                
                  // Fill in a given object with default properties.
                  _.defaults = function(obj) {
                    each(slice.call(arguments, 1), function(source) {
                      if (source) {
                        for (var prop in source) {
                          if (obj[prop] === void 0) obj[prop] = source[prop];
                        }
                      }
                    });
                    return obj;
                  };
                
                  // Create a (shallow-cloned) duplicate of an object.
                  _.clone = function(obj) {
                    if (!_.isObject(obj)) return obj;
                    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
                  };
                
                  // Invokes interceptor with the obj, and then returns obj.
                  // The primary purpose of this method is to "tap into" a method chain, in
                  // order to perform operations on intermediate results within the chain.
                  _.tap = function(obj, interceptor) {
                    interceptor(obj);
                    return obj;
                  };
                
                  // Internal recursive comparison function for `isEqual`.
                  var eq = function(a, b, aStack, bStack) {
                    // Identical objects are equal. `0 === -0`, but they aren't identical.
                    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
                    if (a === b) return a !== 0 || 1 / a == 1 / b;
                    // A strict comparison is necessary because `null == undefined`.
                    if (a == null || b == null) return a === b;
                    // Unwrap any wrapped objects.
                    if (a instanceof _) a = a._wrapped;
                    if (b instanceof _) b = b._wrapped;
                    // Compare `[[Class]]` names.
                    var className = toString.call(a);
                    if (className != toString.call(b)) return false;
                    switch (className) {
                      // Strings, numbers, dates, and booleans are compared by value.
                      case '[object String]':
                        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                        // equivalent to `new String("5")`.
                        return a == String(b);
                      case '[object Number]':
                        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                        // other numeric values.
                        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
                      case '[object Date]':
                      case '[object Boolean]':
                        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                        // millisecond representations. Note that invalid dates with millisecond representations
                        // of `NaN` are not equivalent.
                        return +a == +b;
                      // RegExps are compared by their source patterns and flags.
                      case '[object RegExp]':
                        return a.source == b.source &&
                               a.global == b.global &&
                               a.multiline == b.multiline &&
                               a.ignoreCase == b.ignoreCase;
                    }
                    if (typeof a != 'object' || typeof b != 'object') return false;
                    // Assume equality for cyclic structures. The algorithm for detecting cyclic
                    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
                    var length = aStack.length;
                    while (length--) {
                      // Linear search. Performance is inversely proportional to the number of
                      // unique nested structures.
                      if (aStack[length] == a) return bStack[length] == b;
                    }
                    // Objects with different constructors are not equivalent, but `Object`s
                    // from different frames are.
                    var aCtor = a.constructor, bCtor = b.constructor;
                    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
                      return false;
                    }
                    // Add the first object to the stack of traversed objects.
                    aStack.push(a);
                    bStack.push(b);
                    var size = 0, result = true;
                    // Recursively compare objects and arrays.
                    if (className == '[object Array]') {
                      // Compare array lengths to determine if a deep comparison is necessary.
                      size = a.length;
                      result = size == b.length;
                      if (result) {
                        // Deep compare the contents, ignoring non-numeric properties.
                        while (size--) {
                          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
                        }
                      }
                    } else {
                      // Deep compare objects.
                      for (var key in a) {
                        if (_.has(a, key)) {
                          // Count the expected number of properties.
                          size++;
                          // Deep compare each member.
                          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
                        }
                      }
                      // Ensure that both objects contain the same number of properties.
                      if (result) {
                        for (key in b) {
                          if (_.has(b, key) && !(size--)) break;
                        }
                        result = !size;
                      }
                    }
                    // Remove the first object from the stack of traversed objects.
                    aStack.pop();
                    bStack.pop();
                    return result;
                  };
                
                  // Perform a deep comparison to check if two objects are equal.
                  _.isEqual = function(a, b) {
                    return eq(a, b, [], []);
                  };
                
                  // Is a given array, string, or object empty?
                  // An "empty" object has no enumerable own-properties.
                  _.isEmpty = function(obj) {
                    if (obj == null) return true;
                    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
                    for (var key in obj) if (_.has(obj, key)) return false;
                    return true;
                  };
                
                  // Is a given value a DOM element?
                  _.isElement = function(obj) {
                    return !!(obj && obj.nodeType === 1);
                  };
                
                  // Is a given value an array?
                  // Delegates to ECMA5's native Array.isArray
                  _.isArray = nativeIsArray || function(obj) {
                    return toString.call(obj) == '[object Array]';
                  };
                
                  // Is a given variable an object?
                  _.isObject = function(obj) {
                    return obj === Object(obj);
                  };
                
                  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
                  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
                    _['is' + name] = function(obj) {
                      return toString.call(obj) == '[object ' + name + ']';
                    };
                  });
                
                  // Define a fallback version of the method in browsers (ahem, IE), where
                  // there isn't any inspectable "Arguments" type.
                  if (!_.isArguments(arguments)) {
                    _.isArguments = function(obj) {
                      return !!(obj && _.has(obj, 'callee'));
                    };
                  }
                
                  // Optimize `isFunction` if appropriate.
                  if (typeof (/./) !== 'function') {
                    _.isFunction = function(obj) {
                      return typeof obj === 'function';
                    };
                  }
                
                  // Is a given object a finite number?
                  _.isFinite = function(obj) {
                    return isFinite(obj) && !isNaN(parseFloat(obj));
                  };
                
                  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
                  _.isNaN = function(obj) {
                    return _.isNumber(obj) && obj != +obj;
                  };
                
                  // Is a given value a boolean?
                  _.isBoolean = function(obj) {
                    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
                  };
                
                  // Is a given value equal to null?
                  _.isNull = function(obj) {
                    return obj === null;
                  };
                
                  // Is a given variable undefined?
                  _.isUndefined = function(obj) {
                    return obj === void 0;
                  };
                
                  // Shortcut function for checking if an object has a given property directly
                  // on itself (in other words, not on a prototype).
                  _.has = function(obj, key) {
                    return hasOwnProperty.call(obj, key);
                  };
                
                  // Utility Functions
                  // -----------------
                
                  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
                  // previous owner. Returns a reference to the Underscore object.
                  _.noConflict = function() {
                    root._ = previousUnderscore;
                    return this;
                  };
                
                  // Keep the identity function around for default iterators.
                  _.identity = function(value) {
                    return value;
                  };
                
                  // Run a function **n** times.
                  _.times = function(n, iterator, context) {
                    var accum = Array(Math.max(0, n));
                    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
                    return accum;
                  };
                
                  // Return a random integer between min and max (inclusive).
                  _.random = function(min, max) {
                    if (max == null) {
                      max = min;
                      min = 0;
                    }
                    return min + Math.floor(Math.random() * (max - min + 1));
                  };
                
                  // List of HTML entities for escaping.
                  var entityMap = {
                    escape: {
                      '&': '&amp;',
                      '<': '&lt;',
                      '>': '&gt;',
                      '"': '&quot;',
                      "'": '&#x27;'
                    }
                  };
                  entityMap.unescape = _.invert(entityMap.escape);
                
                  // Regexes containing the keys and values listed immediately above.
                  var entityRegexes = {
                    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
                    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
                  };
                
                  // Functions for escaping and unescaping strings to/from HTML interpolation.
                  _.each(['escape', 'unescape'], function(method) {
                    _[method] = function(string) {
                      if (string == null) return '';
                      return ('' + string).replace(entityRegexes[method], function(match) {
                        return entityMap[method][match];
                      });
                    };
                  });
                
                  // If the value of the named `property` is a function then invoke it with the
                  // `object` as context; otherwise, return it.
                  _.result = function(object, property) {
                    if (object == null) return void 0;
                    var value = object[property];
                    return _.isFunction(value) ? value.call(object) : value;
                  };
                
                  // Add your own custom functions to the Underscore object.
                  _.mixin = function(obj) {
                    each(_.functions(obj), function(name) {
                      var func = _[name] = obj[name];
                      _.prototype[name] = function() {
                        var args = [this._wrapped];
                        push.apply(args, arguments);
                        return result.call(this, func.apply(_, args));
                      };
                    });
                  };
                
                  // Generate a unique integer id (unique within the entire client session).
                  // Useful for temporary DOM ids.
                  var idCounter = 0;
                  _.uniqueId = function(prefix) {
                    var id = ++idCounter + '';
                    return prefix ? prefix + id : id;
                  };
                
                  // By default, Underscore uses ERB-style template delimiters, change the
                  // following template settings to use alternative delimiters.
                  _.templateSettings = {
                    evaluate    : /<%([\s\S]+?)%>/g,
                    interpolate : /<%=([\s\S]+?)%>/g,
                    escape      : /<%-([\s\S]+?)%>/g
                  };
                
                  // When customizing `templateSettings`, if you don't want to define an
                  // interpolation, evaluation or escaping regex, we need one that is
                  // guaranteed not to match.
                  var noMatch = /(.)^/;
                
                  // Certain characters need to be escaped so that they can be put into a
                  // string literal.
                  var escapes = {
                    "'":      "'",
                    '\\':     '\\',
                    '\r':     'r',
                    '\n':     'n',
                    '\t':     't',
                    '\u2028': 'u2028',
                    '\u2029': 'u2029'
                  };
                
                  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
                
                  // JavaScript micro-templating, similar to John Resig's implementation.
                  // Underscore templating handles arbitrary delimiters, preserves whitespace,
                  // and correctly escapes quotes within interpolated code.
                  _.template = function(text, data, settings) {
                    var render;
                    settings = _.defaults({}, settings, _.templateSettings);
                
                    // Combine delimiters into one regular expression via alternation.
                    var matcher = new RegExp([
                      (settings.escape || noMatch).source,
                      (settings.interpolate || noMatch).source,
                      (settings.evaluate || noMatch).source
                    ].join('|') + '|$', 'g');
                
                    // Compile the template source, escaping string literals appropriately.
                    var index = 0;
                    var source = "__p+='";
                    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                      source += text.slice(index, offset)
                        .replace(escaper, function(match) { return '\\' + escapes[match]; });
                
                      if (escape) {
                        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
                      }
                      if (interpolate) {
                        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
                      }
                      if (evaluate) {
                        source += "';\n" + evaluate + "\n__p+='";
                      }
                      index = offset + match.length;
                      return match;
                    });
                    source += "';\n";
                
                    // If a variable is not specified, place data values in local scope.
                    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
                
                    source = "var __t,__p='',__j=Array.prototype.join," +
                      "print=function(){__p+=__j.call(arguments,'');};\n" +
                      source + "return __p;\n";
                
                    try {
                      render = new Function(settings.variable || 'obj', '_', source);
                    } catch (e) {
                      e.source = source;
                      throw e;
                    }
                
                    if (data) return render(data, _);
                    var template = function(data) {
                      return render.call(this, data, _);
                    };
                
                    // Provide the compiled function source as a convenience for precompilation.
                    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
                
                    return template;
                  };
                
                  // Add a "chain" function, which will delegate to the wrapper.
                  _.chain = function(obj) {
                    return _(obj).chain();
                  };
                
                  // OOP
                  // ---------------
                  // If Underscore is called as a function, it returns a wrapped object that
                  // can be used OO-style. This wrapper holds altered versions of all the
                  // underscore functions. Wrapped objects may be chained.
                
                  // Helper function to continue chaining intermediate results.
                  var result = function(obj) {
                    return this._chain ? _(obj).chain() : obj;
                  };
                
                  // Add all of the Underscore functions to the wrapper object.
                  _.mixin(_);
                
                  // Add all mutator Array functions to the wrapper.
                  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
                    var method = ArrayProto[name];
                    _.prototype[name] = function() {
                      var obj = this._wrapped;
                      method.apply(obj, arguments);
                      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
                      return result.call(this, obj);
                    };
                  });
                
                  // Add all accessor Array functions to the wrapper.
                  each(['concat', 'join', 'slice'], function(name) {
                    var method = ArrayProto[name];
                    _.prototype[name] = function() {
                      return result.call(this, method.apply(this._wrapped, arguments));
                    };
                  });
                
                  _.extend(_.prototype, {
                
                    // Start chaining a wrapped Underscore object.
                    chain: function() {
                      this._chain = true;
                      return this;
                    },
                
                    // Extracts the result from a wrapped and chained object.
                    value: function() {
                      return this._wrapped;
                    }
                
                  });
                
                  // AMD define happens at the end for compatibility with AMD loaders
                  // that don't enforce next-turn semantics on modules.
                  if (typeof define === 'function' && define.amd) {
                    define('underscore', [],function() {
                      return _;
                    });
                  }
                
                }).call(this);
                
                (function() {
                  define('common/custom',["underscore"], function(_) {
                    var monkey_patch;
                    monkey_patch = function() {
                      return _.uniqueId = function(prefix) {
                        var hexDigits, i, s, uuid, _i;
                        s = [];
                        hexDigits = "0123456789ABCDEF";
                        for (i = _i = 0; _i <= 31; i = ++_i) {
                          s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
                        }
                        s[12] = "4";
                        s[16] = hexDigits.substr((s[16] & 0x3) | 0x8, 1);
                        uuid = s.join("");
                        if (prefix) {
                          return prefix + "-" + uuid;
                        } else {
                          return uuid;
                        }
                      };
                    };
                    _.isNullOrUndefined = function(x) {
                      return _.isNull(x) || _.isUndefined(x);
                    };
                    _.setdefault = function(obj, key, value) {
                      if (_.has(obj, key)) {
                        return obj[key];
                      } else {
                        obj[key] = value;
                        return value;
                      }
                    };
                    return {
                      "monkey_patch": monkey_patch
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=custom.js.map
                */;
                /*! jQuery v2.0.3 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
                //@ sourceMappingURL=jquery.min.map
                */
                (function(e,undefined){var t,n,r=typeof undefined,i=e.location,o=e.document,s=o.documentElement,a=e.jQuery,u=e.$,l={},c=[],p="2.0.3",f=c.concat,h=c.push,d=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=p.trim,x=function(e,n){return new x.fn.init(e,n,t)},b=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,w=/\S+/g,T=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,k=/^-ms-/,N=/-([\da-z])/gi,E=function(e,t){return t.toUpperCase()},S=function(){o.removeEventListener("DOMContentLoaded",S,!1),e.removeEventListener("load",S,!1),x.ready()};x.fn=x.prototype={jquery:p,constructor:x,init:function(e,t,n){var r,i;if(!e)return this;if("string"==typeof e){if(r="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:T.exec(e),!r||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof x?t[0]:t,x.merge(this,x.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:o,!0)),C.test(r[1])&&x.isPlainObject(t))for(r in t)x.isFunction(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return i=o.getElementById(r[2]),i&&i.parentNode&&(this.length=1,this[0]=i),this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?n.ready(e):(e.selector!==undefined&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return d.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,t,n,r,i,o,s=arguments[0]||{},a=1,u=arguments.length,l=!1;for("boolean"==typeof s&&(l=s,s=arguments[1]||{},a=2),"object"==typeof s||x.isFunction(s)||(s={}),u===a&&(s=this,--a);u>a;a++)if(null!=(e=arguments[a]))for(t in e)n=s[t],r=e[t],s!==r&&(l&&r&&(x.isPlainObject(r)||(i=x.isArray(r)))?(i?(i=!1,o=n&&x.isArray(n)?n:[]):o=n&&x.isPlainObject(n)?n:{},s[t]=x.extend(l,o,r)):r!==undefined&&(s[t]=r));return s},x.extend({expando:"jQuery"+(p+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=a),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){(e===!0?--x.readyWait:x.isReady)||(x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(o,[x]),x.fn.trigger&&x(o).trigger("ready").off("ready")))},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[m.call(e)]||"object":typeof e},isPlainObject:function(e){if("object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}return!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:JSON.parse,parseXML:function(e){var t,n;if(!e||"string"!=typeof e)return null;try{n=new DOMParser,t=n.parseFromString(e,"text/xml")}catch(r){t=undefined}return(!t||t.getElementsByTagName("parsererror").length)&&x.error("Invalid XML: "+e),t},noop:function(){},globalEval:function(e){var t,n=eval;e=x.trim(e),e&&(1===e.indexOf("use strict")?(t=o.createElement("script"),t.text=e,o.head.appendChild(t).parentNode.removeChild(t)):n(e))},camelCase:function(e){return e.replace(k,"ms-").replace(N,E)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,s=j(e);if(n){if(s){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(s){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:function(e){return null==e?"":v.call(e)},makeArray:function(e,t){var n=t||[];return null!=e&&(j(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:g.call(t,e,n)},merge:function(e,t){var n=t.length,r=e.length,i=0;if("number"==typeof n)for(;n>i;i++)e[r++]=t[i];else while(t[i]!==undefined)e[r++]=t[i++];return e.length=r,e},grep:function(e,t,n){var r,i=[],o=0,s=e.length;for(n=!!n;s>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,s=j(e),a=[];if(s)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(a[a.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(a[a.length]=r);return f.apply([],a)},guid:1,proxy:function(e,t){var n,r,i;return"string"==typeof t&&(n=e[t],t=e,e=n),x.isFunction(e)?(r=d.call(arguments,2),i=function(){return e.apply(t||this,r.concat(d.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):undefined},access:function(e,t,n,r,i,o,s){var a=0,u=e.length,l=null==n;if("object"===x.type(n)){i=!0;for(a in n)x.access(e,t,a,n[a],!0,o,s)}else if(r!==undefined&&(i=!0,x.isFunction(r)||(s=!0),l&&(s?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(x(e),n)})),t))for(;u>a;a++)t(e[a],n,s?r:r.call(e[a],a,t(e[a],n)));return i?e:l?t.call(e):u?t(e[0],n):o},now:Date.now,swap:function(e,t,n,r){var i,o,s={};for(o in t)s[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=s[o];return i}}),x.ready.promise=function(t){return n||(n=x.Deferred(),"complete"===o.readyState?setTimeout(x.ready):(o.addEventListener("DOMContentLoaded",S,!1),e.addEventListener("load",S,!1))),n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function j(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}t=x(o),function(e,undefined){var t,n,r,i,o,s,a,u,l,c,p,f,h,d,g,m,y,v="sizzle"+-new Date,b=e.document,w=0,T=0,C=st(),k=st(),N=st(),E=!1,S=function(e,t){return e===t?(E=!0,0):0},j=typeof undefined,D=1<<31,A={}.hasOwnProperty,L=[],q=L.pop,H=L.push,O=L.push,F=L.slice,P=L.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",W="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",$=W.replace("w","w#"),B="\\["+M+"*("+W+")"+M+"*(?:([*^$|!~]?=)"+M+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+$+")|)|)"+M+"*\\]",I=":("+W+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+B.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=RegExp("^"+M+"*,"+M+"*"),X=RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=RegExp(M+"*[+~]"),Y=RegExp("="+M+"*([^\\]'\"]*)"+M+"*\\]","g"),V=RegExp(I),G=RegExp("^"+$+"$"),J={ID:RegExp("^#("+W+")"),CLASS:RegExp("^\\.("+W+")"),TAG:RegExp("^("+W.replace("w","w*")+")"),ATTR:RegExp("^"+B),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:RegExp("^(?:"+R+")$","i"),needsContext:RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Q=/^[^{]+\{\s*\[native \w/,K=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,Z=/^(?:input|select|textarea|button)$/i,et=/^h\d$/i,tt=/'|\\/g,nt=RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),rt=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{O.apply(L=F.call(b.childNodes),b.childNodes),L[b.childNodes.length].nodeType}catch(it){O={apply:L.length?function(e,t){H.apply(e,F.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function ot(e,t,r,i){var o,s,a,u,l,f,g,m,x,w;if((t?t.ownerDocument||t:b)!==p&&c(t),t=t||p,r=r||[],!e||"string"!=typeof e)return r;if(1!==(u=t.nodeType)&&9!==u)return[];if(h&&!i){if(o=K.exec(e))if(a=o[1]){if(9===u){if(s=t.getElementById(a),!s||!s.parentNode)return r;if(s.id===a)return r.push(s),r}else if(t.ownerDocument&&(s=t.ownerDocument.getElementById(a))&&y(t,s)&&s.id===a)return r.push(s),r}else{if(o[2])return O.apply(r,t.getElementsByTagName(e)),r;if((a=o[3])&&n.getElementsByClassName&&t.getElementsByClassName)return O.apply(r,t.getElementsByClassName(a)),r}if(n.qsa&&(!d||!d.test(e))){if(m=g=v,x=t,w=9===u&&e,1===u&&"object"!==t.nodeName.toLowerCase()){f=gt(e),(g=t.getAttribute("id"))?m=g.replace(tt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",l=f.length;while(l--)f[l]=m+mt(f[l]);x=U.test(e)&&t.parentNode||t,w=f.join(",")}if(w)try{return O.apply(r,x.querySelectorAll(w)),r}catch(T){}finally{g||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,r,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>i.cacheLength&&delete t[e.shift()],t[n]=r}return t}function at(e){return e[v]=!0,e}function ut(e){var t=p.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function lt(e,t){var n=e.split("|"),r=e.length;while(r--)i.attrHandle[n[r]]=t}function ct(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function pt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return at(function(t){return t=+t,at(function(n,r){var i,o=e([],n.length,t),s=o.length;while(s--)n[i=o[s]]&&(n[i]=!(r[i]=n[i]))})})}s=ot.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},n=ot.support={},c=ot.setDocument=function(e){var t=e?e.ownerDocument||e:b,r=t.defaultView;return t!==p&&9===t.nodeType&&t.documentElement?(p=t,f=t.documentElement,h=!s(t),r&&r.attachEvent&&r!==r.top&&r.attachEvent("onbeforeunload",function(){c()}),n.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),n.getElementsByTagName=ut(function(e){return e.appendChild(t.createComment("")),!e.getElementsByTagName("*").length}),n.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),n.getById=ut(function(e){return f.appendChild(e).id=v,!t.getElementsByName||!t.getElementsByName(v).length}),n.getById?(i.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(nt,rt);return function(e){return e.getAttribute("id")===t}}):(delete i.find.ID,i.filter.ID=function(e){var t=e.replace(nt,rt);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=n.getElementsByTagName?function(e,t){return typeof t.getElementsByTagName!==j?t.getElementsByTagName(e):undefined}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},i.find.CLASS=n.getElementsByClassName&&function(e,t){return typeof t.getElementsByClassName!==j&&h?t.getElementsByClassName(e):undefined},g=[],d=[],(n.qsa=Q.test(t.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||d.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll(":checked").length||d.push(":checked")}),ut(function(e){var n=t.createElement("input");n.setAttribute("type","hidden"),e.appendChild(n).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&d.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||d.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),d.push(",.*:")})),(n.matchesSelector=Q.test(m=f.webkitMatchesSelector||f.mozMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&ut(function(e){n.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!='']:x"),g.push("!=",I)}),d=d.length&&RegExp(d.join("|")),g=g.length&&RegExp(g.join("|")),y=Q.test(f.contains)||f.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},S=f.compareDocumentPosition?function(e,r){if(e===r)return E=!0,0;var i=r.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(r);return i?1&i||!n.sortDetached&&r.compareDocumentPosition(e)===i?e===t||y(b,e)?-1:r===t||y(b,r)?1:l?P.call(l,e)-P.call(l,r):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,n){var r,i=0,o=e.parentNode,s=n.parentNode,a=[e],u=[n];if(e===n)return E=!0,0;if(!o||!s)return e===t?-1:n===t?1:o?-1:s?1:l?P.call(l,e)-P.call(l,n):0;if(o===s)return ct(e,n);r=e;while(r=r.parentNode)a.unshift(r);r=n;while(r=r.parentNode)u.unshift(r);while(a[i]===u[i])i++;return i?ct(a[i],u[i]):a[i]===b?-1:u[i]===b?1:0},t):p},ot.matches=function(e,t){return ot(e,null,null,t)},ot.matchesSelector=function(e,t){if((e.ownerDocument||e)!==p&&c(e),t=t.replace(Y,"='$1']"),!(!n.matchesSelector||!h||g&&g.test(t)||d&&d.test(t)))try{var r=m.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(i){}return ot(t,p,null,[e]).length>0},ot.contains=function(e,t){return(e.ownerDocument||e)!==p&&c(e),y(e,t)},ot.attr=function(e,t){(e.ownerDocument||e)!==p&&c(e);var r=i.attrHandle[t.toLowerCase()],o=r&&A.call(i.attrHandle,t.toLowerCase())?r(e,t,!h):undefined;return o===undefined?n.attributes||!h?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null:o},ot.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},ot.uniqueSort=function(e){var t,r=[],i=0,o=0;if(E=!n.detectDuplicates,l=!n.sortStable&&e.slice(0),e.sort(S),E){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1)}return e},o=ot.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=o(t);return n},i=ot.selectors={cacheLength:50,createPseudo:at,match:J,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(nt,rt),e[3]=(e[4]||e[5]||"").replace(nt,rt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||ot.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&ot.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return J.CHILD.test(e[0])?null:(e[3]&&e[4]!==undefined?e[2]=e[4]:n&&V.test(n)&&(t=gt(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(nt,rt).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=C[e+" "];return t||(t=RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&C(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=ot.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),s="last"!==e.slice(-4),a="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,p,f,h,d,g=o!==s?"nextSibling":"previousSibling",m=t.parentNode,y=a&&t.nodeName.toLowerCase(),x=!u&&!a;if(m){if(o){while(g){p=t;while(p=p[g])if(a?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;d=g="only"===e&&!d&&"nextSibling"}return!0}if(d=[s?m.firstChild:m.lastChild],s&&x){c=m[v]||(m[v]={}),l=c[e]||[],h=l[0]===w&&l[1],f=l[0]===w&&l[2],p=h&&m.childNodes[h];while(p=++h&&p&&p[g]||(f=h=0)||d.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[w,h,f];break}}else if(x&&(l=(t[v]||(t[v]={}))[e])&&l[0]===w)f=l[1];else while(p=++h&&p&&p[g]||(f=h=0)||d.pop())if((a?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(x&&((p[v]||(p[v]={}))[e]=[w,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||ot.error("unsupported pseudo: "+e);return r[v]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?at(function(e,n){var i,o=r(e,t),s=o.length;while(s--)i=P.call(e,o[s]),e[i]=!(n[i]=o[s])}):function(e){return r(e,0,n)}):r}},pseudos:{not:at(function(e){var t=[],n=[],r=a(e.replace(z,"$1"));return r[v]?at(function(e,t,n,i){var o,s=r(e,null,i,[]),a=e.length;while(a--)(o=s[a])&&(e[a]=!(t[a]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:at(function(e){return function(t){return ot(e,t).length>0}}),contains:at(function(e){return function(t){return(t.textContent||t.innerText||o(t)).indexOf(e)>-1}}),lang:at(function(e){return G.test(e||"")||ot.error("unsupported lang: "+e),e=e.replace(nt,rt).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===f},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return et.test(e.nodeName)},input:function(e){return Z.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},i.pseudos.nth=i.pseudos.eq;for(t in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[t]=pt(t);for(t in{submit:!0,reset:!0})i.pseudos[t]=ft(t);function dt(){}dt.prototype=i.filters=i.pseudos,i.setFilters=new dt;function gt(e,t){var n,r,o,s,a,u,l,c=k[e+" "];if(c)return t?0:c.slice(0);a=e,u=[],l=i.preFilter;while(a){(!n||(r=_.exec(a)))&&(r&&(a=a.slice(r[0].length)||a),u.push(o=[])),n=!1,(r=X.exec(a))&&(n=r.shift(),o.push({value:n,type:r[0].replace(z," ")}),a=a.slice(n.length));for(s in i.filter)!(r=J[s].exec(a))||l[s]&&!(r=l[s](r))||(n=r.shift(),o.push({value:n,type:s,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?ot.error(e):k(e,u).slice(0)}function mt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function yt(e,t,n){var i=t.dir,o=n&&"parentNode"===i,s=T++;return t.first?function(t,n,r){while(t=t[i])if(1===t.nodeType||o)return e(t,n,r)}:function(t,n,a){var u,l,c,p=w+" "+s;if(a){while(t=t[i])if((1===t.nodeType||o)&&e(t,n,a))return!0}else while(t=t[i])if(1===t.nodeType||o)if(c=t[v]||(t[v]={}),(l=c[i])&&l[0]===p){if((u=l[1])===!0||u===r)return u===!0}else if(l=c[i]=[p],l[1]=e(t,n,a)||r,l[1]===!0)return!0}}function vt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,s=[],a=0,u=e.length,l=null!=t;for(;u>a;a++)(o=e[a])&&(!n||n(o,r,i))&&(s.push(o),l&&t.push(a));return s}function bt(e,t,n,r,i,o){return r&&!r[v]&&(r=bt(r)),i&&!i[v]&&(i=bt(i,o)),at(function(o,s,a,u){var l,c,p,f=[],h=[],d=s.length,g=o||Ct(t||"*",a.nodeType?[a]:a,[]),m=!e||!o&&t?g:xt(g,f,e,a,u),y=n?i||(o?e:d||r)?[]:s:m;if(n&&n(m,y,a,u),r){l=xt(y,h),r(l,[],a,u),c=l.length;while(c--)(p=l[c])&&(y[h[c]]=!(m[h[c]]=p))}if(o){if(i||e){if(i){l=[],c=y.length;while(c--)(p=y[c])&&l.push(m[c]=p);i(null,y=[],l,u)}c=y.length;while(c--)(p=y[c])&&(l=i?P.call(o,p):f[c])>-1&&(o[l]=!(s[l]=p))}}else y=xt(y===s?y.splice(d,y.length):y),i?i(null,s,y,u):O.apply(s,y)})}function wt(e){var t,n,r,o=e.length,s=i.relative[e[0].type],a=s||i.relative[" "],l=s?1:0,c=yt(function(e){return e===t},a,!0),p=yt(function(e){return P.call(t,e)>-1},a,!0),f=[function(e,n,r){return!s&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;o>l;l++)if(n=i.relative[e[l].type])f=[yt(vt(f),n)];else{if(n=i.filter[e[l].type].apply(null,e[l].matches),n[v]){for(r=++l;o>r;r++)if(i.relative[e[r].type])break;return bt(l>1&&vt(f),l>1&&mt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&wt(e.slice(l,r)),o>r&&wt(e=e.slice(r)),o>r&&mt(e))}f.push(n)}return vt(f)}function Tt(e,t){var n=0,o=t.length>0,s=e.length>0,a=function(a,l,c,f,h){var d,g,m,y=[],v=0,x="0",b=a&&[],T=null!=h,C=u,k=a||s&&i.find.TAG("*",h&&l.parentNode||l),N=w+=null==C?1:Math.random()||.1;for(T&&(u=l!==p&&l,r=n);null!=(d=k[x]);x++){if(s&&d){g=0;while(m=e[g++])if(m(d,l,c)){f.push(d);break}T&&(w=N,r=++n)}o&&((d=!m&&d)&&v--,a&&b.push(d))}if(v+=x,o&&x!==v){g=0;while(m=t[g++])m(b,y,l,c);if(a){if(v>0)while(x--)b[x]||y[x]||(y[x]=q.call(f));y=xt(y)}O.apply(f,y),T&&!a&&y.length>0&&v+t.length>1&&ot.uniqueSort(f)}return T&&(w=N,u=C),b};return o?at(a):a}a=ot.compile=function(e,t){var n,r=[],i=[],o=N[e+" "];if(!o){t||(t=gt(e)),n=t.length;while(n--)o=wt(t[n]),o[v]?r.push(o):i.push(o);o=N(e,Tt(i,r))}return o};function Ct(e,t,n){var r=0,i=t.length;for(;i>r;r++)ot(e,t[r],n);return n}function kt(e,t,r,o){var s,u,l,c,p,f=gt(e);if(!o&&1===f.length){if(u=f[0]=f[0].slice(0),u.length>2&&"ID"===(l=u[0]).type&&n.getById&&9===t.nodeType&&h&&i.relative[u[1].type]){if(t=(i.find.ID(l.matches[0].replace(nt,rt),t)||[])[0],!t)return r;e=e.slice(u.shift().value.length)}s=J.needsContext.test(e)?0:u.length;while(s--){if(l=u[s],i.relative[c=l.type])break;if((p=i.find[c])&&(o=p(l.matches[0].replace(nt,rt),U.test(u[0].type)&&t.parentNode||t))){if(u.splice(s,1),e=o.length&&mt(u),!e)return O.apply(r,o),r;break}}}return a(e,f)(o,t,!h,r,U.test(e)),r}n.sortStable=v.split("").sort(S).join("")===v,n.detectDuplicates=E,c(),n.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(p.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||lt("type|href|height|width",function(e,t,n){return n?undefined:e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),n.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||lt("value",function(e,t,n){return n||"input"!==e.nodeName.toLowerCase()?undefined:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||lt(R,function(e,t,n){var r;return n?undefined:(r=e.getAttributeNode(t))&&r.specified?r.value:e[t]===!0?t.toLowerCase():null}),x.find=ot,x.expr=ot.selectors,x.expr[":"]=x.expr.pseudos,x.unique=ot.uniqueSort,x.text=ot.getText,x.isXMLDoc=ot.isXML,x.contains=ot.contains}(e);var D={};function A(e){var t=D[e]={};return x.each(e.match(w)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?D[e]||A(e):x.extend({},e);var t,n,r,i,o,s,a=[],u=!e.once&&[],l=function(p){for(t=e.memory&&p,n=!0,s=i||0,i=0,o=a.length,r=!0;a&&o>s;s++)if(a[s].apply(p[0],p[1])===!1&&e.stopOnFalse){t=!1;break}r=!1,a&&(u?u.length&&l(u.shift()):t?a=[]:c.disable())},c={add:function(){if(a){var n=a.length;(function s(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&c.has(n)||a.push(n):n&&n.length&&"string"!==r&&s(n)})})(arguments),r?o=a.length:t&&(i=n,l(t))}return this},remove:function(){return a&&x.each(arguments,function(e,t){var n;while((n=x.inArray(t,a,n))>-1)a.splice(n,1),r&&(o>=n&&o--,s>=n&&s--)}),this},has:function(e){return e?x.inArray(e,a)>-1:!(!a||!a.length)},empty:function(){return a=[],o=0,this},disable:function(){return a=u=t=undefined,this},disabled:function(){return!a},lock:function(){return u=undefined,t||c.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!a||n&&!u||(t=t||[],t=[e,t.slice?t.slice():t],r?u.push(t):l(t)),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!n}};return c},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var s=o[0],a=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=a&&a.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[s+"With"](this===r?n.promise():this,a?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var s=o[2],a=o[3];r[o[1]]=s.add,a&&s.add(function(){n=a},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=s.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=d.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),s=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?d.call(arguments):r,n===a?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},a,u,l;if(r>1)for(a=Array(r),u=Array(r),l=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(s(t,l,n)).fail(o.reject).progress(s(t,u,a)):--i;return i||o.resolveWith(l,n),o.promise()}}),x.support=function(t){var n=o.createElement("input"),r=o.createDocumentFragment(),i=o.createElement("div"),s=o.createElement("select"),a=s.appendChild(o.createElement("option"));return n.type?(n.type="checkbox",t.checkOn=""!==n.value,t.optSelected=a.selected,t.reliableMarginRight=!0,t.boxSizingReliable=!0,t.pixelPosition=!1,n.checked=!0,t.noCloneChecked=n.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!a.disabled,n=o.createElement("input"),n.value="t",n.type="radio",t.radioValue="t"===n.value,n.setAttribute("checked","t"),n.setAttribute("name","t"),r.appendChild(n),t.checkClone=r.cloneNode(!0).cloneNode(!0).lastChild.checked,t.focusinBubbles="onfocusin"in e,i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===i.style.backgroundClip,x(function(){var n,r,s="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",a=o.getElementsByTagName("body")[0];a&&(n=o.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",a.appendChild(n).appendChild(i),i.innerHTML="",i.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",x.swap(a,null!=a.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===i.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(i,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(i,null)||{width:"4px"}).width,r=i.appendChild(o.createElement("div")),r.style.cssText=i.style.cssText=s,r.style.marginRight=r.style.width="0",i.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),a.removeChild(n))}),t):t}({});var L,q,H=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,O=/([A-Z])/g;function F(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=x.expando+Math.random()}F.uid=1,F.accepts=function(e){return e.nodeType?1===e.nodeType||9===e.nodeType:!0},F.prototype={key:function(e){if(!F.accepts(e))return 0;var t={},n=e[this.expando];if(!n){n=F.uid++;try{t[this.expando]={value:n},Object.defineProperties(e,t)}catch(r){t[this.expando]=n,x.extend(e,t)}}return this.cache[n]||(this.cache[n]={}),n},set:function(e,t,n){var r,i=this.key(e),o=this.cache[i];if("string"==typeof t)o[t]=n;else if(x.isEmptyObject(o))x.extend(this.cache[i],t);else for(r in t)o[r]=t[r];return o},get:function(e,t){var n=this.cache[this.key(e)];return t===undefined?n:n[t]},access:function(e,t,n){var r;return t===undefined||t&&"string"==typeof t&&n===undefined?(r=this.get(e,t),r!==undefined?r:this.get(e,x.camelCase(t))):(this.set(e,t,n),n!==undefined?n:t)},remove:function(e,t){var n,r,i,o=this.key(e),s=this.cache[o];if(t===undefined)this.cache[o]={};else{x.isArray(t)?r=t.concat(t.map(x.camelCase)):(i=x.camelCase(t),t in s?r=[t,i]:(r=i,r=r in s?[r]:r.match(w)||[])),n=r.length;while(n--)delete s[r[n]]}},hasData:function(e){return!x.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){e[this.expando]&&delete this.cache[e[this.expando]]}},L=new F,q=new F,x.extend({acceptData:F.accepts,hasData:function(e){return L.hasData(e)||q.hasData(e)},data:function(e,t,n){return L.access(e,t,n)},removeData:function(e,t){L.remove(e,t)},_data:function(e,t,n){return q.access(e,t,n)},_removeData:function(e,t){q.remove(e,t)}}),x.fn.extend({data:function(e,t){var n,r,i=this[0],o=0,s=null;if(e===undefined){if(this.length&&(s=L.get(i),1===i.nodeType&&!q.get(i,"hasDataAttrs"))){for(n=i.attributes;n.length>o;o++)r=n[o].name,0===r.indexOf("data-")&&(r=x.camelCase(r.slice(5)),P(i,r,s[r]));q.set(i,"hasDataAttrs",!0)}return s}return"object"==typeof e?this.each(function(){L.set(this,e)}):x.access(this,function(t){var n,r=x.camelCase(e);if(i&&t===undefined){if(n=L.get(i,e),n!==undefined)return n;if(n=L.get(i,r),n!==undefined)return n;if(n=P(i,r,undefined),n!==undefined)return n}else this.each(function(){var n=L.get(this,r);L.set(this,r,t),-1!==e.indexOf("-")&&n!==undefined&&L.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){L.remove(this,e)})}});function P(e,t,n){var r;if(n===undefined&&1===e.nodeType)if(r="data-"+t.replace(O,"-$1").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n="true"===n?!0:"false"===n?!1:"null"===n?null:+n+""===n?+n:H.test(n)?JSON.parse(n):n}catch(i){}L.set(e,t,n)}else n=undefined;return n}x.extend({queue:function(e,t,n){var r;return e?(t=(t||"fx")+"queue",r=q.get(e,t),n&&(!r||x.isArray(n)?r=q.access(e,t,x.makeArray(n)):r.push(n)),r||[]):undefined},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),s=function(){x.dequeue(e,t)
                };"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,s,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return q.get(e,n)||q.access(e,n,{empty:x.Callbacks("once memory").add(function(){q.remove(e,[t+"queue",n])})})}}),x.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),n>arguments.length?x.queue(this[0],e):t===undefined?this:this.each(function(){var n=x.queue(this,e,t);x._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=x.Deferred(),o=this,s=this.length,a=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=undefined),e=e||"fx";while(s--)n=q.get(o[s],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(a));return a(),i.promise(t)}});var R,M,W=/[\t\r\n\f]/g,$=/\r/g,B=/^(?:input|select|textarea|button)$/i;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[x.propFix[e]||e]})},addClass:function(e){var t,n,r,i,o,s=0,a=this.length,u="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];a>s;s++)if(n=this[s],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(W," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,s=0,a=this.length,u=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];a>s;s++)if(n=this[s],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(W," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,i=0,o=x(this),s=e.match(w)||[];while(t=s[i++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===r||"boolean"===n)&&(this.className&&q.set(this,"__className__",this.className),this.className=this.className||e===!1?"":q.get(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(W," ").indexOf(t)>=0)return!0;return!1},val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=x.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,x(this).val()):e,null==i?i="":"number"==typeof i?i+="":x.isArray(i)&&(i=x.map(i,function(e){return null==e?"":e+""})),t=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&t.set(this,i,"value")!==undefined||(this.value=i))});if(i)return t=x.valHooks[i.type]||x.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&(n=t.get(i,"value"))!==undefined?n:(n=i.value,"string"==typeof n?n.replace($,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,s=o?null:[],a=o?i+1:r.length,u=0>i?a:o?i:0;for(;a>u;u++)if(n=r[u],!(!n.selected&&u!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),s=i.length;while(s--)r=i[s],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,t,n){var i,o,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===r?x.prop(e,t,n):(1===s&&x.isXMLDoc(e)||(t=t.toLowerCase(),i=x.attrHooks[t]||(x.expr.match.bool.test(t)?M:R)),n===undefined?i&&"get"in i&&null!==(o=i.get(e,t))?o:(o=x.find.attr(e,t),null==o?undefined:o):null!==n?i&&"set"in i&&(o=i.set(e,n,t))!==undefined?o:(e.setAttribute(t,n+""),n):(x.removeAttr(e,t),undefined))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(w);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)&&(e[r]=!1),e.removeAttribute(n)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,t,n){var r,i,o,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return o=1!==s||!x.isXMLDoc(e),o&&(t=x.propFix[t]||t,i=x.propHooks[t]),n!==undefined?i&&"set"in i&&(r=i.set(e,n,t))!==undefined?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||B.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),M={set:function(e,t,n){return t===!1?x.removeAttr(e,n):e.setAttribute(n,n),n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,t){var n=x.expr.attrHandle[t]||x.find.attr;x.expr.attrHandle[t]=function(e,t,r){var i=x.expr.attrHandle[t],o=r?undefined:(x.expr.attrHandle[t]=undefined)!=n(e,t,r)?t.toLowerCase():null;return x.expr.attrHandle[t]=i,o}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,t){return x.isArray(t)?e.checked=x.inArray(x(e).val(),t)>=0:undefined}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var I=/^key/,z=/^(?:mouse|contextmenu)|click/,_=/^(?:focusinfocus|focusoutblur)$/,X=/^([^.]*)(?:\.(.+)|)$/;function U(){return!0}function Y(){return!1}function V(){try{return o.activeElement}catch(e){}}x.event={global:{},add:function(e,t,n,i,o){var s,a,u,l,c,p,f,h,d,g,m,y=q.get(e);if(y){n.handler&&(s=n,n=s.handler,o=s.selector),n.guid||(n.guid=x.guid++),(l=y.events)||(l=y.events={}),(a=y.handle)||(a=y.handle=function(e){return typeof x===r||e&&x.event.triggered===e.type?undefined:x.event.dispatch.apply(a.elem,arguments)},a.elem=e),t=(t||"").match(w)||[""],c=t.length;while(c--)u=X.exec(t[c])||[],d=m=u[1],g=(u[2]||"").split(".").sort(),d&&(f=x.event.special[d]||{},d=(o?f.delegateType:f.bindType)||d,f=x.event.special[d]||{},p=x.extend({type:d,origType:m,data:i,handler:n,guid:n.guid,selector:o,needsContext:o&&x.expr.match.needsContext.test(o),namespace:g.join(".")},s),(h=l[d])||(h=l[d]=[],h.delegateCount=0,f.setup&&f.setup.call(e,i,g,a)!==!1||e.addEventListener&&e.addEventListener(d,a,!1)),f.add&&(f.add.call(e,p),p.handler.guid||(p.handler.guid=n.guid)),o?h.splice(h.delegateCount++,0,p):h.push(p),x.event.global[d]=!0);e=null}},remove:function(e,t,n,r,i){var o,s,a,u,l,c,p,f,h,d,g,m=q.hasData(e)&&q.get(e);if(m&&(u=m.events)){t=(t||"").match(w)||[""],l=t.length;while(l--)if(a=X.exec(t[l])||[],h=g=a[1],d=(a[2]||"").split(".").sort(),h){p=x.event.special[h]||{},h=(r?p.delegateType:p.bindType)||h,f=u[h]||[],a=a[2]&&RegExp("(^|\\.)"+d.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=o=f.length;while(o--)c=f[o],!i&&g!==c.origType||n&&n.guid!==c.guid||a&&!a.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(f.splice(o,1),c.selector&&f.delegateCount--,p.remove&&p.remove.call(e,c));s&&!f.length&&(p.teardown&&p.teardown.call(e,d,m.handle)!==!1||x.removeEvent(e,h,m.handle),delete u[h])}else for(h in u)x.event.remove(e,h+t[l],n,r,!0);x.isEmptyObject(u)&&(delete m.handle,q.remove(e,"events"))}},trigger:function(t,n,r,i){var s,a,u,l,c,p,f,h=[r||o],d=y.call(t,"type")?t.type:t,g=y.call(t,"namespace")?t.namespace.split("."):[];if(a=u=r=r||o,3!==r.nodeType&&8!==r.nodeType&&!_.test(d+x.event.triggered)&&(d.indexOf(".")>=0&&(g=d.split("."),d=g.shift(),g.sort()),c=0>d.indexOf(":")&&"on"+d,t=t[x.expando]?t:new x.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=g.join("."),t.namespace_re=t.namespace?RegExp("(^|\\.)"+g.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=undefined,t.target||(t.target=r),n=null==n?[t]:x.makeArray(n,[t]),f=x.event.special[d]||{},i||!f.trigger||f.trigger.apply(r,n)!==!1)){if(!i&&!f.noBubble&&!x.isWindow(r)){for(l=f.delegateType||d,_.test(l+d)||(a=a.parentNode);a;a=a.parentNode)h.push(a),u=a;u===(r.ownerDocument||o)&&h.push(u.defaultView||u.parentWindow||e)}s=0;while((a=h[s++])&&!t.isPropagationStopped())t.type=s>1?l:f.bindType||d,p=(q.get(a,"events")||{})[t.type]&&q.get(a,"handle"),p&&p.apply(a,n),p=c&&a[c],p&&x.acceptData(a)&&p.apply&&p.apply(a,n)===!1&&t.preventDefault();return t.type=d,i||t.isDefaultPrevented()||f._default&&f._default.apply(h.pop(),n)!==!1||!x.acceptData(r)||c&&x.isFunction(r[d])&&!x.isWindow(r)&&(u=r[c],u&&(r[c]=null),x.event.triggered=d,r[d](),x.event.triggered=undefined,u&&(r[c]=u)),t.result}},dispatch:function(e){e=x.event.fix(e);var t,n,r,i,o,s=[],a=d.call(arguments),u=(q.get(this,"events")||{})[e.type]||[],l=x.event.special[e.type]||{};if(a[0]=e,e.delegateTarget=this,!l.preDispatch||l.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),t=0;while((i=s[t++])&&!e.isPropagationStopped()){e.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(o.namespace))&&(e.handleObj=o,e.data=o.data,r=((x.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,a),r!==undefined&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return l.postDispatch&&l.postDispatch.call(this,e),e.result}},handlers:function(e,t){var n,r,i,o,s=[],a=t.delegateCount,u=e.target;if(a&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!==this;u=u.parentNode||this)if(u.disabled!==!0||"click"!==e.type){for(r=[],n=0;a>n;n++)o=t[n],i=o.selector+" ",r[i]===undefined&&(r[i]=o.needsContext?x(i,this).index(u)>=0:x.find(i,this,null,[u]).length),r[i]&&r.push(o);r.length&&s.push({elem:u,handlers:r})}return t.length>a&&s.push({elem:this,handlers:t.slice(a)}),s},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,t){var n,r,i,s=t.button;return null==e.pageX&&null!=t.clientX&&(n=e.target.ownerDocument||o,r=n.documentElement,i=n.body,e.pageX=t.clientX+(r&&r.scrollLeft||i&&i.scrollLeft||0)-(r&&r.clientLeft||i&&i.clientLeft||0),e.pageY=t.clientY+(r&&r.scrollTop||i&&i.scrollTop||0)-(r&&r.clientTop||i&&i.clientTop||0)),e.which||s===undefined||(e.which=1&s?1:2&s?3:4&s?2:0),e}},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,s=e,a=this.fixHooks[i];a||(this.fixHooks[i]=a=z.test(i)?this.mouseHooks:I.test(i)?this.keyHooks:{}),r=a.props?this.props.concat(a.props):this.props,e=new x.Event(s),t=r.length;while(t--)n=r[t],e[n]=s[n];return e.target||(e.target=o),3===e.target.nodeType&&(e.target=e.target.parentNode),a.filter?a.filter(e,s):e},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==V()&&this.focus?(this.focus(),!1):undefined},delegateType:"focusin"},blur:{trigger:function(){return this===V()&&this.blur?(this.blur(),!1):undefined},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&x.nodeName(this,"input")?(this.click(),!1):undefined},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==undefined&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)},x.Event=function(e,t){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.getPreventDefault&&e.getPreventDefault()?U:Y):this.type=e,t&&x.extend(this,t),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,undefined):new x.Event(e,t)},x.Event.prototype={isDefaultPrevented:Y,isPropagationStopped:Y,isImmediatePropagationStopped:Y,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=U,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=U,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=U,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&o.addEventListener(e,r,!0)},teardown:function(){0===--n&&o.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,t,n,r,i){var o,s;if("object"==typeof e){"string"!=typeof t&&(n=n||t,t=undefined);for(s in e)this.on(s,t,n,e[s],i);return this}if(null==n&&null==r?(r=t,n=t=undefined):null==r&&("string"==typeof t?(r=n,n=undefined):(r=n,n=t,t=undefined)),r===!1)r=Y;else if(!r)return this;return 1===i&&(o=r,r=function(e){return x().off(e),o.apply(this,arguments)},r.guid=o.guid||(o.guid=x.guid++)),this.each(function(){x.event.add(this,e,r,n,t)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,x(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return(t===!1||"function"==typeof t)&&(n=t,t=undefined),n===!1&&(n=Y),this.each(function(){x.event.remove(this,e,n,t)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];return n?x.event.trigger(e,t,n,!0):undefined}});var G=/^.[^:#\[\.,]*$/,J=/^(?:parents|prev(?:Until|All))/,Q=x.expr.match.needsContext,K={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t=x(e,this),n=t.length;return this.filter(function(){var e=0;for(;n>e;e++)if(x.contains(this,t[e]))return!0})},not:function(e){return this.pushStack(et(this,e||[],!0))},filter:function(e){return this.pushStack(et(this,e||[],!1))},is:function(e){return!!et(this,"string"==typeof e&&Q.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],s=Q.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(s?s.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?g.call(x(e),this[0]):g.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function Z(e,t){while((e=e[t])&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return Z(e,"nextSibling")},prev:function(e){return Z(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return e.contentDocument||x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(K[e]||x.unique(i),J.test(e)&&i.reverse()),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,t,n){var r=[],i=n!==undefined;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&x(e).is(n))break;r.push(e)}return r},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function et(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(G.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return g.call(t,e)>=0!==n})}var tt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,nt=/<([\w:]+)/,rt=/<|&#?\w+;/,it=/<(?:script|style|link)/i,ot=/^(?:checkbox|radio)$/i,st=/checked\s*(?:[^=]|=\s*.checked.)/i,at=/^$|\/(?:java|ecma)script/i,ut=/^true\/(.*)/,lt=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ct={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ct.optgroup=ct.option,ct.tbody=ct.tfoot=ct.colgroup=ct.caption=ct.thead,ct.th=ct.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===undefined?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||o).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=pt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=pt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(mt(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&dt(mt(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++)1===e.nodeType&&(x.cleanData(mt(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var t=this[0]||{},n=0,r=this.length;if(e===undefined&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!it.test(e)&&!ct[(nt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(tt,"<$1></$2>");try{for(;r>n;n++)t=this[n]||{},1===t.nodeType&&(x.cleanData(mt(t,!1)),t.innerHTML=e);t=0}catch(i){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=f.apply([],e);var r,i,o,s,a,u,l=0,c=this.length,p=this,h=c-1,d=e[0],g=x.isFunction(d);if(g||!(1>=c||"string"!=typeof d||x.support.checkClone)&&st.test(d))return this.each(function(r){var i=p.eq(r);g&&(e[0]=d.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(r=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),i=r.firstChild,1===r.childNodes.length&&(r=i),i)){for(o=x.map(mt(r,"script"),ft),s=o.length;c>l;l++)a=r,l!==h&&(a=x.clone(a,!0,!0),s&&x.merge(o,mt(a,"script"))),t.call(this[l],a,l);if(s)for(u=o[o.length-1].ownerDocument,x.map(o,ht),l=0;s>l;l++)a=o[l],at.test(a.type||"")&&!q.access(a,"globalEval")&&x.contains(u,a)&&(a.src?x._evalUrl(a.src):x.globalEval(a.textContent.replace(lt,"")))}return this}}),x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=[],i=x(e),o=i.length-1,s=0;for(;o>=s;s++)n=s===o?this:this.clone(!0),x(i[s])[t](n),h.apply(r,n.get());return this.pushStack(r)}}),x.extend({clone:function(e,t,n){var r,i,o,s,a=e.cloneNode(!0),u=x.contains(e.ownerDocument,e);if(!(x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(s=mt(a),o=mt(e),r=0,i=o.length;i>r;r++)yt(o[r],s[r]);if(t)if(n)for(o=o||mt(e),s=s||mt(a),r=0,i=o.length;i>r;r++)gt(o[r],s[r]);else gt(e,a);return s=mt(a,"script"),s.length>0&&dt(s,!u&&mt(e,"script")),a},buildFragment:function(e,t,n,r){var i,o,s,a,u,l,c=0,p=e.length,f=t.createDocumentFragment(),h=[];for(;p>c;c++)if(i=e[c],i||0===i)if("object"===x.type(i))x.merge(h,i.nodeType?[i]:i);else if(rt.test(i)){o=o||f.appendChild(t.createElement("div")),s=(nt.exec(i)||["",""])[1].toLowerCase(),a=ct[s]||ct._default,o.innerHTML=a[1]+i.replace(tt,"<$1></$2>")+a[2],l=a[0];while(l--)o=o.lastChild;x.merge(h,o.childNodes),o=f.firstChild,o.textContent=""}else h.push(t.createTextNode(i));f.textContent="",c=0;while(i=h[c++])if((!r||-1===x.inArray(i,r))&&(u=x.contains(i.ownerDocument,i),o=mt(f.appendChild(i),"script"),u&&dt(o),n)){l=0;while(i=o[l++])at.test(i.type||"")&&n.push(i)}return f},cleanData:function(e){var t,n,r,i,o,s,a=x.event.special,u=0;for(;(n=e[u])!==undefined;u++){if(F.accepts(n)&&(o=n[q.expando],o&&(t=q.cache[o]))){if(r=Object.keys(t.events||{}),r.length)for(s=0;(i=r[s])!==undefined;s++)a[i]?x.event.remove(n,i):x.removeEvent(n,i,t.handle);q.cache[o]&&delete q.cache[o]}delete L.cache[n[L.expando]]}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}});function pt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function ft(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function ht(e){var t=ut.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function dt(e,t){var n=e.length,r=0;for(;n>r;r++)q.set(e[r],"globalEval",!t||q.get(t[r],"globalEval"))}function gt(e,t){var n,r,i,o,s,a,u,l;if(1===t.nodeType){if(q.hasData(e)&&(o=q.access(e),s=q.set(t,o),l=o.events)){delete s.handle,s.events={};for(i in l)for(n=0,r=l[i].length;r>n;n++)x.event.add(t,i,l[i][n])}L.hasData(e)&&(a=L.access(e),u=x.extend({},a),L.set(t,u))}}function mt(e,t){var n=e.getElementsByTagName?e.getElementsByTagName(t||"*"):e.querySelectorAll?e.querySelectorAll(t||"*"):[];return t===undefined||t&&x.nodeName(e,t)?x.merge([e],n):n}function yt(e,t){var n=t.nodeName.toLowerCase();"input"===n&&ot.test(e.type)?t.checked=e.checked:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}x.fn.extend({wrapAll:function(e){var t;return x.isFunction(e)?this.each(function(t){x(this).wrapAll(e.call(this,t))}):(this[0]&&(t=x(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var vt,xt,bt=/^(none|table(?!-c[ea]).+)/,wt=/^margin/,Tt=RegExp("^("+b+")(.*)$","i"),Ct=RegExp("^("+b+")(?!px)[a-z%]+$","i"),kt=RegExp("^([+-])=("+b+")","i"),Nt={BODY:"block"},Et={position:"absolute",visibility:"hidden",display:"block"},St={letterSpacing:0,fontWeight:400},jt=["Top","Right","Bottom","Left"],Dt=["Webkit","O","Moz","ms"];function At(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=Dt.length;while(i--)if(t=Dt[i]+n,t in e)return t;return r}function Lt(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function qt(t){return e.getComputedStyle(t,null)}function Ht(e,t){var n,r,i,o=[],s=0,a=e.length;for(;a>s;s++)r=e[s],r.style&&(o[s]=q.get(r,"olddisplay"),n=r.style.display,t?(o[s]||"none"!==n||(r.style.display=""),""===r.style.display&&Lt(r)&&(o[s]=q.access(r,"olddisplay",Rt(r.nodeName)))):o[s]||(i=Lt(r),(n&&"none"!==n||!i)&&q.set(r,"olddisplay",i?n:x.css(r,"display"))));for(s=0;a>s;s++)r=e[s],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[s]||"":"none"));return e}x.fn.extend({css:function(e,t){return x.access(this,function(e,t,n){var r,i,o={},s=0;if(x.isArray(t)){for(r=qt(e),i=t.length;i>s;s++)o[t[s]]=x.css(e,t[s],!1,r);return o}return n!==undefined?x.style(e,t,n):x.css(e,t)},e,t,arguments.length>1)},show:function(){return Ht(this,!0)},hide:function(){return Ht(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){Lt(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=vt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,s,a=x.camelCase(t),u=e.style;return t=x.cssProps[a]||(x.cssProps[a]=At(u,a)),s=x.cssHooks[t]||x.cssHooks[a],n===undefined?s&&"get"in s&&(i=s.get(e,!1,r))!==undefined?i:u[t]:(o=typeof n,"string"===o&&(i=kt.exec(n))&&(n=(i[1]+1)*i[2]+parseFloat(x.css(e,t)),o="number"),null==n||"number"===o&&isNaN(n)||("number"!==o||x.cssNumber[a]||(n+="px"),x.support.clearCloneStyle||""!==n||0!==t.indexOf("background")||(u[t]="inherit"),s&&"set"in s&&(n=s.set(e,n,r))===undefined||(u[t]=n)),undefined)}},css:function(e,t,n,r){var i,o,s,a=x.camelCase(t);return t=x.cssProps[a]||(x.cssProps[a]=At(e.style,a)),s=x.cssHooks[t]||x.cssHooks[a],s&&"get"in s&&(i=s.get(e,!0,n)),i===undefined&&(i=vt(e,t,r)),"normal"===i&&t in St&&(i=St[t]),""===n||n?(o=parseFloat(i),n===!0||x.isNumeric(o)?o||0:i):i}}),vt=function(e,t,n){var r,i,o,s=n||qt(e),a=s?s.getPropertyValue(t)||s[t]:undefined,u=e.style;return s&&(""!==a||x.contains(e.ownerDocument,e)||(a=x.style(e,t)),Ct.test(a)&&wt.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=s.width,u.width=r,u.minWidth=i,u.maxWidth=o)),a};function Ot(e,t,n){var r=Tt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function Ft(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,s=0;for(;4>o;o+=2)"margin"===n&&(s+=x.css(e,n+jt[o],!0,i)),r?("content"===n&&(s-=x.css(e,"padding"+jt[o],!0,i)),"margin"!==n&&(s-=x.css(e,"border"+jt[o]+"Width",!0,i))):(s+=x.css(e,"padding"+jt[o],!0,i),"padding"!==n&&(s+=x.css(e,"border"+jt[o]+"Width",!0,i)));return s}function Pt(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=qt(e),s=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=vt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Ct.test(i))return i;r=s&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+Ft(e,t,n||(s?"border":"content"),r,o)+"px"}function Rt(e){var t=o,n=Nt[e];return n||(n=Mt(e,t),"none"!==n&&n||(xt=(xt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(xt[0].contentWindow||xt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=Mt(e,t),xt.detach()),Nt[e]=n),n}function Mt(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,t){x.cssHooks[t]={get:function(e,n,r){return n?0===e.offsetWidth&&bt.test(x.css(e,"display"))?x.swap(e,Et,function(){return Pt(e,t,r)}):Pt(e,t,r):undefined},set:function(e,n,r){var i=r&&qt(e);return Ot(e,n,r?Ft(e,t,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,t){return t?x.swap(e,{display:"inline-block"},vt,[e,"marginRight"]):undefined}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,t){x.cssHooks[t]={get:function(e,n){return n?(n=vt(e,t),Ct.test(n)?x(e).position()[t]+"px":n):undefined}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+jt[r]+t]=o[r]||o[r-2]||o[0];return i}},wt.test(e)||(x.cssHooks[e+t].set=Ot)});var Wt=/%20/g,$t=/\[\]$/,Bt=/\r?\n/g,It=/^(?:submit|button|image|reset|file)$/i,zt=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&zt.test(this.nodeName)&&!It.test(e)&&(this.checked||!ot.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(Bt,"\r\n")}}):{name:t.name,value:n.replace(Bt,"\r\n")}}).get()}}),x.param=function(e,t){var n,r=[],i=function(e,t){t=x.isFunction(t)?t():null==t?"":t,r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(t===undefined&&(t=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){i(this.name,this.value)});else for(n in e)_t(n,e[n],t,i);return r.join("&").replace(Wt,"+")};function _t(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||$t.test(e)?r(e,i):_t(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)_t(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)
                },delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var Xt,Ut,Yt=x.now(),Vt=/\?/,Gt=/#.*$/,Jt=/([?&])_=[^&]*/,Qt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Kt=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Zt=/^(?:GET|HEAD)$/,en=/^\/\//,tn=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,nn=x.fn.load,rn={},on={},sn="*/".concat("*");try{Ut=i.href}catch(an){Ut=o.createElement("a"),Ut.href="",Ut=Ut.href}Xt=tn.exec(Ut.toLowerCase())||[];function un(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(w)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function ln(e,t,n,r){var i={},o=e===on;function s(a){var u;return i[a]=!0,x.each(e[a]||[],function(e,a){var l=a(t,n,r);return"string"!=typeof l||o||i[l]?o?!(u=l):undefined:(t.dataTypes.unshift(l),s(l),!1)}),u}return s(t.dataTypes[0])||!i["*"]&&s("*")}function cn(e,t){var n,r,i=x.ajaxSettings.flatOptions||{};for(n in t)t[n]!==undefined&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,t,n){if("string"!=typeof e&&nn)return nn.apply(this,arguments);var r,i,o,s=this,a=e.indexOf(" ");return a>=0&&(r=e.slice(a),e=e.slice(0,a)),x.isFunction(t)?(n=t,t=undefined):t&&"object"==typeof t&&(i="POST"),s.length>0&&x.ajax({url:e,type:i,dataType:"html",data:t}).done(function(e){o=arguments,s.html(r?x("<div>").append(x.parseHTML(e)).find(r):e)}).complete(n&&function(e,t){s.each(n,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ut,type:"GET",isLocal:Kt.test(Xt[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":sn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?cn(cn(e,x.ajaxSettings),t):cn(x.ajaxSettings,e)},ajaxPrefilter:un(rn),ajaxTransport:un(on),ajax:function(e,t){"object"==typeof e&&(t=e,e=undefined),t=t||{};var n,r,i,o,s,a,u,l,c=x.ajaxSetup({},t),p=c.context||c,f=c.context&&(p.nodeType||p.jquery)?x(p):x.event,h=x.Deferred(),d=x.Callbacks("once memory"),g=c.statusCode||{},m={},y={},v=0,b="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(2===v){if(!o){o={};while(t=Qt.exec(i))o[t[1].toLowerCase()]=t[2]}t=o[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===v?i:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return v||(e=y[n]=y[n]||e,m[e]=t),this},overrideMimeType:function(e){return v||(c.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>v)for(t in e)g[t]=[g[t],e[t]];else T.always(e[T.status]);return this},abort:function(e){var t=e||b;return n&&n.abort(t),k(0,t),this}};if(h.promise(T).complete=d.add,T.success=T.done,T.error=T.fail,c.url=((e||c.url||Ut)+"").replace(Gt,"").replace(en,Xt[1]+"//"),c.type=t.method||t.type||c.method||c.type,c.dataTypes=x.trim(c.dataType||"*").toLowerCase().match(w)||[""],null==c.crossDomain&&(a=tn.exec(c.url.toLowerCase()),c.crossDomain=!(!a||a[1]===Xt[1]&&a[2]===Xt[2]&&(a[3]||("http:"===a[1]?"80":"443"))===(Xt[3]||("http:"===Xt[1]?"80":"443")))),c.data&&c.processData&&"string"!=typeof c.data&&(c.data=x.param(c.data,c.traditional)),ln(rn,c,t,T),2===v)return T;u=c.global,u&&0===x.active++&&x.event.trigger("ajaxStart"),c.type=c.type.toUpperCase(),c.hasContent=!Zt.test(c.type),r=c.url,c.hasContent||(c.data&&(r=c.url+=(Vt.test(r)?"&":"?")+c.data,delete c.data),c.cache===!1&&(c.url=Jt.test(r)?r.replace(Jt,"$1_="+Yt++):r+(Vt.test(r)?"&":"?")+"_="+Yt++)),c.ifModified&&(x.lastModified[r]&&T.setRequestHeader("If-Modified-Since",x.lastModified[r]),x.etag[r]&&T.setRequestHeader("If-None-Match",x.etag[r])),(c.data&&c.hasContent&&c.contentType!==!1||t.contentType)&&T.setRequestHeader("Content-Type",c.contentType),T.setRequestHeader("Accept",c.dataTypes[0]&&c.accepts[c.dataTypes[0]]?c.accepts[c.dataTypes[0]]+("*"!==c.dataTypes[0]?", "+sn+"; q=0.01":""):c.accepts["*"]);for(l in c.headers)T.setRequestHeader(l,c.headers[l]);if(c.beforeSend&&(c.beforeSend.call(p,T,c)===!1||2===v))return T.abort();b="abort";for(l in{success:1,error:1,complete:1})T[l](c[l]);if(n=ln(on,c,t,T)){T.readyState=1,u&&f.trigger("ajaxSend",[T,c]),c.async&&c.timeout>0&&(s=setTimeout(function(){T.abort("timeout")},c.timeout));try{v=1,n.send(m,k)}catch(C){if(!(2>v))throw C;k(-1,C)}}else k(-1,"No Transport");function k(e,t,o,a){var l,m,y,b,w,C=t;2!==v&&(v=2,s&&clearTimeout(s),n=undefined,i=a||"",T.readyState=e>0?4:0,l=e>=200&&300>e||304===e,o&&(b=pn(c,T,o)),b=fn(c,b,T,l),l?(c.ifModified&&(w=T.getResponseHeader("Last-Modified"),w&&(x.lastModified[r]=w),w=T.getResponseHeader("etag"),w&&(x.etag[r]=w)),204===e||"HEAD"===c.type?C="nocontent":304===e?C="notmodified":(C=b.state,m=b.data,y=b.error,l=!y)):(y=C,(e||!C)&&(C="error",0>e&&(e=0))),T.status=e,T.statusText=(t||C)+"",l?h.resolveWith(p,[m,C,T]):h.rejectWith(p,[T,C,y]),T.statusCode(g),g=undefined,u&&f.trigger(l?"ajaxSuccess":"ajaxError",[T,c,l?m:y]),d.fireWith(p,[T,C]),u&&(f.trigger("ajaxComplete",[T,c]),--x.active||x.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,t){return x.get(e,undefined,t,"script")}}),x.each(["get","post"],function(e,t){x[t]=function(e,n,r,i){return x.isFunction(n)&&(i=i||r,r=n,n=undefined),x.ajax({url:e,type:t,dataType:i,data:n,success:r})}});function pn(e,t,n){var r,i,o,s,a=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),r===undefined&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in a)if(a[i]&&a[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}s||(s=i)}o=o||s}return o?(o!==u[0]&&u.unshift(o),n[o]):undefined}function fn(e,t,n,r){var i,o,s,a,u,l={},c=e.dataTypes.slice();if(c[1])for(s in e.converters)l[s.toLowerCase()]=e.converters[s];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(s=l[u+" "+o]||l["* "+o],!s)for(i in l)if(a=i.split(" "),a[1]===o&&(s=l[u+" "+a[0]]||l["* "+a[0]])){s===!0?s=l[i]:l[i]!==!0&&(o=a[0],c.unshift(a[1]));break}if(s!==!0)if(s&&e["throws"])t=s(t);else try{t=s(t)}catch(p){return{state:"parsererror",error:s?p:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===undefined&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),x.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=x("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),o.head.appendChild(t[0])},abort:function(){n&&n()}}}});var hn=[],dn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=hn.pop()||x.expando+"_"+Yt++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,s,a=t.jsonp!==!1&&(dn.test(t.url)?"url":"string"==typeof t.data&&!(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&dn.test(t.data)&&"data");return a||"jsonp"===t.dataTypes[0]?(i=t.jsonpCallback=x.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,a?t[a]=t[a].replace(dn,"$1"+i):t.jsonp!==!1&&(t.url+=(Vt.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return s||x.error(i+" was not called"),s[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){s=arguments},r.always(function(){e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,hn.push(i)),s&&x.isFunction(o)&&o(s[0]),s=o=undefined}),"script"):undefined}),x.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var gn=x.ajaxSettings.xhr(),mn={0:200,1223:204},yn=0,vn={};e.ActiveXObject&&x(e).on("unload",function(){for(var e in vn)vn[e]();vn=undefined}),x.support.cors=!!gn&&"withCredentials"in gn,x.support.ajax=gn=!!gn,x.ajaxTransport(function(e){var t;return x.support.cors||gn&&!e.crossDomain?{send:function(n,r){var i,o,s=e.xhr();if(s.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(i in e.xhrFields)s[i]=e.xhrFields[i];e.mimeType&&s.overrideMimeType&&s.overrideMimeType(e.mimeType),e.crossDomain||n["X-Requested-With"]||(n["X-Requested-With"]="XMLHttpRequest");for(i in n)s.setRequestHeader(i,n[i]);t=function(e){return function(){t&&(delete vn[o],t=s.onload=s.onerror=null,"abort"===e?s.abort():"error"===e?r(s.status||404,s.statusText):r(mn[s.status]||s.status,s.statusText,"string"==typeof s.responseText?{text:s.responseText}:undefined,s.getAllResponseHeaders()))}},s.onload=t(),s.onerror=t("error"),t=vn[o=yn++]=t("abort"),s.send(e.hasContent&&e.data||null)},abort:function(){t&&t()}}:undefined});var xn,bn,wn=/^(?:toggle|show|hide)$/,Tn=RegExp("^(?:([+-])=|)("+b+")([a-z%]*)$","i"),Cn=/queueHooks$/,kn=[An],Nn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Tn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),s=(x.cssNumber[e]||"px"!==o&&+r)&&Tn.exec(x.css(n.elem,e)),a=1,u=20;if(s&&s[3]!==o){o=o||s[3],i=i||[],s=+r||1;do a=a||".5",s/=a,x.style(n.elem,e,s+o);while(a!==(a=n.cur()/r)&&1!==a&&--u)}return i&&(s=n.start=+s||+r||0,n.unit=o,n.end=i[1]?s+(i[1]+1)*i[2]:+i[2]),n}]};function En(){return setTimeout(function(){xn=undefined}),xn=x.now()}function Sn(e,t,n){var r,i=(Nn[t]||[]).concat(Nn["*"]),o=0,s=i.length;for(;s>o;o++)if(r=i[o].call(n,t,e))return r}function jn(e,t,n){var r,i,o=0,s=kn.length,a=x.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;var t=xn||En(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,s=0,u=l.tweens.length;for(;u>s;s++)l.tweens[s].run(o);return a.notifyWith(e,[l,o,n]),1>o&&u?n:(a.resolveWith(e,[l]),!1)},l=a.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:xn||En(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?a.resolveWith(e,[l,t]):a.rejectWith(e,[l,t]),this}}),c=l.props;for(Dn(c,l.opts.specialEasing);s>o;o++)if(r=kn[o].call(l,e,c,l.opts))return r;return x.map(c,Sn,l),x.isFunction(l.opts.start)&&l.opts.start.call(e,l),x.fx.timer(x.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function Dn(e,t){var n,r,i,o,s;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),s=x.cssHooks[r],s&&"expand"in s){o=s.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(jn,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Nn[n]=Nn[n]||[],Nn[n].unshift(t)},prefilter:function(e,t){t?kn.unshift(e):kn.push(e)}});function An(e,t,n){var r,i,o,s,a,u,l=this,c={},p=e.style,f=e.nodeType&&Lt(e),h=q.get(e,"fxshow");n.queue||(a=x._queueHooks(e,"fx"),null==a.unqueued&&(a.unqueued=0,u=a.empty.fire,a.empty.fire=function(){a.unqueued||u()}),a.unqueued++,l.always(function(){l.always(function(){a.unqueued--,x.queue(e,"fx").length||a.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(p.display="inline-block")),n.overflow&&(p.overflow="hidden",l.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],wn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show")){if("show"!==i||!h||h[r]===undefined)continue;f=!0}c[r]=h&&h[r]||x.style(e,r)}if(!x.isEmptyObject(c)){h?"hidden"in h&&(f=h.hidden):h=q.access(e,"fxshow",{}),o&&(h.hidden=!f),f?x(e).show():l.done(function(){x(e).hide()}),l.done(function(){var t;q.remove(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)s=Sn(f?h[r]:0,r,l),r in h||(h[r]=s.start,f&&(s.end=s.start,s.start="width"===r||"height"===r?1:0))}}function Ln(e,t,n,r,i){return new Ln.prototype.init(e,t,n,r,i)}x.Tween=Ln,Ln.prototype={constructor:Ln,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=Ln.propHooks[this.prop];return e&&e.get?e.get(this):Ln.propHooks._default.get(this)},run:function(e){var t,n=Ln.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Ln.propHooks._default.set(this),this}},Ln.prototype.init.prototype=Ln.prototype,Ln.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},Ln.propHooks.scrollTop=Ln.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(qn(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Lt).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),s=function(){var t=jn(this,x.extend({},e),o);(i||q.get(this,"finish"))&&t.stop(!0)};return s.finish=s,i||o.queue===!1?this.each(s):this.queue(o.queue,s)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=undefined),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=x.timers,s=q.get(this);if(i)s[i]&&s[i].stop&&r(s[i]);else for(i in s)s[i]&&s[i].stop&&Cn.test(i)&&r(s[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));(t||!n)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=q.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,s=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;s>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function qn(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=jt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:qn("show"),slideUp:qn("hide"),slideToggle:qn("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=Ln.prototype.init,x.fx.tick=function(){var e,t=x.timers,n=0;for(xn=x.now();t.length>n;n++)e=t[n],e()||t[n]!==e||t.splice(n--,1);t.length||x.fx.stop(),xn=undefined},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){bn||(bn=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(bn),bn=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===undefined?this:this.each(function(t){x.offset.setOffset(this,e,t)});var t,n,i=this[0],o={top:0,left:0},s=i&&i.ownerDocument;if(s)return t=s.documentElement,x.contains(t,i)?(typeof i.getBoundingClientRect!==r&&(o=i.getBoundingClientRect()),n=Hn(s),{top:o.top+n.pageYOffset-t.clientTop,left:o.left+n.pageXOffset-t.clientLeft}):o},x.offset={setOffset:function(e,t,n){var r,i,o,s,a,u,l,c=x.css(e,"position"),p=x(e),f={};"static"===c&&(e.style.position="relative"),a=p.offset(),o=x.css(e,"top"),u=x.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=p.position(),s=r.top,i=r.left):(s=parseFloat(o)||0,i=parseFloat(u)||0),x.isFunction(t)&&(t=t.call(e,n,a)),null!=t.top&&(f.top=t.top-a.top+s),null!=t.left&&(f.left=t.left-a.left+i),"using"in t?t.using.call(e,f):p.css(f)}},x.fn.extend({position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===x.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(r=e.offset()),r.top+=x.css(e[0],"borderTopWidth",!0),r.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-r.top-x.css(n,"marginTop",!0),left:t.left-r.left-x.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,n){var r="pageYOffset"===n;x.fn[t]=function(i){return x.access(this,function(t,i,o){var s=Hn(t);return o===undefined?s?s[n]:t[i]:(s?s.scrollTo(r?e.pageXOffset:o,r?o:e.pageYOffset):t[i]=o,undefined)},t,i,arguments.length,null)}});function Hn(e){return x.isWindow(e)?e:9===e.nodeType&&e.defaultView}x.each({Height:"height",Width:"width"},function(e,t){x.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){x.fn[r]=function(r,i){var o=arguments.length&&(n||"boolean"!=typeof r),s=n||(r===!0||i===!0?"margin":"border");return x.access(this,function(t,n,r){var i;return x.isWindow(t)?t.document.documentElement["client"+e]:9===t.nodeType?(i=t.documentElement,Math.max(t.body["scroll"+e],i["scroll"+e],t.body["offset"+e],i["offset"+e],i["client"+e])):r===undefined?x.css(t,n,s):x.style(t,n,r,s)},t,o?r:undefined,o,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}),"object"==typeof e&&"object"==typeof e.document&&(e.jQuery=e.$=x)})(window);
                
                //     Backbone.js 1.1.0
                
                //     (c) 2010-2011 Jeremy Ashkenas, DocumentCloud Inc.
                //     (c) 2011-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                //     Backbone may be freely distributed under the MIT license.
                //     For all details and documentation:
                //     http://backbonejs.org
                
                (function(root, factory) {
                  // Set up Backbone appropriately for the environment.
                  if (typeof exports !== 'undefined') {
                    // Node/CommonJS, no need for jQuery in that case.
                    factory(root, exports, require('underscore'));
                  } else if (typeof define === 'function' && define.amd) {
                    // AMD
                    define('backbone',['underscore', 'jquery', 'exports'], function(_, $, exports) {
                      // Export global even in AMD case in case this script is loaded with
                      // others that may still expect a global Backbone.
                      root.Backbone = factory(root, exports, _, $);
                    });
                  } else {
                    // Browser globals
                    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
                  }
                }(this, function(root, Backbone, _, $) {
                
                  // Initial Setup
                  // -------------
                
                  // Save the previous value of the `Backbone` variable, so that it can be
                  // restored later on, if `noConflict` is used.
                  var previousBackbone = root.Backbone;
                
                  // Create local references to array methods we'll want to use later.
                  var array = [];
                  var push = array.push;
                  var slice = array.slice;
                  var splice = array.splice;
                
                  // Current version of the library. Keep in sync with `package.json`.
                  Backbone.VERSION = '1.1.0';
                
                  // For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.
                  Backbone.$ = $;
                
                  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
                  // to its previous owner. Returns a reference to this Backbone object.
                  Backbone.noConflict = function() {
                    root.Backbone = previousBackbone;
                    return this;
                  };
                
                  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
                  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
                  // set a `X-Http-Method-Override` header.
                  Backbone.emulateHTTP = false;
                
                  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
                  // `application/json` requests ... will encode the body as
                  // `application/x-www-form-urlencoded` instead and will send the model in a
                  // form param named `model`.
                  Backbone.emulateJSON = false;
                
                  // Backbone.Events
                  // ---------------
                
                  // A module that can be mixed in to *any object* in order to provide it with
                  // custom events. You may bind with `on` or remove with `off` callback
                  // functions to an event; `trigger`-ing an event fires all callbacks in
                  // succession.
                  //
                  //     var object = {};
                  //     _.extend(object, Backbone.Events);
                  //     object.on('expand', function(){ alert('expanded'); });
                  //     object.trigger('expand');
                  //
                  var Events = Backbone.Events = {
                
                    // Bind an event to a `callback` function. Passing `"all"` will bind
                    // the callback to all events fired.
                    on: function(name, callback, context) {
                      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
                      this._events || (this._events = {});
                      var events = this._events[name] || (this._events[name] = []);
                      events.push({callback: callback, context: context, ctx: context || this});
                      return this;
                    },
                
                    // Bind an event to only be triggered a single time. After the first time
                    // the callback is invoked, it will be removed.
                    once: function(name, callback, context) {
                      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
                      var self = this;
                      var once = _.once(function() {
                        self.off(name, once);
                        callback.apply(this, arguments);
                      });
                      once._callback = callback;
                      return this.on(name, once, context);
                    },
                
                    // Remove one or many callbacks. If `context` is null, removes all
                    // callbacks with that function. If `callback` is null, removes all
                    // callbacks for the event. If `name` is null, removes all bound
                    // callbacks for all events.
                    off: function(name, callback, context) {
                      var retain, ev, events, names, i, l, j, k;
                      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
                      if (!name && !callback && !context) {
                        this._events = {};
                        return this;
                      }
                      names = name ? [name] : _.keys(this._events);
                      for (i = 0, l = names.length; i < l; i++) {
                        name = names[i];
                        if (events = this._events[name]) {
                          this._events[name] = retain = [];
                          if (callback || context) {
                            for (j = 0, k = events.length; j < k; j++) {
                              ev = events[j];
                              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                                  (context && context !== ev.context)) {
                                retain.push(ev);
                              }
                            }
                          }
                          if (!retain.length) delete this._events[name];
                        }
                      }
                
                      return this;
                    },
                
                    // Trigger one or many events, firing all bound callbacks. Callbacks are
                    // passed the same arguments as `trigger` is, apart from the event name
                    // (unless you're listening on `"all"`, which will cause your callback to
                    // receive the true name of the event as the first argument).
                    trigger: function(name) {
                      if (!this._events) return this;
                      var args = slice.call(arguments, 1);
                      if (!eventsApi(this, 'trigger', name, args)) return this;
                      var events = this._events[name];
                      var allEvents = this._events.all;
                      if (events) triggerEvents(events, args);
                      if (allEvents) triggerEvents(allEvents, arguments);
                      return this;
                    },
                
                    // Tell this object to stop listening to either specific events ... or
                    // to every object it's currently listening to.
                    stopListening: function(obj, name, callback) {
                      var listeningTo = this._listeningTo;
                      if (!listeningTo) return this;
                      var remove = !name && !callback;
                      if (!callback && typeof name === 'object') callback = this;
                      if (obj) (listeningTo = {})[obj._listenId] = obj;
                      for (var id in listeningTo) {
                        obj = listeningTo[id];
                        obj.off(name, callback, this);
                        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
                      }
                      return this;
                    }
                
                  };
                
                  // Regular expression used to split event strings.
                  var eventSplitter = /\s+/;
                
                  // Implement fancy features of the Events API such as multiple event
                  // names `"change blur"` and jQuery-style event maps `{change: action}`
                  // in terms of the existing API.
                  var eventsApi = function(obj, action, name, rest) {
                    if (!name) return true;
                
                    // Handle event maps.
                    if (typeof name === 'object') {
                      for (var key in name) {
                        obj[action].apply(obj, [key, name[key]].concat(rest));
                      }
                      return false;
                    }
                
                    // Handle space separated event names.
                    if (eventSplitter.test(name)) {
                      var names = name.split(eventSplitter);
                      for (var i = 0, l = names.length; i < l; i++) {
                        obj[action].apply(obj, [names[i]].concat(rest));
                      }
                      return false;
                    }
                
                    return true;
                  };
                
                  // A difficult-to-believe, but optimized internal dispatch function for
                  // triggering events. Tries to keep the usual cases speedy (most internal
                  // Backbone events have 3 arguments).
                  var triggerEvents = function(events, args) {
                    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
                    switch (args.length) {
                      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
                      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
                      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
                      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
                      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
                    }
                  };
                
                  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};
                
                  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
                  // listen to an event in another object ... keeping track of what it's
                  // listening to.
                  _.each(listenMethods, function(implementation, method) {
                    Events[method] = function(obj, name, callback) {
                      var listeningTo = this._listeningTo || (this._listeningTo = {});
                      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
                      listeningTo[id] = obj;
                      if (!callback && typeof name === 'object') callback = this;
                      obj[implementation](name, callback, this);
                      return this;
                    };
                  });
                
                  // Aliases for backwards compatibility.
                  Events.bind   = Events.on;
                  Events.unbind = Events.off;
                
                  // Allow the `Backbone` object to serve as a global event bus, for folks who
                  // want global "pubsub" in a convenient place.
                  _.extend(Backbone, Events);
                
                  // Backbone.Model
                  // --------------
                
                  // Backbone **Models** are the basic data object in the framework --
                  // frequently representing a row in a table in a database on your server.
                  // A discrete chunk of data and a bunch of useful, related methods for
                  // performing computations and transformations on that data.
                
                  // Create a new model with the specified attributes. A client id (`cid`)
                  // is automatically generated and assigned for you.
                  var Model = Backbone.Model = function(attributes, options) {
                    var attrs = attributes || {};
                    options || (options = {});
                    this.cid = _.uniqueId('c');
                    this.attributes = {};
                    if (options.collection) this.collection = options.collection;
                    if (options.parse) attrs = this.parse(attrs, options) || {};
                    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
                    this.set(attrs, options);
                    this.changed = {};
                    this.initialize.apply(this, arguments);
                  };
                
                  // Attach all inheritable methods to the Model prototype.
                  _.extend(Model.prototype, Events, {
                
                    // A hash of attributes whose current and previous value differ.
                    changed: null,
                
                    // The value returned during the last failed validation.
                    validationError: null,
                
                    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
                    // CouchDB users may want to set this to `"_id"`.
                    idAttribute: 'id',
                
                    // Initialize is an empty function by default. Override it with your own
                    // initialization logic.
                    initialize: function(){},
                
                    // Return a copy of the model's `attributes` object.
                    toJSON: function(options) {
                      return _.clone(this.attributes);
                    },
                
                    // Proxy `Backbone.sync` by default -- but override this if you need
                    // custom syncing semantics for *this* particular model.
                    sync: function() {
                      return Backbone.sync.apply(this, arguments);
                    },
                
                    // Get the value of an attribute.
                    get: function(attr) {
                      return this.attributes[attr];
                    },
                
                    // Get the HTML-escaped value of an attribute.
                    escape: function(attr) {
                      return _.escape(this.get(attr));
                    },
                
                    // Returns `true` if the attribute contains a value that is not null
                    // or undefined.
                    has: function(attr) {
                      return this.get(attr) != null;
                    },
                
                    // Set a hash of model attributes on the object, firing `"change"`. This is
                    // the core primitive operation of a model, updating the data and notifying
                    // anyone who needs to know about the change in state. The heart of the beast.
                    set: function(key, val, options) {
                      var attr, attrs, unset, changes, silent, changing, prev, current;
                      if (key == null) return this;
                
                      // Handle both `"key", value` and `{key: value}` -style arguments.
                      if (typeof key === 'object') {
                        attrs = key;
                        options = val;
                      } else {
                        (attrs = {})[key] = val;
                      }
                
                      options || (options = {});
                
                      // Run validation.
                      if (!this._validate(attrs, options)) return false;
                
                      // Extract attributes and options.
                      unset           = options.unset;
                      silent          = options.silent;
                      changes         = [];
                      changing        = this._changing;
                      this._changing  = true;
                
                      if (!changing) {
                        this._previousAttributes = _.clone(this.attributes);
                        this.changed = {};
                      }
                      current = this.attributes, prev = this._previousAttributes;
                
                      // Check for changes of `id`.
                      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
                
                      // For each `set` attribute, update or delete the current value.
                      for (attr in attrs) {
                        val = attrs[attr];
                        if (!_.isEqual(current[attr], val)) changes.push(attr);
                        if (!_.isEqual(prev[attr], val)) {
                          this.changed[attr] = val;
                        } else {
                          delete this.changed[attr];
                        }
                        unset ? delete current[attr] : current[attr] = val;
                      }
                
                      // Trigger all relevant attribute changes.
                      if (!silent) {
                        if (changes.length) this._pending = true;
                        for (var i = 0, l = changes.length; i < l; i++) {
                          this.trigger('change:' + changes[i], this, current[changes[i]], options);
                        }
                      }
                
                      // You might be wondering why there's a `while` loop here. Changes can
                      // be recursively nested within `"change"` events.
                      if (changing) return this;
                      if (!silent) {
                        while (this._pending) {
                          this._pending = false;
                          this.trigger('change', this, options);
                        }
                      }
                      this._pending = false;
                      this._changing = false;
                      return this;
                    },
                
                    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
                    // if the attribute doesn't exist.
                    unset: function(attr, options) {
                      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
                    },
                
                    // Clear all attributes on the model, firing `"change"`.
                    clear: function(options) {
                      var attrs = {};
                      for (var key in this.attributes) attrs[key] = void 0;
                      return this.set(attrs, _.extend({}, options, {unset: true}));
                    },
                
                    // Determine if the model has changed since the last `"change"` event.
                    // If you specify an attribute name, determine if that attribute has changed.
                    hasChanged: function(attr) {
                      if (attr == null) return !_.isEmpty(this.changed);
                      return _.has(this.changed, attr);
                    },
                
                    // Return an object containing all the attributes that have changed, or
                    // false if there are no changed attributes. Useful for determining what
                    // parts of a view need to be updated and/or what attributes need to be
                    // persisted to the server. Unset attributes will be set to undefined.
                    // You can also pass an attributes object to diff against the model,
                    // determining if there *would be* a change.
                    changedAttributes: function(diff) {
                      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
                      var val, changed = false;
                      var old = this._changing ? this._previousAttributes : this.attributes;
                      for (var attr in diff) {
                        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
                        (changed || (changed = {}))[attr] = val;
                      }
                      return changed;
                    },
                
                    // Get the previous value of an attribute, recorded at the time the last
                    // `"change"` event was fired.
                    previous: function(attr) {
                      if (attr == null || !this._previousAttributes) return null;
                      return this._previousAttributes[attr];
                    },
                
                    // Get all of the attributes of the model at the time of the previous
                    // `"change"` event.
                    previousAttributes: function() {
                      return _.clone(this._previousAttributes);
                    },
                
                    // Fetch the model from the server. If the server's representation of the
                    // model differs from its current attributes, they will be overridden,
                    // triggering a `"change"` event.
                    fetch: function(options) {
                      options = options ? _.clone(options) : {};
                      if (options.parse === void 0) options.parse = true;
                      var model = this;
                      var success = options.success;
                      options.success = function(resp) {
                        if (!model.set(model.parse(resp, options), options)) return false;
                        if (success) success(model, resp, options);
                        model.trigger('sync', model, resp, options);
                      };
                      wrapError(this, options);
                      return this.sync('read', this, options);
                    },
                
                    // Set a hash of model attributes, and sync the model to the server.
                    // If the server returns an attributes hash that differs, the model's
                    // state will be `set` again.
                    save: function(key, val, options) {
                      var attrs, method, xhr, attributes = this.attributes;
                
                      // Handle both `"key", value` and `{key: value}` -style arguments.
                      if (key == null || typeof key === 'object') {
                        attrs = key;
                        options = val;
                      } else {
                        (attrs = {})[key] = val;
                      }
                
                      options = _.extend({validate: true}, options);
                
                      // If we're not waiting and attributes exist, save acts as
                      // `set(attr).save(null, opts)` with validation. Otherwise, check if
                      // the model will be valid when the attributes, if any, are set.
                      if (attrs && !options.wait) {
                        if (!this.set(attrs, options)) return false;
                      } else {
                        if (!this._validate(attrs, options)) return false;
                      }
                
                      // Set temporary attributes if `{wait: true}`.
                      if (attrs && options.wait) {
                        this.attributes = _.extend({}, attributes, attrs);
                      }
                
                      // After a successful server-side save, the client is (optionally)
                      // updated with the server-side state.
                      if (options.parse === void 0) options.parse = true;
                      var model = this;
                      var success = options.success;
                      options.success = function(resp) {
                        // Ensure attributes are restored during synchronous saves.
                        model.attributes = attributes;
                        var serverAttrs = model.parse(resp, options);
                        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
                        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                          return false;
                        }
                        if (success) success(model, resp, options);
                        model.trigger('sync', model, resp, options);
                      };
                      wrapError(this, options);
                
                      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
                      if (method === 'patch') options.attrs = attrs;
                      xhr = this.sync(method, this, options);
                
                      // Restore attributes.
                      if (attrs && options.wait) this.attributes = attributes;
                
                      return xhr;
                    },
                
                    // Destroy this model on the server if it was already persisted.
                    // Optimistically removes the model from its collection, if it has one.
                    // If `wait: true` is passed, waits for the server to respond before removal.
                    destroy: function(options) {
                      options = options ? _.clone(options) : {};
                      var model = this;
                      var success = options.success;
                
                      var destroy = function() {
                        model.trigger('destroy', model, model.collection, options);
                      };
                
                      options.success = function(resp) {
                        if (options.wait || model.isNew()) destroy();
                        if (success) success(model, resp, options);
                        if (!model.isNew()) model.trigger('sync', model, resp, options);
                      };
                
                      if (this.isNew()) {
                        options.success();
                        return false;
                      }
                      wrapError(this, options);
                
                      var xhr = this.sync('delete', this, options);
                      if (!options.wait) destroy();
                      return xhr;
                    },
                
                    // Default URL for the model's representation on the server -- if you're
                    // using Backbone's restful methods, override this to change the endpoint
                    // that will be called.
                    url: function() {
                      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
                      if (this.isNew()) return base;
                      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
                    },
                
                    // **parse** converts a response into the hash of attributes to be `set` on
                    // the model. The default implementation is just to pass the response along.
                    parse: function(resp, options) {
                      return resp;
                    },
                
                    // Create a new model with identical attributes to this one.
                    clone: function() {
                      return new this.constructor(this.attributes);
                    },
                
                    // A model is new if it has never been saved to the server, and lacks an id.
                    isNew: function() {
                      return this.id == null;
                    },
                
                    // Check if the model is currently in a valid state.
                    isValid: function(options) {
                      return this._validate({}, _.extend(options || {}, { validate: true }));
                    },
                
                    // Run validation against the next complete set of model attributes,
                    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
                    _validate: function(attrs, options) {
                      if (!options.validate || !this.validate) return true;
                      attrs = _.extend({}, this.attributes, attrs);
                      var error = this.validationError = this.validate(attrs, options) || null;
                      if (!error) return true;
                      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
                      return false;
                    }
                
                  });
                
                  // Underscore methods that we want to implement on the Model.
                  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];
                
                  // Mix in each Underscore method as a proxy to `Model#attributes`.
                  _.each(modelMethods, function(method) {
                    Model.prototype[method] = function() {
                      var args = slice.call(arguments);
                      args.unshift(this.attributes);
                      return _[method].apply(_, args);
                    };
                  });
                
                  // Backbone.Collection
                  // -------------------
                
                  // If models tend to represent a single row of data, a Backbone Collection is
                  // more analagous to a table full of data ... or a small slice or page of that
                  // table, or a collection of rows that belong together for a particular reason
                  // -- all of the messages in this particular folder, all of the documents
                  // belonging to this particular author, and so on. Collections maintain
                  // indexes of their models, both in order, and for lookup by `id`.
                
                  // Create a new **Collection**, perhaps to contain a specific type of `model`.
                  // If a `comparator` is specified, the Collection will maintain
                  // its models in sort order, as they're added and removed.
                  var Collection = Backbone.Collection = function(models, options) {
                    options || (options = {});
                    if (options.model) this.model = options.model;
                    if (options.comparator !== void 0) this.comparator = options.comparator;
                    this._reset();
                    this.initialize.apply(this, arguments);
                    if (models) this.reset(models, _.extend({silent: true}, options));
                  };
                
                  // Default options for `Collection#set`.
                  var setOptions = {add: true, remove: true, merge: true};
                  var addOptions = {add: true, remove: false};
                
                  // Define the Collection's inheritable methods.
                  _.extend(Collection.prototype, Events, {
                
                    // The default model for a collection is just a **Backbone.Model**.
                    // This should be overridden in most cases.
                    model: Model,
                
                    // Initialize is an empty function by default. Override it with your own
                    // initialization logic.
                    initialize: function(){},
                
                    // The JSON representation of a Collection is an array of the
                    // models' attributes.
                    toJSON: function(options) {
                      return this.map(function(model){ return model.toJSON(options); });
                    },
                
                    // Proxy `Backbone.sync` by default.
                    sync: function() {
                      return Backbone.sync.apply(this, arguments);
                    },
                
                    // Add a model, or list of models to the set.
                    add: function(models, options) {
                      return this.set(models, _.extend({merge: false}, options, addOptions));
                    },
                
                    // Remove a model, or a list of models from the set.
                    remove: function(models, options) {
                      var singular = !_.isArray(models);
                      models = singular ? [models] : _.clone(models);
                      options || (options = {});
                      var i, l, index, model;
                      for (i = 0, l = models.length; i < l; i++) {
                        model = models[i] = this.get(models[i]);
                        if (!model) continue;
                        delete this._byId[model.id];
                        delete this._byId[model.cid];
                        index = this.indexOf(model);
                        this.models.splice(index, 1);
                        this.length--;
                        if (!options.silent) {
                          options.index = index;
                          model.trigger('remove', model, this, options);
                        }
                        this._removeReference(model);
                      }
                      return singular ? models[0] : models;
                    },
                
                    // Update a collection by `set`-ing a new list of models, adding new ones,
                    // removing models that are no longer present, and merging models that
                    // already exist in the collection, as necessary. Similar to **Model#set**,
                    // the core operation for updating the data contained by the collection.
                    set: function(models, options) {
                      options = _.defaults({}, options, setOptions);
                      if (options.parse) models = this.parse(models, options);
                      var singular = !_.isArray(models);
                      models = singular ? (models ? [models] : []) : _.clone(models);
                      var i, l, id, model, attrs, existing, sort;
                      var at = options.at;
                      var targetModel = this.model;
                      var sortable = this.comparator && (at == null) && options.sort !== false;
                      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
                      var toAdd = [], toRemove = [], modelMap = {};
                      var add = options.add, merge = options.merge, remove = options.remove;
                      var order = !sortable && add && remove ? [] : false;
                
                      // Turn bare objects into model references, and prevent invalid models
                      // from being added.
                      for (i = 0, l = models.length; i < l; i++) {
                        attrs = models[i];
                        if (attrs instanceof Model) {
                          id = model = attrs;
                        } else {
                          id = attrs[targetModel.prototype.idAttribute];
                        }
                
                        // If a duplicate is found, prevent it from being added and
                        // optionally merge it into the existing model.
                        if (existing = this.get(id)) {
                          if (remove) modelMap[existing.cid] = true;
                          if (merge) {
                            attrs = attrs === model ? model.attributes : attrs;
                            if (options.parse) attrs = existing.parse(attrs, options);
                            existing.set(attrs, options);
                            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
                          }
                          models[i] = existing;
                
                        // If this is a new, valid model, push it to the `toAdd` list.
                        } else if (add) {
                          model = models[i] = this._prepareModel(attrs, options);
                          if (!model) continue;
                          toAdd.push(model);
                
                          // Listen to added models' events, and index models for lookup by
                          // `id` and by `cid`.
                          model.on('all', this._onModelEvent, this);
                          this._byId[model.cid] = model;
                          if (model.id != null) this._byId[model.id] = model;
                        }
                        if (order) order.push(existing || model);
                      }
                
                      // Remove nonexistent models if appropriate.
                      if (remove) {
                        for (i = 0, l = this.length; i < l; ++i) {
                          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
                        }
                        if (toRemove.length) this.remove(toRemove, options);
                      }
                
                      // See if sorting is needed, update `length` and splice in new models.
                      if (toAdd.length || (order && order.length)) {
                        if (sortable) sort = true;
                        this.length += toAdd.length;
                        if (at != null) {
                          for (i = 0, l = toAdd.length; i < l; i++) {
                            this.models.splice(at + i, 0, toAdd[i]);
                          }
                        } else {
                          if (order) this.models.length = 0;
                          var orderedModels = order || toAdd;
                          for (i = 0, l = orderedModels.length; i < l; i++) {
                            this.models.push(orderedModels[i]);
                          }
                        }
                      }
                
                      // Silently sort the collection if appropriate.
                      if (sort) this.sort({silent: true});
                
                      // Unless silenced, it's time to fire all appropriate add/sort events.
                      if (!options.silent) {
                        for (i = 0, l = toAdd.length; i < l; i++) {
                          (model = toAdd[i]).trigger('add', model, this, options);
                        }
                        if (sort || (order && order.length)) this.trigger('sort', this, options);
                      }
                      
                      // Return the added (or merged) model (or models).
                      return singular ? models[0] : models;
                    },
                
                    // When you have more items than you want to add or remove individually,
                    // you can reset the entire set with a new list of models, without firing
                    // any granular `add` or `remove` events. Fires `reset` when finished.
                    // Useful for bulk operations and optimizations.
                    reset: function(models, options) {
                      options || (options = {});
                      for (var i = 0, l = this.models.length; i < l; i++) {
                        this._removeReference(this.models[i]);
                      }
                      options.previousModels = this.models;
                      this._reset();
                      models = this.add(models, _.extend({silent: true}, options));
                      if (!options.silent) this.trigger('reset', this, options);
                      return models;
                    },
                
                    // Add a model to the end of the collection.
                    push: function(model, options) {
                      return this.add(model, _.extend({at: this.length}, options));
                    },
                
                    // Remove a model from the end of the collection.
                    pop: function(options) {
                      var model = this.at(this.length - 1);
                      this.remove(model, options);
                      return model;
                    },
                
                    // Add a model to the beginning of the collection.
                    unshift: function(model, options) {
                      return this.add(model, _.extend({at: 0}, options));
                    },
                
                    // Remove a model from the beginning of the collection.
                    shift: function(options) {
                      var model = this.at(0);
                      this.remove(model, options);
                      return model;
                    },
                
                    // Slice out a sub-array of models from the collection.
                    slice: function() {
                      return slice.apply(this.models, arguments);
                    },
                
                    // Get a model from the set by id.
                    get: function(obj) {
                      if (obj == null) return void 0;
                      return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];
                    },
                
                    // Get the model at the given index.
                    at: function(index) {
                      return this.models[index];
                    },
                
                    // Return models with matching attributes. Useful for simple cases of
                    // `filter`.
                    where: function(attrs, first) {
                      if (_.isEmpty(attrs)) return first ? void 0 : [];
                      return this[first ? 'find' : 'filter'](function(model) {
                        for (var key in attrs) {
                          if (attrs[key] !== model.get(key)) return false;
                        }
                        return true;
                      });
                    },
                
                    // Return the first model with matching attributes. Useful for simple cases
                    // of `find`.
                    findWhere: function(attrs) {
                      return this.where(attrs, true);
                    },
                
                    // Force the collection to re-sort itself. You don't need to call this under
                    // normal circumstances, as the set will maintain sort order as each item
                    // is added.
                    sort: function(options) {
                      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
                      options || (options = {});
                
                      // Run sort based on type of `comparator`.
                      if (_.isString(this.comparator) || this.comparator.length === 1) {
                        this.models = this.sortBy(this.comparator, this);
                      } else {
                        this.models.sort(_.bind(this.comparator, this));
                      }
                
                      if (!options.silent) this.trigger('sort', this, options);
                      return this;
                    },
                
                    // Pluck an attribute from each model in the collection.
                    pluck: function(attr) {
                      return _.invoke(this.models, 'get', attr);
                    },
                
                    // Fetch the default set of models for this collection, resetting the
                    // collection when they arrive. If `reset: true` is passed, the response
                    // data will be passed through the `reset` method instead of `set`.
                    fetch: function(options) {
                      options = options ? _.clone(options) : {};
                      if (options.parse === void 0) options.parse = true;
                      var success = options.success;
                      var collection = this;
                      options.success = function(resp) {
                        var method = options.reset ? 'reset' : 'set';
                        collection[method](resp, options);
                        if (success) success(collection, resp, options);
                        collection.trigger('sync', collection, resp, options);
                      };
                      wrapError(this, options);
                      return this.sync('read', this, options);
                    },
                
                    // Create a new instance of a model in this collection. Add the model to the
                    // collection immediately, unless `wait: true` is passed, in which case we
                    // wait for the server to agree.
                    create: function(model, options) {
                      options = options ? _.clone(options) : {};
                      if (!(model = this._prepareModel(model, options))) return false;
                      if (!options.wait) this.add(model, options);
                      var collection = this;
                      var success = options.success;
                      options.success = function(model, resp, options) {
                        if (options.wait) collection.add(model, options);
                        if (success) success(model, resp, options);
                      };
                      model.save(null, options);
                      return model;
                    },
                
                    // **parse** converts a response into a list of models to be added to the
                    // collection. The default implementation is just to pass it through.
                    parse: function(resp, options) {
                      return resp;
                    },
                
                    // Create a new collection with an identical list of models as this one.
                    clone: function() {
                      return new this.constructor(this.models);
                    },
                
                    // Private method to reset all internal state. Called when the collection
                    // is first initialized or reset.
                    _reset: function() {
                      this.length = 0;
                      this.models = [];
                      this._byId  = {};
                    },
                
                    // Prepare a hash of attributes (or other model) to be added to this
                    // collection.
                    _prepareModel: function(attrs, options) {
                      if (attrs instanceof Model) {
                        if (!attrs.collection) attrs.collection = this;
                        return attrs;
                      }
                      options = options ? _.clone(options) : {};
                      options.collection = this;
                      var model = new this.model(attrs, options);
                      if (!model.validationError) return model;
                      this.trigger('invalid', this, model.validationError, options);
                      return false;
                    },
                
                    // Internal method to sever a model's ties to a collection.
                    _removeReference: function(model) {
                      if (this === model.collection) delete model.collection;
                      model.off('all', this._onModelEvent, this);
                    },
                
                    // Internal method called every time a model in the set fires an event.
                    // Sets need to update their indexes when models change ids. All other
                    // events simply proxy through. "add" and "remove" events that originate
                    // in other collections are ignored.
                    _onModelEvent: function(event, model, collection, options) {
                      if ((event === 'add' || event === 'remove') && collection !== this) return;
                      if (event === 'destroy') this.remove(model, options);
                      if (model && event === 'change:' + model.idAttribute) {
                        delete this._byId[model.previous(model.idAttribute)];
                        if (model.id != null) this._byId[model.id] = model;
                      }
                      this.trigger.apply(this, arguments);
                    }
                
                  });
                
                  // Underscore methods that we want to implement on the Collection.
                  // 90% of the core usefulness of Backbone Collections is actually implemented
                  // right here:
                  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
                    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
                    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
                    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
                    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
                    'lastIndexOf', 'isEmpty', 'chain'];
                
                  // Mix in each Underscore method as a proxy to `Collection#models`.
                  _.each(methods, function(method) {
                    Collection.prototype[method] = function() {
                      var args = slice.call(arguments);
                      args.unshift(this.models);
                      return _[method].apply(_, args);
                    };
                  });
                
                  // Underscore methods that take a property name as an argument.
                  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];
                
                  // Use attributes instead of properties.
                  _.each(attributeMethods, function(method) {
                    Collection.prototype[method] = function(value, context) {
                      var iterator = _.isFunction(value) ? value : function(model) {
                        return model.get(value);
                      };
                      return _[method](this.models, iterator, context);
                    };
                  });
                
                  // Backbone.View
                  // -------------
                
                  // Backbone Views are almost more convention than they are actual code. A View
                  // is simply a JavaScript object that represents a logical chunk of UI in the
                  // DOM. This might be a single item, an entire list, a sidebar or panel, or
                  // even the surrounding frame which wraps your whole app. Defining a chunk of
                  // UI as a **View** allows you to define your DOM events declaratively, without
                  // having to worry about render order ... and makes it easy for the view to
                  // react to specific changes in the state of your models.
                
                  // Creating a Backbone.View creates its initial element outside of the DOM,
                  // if an existing element is not provided...
                  var View = Backbone.View = function(options) {
                    this.cid = _.uniqueId('view');
                    options || (options = {});
                    _.extend(this, _.pick(options, viewOptions));
                    this._ensureElement();
                    this.initialize.apply(this, arguments);
                    this.delegateEvents();
                  };
                
                  // Cached regex to split keys for `delegate`.
                  var delegateEventSplitter = /^(\S+)\s*(.*)$/;
                
                  // List of view options to be merged as properties.
                  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];
                
                  // Set up all inheritable **Backbone.View** properties and methods.
                  _.extend(View.prototype, Events, {
                
                    // The default `tagName` of a View's element is `"div"`.
                    tagName: 'div',
                
                    // jQuery delegate for element lookup, scoped to DOM elements within the
                    // current view. This should be preferred to global lookups where possible.
                    $: function(selector) {
                      return this.$el.find(selector);
                    },
                
                    // Initialize is an empty function by default. Override it with your own
                    // initialization logic.
                    initialize: function(){},
                
                    // **render** is the core function that your view should override, in order
                    // to populate its element (`this.el`), with the appropriate HTML. The
                    // convention is for **render** to always return `this`.
                    render: function() {
                      return this;
                    },
                
                    // Remove this view by taking the element out of the DOM, and removing any
                    // applicable Backbone.Events listeners.
                    remove: function() {
                      this.$el.remove();
                      this.stopListening();
                      return this;
                    },
                
                    // Change the view's element (`this.el` property), including event
                    // re-delegation.
                    setElement: function(element, delegate) {
                      if (this.$el) this.undelegateEvents();
                      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
                      this.el = this.$el[0];
                      if (delegate !== false) this.delegateEvents();
                      return this;
                    },
                
                    // Set callbacks, where `this.events` is a hash of
                    //
                    // *{"event selector": "callback"}*
                    //
                    //     {
                    //       'mousedown .title':  'edit',
                    //       'click .button':     'save',
                    //       'click .open':       function(e) { ... }
                    //     }
                    //
                    // pairs. Callbacks will be bound to the view, with `this` set properly.
                    // Uses event delegation for efficiency.
                    // Omitting the selector binds the event to `this.el`.
                    // This only works for delegate-able events: not `focus`, `blur`, and
                    // not `change`, `submit`, and `reset` in Internet Explorer.
                    delegateEvents: function(events) {
                      if (!(events || (events = _.result(this, 'events')))) return this;
                      this.undelegateEvents();
                      for (var key in events) {
                        var method = events[key];
                        if (!_.isFunction(method)) method = this[events[key]];
                        if (!method) continue;
                
                        var match = key.match(delegateEventSplitter);
                        var eventName = match[1], selector = match[2];
                        method = _.bind(method, this);
                        eventName += '.delegateEvents' + this.cid;
                        if (selector === '') {
                          this.$el.on(eventName, method);
                        } else {
                          this.$el.on(eventName, selector, method);
                        }
                      }
                      return this;
                    },
                
                    // Clears all callbacks previously bound to the view with `delegateEvents`.
                    // You usually don't need to use this, but may wish to if you have multiple
                    // Backbone views attached to the same DOM element.
                    undelegateEvents: function() {
                      this.$el.off('.delegateEvents' + this.cid);
                      return this;
                    },
                
                    // Ensure that the View has a DOM element to render into.
                    // If `this.el` is a string, pass it through `$()`, take the first
                    // matching element, and re-assign it to `el`. Otherwise, create
                    // an element from the `id`, `className` and `tagName` properties.
                    _ensureElement: function() {
                      if (!this.el) {
                        var attrs = _.extend({}, _.result(this, 'attributes'));
                        if (this.id) attrs.id = _.result(this, 'id');
                        if (this.className) attrs['class'] = _.result(this, 'className');
                        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
                        this.setElement($el, false);
                      } else {
                        this.setElement(_.result(this, 'el'), false);
                      }
                    }
                
                  });
                
                  // Backbone.sync
                  // -------------
                
                  // Override this function to change the manner in which Backbone persists
                  // models to the server. You will be passed the type of request, and the
                  // model in question. By default, makes a RESTful Ajax request
                  // to the model's `url()`. Some possible customizations could be:
                  //
                  // * Use `setTimeout` to batch rapid-fire updates into a single request.
                  // * Send up the models as XML instead of JSON.
                  // * Persist models via WebSockets instead of Ajax.
                  //
                  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
                  // as `POST`, with a `_method` parameter containing the true HTTP method,
                  // as well as all requests with the body as `application/x-www-form-urlencoded`
                  // instead of `application/json` with the model in a param named `model`.
                  // Useful when interfacing with server-side languages like **PHP** that make
                  // it difficult to read the body of `PUT` requests.
                  Backbone.sync = function(method, model, options) {
                    var type = methodMap[method];
                
                    // Default options, unless specified.
                    _.defaults(options || (options = {}), {
                      emulateHTTP: Backbone.emulateHTTP,
                      emulateJSON: Backbone.emulateJSON
                    });
                
                    // Default JSON-request options.
                    var params = {type: type, dataType: 'json'};
                
                    // Ensure that we have a URL.
                    if (!options.url) {
                      params.url = _.result(model, 'url') || urlError();
                    }
                
                    // Ensure that we have the appropriate request data.
                    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
                      params.contentType = 'application/json';
                      params.data = JSON.stringify(options.attrs || model.toJSON(options));
                    }
                
                    // For older servers, emulate JSON by encoding the request into an HTML-form.
                    if (options.emulateJSON) {
                      params.contentType = 'application/x-www-form-urlencoded';
                      params.data = params.data ? {model: params.data} : {};
                    }
                
                    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
                    // And an `X-HTTP-Method-Override` header.
                    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
                      params.type = 'POST';
                      if (options.emulateJSON) params.data._method = type;
                      var beforeSend = options.beforeSend;
                      options.beforeSend = function(xhr) {
                        xhr.setRequestHeader('X-HTTP-Method-Override', type);
                        if (beforeSend) return beforeSend.apply(this, arguments);
                      };
                    }
                
                    // Don't process data on a non-GET request.
                    if (params.type !== 'GET' && !options.emulateJSON) {
                      params.processData = false;
                    }
                
                    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
                    // that still has ActiveX enabled by default, override jQuery to use that
                    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
                    if (params.type === 'PATCH' && noXhrPatch) {
                      params.xhr = function() {
                        return new ActiveXObject("Microsoft.XMLHTTP");
                      };
                    }
                
                    // Make the request, allowing the user to override any Ajax options.
                    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
                    model.trigger('request', model, xhr, options);
                    return xhr;
                  };
                
                  var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);
                
                  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
                  var methodMap = {
                    'create': 'POST',
                    'update': 'PUT',
                    'patch':  'PATCH',
                    'delete': 'DELETE',
                    'read':   'GET'
                  };
                
                  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
                  // Override this if you'd like to use a different library.
                  Backbone.ajax = function() {
                    return Backbone.$.ajax.apply(Backbone.$, arguments);
                  };
                
                  // Backbone.Router
                  // ---------------
                
                  // Routers map faux-URLs to actions, and fire events when routes are
                  // matched. Creating a new one sets its `routes` hash, if not set statically.
                  var Router = Backbone.Router = function(options) {
                    options || (options = {});
                    if (options.routes) this.routes = options.routes;
                    this._bindRoutes();
                    this.initialize.apply(this, arguments);
                  };
                
                  // Cached regular expressions for matching named param parts and splatted
                  // parts of route strings.
                  var optionalParam = /\((.*?)\)/g;
                  var namedParam    = /(\(\?)?:\w+/g;
                  var splatParam    = /\*\w+/g;
                  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;
                
                  // Set up all inheritable **Backbone.Router** properties and methods.
                  _.extend(Router.prototype, Events, {
                
                    // Initialize is an empty function by default. Override it with your own
                    // initialization logic.
                    initialize: function(){},
                
                    // Manually bind a single named route to a callback. For example:
                    //
                    //     this.route('search/:query/p:num', 'search', function(query, num) {
                    //       ...
                    //     });
                    //
                    route: function(route, name, callback) {
                      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
                      if (_.isFunction(name)) {
                        callback = name;
                        name = '';
                      }
                      if (!callback) callback = this[name];
                      var router = this;
                      Backbone.history.route(route, function(fragment) {
                        var args = router._extractParameters(route, fragment);
                        callback && callback.apply(router, args);
                        router.trigger.apply(router, ['route:' + name].concat(args));
                        router.trigger('route', name, args);
                        Backbone.history.trigger('route', router, name, args);
                      });
                      return this;
                    },
                
                    // Simple proxy to `Backbone.history` to save a fragment into the history.
                    navigate: function(fragment, options) {
                      Backbone.history.navigate(fragment, options);
                      return this;
                    },
                
                    // Bind all defined routes to `Backbone.history`. We have to reverse the
                    // order of the routes here to support behavior where the most general
                    // routes can be defined at the bottom of the route map.
                    _bindRoutes: function() {
                      if (!this.routes) return;
                      this.routes = _.result(this, 'routes');
                      var route, routes = _.keys(this.routes);
                      while ((route = routes.pop()) != null) {
                        this.route(route, this.routes[route]);
                      }
                    },
                
                    // Convert a route string into a regular expression, suitable for matching
                    // against the current location hash.
                    _routeToRegExp: function(route) {
                      route = route.replace(escapeRegExp, '\\$&')
                                   .replace(optionalParam, '(?:$1)?')
                                   .replace(namedParam, function(match, optional) {
                                     return optional ? match : '([^\/]+)';
                                   })
                                   .replace(splatParam, '(.*?)');
                      return new RegExp('^' + route + '$');
                    },
                
                    // Given a route, and a URL fragment that it matches, return the array of
                    // extracted decoded parameters. Empty or unmatched parameters will be
                    // treated as `null` to normalize cross-browser behavior.
                    _extractParameters: function(route, fragment) {
                      var params = route.exec(fragment).slice(1);
                      return _.map(params, function(param) {
                        return param ? decodeURIComponent(param) : null;
                      });
                    }
                
                  });
                
                  // Backbone.History
                  // ----------------
                
                  // Handles cross-browser history management, based on either
                  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
                  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
                  // and URL fragments. If the browser supports neither (old IE, natch),
                  // falls back to polling.
                  var History = Backbone.History = function() {
                    this.handlers = [];
                    _.bindAll(this, 'checkUrl');
                
                    // Ensure that `History` can be used outside of the browser.
                    if (typeof window !== 'undefined') {
                      this.location = window.location;
                      this.history = window.history;
                    }
                  };
                
                  // Cached regex for stripping a leading hash/slash and trailing space.
                  var routeStripper = /^[#\/]|\s+$/g;
                
                  // Cached regex for stripping leading and trailing slashes.
                  var rootStripper = /^\/+|\/+$/g;
                
                  // Cached regex for detecting MSIE.
                  var isExplorer = /msie [\w.]+/;
                
                  // Cached regex for removing a trailing slash.
                  var trailingSlash = /\/$/;
                
                  // Cached regex for stripping urls of hash and query.
                  var pathStripper = /[?#].*$/;
                
                  // Has the history handling already been started?
                  History.started = false;
                
                  // Set up all inheritable **Backbone.History** properties and methods.
                  _.extend(History.prototype, Events, {
                
                    // The default interval to poll for hash changes, if necessary, is
                    // twenty times a second.
                    interval: 50,
                
                    // Gets the true hash value. Cannot use location.hash directly due to bug
                    // in Firefox where location.hash will always be decoded.
                    getHash: function(window) {
                      var match = (window || this).location.href.match(/#(.*)$/);
                      return match ? match[1] : '';
                    },
                
                    // Get the cross-browser normalized URL fragment, either from the URL,
                    // the hash, or the override.
                    getFragment: function(fragment, forcePushState) {
                      if (fragment == null) {
                        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                          fragment = this.location.pathname;
                          var root = this.root.replace(trailingSlash, '');
                          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
                        } else {
                          fragment = this.getHash();
                        }
                      }
                      return fragment.replace(routeStripper, '');
                    },
                
                    // Start the hash change handling, returning `true` if the current URL matches
                    // an existing route, and `false` otherwise.
                    start: function(options) {
                      if (History.started) throw new Error("Backbone.history has already been started");
                      History.started = true;
                
                      // Figure out the initial configuration. Do we need an iframe?
                      // Is pushState desired ... is it available?
                      this.options          = _.extend({root: '/'}, this.options, options);
                      this.root             = this.options.root;
                      this._wantsHashChange = this.options.hashChange !== false;
                      this._wantsPushState  = !!this.options.pushState;
                      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
                      var fragment          = this.getFragment();
                      var docMode           = document.documentMode;
                      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));
                
                      // Normalize root to always include a leading and trailing slash.
                      this.root = ('/' + this.root + '/').replace(rootStripper, '/');
                
                      if (oldIE && this._wantsHashChange) {
                        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
                        this.navigate(fragment);
                      }
                
                      // Depending on whether we're using pushState or hashes, and whether
                      // 'onhashchange' is supported, determine how we check the URL state.
                      if (this._hasPushState) {
                        Backbone.$(window).on('popstate', this.checkUrl);
                      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
                        Backbone.$(window).on('hashchange', this.checkUrl);
                      } else if (this._wantsHashChange) {
                        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
                      }
                
                      // Determine if we need to change the base url, for a pushState link
                      // opened by a non-pushState browser.
                      this.fragment = fragment;
                      var loc = this.location;
                      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;
                
                      // Transition from hashChange to pushState or vice versa if both are
                      // requested.
                      if (this._wantsHashChange && this._wantsPushState) {
                
                        // If we've started off with a route from a `pushState`-enabled
                        // browser, but we're currently in a browser that doesn't support it...
                        if (!this._hasPushState && !atRoot) {
                          this.fragment = this.getFragment(null, true);
                          this.location.replace(this.root + this.location.search + '#' + this.fragment);
                          // Return immediately as browser will do redirect to new url
                          return true;
                
                        // Or if we've started out with a hash-based route, but we're currently
                        // in a browser where it could be `pushState`-based instead...
                        } else if (this._hasPushState && atRoot && loc.hash) {
                          this.fragment = this.getHash().replace(routeStripper, '');
                          this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
                        }
                
                      }
                
                      if (!this.options.silent) return this.loadUrl();
                    },
                
                    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
                    // but possibly useful for unit testing Routers.
                    stop: function() {
                      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
                      clearInterval(this._checkUrlInterval);
                      History.started = false;
                    },
                
                    // Add a route to be tested when the fragment changes. Routes added later
                    // may override previous routes.
                    route: function(route, callback) {
                      this.handlers.unshift({route: route, callback: callback});
                    },
                
                    // Checks the current URL to see if it has changed, and if it has,
                    // calls `loadUrl`, normalizing across the hidden iframe.
                    checkUrl: function(e) {
                      var current = this.getFragment();
                      if (current === this.fragment && this.iframe) {
                        current = this.getFragment(this.getHash(this.iframe));
                      }
                      if (current === this.fragment) return false;
                      if (this.iframe) this.navigate(current);
                      this.loadUrl();
                    },
                
                    // Attempt to load the current URL fragment. If a route succeeds with a
                    // match, returns `true`. If no defined routes matches the fragment,
                    // returns `false`.
                    loadUrl: function(fragment) {
                      fragment = this.fragment = this.getFragment(fragment);
                      return _.any(this.handlers, function(handler) {
                        if (handler.route.test(fragment)) {
                          handler.callback(fragment);
                          return true;
                        }
                      });
                    },
                
                    // Save a fragment into the hash history, or replace the URL state if the
                    // 'replace' option is passed. You are responsible for properly URL-encoding
                    // the fragment in advance.
                    //
                    // The options object can contain `trigger: true` if you wish to have the
                    // route callback be fired (not usually desirable), or `replace: true`, if
                    // you wish to modify the current URL without adding an entry to the history.
                    navigate: function(fragment, options) {
                      if (!History.started) return false;
                      if (!options || options === true) options = {trigger: !!options};
                
                      var url = this.root + (fragment = this.getFragment(fragment || ''));
                
                      // Strip the fragment of the query and hash for matching.
                      fragment = fragment.replace(pathStripper, '');
                
                      if (this.fragment === fragment) return;
                      this.fragment = fragment;
                
                      // Don't include a trailing slash on the root.
                      if (fragment === '' && url !== '/') url = url.slice(0, -1);
                
                      // If pushState is available, we use it to set the fragment as a real URL.
                      if (this._hasPushState) {
                        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
                
                      // If hash changes haven't been explicitly disabled, update the hash
                      // fragment to store history.
                      } else if (this._wantsHashChange) {
                        this._updateHash(this.location, fragment, options.replace);
                        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
                          // Opening and closing the iframe tricks IE7 and earlier to push a
                          // history entry on hash-tag change.  When replace is true, we don't
                          // want this.
                          if(!options.replace) this.iframe.document.open().close();
                          this._updateHash(this.iframe.location, fragment, options.replace);
                        }
                
                      // If you've told us that you explicitly don't want fallback hashchange-
                      // based history, then `navigate` becomes a page refresh.
                      } else {
                        return this.location.assign(url);
                      }
                      if (options.trigger) return this.loadUrl(fragment);
                    },
                
                    // Update the hash location, either replacing the current entry, or adding
                    // a new one to the browser history.
                    _updateHash: function(location, fragment, replace) {
                      if (replace) {
                        var href = location.href.replace(/(javascript:|#).*$/, '');
                        location.replace(href + '#' + fragment);
                      } else {
                        // Some browsers require that `hash` contains a leading #.
                        location.hash = '#' + fragment;
                      }
                    }
                
                  });
                
                  // Create the default Backbone.history.
                  Backbone.history = new History;
                
                  // Helpers
                  // -------
                
                  // Helper function to correctly set up the prototype chain, for subclasses.
                  // Similar to `goog.inherits`, but uses a hash of prototype properties and
                  // class properties to be extended.
                  var extend = function(protoProps, staticProps) {
                    var parent = this;
                    var child;
                
                    // The constructor function for the new subclass is either defined by you
                    // (the "constructor" property in your `extend` definition), or defaulted
                    // by us to simply call the parent's constructor.
                    if (protoProps && _.has(protoProps, 'constructor')) {
                      child = protoProps.constructor;
                    } else {
                      child = function(){ return parent.apply(this, arguments); };
                    }
                
                    // Add static properties to the constructor function, if supplied.
                    _.extend(child, parent, staticProps);
                
                    // Set the prototype chain to inherit from `parent`, without calling
                    // `parent`'s constructor function.
                    var Surrogate = function(){ this.constructor = child; };
                    Surrogate.prototype = parent.prototype;
                    child.prototype = new Surrogate;
                
                    // Add prototype properties (instance properties) to the subclass,
                    // if supplied.
                    if (protoProps) _.extend(child.prototype, protoProps);
                
                    // Set a convenience property in case the parent's prototype is needed
                    // later.
                    child.__super__ = parent.prototype;
                
                    return child;
                  };
                
                  // Set up inheritance for the model, collection, router, view and history.
                  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
                
                  // Throw an error when a URL is needed, and none is supplied.
                  var urlError = function() {
                    throw new Error('A "url" property or function must be specified');
                  };
                
                  // Wrap an optional error callback with a fallback error event.
                  var wrapError = function(model, options) {
                    var error = options.error;
                    options.error = function(resp) {
                      if (error) error(model, resp, options);
                      model.trigger('error', model, resp, options);
                    };
                  };
                
                  return Backbone;
                }));
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/collection',["underscore", "backbone"], function(_, Backbone) {
                    var Collection, _ref;
                    return Collection = (function(_super) {
                      __extends(Collection, _super);
                
                      function Collection() {
                        _ref = Collection.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      return Collection;
                
                    })(Backbone.Collection);
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=collection.js.map
                */;
                (function(root) {
                define("kiwi", [], function() {
                  return (function() {
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                var tsu;
                (function (tsu) {
                
                
                
                
                
                
                    /**
                    * An iterator for an array of items.
                    */
                    var ArrayIterator = (function () {
                        /*
                        * Construct a new ArrayIterator.
                        *
                        * @param array The array of items to iterate.
                        * @param [index] The index at which to start iteration.
                        */
                        function ArrayIterator(array, index) {
                            if (typeof index === "undefined") { index = 0; }
                            this._array = array;
                            this._index = Math.max(0, Math.min(index, array.length));
                        }
                        /**
                        * Returns the next item from the iterator or undefined.
                        */
                        ArrayIterator.prototype.__next__ = function () {
                            return this._array[this._index++];
                        };
                
                        /**
                        * Returns this same iterator.
                        */
                        ArrayIterator.prototype.__iter__ = function () {
                            return this;
                        };
                        return ArrayIterator;
                    })();
                    tsu.ArrayIterator = ArrayIterator;
                
                    /**
                    * A reverse iterator for an array of items.
                    */
                    var ReverseArrayIterator = (function () {
                        /**
                        * Construct a new ReverseArrayIterator.
                        *
                        * @param array The array of items to iterate.
                        * @param [index] The index at which to start iteration.
                        */
                        function ReverseArrayIterator(array, index) {
                            if (typeof index === "undefined") { index = array.length; }
                            this._array = array;
                            this._index = Math.max(0, Math.min(index, array.length));
                        }
                        /**
                        * Returns the next item from the iterator or undefined.
                        */
                        ReverseArrayIterator.prototype.__next__ = function () {
                            return this._array[--this._index];
                        };
                
                        /**
                        * Returns this same iterator.
                        */
                        ReverseArrayIterator.prototype.__iter__ = function () {
                            return this;
                        };
                        return ReverseArrayIterator;
                    })();
                    tsu.ReverseArrayIterator = ReverseArrayIterator;
                
                
                
                    function iter(object) {
                        if (object instanceof Array) {
                            return new ArrayIterator(object);
                        }
                        return object.__iter__();
                    }
                    tsu.iter = iter;
                
                
                
                    function reversed(object) {
                        if (object instanceof Array) {
                            return new ReverseArrayIterator(object);
                        }
                        return object.__reversed__();
                    }
                    tsu.reversed = reversed;
                
                    /**
                    * Returns the next value from an iterator, or undefined.
                    */
                    function next(iterator) {
                        return iterator.__next__();
                    }
                    tsu.next = next;
                
                
                
                    function asArray(object) {
                        if (object instanceof Array) {
                            return object.slice();
                        }
                        var value;
                        var array = [];
                        var it = object.__iter__();
                        while ((value = it.__next__()) !== undefined) {
                            array.push(value);
                        }
                        return array;
                    }
                    tsu.asArray = asArray;
                
                
                
                    function forEach(object, callback) {
                        if (object instanceof Array) {
                            for (var i = 0, n = object.length; i < n; ++i) {
                                if (callback(object[i]) === false) {
                                    return;
                                }
                            }
                        } else {
                            var value;
                            var it = object.__iter__();
                            while ((value = it.__next__()) !== undefined) {
                                if (callback(value) === false) {
                                    return;
                                }
                            }
                        }
                    }
                    tsu.forEach = forEach;
                
                
                
                    function map(object, callback) {
                        var result = [];
                        if (object instanceof Array) {
                            for (var i = 0, n = object.length; i < n; ++i) {
                                result.push(callback(object[i]));
                            }
                        } else {
                            var value;
                            var it = object.__iter__();
                            while ((value = it.__next__()) !== undefined) {
                                result.push(callback(value));
                            }
                        }
                        return result;
                    }
                    tsu.map = map;
                
                
                
                    function filter(object, callback) {
                        var value;
                        var result = [];
                        if (object instanceof Array) {
                            for (var i = 0, n = object.length; i < n; ++i) {
                                value = object[i];
                                if (callback(value)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            var it = object.__iter__();
                            while ((value = it.__next__()) !== undefined) {
                                if (callback(value)) {
                                    result.push(value);
                                }
                            }
                        }
                        return result;
                    }
                    tsu.filter = filter;
                })(tsu || (tsu = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                var tsu;
                (function (tsu) {
                
                
                    /**
                    * A class which defines a generic pair object.
                    */
                    var Pair = (function () {
                        /**
                        * Construct a new Pair object.
                        *
                        * @param first The first item of the pair.
                        * @param second The second item of the pair.
                        */
                        function Pair(first, second) {
                            this.first = first;
                            this.second = second;
                        }
                        /**
                        * Create a copy of the pair.
                        */
                        Pair.prototype.copy = function () {
                            return new Pair(this.first, this.second);
                        };
                        return Pair;
                    })();
                    tsu.Pair = Pair;
                })(tsu || (tsu = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                /// <reference path="iterator.ts"/>
                /// <reference path="utility.ts"/>
                var tsu;
                (function (tsu) {
                    /**
                    * Perform a lower bound search on a sorted array.
                    *
                    * @param array The array of sorted items to search.
                    * @param value The value to located in the array.
                    * @param compare The value comparison function.
                    * @returns The index of the first element in the array which
                    *          compares greater than or equal to the given value.
                    */
                    function lowerBound(array, value, compare) {
                        var begin = 0;
                        var n = array.length;
                        var half;
                        var middle;
                        while (n > 0) {
                            half = n >> 1;
                            middle = begin + half;
                            if (compare(array[middle], value) < 0) {
                                begin = middle + 1;
                                n -= half + 1;
                            } else {
                                n = half;
                            }
                        }
                        return begin;
                    }
                    tsu.lowerBound = lowerBound;
                
                    /**
                    * Perform a binary search on a sorted array.
                    *
                    * @param array The array of sorted items to search.
                    * @param value The value to located in the array.
                    * @param compare The value comparison function.
                    * @returns The index of the found item, or -1.
                    */
                    function binarySearch(array, value, compare) {
                        var index = lowerBound(array, value, compare);
                        if (index === array.length) {
                            return -1;
                        }
                        var item = array[index];
                        if (compare(item, value) !== 0) {
                            return -1;
                        }
                        return index;
                    }
                    tsu.binarySearch = binarySearch;
                
                    /**
                    * Perform a binary find on a sorted array.
                    *
                    * @param array The array of sorted items to search.
                    * @param value The value to located in the array.
                    * @param compare The value comparison function.
                    * @returns The found item in the array, or undefined.
                    */
                    function binaryFind(array, value, compare) {
                        var index = lowerBound(array, value, compare);
                        if (index === array.length) {
                            return undefined;
                        }
                        var item = array[index];
                        if (compare(item, value) !== 0) {
                            return undefined;
                        }
                        return item;
                    }
                    tsu.binaryFind = binaryFind;
                
                
                
                    function asSet(items, compare) {
                        var array = tsu.asArray(items);
                        var n = array.length;
                        if (n <= 1) {
                            return array;
                        }
                        array.sort(compare);
                        var result = [array[0]];
                        for (var i = 1, j = 0; i < n; ++i) {
                            var item = array[i];
                            if (compare(result[j], item) !== 0) {
                                result.push(item);
                                ++j;
                            }
                        }
                        return result;
                    }
                    tsu.asSet = asSet;
                
                    /**
                    * Test whether a two sorted arrays sets are disjoint.
                    *
                    * @param first The first sorted array set.
                    * @param second The second sorted array set.
                    * @param compare The value comparison function.
                    * @returns true if the sets are disjoint, false otherwise.
                    */
                    function setIsDisjoint(first, second, compare) {
                        var i = 0, j = 0;
                        var len1 = first.length;
                        var len2 = second.length;
                        while (i < len1 && j < len2) {
                            var v = compare(first[i], second[j]);
                            if (v < 0) {
                                ++i;
                            } else if (v > 0) {
                                ++j;
                            } else {
                                return false;
                            }
                        }
                        return true;
                    }
                    tsu.setIsDisjoint = setIsDisjoint;
                
                    /**
                    * Test whether one sorted array set is the subset of another.
                    *
                    * @param first The potential subset.
                    * @param second The potential superset.
                    * @param compare The value comparison function.
                    * @returns true if the first set is a subset of the second.
                    */
                    function setIsSubset(first, second, compare) {
                        var len1 = first.length;
                        var len2 = second.length;
                        if (len1 > len2) {
                            return false;
                        }
                        var i = 0, j = 0;
                        while (i < len1 && j < len2) {
                            var v = compare(first[i], second[j]);
                            if (v < 0) {
                                return false;
                            } else if (v > 0) {
                                ++j;
                            } else {
                                ++i;
                                ++j;
                            }
                        }
                        if (i < len1) {
                            return false;
                        }
                        return true;
                    }
                    tsu.setIsSubset = setIsSubset;
                
                    /**
                    * Create the set union of two sorted set arrays.
                    var j = 0;
                    *
                    * @param first The first sorted array set.
                    * @param second The second sorted array set.
                    * @param compare The value comparison function.
                    * @returns The set union of the two arrays.
                    */
                    function setUnion(first, second, compare) {
                        var i = 0, j = 0;
                        var len1 = first.length;
                        var len2 = second.length;
                        var merged = [];
                        while (i < len1 && j < len2) {
                            var a = first[i];
                            var b = second[j];
                            var v = compare(a, b);
                            if (v < 0) {
                                merged.push(a);
                                ++i;
                            } else if (v > 0) {
                                merged.push(b);
                                ++j;
                            } else {
                                merged.push(a);
                                ++i;
                                ++j;
                            }
                        }
                        while (i < len1) {
                            merged.push(first[i]);
                            ++i;
                        }
                        while (j < len2) {
                            merged.push(second[j]);
                            ++j;
                        }
                        return merged;
                    }
                    tsu.setUnion = setUnion;
                
                    /**
                    * Create a set intersection of two sorted set arrays.
                    *
                    * @param first The first sorted array set.
                    * @param second The second sorted array set.
                    * @param compare The value comparison function.
                    * @returns The set intersection of the two arrays.
                    */
                    function setIntersection(first, second, compare) {
                        var i = 0, j = 0;
                        var len1 = first.length;
                        var len2 = second.length;
                        var merged = [];
                        while (i < len1 && j < len2) {
                            var a = first[i];
                            var b = second[j];
                            var v = compare(a, b);
                            if (v < 0) {
                                ++i;
                            } else if (v > 0) {
                                ++j;
                            } else {
                                merged.push(a);
                                ++i;
                                ++j;
                            }
                        }
                        return merged;
                    }
                    tsu.setIntersection = setIntersection;
                
                    /**
                    * Create a set difference of two sorted set arrays.
                    *
                    * @param first The first sorted array set.
                    * @param second The second sorted array set.
                    * @param compare The value comparison function.
                    * @returns The set difference of the two arrays.
                    */
                    function setDifference(first, second, compare) {
                        var i = 0, j = 0;
                        var len1 = first.length;
                        var len2 = second.length;
                        var merged = [];
                        while (i < len1 && j < len2) {
                            var a = first[i];
                            var b = second[j];
                            var v = compare(a, b);
                            if (v < 0) {
                                merged.push(a);
                                ++i;
                            } else if (v > 0) {
                                ++j;
                            } else {
                                ++i;
                                ++j;
                            }
                        }
                        while (i < len1) {
                            merged.push(first[i]);
                            ++i;
                        }
                        return merged;
                    }
                    tsu.setDifference = setDifference;
                
                    /**
                    * Create a set symmetric difference of two sorted set arrays.
                    *
                    * @param first The first sorted array set.
                    * @param second The second sorted array set.
                    * @param compare The value comparison function.
                    * @returns The set symmetric difference of the two arrays.
                    */
                    function setSymmetricDifference(first, second, compare) {
                        var i = 0, j = 0;
                        var len1 = first.length;
                        var len2 = second.length;
                        var merged = [];
                        while (i < len1 && j < len2) {
                            var a = first[i];
                            var b = second[j];
                            var v = compare(a, b);
                            if (v < 0) {
                                merged.push(a);
                                ++i;
                            } else if (v > 0) {
                                merged.push(b);
                                ++j;
                            } else {
                                ++i;
                                ++j;
                            }
                        }
                        while (i < len1) {
                            merged.push(first[i]);
                            ++i;
                        }
                        while (j < len2) {
                            merged.push(second[j]);
                            ++j;
                        }
                        return merged;
                    }
                    tsu.setSymmetricDifference = setSymmetricDifference;
                })(tsu || (tsu = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                /// <reference path="iterator.ts"/>
                var tsu;
                (function (tsu) {
                    /**
                    * A base class for implementing array-based data structures.
                    *
                    * @class
                    */
                    var ArrayBase = (function () {
                        function ArrayBase() {
                            /*
                            * The internal data array.
                            *
                            * @protected
                            */
                            this._array = [];
                        }
                        /**
                        * Returns the number of items in the array.
                        */
                        ArrayBase.prototype.size = function () {
                            return this._array.length;
                        };
                
                        /**
                        * Returns true if the array is empty.
                        */
                        ArrayBase.prototype.empty = function () {
                            return this._array.length === 0;
                        };
                
                        /**
                        * Returns the item at the given array index.
                        *
                        * @param index The integer index of the desired item.
                        */
                        ArrayBase.prototype.itemAt = function (index) {
                            return this._array[index];
                        };
                
                        /**
                        * Removes and returns the item at the given index.
                        *
                        * @param index The integer index of the desired item.
                        */
                        ArrayBase.prototype.takeAt = function (index) {
                            return this._array.splice(index, 1)[0];
                        };
                
                        /**
                        * Clear the internal contents of array.
                        */
                        ArrayBase.prototype.clear = function () {
                            this._array = [];
                        };
                
                        /**
                        * Swap this array's contents with another array.
                        *
                        * @param other The array base to use for the swap.
                        */
                        ArrayBase.prototype.swap = function (other) {
                            var array = this._array;
                            this._array = other._array;
                            other._array = array;
                        };
                
                        /**
                        * Returns an iterator over the array of items.
                        */
                        ArrayBase.prototype.__iter__ = function () {
                            return tsu.iter(this._array);
                        };
                
                        /**
                        * Returns a reverse iterator over the array of items.
                        */
                        ArrayBase.prototype.__reversed__ = function () {
                            return tsu.reversed(this._array);
                        };
                        return ArrayBase;
                    })();
                    tsu.ArrayBase = ArrayBase;
                })(tsu || (tsu = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                var __extends = this.__extends || function (d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    function __() { this.constructor = d; }
                    __.prototype = b.prototype;
                    d.prototype = new __();
                };
                /// <reference path="algorithm.ts"/>
                /// <reference path="array_base.ts"/>
                /// <reference path="iterator.ts"/>
                /// <reference path="utility.ts"/>
                var tsu;
                (function (tsu) {
                    /**
                    * A mapping container build on a sorted array.
                    *
                    * @class
                    */
                    var AssociativeArray = (function (_super) {
                        __extends(AssociativeArray, _super);
                        /**
                        * Construct a new AssociativeArray.
                        *
                        * @param compare The key comparison function.
                        */
                        function AssociativeArray(compare) {
                            _super.call(this);
                            this._compare = compare;
                            this._wrapped = wrapCompare(compare);
                        }
                        /**
                        * Returns the key comparison function used by this array.
                        */
                        AssociativeArray.prototype.comparitor = function () {
                            return this._compare;
                        };
                
                        /**
                        * Return the array index of the given key, or -1.
                        *
                        * @param key The key to locate in the array.
                        */
                        AssociativeArray.prototype.indexOf = function (key) {
                            return tsu.binarySearch(this._array, key, this._wrapped);
                        };
                
                        /**
                        * Returns true if the key is in the array, false otherwise.
                        *
                        * @param key The key to locate in the array.
                        */
                        AssociativeArray.prototype.contains = function (key) {
                            return tsu.binarySearch(this._array, key, this._wrapped) >= 0;
                        };
                
                        /**
                        * Returns the pair associated with the given key, or undefined.
                        *
                        * @param key The key to locate in the array.
                        */
                        AssociativeArray.prototype.find = function (key) {
                            return tsu.binaryFind(this._array, key, this._wrapped);
                        };
                
                        /**
                        * Returns the pair associated with the key if it exists.
                        *
                        * If the key does not exist, a new pair will be created and
                        * inserted using the value created by the given factory.
                        *
                        * @param key The key to locate in the array.
                        * @param factory The function which creates the default value.
                        */
                        AssociativeArray.prototype.setDefault = function (key, factory) {
                            var array = this._array;
                            var index = tsu.lowerBound(array, key, this._wrapped);
                            if (index === array.length) {
                                var pair = new tsu.Pair(key, factory());
                                array.push(pair);
                                return pair;
                            }
                            var currPair = array[index];
                            if (this._compare(currPair.first, key) !== 0) {
                                var pair = new tsu.Pair(key, factory());
                                array.splice(index, 0, pair);
                                return pair;
                            }
                            return currPair;
                        };
                
                        /**
                        * Insert the pair into the array and return the pair.
                        *
                        * This will overwrite any existing entry in the array.
                        *
                        * @param key The key portion of the pair.
                        * @param value The value portion of the pair.
                        */
                        AssociativeArray.prototype.insert = function (key, value) {
                            var array = this._array;
                            var index = tsu.lowerBound(array, key, this._wrapped);
                            if (index === array.length) {
                                var pair = new tsu.Pair(key, value);
                                array.push(pair);
                                return pair;
                            }
                            var currPair = array[index];
                            if (this._compare(currPair.first, key) !== 0) {
                                var pair = new tsu.Pair(key, value);
                                array.splice(index, 0, pair);
                                return pair;
                            }
                            currPair.second = value;
                            return currPair;
                        };
                
                        AssociativeArray.prototype.update = function (object) {
                            var _this = this;
                            if (object instanceof AssociativeArray) {
                                var obj = object;
                                this._array = merge(this._array, obj._array, this._compare);
                            } else {
                                tsu.forEach(object, function (pair) {
                                    _this.insert(pair.first, pair.second);
                                });
                            }
                        };
                
                        /**
                        * Removes and returns the pair for the given key, or undefined.
                        *
                        * @param key The key to remove from the map.
                        */
                        AssociativeArray.prototype.erase = function (key) {
                            var array = this._array;
                            var index = tsu.binarySearch(array, key, this._wrapped);
                            if (index < 0) {
                                return undefined;
                            }
                            return array.splice(index, 1)[0];
                        };
                
                        /**
                        * Create a copy of this associative array.
                        */
                        AssociativeArray.prototype.copy = function () {
                            var theCopy = new AssociativeArray(this._compare);
                            var copyArray = theCopy._array;
                            var thisArray = this._array;
                            for (var i = 0, n = thisArray.length; i < n; ++i) {
                                copyArray.push(thisArray[i].copy());
                            }
                            return theCopy;
                        };
                        return AssociativeArray;
                    })(tsu.ArrayBase);
                    tsu.AssociativeArray = AssociativeArray;
                
                    /**
                    * An internal which wraps a comparison key function.
                    */
                    function wrapCompare(cmp) {
                        return function (pair, value) {
                            return cmp(pair.first, value);
                        };
                    }
                
                    /**
                    * An internal function which merges two ordered pair arrays.
                    */
                    function merge(first, second, compare) {
                        var i = 0, j = 0;
                        var len1 = first.length;
                        var len2 = second.length;
                        var merged = [];
                        while (i < len1 && j < len2) {
                            var a = first[i];
                            var b = second[j];
                            var v = compare(a.first, b.first);
                            if (v < 0) {
                                merged.push(a.copy());
                                ++i;
                            } else if (v > 0) {
                                merged.push(b.copy());
                                ++j;
                            } else {
                                merged.push(b.copy());
                                ++i;
                                ++j;
                            }
                        }
                        while (i < len1) {
                            merged.push(first[i].copy());
                            ++i;
                        }
                        while (j < len2) {
                            merged.push(second[j].copy());
                            ++j;
                        }
                        return merged;
                    }
                })(tsu || (tsu = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                /// <reference path="algorithm.ts"/>
                /// <reference path="array_base.ts"/>
                /// <reference path="iterator.ts"/>
                /// <reference path="utility.ts"/>
                var tsu;
                (function (tsu) {
                    /**
                    * A set container built on a sorted array.
                    *
                    * @class
                    */
                    var UniqueArray = (function (_super) {
                        __extends(UniqueArray, _super);
                        /**
                        * Construct a new UniqueArray.
                        *
                        * @param compare The item comparison function.
                        */
                        function UniqueArray(compare) {
                            _super.call(this);
                            this._compare = compare;
                        }
                        /**
                        * Returns the comparison function for this array.
                        */
                        UniqueArray.prototype.comparitor = function () {
                            return this._compare;
                        };
                
                        /**
                        * Return the array index of the given item, or -1.
                        *
                        * @param item The item to locate in the array.
                        */
                        UniqueArray.prototype.indexOf = function (item) {
                            return tsu.binarySearch(this._array, item, this._compare);
                        };
                
                        /**
                        * Returns true if the item is in the array, false otherwise.
                        *
                        * @param item The item to locate in the array.
                        */
                        UniqueArray.prototype.contains = function (item) {
                            return tsu.binarySearch(this._array, item, this._compare) >= 0;
                        };
                
                        /**
                        * Insert an item into the array.
                        *
                        * Returns true if the item is new to the set, false otherwise.
                        *
                        * @param item The item to insert into the array.
                        */
                        UniqueArray.prototype.insert = function (item) {
                            var array = this._array;
                            var index = tsu.lowerBound(array, item, this._compare);
                            if (index === array.length) {
                                array.push(item);
                                return true;
                            }
                            if (this._compare(array[index], item) !== 0) {
                                array.splice(index, 0, item);
                                return true;
                            }
                            return false;
                        };
                
                        /**
                        * Remove an item from the array.
                        *
                        * Returns true if the item was removed, false otherwise.
                        *
                        * @param item The item to remove from the array.
                        */
                        UniqueArray.prototype.erase = function (item) {
                            var array = this._array;
                            var index = tsu.binarySearch(array, item, this._compare);
                            if (index < 0) {
                                return false;
                            }
                            array.splice(index, 1);
                            return true;
                        };
                
                        /**
                        * Create a copy of this unique array.
                        */
                        UniqueArray.prototype.copy = function () {
                            var theCopy = new UniqueArray(this._compare);
                            theCopy._array = this._array.slice();
                            return theCopy;
                        };
                
                        UniqueArray.prototype.isDisjoint = function (object) {
                            var cmp = this._compare;
                            var other = toSet(object, cmp);
                            return tsu.setIsDisjoint(this._array, other, cmp);
                        };
                
                        UniqueArray.prototype.isSubset = function (object) {
                            var cmp = this._compare;
                            var other = toSet(object, cmp);
                            return tsu.setIsSubset(this._array, other, cmp);
                        };
                
                        UniqueArray.prototype.isSuperset = function (object) {
                            var cmp = this._compare;
                            var other = toSet(object, cmp);
                            return tsu.setIsSubset(other, this._array, cmp);
                        };
                
                        UniqueArray.prototype.union = function (object) {
                            var cmp = this._compare;
                            var res = new UniqueArray(cmp);
                            var other = toSet(object, cmp);
                            res._array = tsu.setUnion(this._array, other, cmp);
                            return res;
                        };
                
                        UniqueArray.prototype.intersection = function (object) {
                            var cmp = this._compare;
                            var res = new UniqueArray(cmp);
                            var other = toSet(object, cmp);
                            res._array = tsu.setIntersection(this._array, other, cmp);
                            return res;
                        };
                
                        UniqueArray.prototype.difference = function (object) {
                            var cmp = this._compare;
                            var res = new UniqueArray(cmp);
                            var other = toSet(object, cmp);
                            res._array = tsu.setDifference(this._array, other, cmp);
                            return res;
                        };
                
                        UniqueArray.prototype.symmetricDifference = function (object) {
                            var cmp = this._compare;
                            var res = new UniqueArray(cmp);
                            var other = toSet(object, cmp);
                            res._array = tsu.setSymmetricDifference(this._array, other, cmp);
                            return res;
                        };
                
                        UniqueArray.prototype.unionUpdate = function (object) {
                            var cmp = this._compare;
                            var other = toSet(object, cmp);
                            this._array = tsu.setUnion(this._array, other, cmp);
                        };
                
                        UniqueArray.prototype.intersectionUpdate = function (object) {
                            var cmp = this._compare;
                            var other = toSet(object, cmp);
                            this._array = tsu.setIntersection(this._array, other, cmp);
                        };
                
                        UniqueArray.prototype.differenceUpdate = function (object) {
                            var cmp = this._compare;
                            var other = toSet(object, cmp);
                            this._array = tsu.setDifference(this._array, other, cmp);
                        };
                
                        UniqueArray.prototype.symmetricDifferenceUpdate = function (object) {
                            var cmp = this._compare;
                            var other = toSet(object, cmp);
                            this._array = tsu.setSymmetricDifference(this._array, other, cmp);
                        };
                        return UniqueArray;
                    })(tsu.ArrayBase);
                    tsu.UniqueArray = UniqueArray;
                
                
                
                    function toSet(arg, cmp) {
                        if (arg instanceof UniqueArray) {
                            return arg._array;
                        }
                        return tsu.asSet(arg, cmp);
                    }
                })(tsu || (tsu = {}));
                
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                /// <reference path="algorithm.ts"/>
                /// <reference path="array_base.ts"/>
                /// <reference path="associative_array.ts"/>
                /// <reference path="iterator.ts"/>
                /// <reference path="unique_array.ts"/>
                /// <reference path="utility.ts"/>
                
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                // <reference path="expression.ts">
                // <reference path="strength.ts">
                var kiwi;
                (function (kiwi) {
                    /**
                    * An enum defining the linear constraint operators.
                    */
                    (function (Operator) {
                        Operator[Operator["Le"] = 0] = "Le";
                        Operator[Operator["Ge"] = 1] = "Ge";
                        Operator[Operator["Eq"] = 2] = "Eq";
                    })(kiwi.Operator || (kiwi.Operator = {}));
                    var Operator = kiwi.Operator;
                
                    /**
                    * A linear constraint equation.
                    *
                    * A constraint equation is composed of an expression, an operator,
                    * and a strength. The RHS of the equation is implicitly zero.
                    *
                    * @class
                    */
                    var Constraint = (function () {
                        /**
                        * Construct a new Constraint.
                        *
                        * @param expression The constraint expression.
                        * @param operator The equation operator.
                        * @param strength The strength of the constraint.
                        */
                        function Constraint(expression, operator, strength) {
                            if (typeof strength === "undefined") { strength = kiwi.Strength.required; }
                            this._id = CnId++;
                            this._operator = operator;
                            this._expression = expression;
                            this._strength = kiwi.Strength.clip(strength);
                        }
                        /**
                        * A static constraint comparison function.
                        */
                        Constraint.Compare = function (a, b) {
                            return a.id() - b.id();
                        };
                
                        /**
                        * Returns the unique id number of the constraint.
                        */
                        Constraint.prototype.id = function () {
                            return this._id;
                        };
                
                        /**
                        * Returns the expression of the constraint.
                        */
                        Constraint.prototype.expression = function () {
                            return this._expression;
                        };
                
                        /**
                        * Returns the relational operator of the constraint.
                        */
                        Constraint.prototype.op = function () {
                            return this._operator;
                        };
                
                        /**
                        * Returns the strength of the constraint.
                        */
                        Constraint.prototype.strength = function () {
                            return this._strength;
                        };
                        return Constraint;
                    })();
                    kiwi.Constraint = Constraint;
                
                    /**
                    * The internal constraint id counter.
                    */
                    var CnId = 0;
                })(kiwi || (kiwi = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                /// <reference path="../thirdparty/tsu.d.ts"/>
                var kiwi;
                (function (kiwi) {
                    function createMap(compare) {
                        return new tsu.AssociativeArray(compare);
                    }
                    kiwi.createMap = createMap;
                })(kiwi || (kiwi = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                var kiwi;
                (function (kiwi) {
                    /**
                    * The primary user constraint variable.
                    *
                    * @class
                    */
                    var Variable = (function () {
                        /**
                        * Construct a new Variable
                        *
                        * @param [name] The name to associated with the variable.
                        */
                        function Variable(name) {
                            if (typeof name === "undefined") { name = ""; }
                            this._value = 0.0;
                            this._context = null;
                            this._id = VarId++;
                            this._name = name;
                        }
                        /**
                        * A static variable comparison function.
                        */
                        Variable.Compare = function (a, b) {
                            return a.id() - b.id();
                        };
                
                        /**
                        * Returns the unique id number of the variable.
                        */
                        Variable.prototype.id = function () {
                            return this._id;
                        };
                
                        /**
                        * Returns the name of the variable.
                        */
                        Variable.prototype.name = function () {
                            return this._name;
                        };
                
                        /**
                        * Set the name of the variable.
                        */
                        Variable.prototype.setName = function (name) {
                            this._name = name;
                        };
                
                        /**
                        * Returns the user context object of the variable.
                        */
                        Variable.prototype.context = function () {
                            return this._context;
                        };
                
                        /**
                        * Set the user context object of the variable.
                        */
                        Variable.prototype.setContext = function (context) {
                            this._context = context;
                        };
                
                        /**
                        * Returns the value of the variable.
                        */
                        Variable.prototype.value = function () {
                            return this._value;
                        };
                
                        /**
                        * Set the value of the variable.
                        */
                        Variable.prototype.setValue = function (value) {
                            this._value = value;
                        };
                        return Variable;
                    })();
                    kiwi.Variable = Variable;
                
                    /**
                    * The internal variable id counter.
                    */
                    var VarId = 0;
                })(kiwi || (kiwi = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                /// <reference path="../thirdparty/tsu.d.ts"/>
                /// <reference path="maptype.ts"/>
                /// <reference path="variable.ts"/>
                var kiwi;
                (function (kiwi) {
                    /**
                    * An expression of variable terms and a constant.
                    *
                    * @class
                    */
                    var Expression = (function () {
                        function Expression() {
                            var parsed = parseArgs(arguments);
                            this._terms = parsed.terms;
                            this._constant = parsed.constant;
                        }
                        /**
                        * Returns the mapping of terms in the expression.
                        *
                        * This *must* be treated as const.
                        */
                        Expression.prototype.terms = function () {
                            return this._terms;
                        };
                
                        /**
                        * Returns the constant of the expression.
                        */
                        Expression.prototype.constant = function () {
                            return this._constant;
                        };
                
                        /**
                        * Returns the computed value of the expression.
                        */
                        Expression.prototype.value = function () {
                            var result = this._constant;
                            tsu.forEach(this._terms, function (pair) {
                                result += pair.first.value() * pair.second;
                            });
                            return result;
                        };
                        return Expression;
                    })();
                    kiwi.Expression = Expression;
                
                
                
                    /**
                    * An internal argument parsing function.
                    */
                    function parseArgs(args) {
                        var constant = 0.0;
                        var factory = function () {
                            return 0.0;
                        };
                        var terms = kiwi.createMap(kiwi.Variable.Compare);
                        for (var i = 0, n = args.length; i < n; ++i) {
                            var item = args[i];
                            if (typeof item === "number") {
                                constant += item;
                            } else if (item instanceof kiwi.Variable) {
                                terms.setDefault(item, factory).second += 1.0;
                            } else if (item instanceof Array) {
                                if (item.length !== 2) {
                                    throw new Error("array must have length 2");
                                }
                                var value = item[0];
                                var variable = item[1];
                                if (typeof value !== "number") {
                                    throw new Error("array item 0 must be a number");
                                }
                                if (!(variable instanceof kiwi.Variable)) {
                                    throw new Error("array item 1 must be a variable");
                                }
                                terms.setDefault(variable, factory).second += value;
                            } else {
                                throw new Error("invalid Expression argument: " + item);
                            }
                        }
                        return { terms: terms, constant: constant };
                    }
                })(kiwi || (kiwi = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                var kiwi;
                (function (kiwi) {
                    (function (Strength) {
                        /**
                        * Create a new symbolic strength.
                        */
                        function create(a, b, c, w) {
                            if (typeof w === "undefined") { w = 1.0; }
                            var result = 0.0;
                            result += Math.max(0.0, Math.min(1000.0, a * w)) * 1000000.0;
                            result += Math.max(0.0, Math.min(1000.0, b * w)) * 1000.0;
                            result += Math.max(0.0, Math.min(1000.0, c * w));
                            return result;
                        }
                        Strength.create = create;
                
                        /**
                        * The 'required' symbolic strength.
                        */
                        Strength.required = create(1000.0, 1000.0, 1000.0);
                
                        /**
                        * The 'strong' symbolic strength.
                        */
                        Strength.strong = create(1.0, 0.0, 0.0);
                
                        /**
                        * The 'medium' symbolic strength.
                        */
                        Strength.medium = create(0.0, 1.0, 0.0);
                
                        /**
                        * The 'weak' symbolic strength.
                        */
                        Strength.weak = create(0.0, 0.0, 1.0);
                
                        /**
                        * Clip a symbolic strength to the allowed min and max.
                        */
                        function clip(value) {
                            return Math.max(0.0, Math.min(Strength.required, value));
                        }
                        Strength.clip = clip;
                    })(kiwi.Strength || (kiwi.Strength = {}));
                    var Strength = kiwi.Strength;
                })(kiwi || (kiwi = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                /// <reference path="../thirdparty/tsu.d.ts"/>
                /// <reference path="constraint.ts"/>
                /// <reference path="expression.ts"/>
                /// <reference path="maptype.ts"/>
                /// <reference path="strength.ts"/>
                /// <reference path="variable.ts"/>
                var kiwi;
                (function (kiwi) {
                    /**
                    * The constraint solver class.
                    *
                    * @class
                    */
                    var Solver = (function () {
                        /**
                        * Construct a new Solver.
                        */
                        function Solver() {
                            this._cnMap = createCnMap();
                            this._rowMap = createRowMap();
                            this._varMap = createVarMap();
                            this._editMap = createEditMap();
                            this._infeasibleRows = [];
                            this._objective = new Row();
                            this._artificial = null;
                            this._idTick = 0;
                        }
                        /**
                        * Add a constraint to the solver.
                        */
                        Solver.prototype.addConstraint = function (constraint) {
                            var cnPair = this._cnMap.find(constraint);
                            if (cnPair !== undefined) {
                                throw new Error("duplicate constraint");
                            }
                
                            // Creating a row causes symbols to be reserved for the variables
                            // in the constraint. If this method exits with an exception,
                            // then its possible those variables will linger in the var map.
                            // Since its likely that those variables will be used in other
                            // constraints and since exceptional conditions are uncommon,
                            // i'm not too worried about aggressive cleanup of the var map.
                            var data = this._createRow(constraint);
                            var row = data.row;
                            var tag = data.tag;
                            var subject = this._chooseSubject(row, tag);
                
                            // If chooseSubject couldnt find a valid entering symbol, one
                            // last option is available if the entire row is composed of
                            // dummy variables. If the constant of the row is zero, then
                            // this represents redundant constraints and the new dummy
                            // marker can enter the basis. If the constant is non-zero,
                            // then it represents an unsatisfiable constraint.
                            if (subject.type() === 0 /* Invalid */ && row.allDummies()) {
                                if (!nearZero(row.constant())) {
                                    throw new Error("unsatifiable constraint");
                                } else {
                                    subject = tag.marker;
                                }
                            }
                
                            // If an entering symbol still isn't found, then the row must
                            // be added using an artificial variable. If that fails, then
                            // the row represents an unsatisfiable constraint.
                            if (subject.type() === 0 /* Invalid */) {
                                if (!this._addWithArtificialVariable(row)) {
                                    throw new Error("unsatisfiable constraint");
                                }
                            } else {
                                row.solveFor(subject);
                                this._substitute(subject, row);
                                this._rowMap.insert(subject, row);
                            }
                
                            this._cnMap.insert(constraint, tag);
                
                            // Optimizing after each constraint is added performs less
                            // aggregate work due to a smaller average system size. It
                            // also ensures the solver remains in a consistent state.
                            this._optimize(this._objective);
                        };
                
                        /**
                        * Remove a constraint from the solver.
                        */
                        Solver.prototype.removeConstraint = function (constraint) {
                            var cnPair = this._cnMap.erase(constraint);
                            if (cnPair === undefined) {
                                throw new Error("unknown constraint");
                            }
                
                            // Remove the error effects from the objective function
                            // *before* pivoting, or substitutions into the objective
                            // will lead to incorrect solver results.
                            this._removeConstraintEffects(constraint, cnPair.second);
                
                            // If the marker is basic, simply drop the row. Otherwise,
                            // pivot the marker into the basis and then drop the row.
                            var marker = cnPair.second.marker;
                            var rowPair = this._rowMap.erase(marker);
                            if (rowPair === undefined) {
                                var leaving = this._getMarkerLeavingSymbol(marker);
                                if (leaving.type() === 0 /* Invalid */) {
                                    throw new Error("failed to find leaving row");
                                }
                                rowPair = this._rowMap.erase(leaving);
                                rowPair.second.solveForEx(leaving, marker);
                                this._substitute(marker, rowPair.second);
                            }
                
                            // Optimizing after each constraint is removed ensures that the
                            // solver remains consistent. It makes the solver api easier to
                            // use at a small tradeoff for speed.
                            this._optimize(this._objective);
                        };
                
                        /**
                        * Test whether the solver contains the constraint.
                        */
                        Solver.prototype.hasConstraint = function (constraint) {
                            return this._cnMap.contains(constraint);
                        };
                
                        /**
                        * Add an edit variable to the solver.
                        */
                        Solver.prototype.addEditVariable = function (variable, strength) {
                            var editPair = this._editMap.find(variable);
                            if (editPair !== undefined) {
                                throw new Error("duplicate edit variable");
                            }
                            strength = kiwi.Strength.clip(strength);
                            if (strength === kiwi.Strength.required) {
                                throw new Error("bad required strength");
                            }
                            var expr = new kiwi.Expression(variable);
                            var cn = new kiwi.Constraint(expr, 2 /* Eq */, strength);
                            this.addConstraint(cn);
                            var tag = this._cnMap.find(cn).second;
                            var info = { tag: tag, constraint: cn, constant: 0.0 };
                            this._editMap.insert(variable, info);
                        };
                
                        /**
                        * Remove an edit variable from the solver.
                        */
                        Solver.prototype.removeEditVariable = function (variable) {
                            var editPair = this._editMap.erase(variable);
                            if (editPair === undefined) {
                                throw new Error("unknown edit variable");
                            }
                            this.removeConstraint(editPair.second.constraint);
                        };
                
                        /**
                        * Test whether the solver contains the edit variable.
                        */
                        Solver.prototype.hasEditVariable = function (variable) {
                            return this._editMap.contains(variable);
                        };
                
                        /**
                        * Suggest the value of an edit variable.
                        */
                        Solver.prototype.suggestValue = function (variable, value) {
                            var editPair = this._editMap.find(variable);
                            if (editPair === undefined) {
                                throw new Error("unknown edit variable");
                            }
                
                            var rows = this._rowMap;
                            var info = editPair.second;
                            var delta = value - info.constant;
                            info.constant = value;
                
                            // Check first if the positive error variable is basic.
                            var marker = info.tag.marker;
                            var rowPair = rows.find(marker);
                            if (rowPair !== undefined) {
                                if (rowPair.second.add(-delta) < 0.0) {
                                    this._infeasibleRows.push(marker);
                                }
                                this._dualOptimize();
                                return;
                            }
                
                            // Check next if the negative error variable is basic.
                            var other = info.tag.other;
                            var rowPair = rows.find(other);
                            if (rowPair !== undefined) {
                                if (rowPair.second.add(delta) < 0.0) {
                                    this._infeasibleRows.push(other);
                                }
                                this._dualOptimize();
                                return;
                            }
                
                            for (var i = 0, n = rows.size(); i < n; ++i) {
                                var rowPair = rows.itemAt(i);
                                var row = rowPair.second;
                                var coeff = row.coefficientFor(marker);
                                if (coeff !== 0.0 && row.add(delta * coeff) < 0.0 && rowPair.first.type() !== 1 /* External */) {
                                    this._infeasibleRows.push(rowPair.first);
                                }
                            }
                            this._dualOptimize();
                        };
                
                        /**
                        * Update the values of the variables.
                        */
                        Solver.prototype.updateVariables = function () {
                            var vars = this._varMap;
                            var rows = this._rowMap;
                            for (var i = 0, n = vars.size(); i < n; ++i) {
                                var pair = vars.itemAt(i);
                                var rowPair = rows.find(pair.second);
                                if (rowPair !== undefined) {
                                    pair.first.setValue(rowPair.second.constant());
                                } else {
                                    pair.first.setValue(0.0);
                                }
                            }
                        };
                
                        /**
                        * Get the symbol for the given variable.
                        *
                        * If a symbol does not exist for the variable, one will be created.
                        */
                        Solver.prototype._getVarSymbol = function (variable) {
                            var _this = this;
                            var factory = function () {
                                return _this._makeSymbol(1 /* External */);
                            };
                            return this._varMap.setDefault(variable, factory).second;
                        };
                
                        /**
                        * Create a new Row object for the given constraint.
                        *
                        * The terms in the constraint will be converted to cells in the row.
                        * Any term in the constraint with a coefficient of zero is ignored.
                        * This method uses the `_getVarSymbol` method to get the symbol for
                        * the variables added to the row. If the symbol for a given cell
                        * variable is basic, the cell variable will be substituted with the
                        * basic row.
                        *
                        * The necessary slack and error variables will be added to the row.
                        * If the constant for the row is negative, the sign for the row
                        * will be inverted so the constant becomes positive.
                        *
                        * Returns the created Row and the tag for tracking the constraint.
                        */
                        Solver.prototype._createRow = function (constraint) {
                            var expr = constraint.expression();
                            var row = new Row(expr.constant());
                
                            // Substitute the current basic variables into the row.
                            var terms = expr.terms();
                            for (var i = 0, n = terms.size(); i < n; ++i) {
                                var termPair = terms.itemAt(i);
                                if (!nearZero(termPair.second)) {
                                    var symbol = this._getVarSymbol(termPair.first);
                                    var basicPair = this._rowMap.find(symbol);
                                    if (basicPair !== undefined) {
                                        row.insertRow(basicPair.second, termPair.second);
                                    } else {
                                        row.insertSymbol(symbol, termPair.second);
                                    }
                                }
                            }
                
                            // Add the necessary slack, error, and dummy variables.
                            var objective = this._objective;
                            var strength = constraint.strength();
                            var tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };
                            switch (constraint.op()) {
                                case 0 /* Le */:
                                case 1 /* Ge */: {
                                    var coeff = constraint.op() === 0 /* Le */ ? 1.0 : -1.0;
                                    var slack = this._makeSymbol(2 /* Slack */);
                                    tag.marker = slack;
                                    row.insertSymbol(slack, coeff);
                                    if (strength < kiwi.Strength.required) {
                                        var error = this._makeSymbol(3 /* Error */);
                                        tag.other = error;
                                        row.insertSymbol(error, -coeff);
                                        objective.insertSymbol(error, strength);
                                    }
                                    break;
                                }
                                case 2 /* Eq */: {
                                    if (strength < kiwi.Strength.required) {
                                        var errplus = this._makeSymbol(3 /* Error */);
                                        var errminus = this._makeSymbol(3 /* Error */);
                                        tag.marker = errplus;
                                        tag.other = errminus;
                                        row.insertSymbol(errplus, -1.0); // v = eplus - eminus
                                        row.insertSymbol(errminus, 1.0); // v - eplus + eminus = 0
                                        objective.insertSymbol(errplus, strength);
                                        objective.insertSymbol(errminus, strength);
                                    } else {
                                        var dummy = this._makeSymbol(4 /* Dummy */);
                                        tag.marker = dummy;
                                        row.insertSymbol(dummy);
                                    }
                                    break;
                                }
                            }
                
                            // Ensure the row has a positive constant.
                            if (row.constant() < 0.0) {
                                row.reverseSign();
                            }
                
                            return { row: row, tag: tag };
                        };
                
                        /**
                        * Choose the subject for solving for the row.
                        *
                        * This method will choose the best subject for using as the solve
                        * target for the row. An invalid symbol will be returned if there
                        * is no valid target.
                        *
                        * The symbols are chosen according to the following precedence:
                        *
                        * 1) The first symbol representing an external variable.
                        * 2) A negative slack or error tag variable.
                        *
                        * If a subject cannot be found, an invalid symbol will be returned.
                        */
                        Solver.prototype._chooseSubject = function (row, tag) {
                            var cells = row.cells();
                            for (var i = 0, n = cells.size(); i < n; ++i) {
                                var pair = cells.itemAt(i);
                                if (pair.first.type() === 1 /* External */) {
                                    return pair.first;
                                }
                            }
                            var type = tag.marker.type();
                            if (type === 2 /* Slack */ || type === 3 /* Error */) {
                                if (row.coefficientFor(tag.marker) < 0.0) {
                                    return tag.marker;
                                }
                            }
                            type = tag.other.type();
                            if (type === 2 /* Slack */ || type === 3 /* Error */) {
                                if (row.coefficientFor(tag.other) < 0.0) {
                                    return tag.other;
                                }
                            }
                            return INVALID_SYMBOL;
                        };
                
                        /**
                        * Add the row to the tableau using an artificial variable.
                        *
                        * This will return false if the constraint cannot be satisfied.
                        */
                        Solver.prototype._addWithArtificialVariable = function (row) {
                            // Create and add the artificial variable to the tableau.
                            var art = this._makeSymbol(2 /* Slack */);
                            this._rowMap.insert(art, row.copy());
                            this._artificial = row.copy();
                
                            // Optimize the artificial objective. This is successful
                            // only if the artificial objective is optimized to zero.
                            this._optimize(this._artificial);
                            var success = nearZero(this._artificial.constant());
                            this._artificial = null;
                
                            // If the artificial variable is basic, pivot the row so that
                            // it becomes non-basic. If the row is constant, exit early.
                            var pair = this._rowMap.erase(art);
                            if (pair !== undefined) {
                                var basicRow = pair.second;
                                if (basicRow.isConstant()) {
                                    return success;
                                }
                                var entering = this._anyPivotableSymbol(basicRow);
                                if (entering.type() === 0 /* Invalid */) {
                                    return false;
                                }
                                basicRow.solveForEx(art, entering);
                                this._substitute(entering, basicRow);
                                this._rowMap.insert(entering, basicRow);
                            }
                
                            // Remove the artificial variable from the tableau.
                            var rows = this._rowMap;
                            for (var i = 0, n = rows.size(); i < n; ++i) {
                                rows.itemAt(i).second.removeSymbol(art);
                            }
                            this._objective.removeSymbol(art);
                            return success;
                        };
                
                        /**
                        * Substitute the parametric symbol with the given row.
                        *
                        * This method will substitute all instances of the parametric symbol
                        * in the tableau and the objective function with the given row.
                        */
                        Solver.prototype._substitute = function (symbol, row) {
                            var rows = this._rowMap;
                            for (var i = 0, n = rows.size(); i < n; ++i) {
                                var pair = rows.itemAt(i);
                                pair.second.substitute(symbol, row);
                                if (pair.second.constant() < 0.0 && pair.first.type() !== 1 /* External */) {
                                    this._infeasibleRows.push(pair.first);
                                }
                            }
                            this._objective.substitute(symbol, row);
                            if (this._artificial) {
                                this._artificial.substitute(symbol, row);
                            }
                        };
                
                        /**
                        * Optimize the system for the given objective function.
                        *
                        * This method performs iterations of Phase 2 of the simplex method
                        * until the objective function reaches a minimum.
                        */
                        Solver.prototype._optimize = function (objective) {
                            while (true) {
                                var entering = this._getEnteringSymbol(objective);
                                if (entering.type() === 0 /* Invalid */) {
                                    return;
                                }
                                var leaving = this._getLeavingSymbol(entering);
                                if (leaving.type() === 0 /* Invalid */) {
                                    throw new Error("the objective is unbounded");
                                }
                
                                // pivot the entering symbol into the basis
                                var row = this._rowMap.erase(leaving).second;
                                row.solveForEx(leaving, entering);
                                this._substitute(entering, row);
                                this._rowMap.insert(entering, row);
                            }
                        };
                
                        /**
                        * Optimize the system using the dual of the simplex method.
                        *
                        * The current state of the system should be such that the objective
                        * function is optimal, but not feasible. This method will perform
                        * an iteration of the dual simplex method to make the solution both
                        * optimal and feasible.
                        */
                        Solver.prototype._dualOptimize = function () {
                            var rows = this._rowMap;
                            var infeasible = this._infeasibleRows;
                            while (infeasible.length !== 0) {
                                var leaving = infeasible.pop();
                                var pair = rows.find(leaving);
                                if (pair !== undefined && pair.second.constant() < 0.0) {
                                    var entering = this._getDualEnteringSymbol(pair.second);
                                    if (entering.type() === 0 /* Invalid */) {
                                        throw new Error("dual optimize failed");
                                    }
                
                                    // pivot the entering symbol into the basis
                                    var row = pair.second;
                                    rows.erase(leaving);
                                    row.solveForEx(leaving, entering);
                                    this._substitute(entering, row);
                                    rows.insert(entering, row);
                                }
                            }
                        };
                
                        /**
                        * Compute the entering variable for a pivot operation.
                        *
                        * This method will return first symbol in the objective function which
                        * is non-dummy and has a coefficient less than zero. If no symbol meets
                        * the criteria, it means the objective function is at a minimum, and an
                        * invalid symbol is returned.
                        */
                        Solver.prototype._getEnteringSymbol = function (objective) {
                            var cells = objective.cells();
                            for (var i = 0, n = cells.size(); i < n; ++i) {
                                var pair = cells.itemAt(i);
                                var symbol = pair.first;
                                if (pair.second < 0.0 && symbol.type() !== 4 /* Dummy */) {
                                    return symbol;
                                }
                            }
                            return INVALID_SYMBOL;
                        };
                
                        /**
                        * Compute the entering symbol for the dual optimize operation.
                        *
                        * This method will return the symbol in the row which has a positive
                        * coefficient and yields the minimum ratio for its respective symbol
                        * in the objective function. The provided row *must* be infeasible.
                        * If no symbol is found which meats the criteria, an invalid symbol
                        * is returned.
                        */
                        Solver.prototype._getDualEnteringSymbol = function (row) {
                            var ratio = Number.MAX_VALUE;
                            var entering = INVALID_SYMBOL;
                            var cells = row.cells();
                            for (var i = 0, n = cells.size(); i < n; ++i) {
                                var pair = cells.itemAt(i);
                                var symbol = pair.first;
                                var c = pair.second;
                                if (c > 0.0 && symbol.type() !== 4 /* Dummy */) {
                                    var coeff = this._objective.coefficientFor(symbol);
                                    var r = coeff / c;
                                    if (r < ratio) {
                                        ratio = r;
                                        entering = symbol;
                                    }
                                }
                            }
                            return entering;
                        };
                
                        /**
                        * Compute the symbol for pivot exit row.
                        *
                        * This method will return the symbol for the exit row in the row
                        * map. If no appropriate exit symbol is found, an invalid symbol
                        * will be returned. This indicates that the objective function is
                        * unbounded.
                        */
                        Solver.prototype._getLeavingSymbol = function (entering) {
                            var ratio = Number.MAX_VALUE;
                            var found = INVALID_SYMBOL;
                            var rows = this._rowMap;
                            for (var i = 0, n = rows.size(); i < n; ++i) {
                                var pair = rows.itemAt(i);
                                var symbol = pair.first;
                                if (symbol.type() !== 1 /* External */) {
                                    var row = pair.second;
                                    var temp = row.coefficientFor(entering);
                                    if (temp < 0.0) {
                                        var temp_ratio = -row.constant() / temp;
                                        if (temp_ratio < ratio) {
                                            ratio = temp_ratio;
                                            found = symbol;
                                        }
                                    }
                                }
                            }
                            return found;
                        };
                
                        /**
                        * Compute the leaving symbol for a marker variable.
                        *
                        * This method will return a symbol corresponding to a basic row
                        * which holds the given marker variable. The row will be chosen
                        * according to the following precedence:
                        *
                        * 1) The row with a restricted basic varible and a negative coefficient
                        *    for the marker with the smallest ratio of -constant / coefficient.
                        *
                        * 2) The row with a restricted basic variable and the smallest ratio
                        *    of constant / coefficient.
                        *
                        * 3) The last unrestricted row which contains the marker.
                        *
                        * If the marker does not exist in any row, an invalid symbol will be
                        * returned. This indicates an internal solver error since the marker
                        * *should* exist somewhere in the tableau.
                        */
                        Solver.prototype._getMarkerLeavingSymbol = function (marker) {
                            var dmax = Number.MAX_VALUE;
                            var r1 = dmax;
                            var r2 = dmax;
                            var invalid = INVALID_SYMBOL;
                            var first = invalid;
                            var second = invalid;
                            var third = invalid;
                            var rows = this._rowMap;
                            for (var i = 0, n = rows.size(); i < n; ++i) {
                                var pair = rows.itemAt(i);
                                var row = pair.second;
                                var c = row.coefficientFor(marker);
                                if (c === 0.0) {
                                    continue;
                                }
                                var symbol = pair.first;
                                if (symbol.type() === 1 /* External */) {
                                    third = symbol;
                                } else if (c < 0.0) {
                                    var r = -row.constant() / c;
                                    if (r < r1) {
                                        r1 = r;
                                        first = symbol;
                                    }
                                } else {
                                    var r = row.constant() / c;
                                    if (r < r2) {
                                        r2 = r;
                                        second = symbol;
                                    }
                                }
                            }
                            if (first !== invalid) {
                                return first;
                            }
                            if (second !== invalid) {
                                return second;
                            }
                            return third;
                        };
                
                        /**
                        * Remove the effects of a constraint on the objective function.
                        */
                        Solver.prototype._removeConstraintEffects = function (cn, tag) {
                            if (tag.marker.type() === 3 /* Error */) {
                                this._removeMarkerEffects(tag.marker, cn.strength());
                            }
                            if (tag.other.type() === 3 /* Error */) {
                                this._removeMarkerEffects(tag.other, cn.strength());
                            }
                        };
                
                        /**
                        * Remove the effects of an error marker on the objective function.
                        */
                        Solver.prototype._removeMarkerEffects = function (marker, strength) {
                            var pair = this._rowMap.find(marker);
                            if (pair !== undefined) {
                                this._objective.insertRow(pair.second, -strength);
                            } else {
                                this._objective.insertSymbol(marker, -strength);
                            }
                        };
                
                        /**
                        * Get the first Slack or Error symbol in the row.
                        *
                        * If no such symbol is present, an invalid symbol will be returned.
                        */
                        Solver.prototype._anyPivotableSymbol = function (row) {
                            var cells = row.cells();
                            for (var i = 0, n = cells.size(); i < n; ++i) {
                                var pair = cells.itemAt(i);
                                var type = pair.first.type();
                                if (type === 2 /* Slack */ || type === 3 /* Error */) {
                                    return pair.first;
                                }
                            }
                            return INVALID_SYMBOL;
                        };
                
                        /**
                        * Returns a new Symbol of the given type.
                        */
                        Solver.prototype._makeSymbol = function (type) {
                            return new Symbol(type, this._idTick++);
                        };
                        return Solver;
                    })();
                    kiwi.Solver = Solver;
                
                    /**
                    * Test whether a value is approximately zero.
                    */
                    function nearZero(value) {
                        var eps = 1.0e-8;
                        return value < 0.0 ? -value < eps : value < eps;
                    }
                
                
                
                
                
                
                
                    /**
                    * An internal function for creating a constraint map.
                    */
                    function createCnMap() {
                        return kiwi.createMap(kiwi.Constraint.Compare);
                    }
                
                    /**
                    * An internal function for creating a row map.
                    */
                    function createRowMap() {
                        return kiwi.createMap(Symbol.Compare);
                    }
                
                    /**
                    * An internal function for creating a variable map.
                    */
                    function createVarMap() {
                        return kiwi.createMap(kiwi.Variable.Compare);
                    }
                
                    /**
                    * An internal function for creating an edit map.
                    */
                    function createEditMap() {
                        return kiwi.createMap(kiwi.Variable.Compare);
                    }
                
                    /**
                    * An enum defining the available symbol types.
                    */
                    var SymbolType;
                    (function (SymbolType) {
                        SymbolType[SymbolType["Invalid"] = 0] = "Invalid";
                        SymbolType[SymbolType["External"] = 1] = "External";
                        SymbolType[SymbolType["Slack"] = 2] = "Slack";
                        SymbolType[SymbolType["Error"] = 3] = "Error";
                        SymbolType[SymbolType["Dummy"] = 4] = "Dummy";
                    })(SymbolType || (SymbolType = {}));
                
                    /**
                    * An internal class representing a symbol in the solver.
                    */
                    var Symbol = (function () {
                        /**
                        * Construct a new Symbol
                        *
                        * @param [type] The type of the symbol.
                        * @param [id] The unique id number of the symbol.
                        */
                        function Symbol(type, id) {
                            this._id = id;
                            this._type = type;
                        }
                        /**
                        * The static Symbol comparison function.
                        */
                        Symbol.Compare = function (a, b) {
                            return a.id() - b.id();
                        };
                
                        /**
                        * Returns the unique id number of the symbol.
                        */
                        Symbol.prototype.id = function () {
                            return this._id;
                        };
                
                        /**
                        * Returns the type of the symbol.
                        */
                        Symbol.prototype.type = function () {
                            return this._type;
                        };
                        return Symbol;
                    })();
                
                    /**
                    * A static invalid symbol
                    */
                    var INVALID_SYMBOL = new Symbol(0 /* Invalid */, -1);
                
                    /**
                    * An internal row class used by the solver.
                    */
                    var Row = (function () {
                        /**
                        * Construct a new Row.
                        */
                        function Row(constant) {
                            if (typeof constant === "undefined") { constant = 0.0; }
                            this._cellMap = kiwi.createMap(Symbol.Compare);
                            this._constant = constant;
                        }
                        /**
                        * Returns the mapping of symbols to coefficients.
                        */
                        Row.prototype.cells = function () {
                            return this._cellMap;
                        };
                
                        /**
                        * Returns the constant for the row.
                        */
                        Row.prototype.constant = function () {
                            return this._constant;
                        };
                
                        /**
                        * Returns true if the row is a constant value.
                        */
                        Row.prototype.isConstant = function () {
                            return this._cellMap.empty();
                        };
                
                        /**
                        * Returns true if the Row has all dummy symbols.
                        */
                        Row.prototype.allDummies = function () {
                            var cells = this._cellMap;
                            for (var i = 0, n = cells.size(); i < n; ++i) {
                                var pair = cells.itemAt(i);
                                if (pair.first.type() !== 4 /* Dummy */) {
                                    return false;
                                }
                            }
                            return true;
                        };
                
                        /**
                        * Create a copy of the row.
                        */
                        Row.prototype.copy = function () {
                            var theCopy = new Row(this._constant);
                            theCopy._cellMap = this._cellMap.copy();
                            return theCopy;
                        };
                
                        /**
                        * Add a constant value to the row constant.
                        *
                        * Returns the new value of the constant.
                        */
                        Row.prototype.add = function (value) {
                            return this._constant += value;
                        };
                
                        /**
                        * Insert the symbol into the row with the given coefficient.
                        *
                        * If the symbol already exists in the row, the coefficient
                        * will be added to the existing coefficient. If the resulting
                        * coefficient is zero, the symbol will be removed from the row.
                        */
                        Row.prototype.insertSymbol = function (symbol, coefficient) {
                            if (typeof coefficient === "undefined") { coefficient = 1.0; }
                            var pair = this._cellMap.setDefault(symbol, function () {
                                return 0.0;
                            });
                            if (nearZero(pair.second += coefficient)) {
                                this._cellMap.erase(symbol);
                            }
                        };
                
                        /**
                        * Insert a row into this row with a given coefficient.
                        *
                        * The constant and the cells of the other row will be
                        * multiplied by the coefficient and added to this row. Any
                        * cell with a resulting coefficient of zero will be removed
                        * from the row.
                        */
                        Row.prototype.insertRow = function (other, coefficient) {
                            if (typeof coefficient === "undefined") { coefficient = 1.0; }
                            this._constant += other._constant * coefficient;
                            var cells = other._cellMap;
                            for (var i = 0, n = cells.size(); i < n; ++i) {
                                var pair = cells.itemAt(i);
                                this.insertSymbol(pair.first, pair.second * coefficient);
                            }
                        };
                
                        /**
                        * Remove a symbol from the row.
                        */
                        Row.prototype.removeSymbol = function (symbol) {
                            this._cellMap.erase(symbol);
                        };
                
                        /**
                        * Reverse the sign of the constant and cells in the row.
                        */
                        Row.prototype.reverseSign = function () {
                            this._constant = -this._constant;
                            var cells = this._cellMap;
                            for (var i = 0, n = cells.size(); i < n; ++i) {
                                var pair = cells.itemAt(i);
                                pair.second = -pair.second;
                            }
                        };
                
                        /**
                        * Solve the row for the given symbol.
                        *
                        * This method assumes the row is of the form
                        * a * x + b * y + c = 0 and (assuming solve for x) will modify
                        * the row to represent the right hand side of
                        * x = -b/a * y - c / a. The target symbol will be removed from
                        * the row, and the constant and other cells will be multiplied
                        * by the negative inverse of the target coefficient.
                        *
                        * The given symbol *must* exist in the row.
                        */
                        Row.prototype.solveFor = function (symbol) {
                            var cells = this._cellMap;
                            var pair = cells.erase(symbol);
                            var coeff = -1.0 / pair.second;
                            this._constant *= coeff;
                            for (var i = 0, n = cells.size(); i < n; ++i) {
                                cells.itemAt(i).second *= coeff;
                            }
                        };
                
                        /**
                        * Solve the row for the given symbols.
                        *
                        * This method assumes the row is of the form
                        * x = b * y + c and will solve the row such that
                        * y = x / b - c / b. The rhs symbol will be removed from the
                        * row, the lhs added, and the result divided by the negative
                        * inverse of the rhs coefficient.
                        *
                        * The lhs symbol *must not* exist in the row, and the rhs
                        * symbol must* exist in the row.
                        */
                        Row.prototype.solveForEx = function (lhs, rhs) {
                            this.insertSymbol(lhs, -1.0);
                            this.solveFor(rhs);
                        };
                
                        /**
                        * Returns the coefficient for the given symbol.
                        */
                        Row.prototype.coefficientFor = function (symbol) {
                            var pair = this._cellMap.find(symbol);
                            return pair !== undefined ? pair.second : 0.0;
                        };
                
                        /**
                        * Substitute a symbol with the data from another row.
                        *
                        * Given a row of the form a * x + b and a substitution of the
                        * form x = 3 * y + c the row will be updated to reflect the
                        * expression 3 * a * y + a * c + b.
                        *
                        * If the symbol does not exist in the row, this is a no-op.
                        */
                        Row.prototype.substitute = function (symbol, row) {
                            var pair = this._cellMap.erase(symbol);
                            if (pair !== undefined) {
                                this.insertRow(row, pair.second);
                            }
                        };
                        return Row;
                    })();
                })(kiwi || (kiwi = {}));
                /*-----------------------------------------------------------------------------
                | Copyright (c) 2014, Nucleic Development Team.
                |
                | Distributed under the terms of the Modified BSD License.
                |
                | The full license is in the file COPYING.txt, distributed with this software.
                |----------------------------------------------------------------------------*/
                /// <reference path="constraint.ts"/>
                /// <reference path="expression.ts"/>
                /// <reference path="maptype.ts"/>
                /// <reference path="solver.ts"/>
                /// <reference path="strength.ts"/>
                /// <reference path="variable.ts"/>
                ;
                return root.kiwi = kiwi;
                  }).apply(root, arguments);
                });
                }(this));
                
                define('common/canvas_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      if (this.map) {
                        _print(_safe('\n<div class="bk-canvas-map"></div>\n'));
                      }
                    
                      _print(_safe('\n<div class="bk-canvas-events" />\n<div class="bk-canvas-overlays" />\n<canvas class=\'bk-canvas\'></canvas>'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/continuum_view',["underscore", "backbone"], function(_, Backbone) {
                    var ContinuumView, _ref;
                    return ContinuumView = (function(_super) {
                      __extends(ContinuumView, _super);
                
                      function ContinuumView() {
                        _ref = ContinuumView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ContinuumView.prototype.initialize = function(options) {
                        if (!_.has(options, 'id')) {
                          return this.id = _.uniqueId('ContinuumView');
                        }
                      };
                
                      ContinuumView.prototype.bind_bokeh_events = function() {
                        return 'pass';
                      };
                
                      ContinuumView.prototype.delegateEvents = function(events) {
                        return ContinuumView.__super__.delegateEvents.call(this, events);
                      };
                
                      ContinuumView.prototype.remove = function() {
                        var target, val, _ref1;
                        if (_.has(this, 'eventers')) {
                          _ref1 = this.eventers;
                          for (target in _ref1) {
                            if (!__hasProp.call(_ref1, target)) continue;
                            val = _ref1[target];
                            val.off(null, null, this);
                          }
                        }
                        this.trigger('remove', this);
                        return ContinuumView.__super__.remove.call(this);
                      };
                
                      ContinuumView.prototype.mget = function() {
                        return this.model.get.apply(this.model, arguments);
                      };
                
                      ContinuumView.prototype.mset = function() {
                        return this.model.set.apply(this.model, arguments);
                      };
                
                      ContinuumView.prototype.render_end = function() {
                        return "pass";
                      };
                
                      return ContinuumView;
                
                    })(Backbone.View);
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=continuum_view.js.map
                */;
                var __extends=this.__extends||function(c,d){function h(){this.constructor=c}for(var e in d)d.hasOwnProperty(e)&&(c[e]=d[e]);h.prototype=d.prototype;c.prototype=new h};function JL(c){if(!c)return JL.__;var d="";return("."+c).split(".").reduce(function(c,e,k,f){d=d?d+("."+e):e;e=c["__"+d];void 0===e&&(JL.Logger.prototype=c,e=new JL.Logger(d),c["__"+d]=e);return e},JL.__)}
                (function(c){function d(b,a,g){void 0!==a[b]&&(null===a[b]?delete g[b]:g[b]=a[b])}function h(b){if(null!=c.enabled&&!c.enabled||null!=c.maxMessages&&1>c.maxMessages)return!1;try{if(b.userAgentRegex&&!RegExp(b.userAgentRegex).test(navigator.userAgent))return!1}catch(a){}try{if(b.ipRegex&&c.clientIP&&!RegExp(b.ipRegex).test(c.clientIP))return!1}catch(g){}return!0}function e(b,a){try{if(b.disallow&&RegExp(b.disallow).test(a))return!1}catch(g){}return!0}function k(b){switch(typeof b){case "string":return b;
                case "number":return b.toString();case "boolean":return b.toString();case "undefined":return"undefined";case "function":return b instanceof RegExp?b.toString():k(b());case "object":return b instanceof RegExp||b instanceof String||b instanceof Number||b instanceof Boolean?b.toString():JSON.stringify(b);default:return"unknown"}}c.enabled;c.maxMessages;c.defaultAjaxUrl;c.clientIP;c.requestId="";c.setOptions=function(b){d("enabled",b,this);d("maxMessages",b,this);d("defaultAjaxUrl",b,this);d("clientIP",
                b,this);d("requestId",b,this);return this};c.getAllLevel=function(){return-2147483648};c.getTraceLevel=function(){return 1E3};c.getDebugLevel=function(){return 2E3};c.getInfoLevel=function(){return 3E3};c.getWarnLevel=function(){return 4E3};c.getErrorLevel=function(){return 5E3};c.getFatalLevel=function(){return 6E3};c.getOffLevel=function(){return 2147483647};var f=function(){return function(b,a){this.inner=a;this.name="JL.Exception";this.message=k(b)}}();c.Exception=f;f.prototype=Error();var m=
                function(){return function(b,a,g,c){this.l=b;this.m=a;this.n=g;this.t=c}}();c.LogItem=m;f=function(){function b(a,b){this.appenderName=a;this.sendLogItems=b;this.level=c.getTraceLevel();this.sendWithBufferLevel=2147483647;this.storeInBufferLevel=-2147483648;this.bufferSize=0;this.batchSize=1;this.buffer=[];this.batchBuffer=[]}b.prototype.setOptions=function(a){d("level",a,this);d("ipRegex",a,this);d("userAgentRegex",a,this);d("disallow",a,this);d("sendWithBufferLevel",a,this);d("storeInBufferLevel",
                a,this);d("bufferSize",a,this);d("batchSize",a,this);this.bufferSize<this.buffer.length&&(this.buffer.length=this.bufferSize);return this};b.prototype.log=function(a,b,c){!h(this)||!e(this,b)||a<this.storeInBufferLevel||(b=new m(a,b,c,(new Date).getTime()),a<this.level?0<this.bufferSize&&(this.buffer.push(b),this.buffer.length>this.bufferSize&&this.buffer.shift()):(a<this.sendWithBufferLevel||!this.buffer.length||(this.batchBuffer=this.batchBuffer.concat(this.buffer),this.buffer.length=0),this.batchBuffer.push(b),
                this.batchBuffer.length>=this.batchSize&&this.sendBatch()))};b.prototype.sendBatch=function(){0==this.batchBuffer.length||null!=c.maxMessages&&1>c.maxMessages||(null!=c.maxMessages&&(c.maxMessages-=this.batchBuffer.length),this.sendLogItems(this.batchBuffer),this.batchBuffer.length=0)};return b}();c.Appender=f;var l=function(b){function a(c){b.call(this,c,a.prototype.sendLogItemsAjax)}__extends(a,b);a.prototype.setOptions=function(a){d("url",a,this);b.prototype.setOptions.call(this,a);return this};
                a.prototype.sendLogItemsAjax=function(a){try{var b="/jsnlog.logger";null!=c.defaultAjaxUrl&&(b=c.defaultAjaxUrl);this.url&&(b=this.url);var d=JSON.stringify({r:c.requestId,lg:a}),e=new XMLHttpRequest;e.open("POST",b);e.setRequestHeader("Content-Type","application/json");e.setRequestHeader("JSNLog-RequestId",c.requestId);e.send(d)}catch(f){}};return a}(f);c.AjaxAppender=l;var n=function(b){function a(c){b.call(this,c,a.prototype.sendLogItemsConsole)}__extends(a,b);a.prototype.clog=function(a){console.log(a)};
                a.prototype.cerror=function(a){console.error?console.error(a):this.clog(a)};a.prototype.cwarn=function(a){console.warn?console.warn(a):this.clog(a)};a.prototype.cinfo=function(a){console.info?console.info(a):this.clog(a)};a.prototype.cdebug=function(a){console.debug?console.debug(a):this.cinfo(a)};a.prototype.sendLogItemsConsole=function(a){try{if(console){var b;for(b=0;b<a.length;++b){var d=a[b],e=d.n+": "+d.m;d.l<=c.getDebugLevel()?this.cdebug(e):d.l<=c.getInfoLevel()?this.cinfo(e):d.l<=c.getWarnLevel()?
                this.cwarn(e):this.cerror(e)}}}catch(f){}};return a}(f);c.ConsoleAppender=n;f=function(){function b(a){this.loggerName=a;this.seenRegexes=[]}b.prototype.setOptions=function(a){d("level",a,this);d("userAgentRegex",a,this);d("disallow",a,this);d("ipRegex",a,this);d("appenders",a,this);d("onceOnly",a,this);this.seenRegexes=[];return this};b.prototype.buildExceptionObject=function(a){var b={};a.stack?b.stack=a.stack:b.e=a;a.message&&(b.message=a.message);a.name&&(b.name=a.name);a.data&&(b.data=a.data);
                a.inner&&(b.inner=this.buildExceptionObject(a.inner));return b};b.prototype.log=function(a,b,c){var d=0;if(!this.appenders)return this;if(a>=this.level&&h(this)&&(b=k(b),c&&(c=this.buildExceptionObject(c),c.logData=b,b=JSON.stringify(c)),e(this,b))){if(this.onceOnly)for(d=this.onceOnly.length-1;0<=d;){if(RegExp(this.onceOnly[d]).test(b)){if(this.seenRegexes[d])return this;this.seenRegexes[d]=!0}d--}for(d=this.appenders.length-1;0<=d;)this.appenders[d].log(a,b,this.loggerName),d--}return this};b.prototype.trace=
                function(a){return this.log(1E3,a)};b.prototype.debug=function(a){return this.log(2E3,a)};b.prototype.info=function(a){return this.log(3E3,a)};b.prototype.warn=function(a){return this.log(4E3,a)};b.prototype.error=function(a){return this.log(5E3,a)};b.prototype.fatal=function(a){return this.log(6E3,a)};b.prototype.fatalException=function(a,b){return this.log(6E3,a,b)};return b}();c.Logger=f;c.createAjaxAppender=function(b){return new l(b)};c.createConsoleAppender=function(b){return new n(b)};f=new l("");
                c.__=new c.Logger("");c.__.setOptions({level:c.getDebugLevel(),appenders:[f]})})(JL||(JL={}));var exports;"undefined"!==typeof exports&&(exports.JL=JL);var define;"function"==typeof define&&define.amd&&define("jsnlog",[],function(){return JL});"function"==typeof __jsnlog_configure&&__jsnlog_configure();
                
                (function() {
                  define('common/logging',["jsnlog"], function(JL) {
                    var logger, set_log_level;
                    logger = JL("Bokeh");
                    logger.setOptions({
                      "appenders": [JL.createConsoleAppender('consoleAppender')]
                    });
                    set_log_level = function(level) {
                      var valid_levels;
                      valid_levels = {
                        "trace": JL.getTraceLevel(),
                        "debug": JL.getDebugLevel(),
                        "info": JL.getInfoLevel(),
                        "warn": JL.getWarnLevel(),
                        "error": JL.getErrorLevel(),
                        "fatal": JL.getFatalLevel()
                      };
                      if (!(level in valid_levels)) {
                        console.log("Bokeh: Unrecognized logging level '" + level + "' passed to Bokeh.set_log_level, ignoring.");
                        console.log("Bokeh: Valid log levels are: " + (Object.keys(valid_levels)));
                        return;
                      }
                      console.log("Bokeh: setting log level to: '" + level + "'");
                      return logger.setOptions({
                        "level": valid_levels[level]
                      });
                    };
                    return {
                      "logger": logger,
                      "set_log_level": set_log_level
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=logging.js.map
                */;
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/has_properties',["underscore", "backbone", "require", "./base", "./logging"], function(_, Backbone, require, base, Logging) {
                    var HasProperties, logger, _is_ref;
                    logger = Logging.logger;
                    _is_ref = function(arg) {
                      var keys;
                      if (_.isObject(arg)) {
                        keys = _.keys(arg).sort();
                        return keys.length === 2 && keys[0] === 'id' && keys[1] === 'type';
                      }
                      return false;
                    };
                    return HasProperties = (function(_super) {
                      __extends(HasProperties, _super);
                
                      HasProperties.prototype.toString = function() {
                        return "" + this.type + "(" + this.id + ")";
                      };
                
                      HasProperties.prototype.destroy = function(options) {
                        HasProperties.__super__.destroy.call(this, options);
                        return this.stopListening();
                      };
                
                      HasProperties.prototype.isNew = function() {
                        return false;
                      };
                
                      HasProperties.prototype.attrs_and_props = function() {
                        var data, prop_name, _i, _len, _ref;
                        data = _.clone(this.attributes);
                        _ref = _.keys(this.properties);
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                          prop_name = _ref[_i];
                          data[prop_name] = this.get(prop_name);
                        }
                        return data;
                      };
                
                      function HasProperties(attributes, options) {
                        this.rpc = __bind(this.rpc, this);
                        this.resolve_ref = __bind(this.resolve_ref, this);
                        this.convert_to_ref = __bind(this.convert_to_ref, this);
                        var attrs;
                        attrs = attributes || {};
                        if (!options) {
                          options = {};
                        }
                        this.cid = _.uniqueId('c');
                        this.attributes = {};
                        if (options.collection) {
                          this.collection = options.collection;
                        }
                        if (options.parse) {
                          attrs = this.parse(attrs, options) || {};
                        }
                        attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
                        this.set(attrs, options);
                        this.changed = {};
                        this._base = false;
                        this.properties = {};
                        this.property_cache = {};
                        if (!_.has(attrs, this.idAttribute)) {
                          this.id = _.uniqueId(this.type);
                          this.attributes[this.idAttribute] = this.id;
                        }
                        if (!options.defer_initialization) {
                          this.initialize.apply(this, arguments);
                        }
                      }
                
                      HasProperties.prototype.set_obj = function(key, value, options) {
                        var attrs, val;
                        if (_.isObject(key) || key === null) {
                          attrs = key;
                          options = value;
                        } else {
                          attrs = {};
                          attrs[key] = value;
                        }
                        for (key in attrs) {
                          if (!__hasProp.call(attrs, key)) continue;
                          val = attrs[key];
                          attrs[key] = this.convert_to_ref(val);
                        }
                        return this.set(attrs, options);
                      };
                
                      HasProperties.prototype.set = function(key, value, options) {
                        var attrs, toremove, val, _i, _len;
                        if (_.isObject(key) || key === null) {
                          attrs = key;
                          options = value;
                        } else {
                          attrs = {};
                          attrs[key] = value;
                        }
                        toremove = [];
                        for (key in attrs) {
                          if (!__hasProp.call(attrs, key)) continue;
                          val = attrs[key];
                          if (_.has(this, 'properties') && _.has(this.properties, key) && this.properties[key]['setter']) {
                            this.properties[key]['setter'].call(this, val, key);
                            toremove.push(key);
                          }
                        }
                        if (!_.isEmpty(toremove)) {
                          attrs = _.clone(attrs);
                          for (_i = 0, _len = toremove.length; _i < _len; _i++) {
                            key = toremove[_i];
                            delete attrs[key];
                          }
                        }
                        if (!_.isEmpty(attrs)) {
                          return HasProperties.__super__.set.call(this, attrs, options);
                        }
                      };
                
                      HasProperties.prototype.convert_to_ref = function(value) {
                        if (_.isArray(value)) {
                          return _.map(value, this.convert_to_ref);
                        } else {
                          if (value instanceof HasProperties) {
                            return value.ref();
                          }
                        }
                      };
                
                      HasProperties.prototype.add_dependencies = function(prop_name, object, fields) {
                        var fld, prop_spec, _i, _len, _results;
                        if (!_.isArray(fields)) {
                          fields = [fields];
                        }
                        prop_spec = this.properties[prop_name];
                        prop_spec.dependencies = prop_spec.dependencies.concat({
                          obj: object,
                          fields: fields
                        });
                        _results = [];
                        for (_i = 0, _len = fields.length; _i < _len; _i++) {
                          fld = fields[_i];
                          _results.push(this.listenTo(object, "change:" + fld, prop_spec['callbacks']['changedep']));
                        }
                        return _results;
                      };
                
                      HasProperties.prototype.register_setter = function(prop_name, setter) {
                        var prop_spec;
                        prop_spec = this.properties[prop_name];
                        return prop_spec.setter = setter;
                      };
                
                      HasProperties.prototype.register_property = function(prop_name, getter, use_cache) {
                        var changedep, prop_spec, propchange,
                          _this = this;
                        if (_.isUndefined(use_cache)) {
                          use_cache = true;
                        }
                        if (_.has(this.properties, prop_name)) {
                          this.remove_property(prop_name);
                        }
                        changedep = function() {
                          return _this.trigger('changedep:' + prop_name);
                        };
                        propchange = function() {
                          var firechange, new_val, old_val;
                          firechange = true;
                          if (prop_spec['use_cache']) {
                            old_val = _this.get_cache(prop_name);
                            _this.clear_cache(prop_name);
                            new_val = _this.get(prop_name);
                            firechange = new_val !== old_val;
                          }
                          if (firechange) {
                            _this.trigger('change:' + prop_name, _this, _this.get(prop_name));
                            return _this.trigger('change', _this);
                          }
                        };
                        prop_spec = {
                          'getter': getter,
                          'dependencies': [],
                          'use_cache': use_cache,
                          'setter': null,
                          'callbacks': {
                            changedep: changedep,
                            propchange: propchange
                          }
                        };
                        this.properties[prop_name] = prop_spec;
                        this.listenTo(this, "changedep:" + prop_name, prop_spec['callbacks']['propchange']);
                        return prop_spec;
                      };
                
                      HasProperties.prototype.remove_property = function(prop_name) {
                        var dep, dependencies, fld, obj, prop_spec, _i, _j, _len, _len1, _ref;
                        prop_spec = this.properties[prop_name];
                        dependencies = prop_spec.dependencies;
                        for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
                          dep = dependencies[_i];
                          obj = dep.obj;
                          _ref = dep['fields'];
                          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                            fld = _ref[_j];
                            obj.off('change:' + fld, prop_spec['callbacks']['changedep'], this);
                          }
                        }
                        this.off("changedep:" + dep);
                        delete this.properties[prop_name];
                        if (prop_spec.use_cache) {
                          return this.clear_cache(prop_name);
                        }
                      };
                
                      HasProperties.prototype.has_cache = function(prop_name) {
                        return _.has(this.property_cache, prop_name);
                      };
                
                      HasProperties.prototype.add_cache = function(prop_name, val) {
                        return this.property_cache[prop_name] = val;
                      };
                
                      HasProperties.prototype.clear_cache = function(prop_name, val) {
                        return delete this.property_cache[prop_name];
                      };
                
                      HasProperties.prototype.get_cache = function(prop_name) {
                        return this.property_cache[prop_name];
                      };
                
                      HasProperties.prototype.get = function(prop_name, resolve_refs) {
                        var ref_or_val;
                        if (resolve_refs == null) {
                          resolve_refs = true;
                        }
                        if (_.has(this.properties, prop_name)) {
                          return this._get_prop(prop_name);
                        } else {
                          ref_or_val = HasProperties.__super__.get.call(this, prop_name);
                          if (!resolve_refs) {
                            return ref_or_val;
                          }
                          return this.resolve_ref(ref_or_val);
                        }
                      };
                
                      HasProperties.prototype._get_prop = function(prop_name) {
                        var computed, getter, prop_spec;
                        prop_spec = this.properties[prop_name];
                        if (prop_spec.use_cache && this.has_cache(prop_name)) {
                          return this.property_cache[prop_name];
                        } else {
                          getter = prop_spec.getter;
                          computed = getter.apply(this, [prop_name]);
                          if (this.properties[prop_name].use_cache) {
                            this.add_cache(prop_name, computed);
                          }
                          return computed;
                        }
                      };
                
                      HasProperties.prototype.ref = function() {
                        return {
                          'type': this.type,
                          'id': this.id
                        };
                      };
                
                      HasProperties.prototype.resolve_ref = function(arg) {
                        var x;
                        if (_.isUndefined(arg)) {
                          return arg;
                        }
                        if (_.isArray(arg)) {
                          return (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = arg.length; _i < _len; _i++) {
                              x = arg[_i];
                              _results.push(this.resolve_ref(x));
                            }
                            return _results;
                          }).call(this);
                        }
                        if (_is_ref(arg)) {
                          if (arg['type'] === this.type && arg['id'] === this.id) {
                            return this;
                          } else {
                            return this.get_base().Collections(arg['type']).get(arg['id']);
                          }
                        }
                        return arg;
                      };
                
                      HasProperties.prototype.get_base = function() {
                        if (!this._base) {
                          this._base = require('./base');
                        }
                        return this._base;
                      };
                
                      HasProperties.prototype.url = function() {
                        var doc, url;
                        doc = this.get('doc');
                        if (doc == null) {
                          logger.error("unset 'doc' in " + this);
                        }
                        url = this.get_base().Config.prefix + "bokeh/bb/" + doc + "/" + this.type + "/";
                        if (this.isNew()) {
                          return url;
                        }
                        return url + this.get('id') + "/";
                      };
                
                      HasProperties.prototype.sync = function(method, model, options) {
                        return options.success(model.attributes, null, {});
                      };
                
                      HasProperties.prototype.defaults = function() {
                        return {};
                      };
                
                      HasProperties.prototype.rpc = function(funcname, args, kwargs) {
                        var data, doc, id, prefix, resp, type, url;
                        prefix = this.get_base().Config.prefix;
                        doc = this.get('doc');
                        if (doc == null) {
                          throw new Error("Unset 'doc' in " + this);
                        }
                        id = this.get('id');
                        type = this.type;
                        url = "" + prefix + "bokeh/bb/rpc/" + doc + "/" + type + "/" + id + "/" + funcname + "/";
                        data = {
                          args: args,
                          kwargs: kwargs
                        };
                        resp = $.ajax({
                          type: 'POST',
                          url: url,
                          data: JSON.stringify(data),
                          contentType: 'application/json',
                          xhrFields: {
                            withCredentials: true
                          }
                        });
                        return resp;
                      };
                
                      return HasProperties;
                
                    })(Backbone.Model);
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=has_properties.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('range/range1d',["underscore", "common/collection", "common/has_properties"], function(_, Collection, HasProperties) {
                    var Range1d, Range1ds, _ref, _ref1;
                    Range1d = (function(_super) {
                      __extends(Range1d, _super);
                
                      function Range1d() {
                        _ref = Range1d.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      Range1d.prototype.type = 'Range1d';
                
                      Range1d.prototype.initialize = function(attrs, options) {
                        Range1d.__super__.initialize.call(this, attrs, options);
                        this.register_property('min', function() {
                          return Math.min(this.get('start'), this.get('end'));
                        }, true);
                        this.add_dependencies('min', this, ['start', 'end']);
                        this.register_property('max', function() {
                          return Math.max(this.get('start'), this.get('end'));
                        }, true);
                        return this.add_dependencies('max', this, ['start', 'end']);
                      };
                
                      Range1d.prototype.defaults = function() {
                        return _.extend({}, Range1d.__super__.defaults.call(this), {
                          start: 0,
                          end: 1
                        });
                      };
                
                      return Range1d;
                
                    })(HasProperties);
                    Range1ds = (function(_super) {
                      __extends(Range1ds, _super);
                
                      function Range1ds() {
                        _ref1 = Range1ds.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Range1ds.prototype.model = Range1d;
                
                      return Range1ds;
                
                    })(Collection);
                    return {
                      "Model": Range1d,
                      "Collection": new Range1ds()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=range1d.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/layout_box',["underscore", "./collection", "kiwi", "./has_properties", "range/range1d"], function(_, Collection, kiwi, HasProperties, Range1d) {
                    var Constraint, EQ, Expr, GE, LE, LayoutBox, LayoutBoxs, Var, _ref, _ref1;
                    Var = kiwi.Variable;
                    Expr = kiwi.Expression;
                    Constraint = kiwi.Constraint;
                    EQ = kiwi.Operator.Eq;
                    LE = kiwi.Operator.Le;
                    GE = kiwi.Operator.Ge;
                    LayoutBox = (function(_super) {
                      __extends(LayoutBox, _super);
                
                      function LayoutBox() {
                        _ref = LayoutBox.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LayoutBox.prototype.type = 'LayoutBox';
                
                      LayoutBox.prototype.initialize = function(attrs, options) {
                        var name, v, _i, _j, _len, _len1, _ref1, _ref2,
                          _this = this;
                        LayoutBox.__super__.initialize.call(this, attrs, options);
                        this.solver = this.get('solver');
                        this.var_constraints = {};
                        _ref1 = ['top', 'left', 'width', 'height'];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          v = _ref1[_i];
                          name = '_' + v;
                          this[name] = new Var(v);
                          this.register_property(v, this._get_var, false);
                          this.register_setter(v, this._set_var);
                          this.solver.add_edit_variable(this[name], kiwi.Strength.strong);
                        }
                        _ref2 = ['right', 'bottom'];
                        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                          v = _ref2[_j];
                          name = '_' + v;
                          this[name] = new Var(v);
                          this.register_property(v, this._get_var, false);
                        }
                        this.solver.add_constraint(new Constraint(new Expr(this._top), GE));
                        this.solver.add_constraint(new Constraint(new Expr(this._bottom), GE));
                        this.solver.add_constraint(new Constraint(new Expr(this._left), GE));
                        this.solver.add_constraint(new Constraint(new Expr(this._right), GE));
                        this.solver.add_constraint(new Constraint(new Expr(this._width), GE));
                        this.solver.add_constraint(new Constraint(new Expr(this._height), GE));
                        this.solver.add_constraint(new Constraint(new Expr(this._left, this._width, [-1, this._right]), EQ));
                        this.solver.add_constraint(new Constraint(new Expr(this._bottom, this._height, [-1, this._top]), EQ));
                        this._h_range = new Range1d.Model({
                          start: this.get('left'),
                          end: this.get('left') + this.get('width')
                        });
                        this.register_property('h_range', function() {
                          _this._h_range.set('start', _this.get('left'));
                          _this._h_range.set('end', _this.get('left') + _this.get('width'));
                          return _this._h_range;
                        }, false);
                        this.add_dependencies('h_range', this, ['left', 'width']);
                        this._v_range = new Range1d.Model({
                          start: this.get('bottom'),
                          end: this.get('bottom') + this.get('height')
                        });
                        this.register_property('v_range', function() {
                          _this._v_range.set('start', _this.get('bottom'));
                          _this._v_range.set('end', _this.get('bottom') + _this.get('height'));
                          return _this._v_range;
                        }, false);
                        this.add_dependencies('v_range', this, ['bottom', 'height']);
                        this._aspect_constraint = null;
                        this.register_property('aspect', function() {
                          return _this.get('width') / _this.get('height');
                        }, true);
                        this.register_setter('aspect', this._set_aspect);
                        return this.add_dependencies('aspect', this, ['width', 'height']);
                      };
                
                      LayoutBox.prototype.contains = function(vx, vy) {
                        return vx >= this.get('left') && vx <= this.get('right') && vy >= this.get('bottom') && vy <= this.get('top');
                      };
                
                      LayoutBox.prototype._set_var = function(value, prop_name) {
                        var c, v;
                        v = this['_' + prop_name];
                        if (typeof value === 'number') {
                          return this.solver.suggest_value(v, value);
                        } else if (typeof value === 'string') {
                
                        } else {
                          c = new Constraint(new Expr(v, [-1, value]), EQ);
                          if (this.var_constraints[prop_name] == null) {
                            this.var_constraints[prop_name] = [];
                          }
                          this.var_constraints[prop_name].push(c);
                          return this.solver.add_constraint(c);
                        }
                      };
                
                      LayoutBox.prototype._get_var = function(prop_name) {
                        return this['_' + prop_name].value();
                      };
                
                      LayoutBox.prototype._set_aspect = function(aspect) {
                        var c;
                        if (this._aspect_constraint != null) {
                          this.solver.remove_constraint(this.aspect_constraint);
                          c = new Constraint(new Expr([aspect, this._height], [-1, this._width]), EQ);
                          this._aspect_constraint = c;
                          return this.solver.add_constraint(c);
                        }
                      };
                
                      LayoutBox.prototype.defaults = function() {
                        return _.extend({}, LayoutBox.__super__.defaults.call(this), {
                          'top_strength': kiwi.Strength.strong,
                          'bottom_strength': kiwi.Strength.strong,
                          'left_strength': kiwi.Strength.strong,
                          'right_strength': kiwi.Strength.strong,
                          'width_strength': kiwi.Strength.strong,
                          'height_strength': kiwi.Strength.strong
                        });
                      };
                
                      return LayoutBox;
                
                    })(HasProperties);
                    LayoutBoxs = (function(_super) {
                      __extends(LayoutBoxs, _super);
                
                      function LayoutBoxs() {
                        _ref1 = LayoutBoxs.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LayoutBoxs.prototype.model = LayoutBox;
                
                      return LayoutBoxs;
                
                    })(Collection);
                    return {
                      "Model": LayoutBox,
                      "Collection": new LayoutBoxs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=layout_box.js.map
                */;
                (function() {
                  define('common/solver',["backbone", "underscore", "kiwi"], function(Backbone, _, kiwi) {
                    var Solver;
                    Solver = (function() {
                      function Solver() {
                        this.solver = new kiwi.Solver();
                      }
                
                      Solver.prototype.update_variables = function(trigger) {
                        if (trigger == null) {
                          trigger = true;
                        }
                        this.solver.updateVariables();
                        if (trigger) {
                          return this.trigger('layout_update');
                        }
                      };
                
                      Solver.prototype.add_constraint = function(constraint) {
                        return this.solver.addConstraint(constraint);
                      };
                
                      Solver.prototype.remove_constraint = function(constraint) {
                        return this.solver.removeConstraint(constraint);
                      };
                
                      Solver.prototype.add_edit_variable = function(variable, strength) {
                        if (strength == null) {
                          strength = kiwi.Strength.strong;
                        }
                        return this.solver.addEditVariable(variable, strength);
                      };
                
                      Solver.prototype.suggest_value = function(variable, value) {
                        return this.solver.suggestValue(variable, value);
                      };
                
                      return Solver;
                
                    })();
                    _.extend(Solver.prototype, Backbone.Events);
                    return Solver;
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=solver.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/canvas',["./collection", "kiwi", "./canvas_template", "./continuum_view", "./layout_box", "./logging", "./solver"], function(Collection, kiwi, canvas_template, ContinuumView, LayoutBox, Logging, Solver) {
                    var Canvas, CanvasView, Canvases, Constraint, EQ, Expr, logger, _ref, _ref1, _ref2;
                    Expr = kiwi.Expression;
                    Constraint = kiwi.Constraint;
                    EQ = kiwi.Operator.Eq;
                    logger = Logging.logger;
                    CanvasView = (function(_super) {
                      __extends(CanvasView, _super);
                
                      function CanvasView() {
                        _ref = CanvasView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CanvasView.prototype.className = "bk-canvas-wrapper";
                
                      CanvasView.prototype.template = canvas_template;
                
                      CanvasView.prototype.initialize = function(options) {
                        var html, template_data, _ref1;
                        CanvasView.__super__.initialize.call(this, options);
                        template_data = {
                          map: this.mget('map')
                        };
                        html = this.template(template_data);
                        this.$el.html(html);
                        this.canvas_wrapper = this.$el;
                        this.canvas = this.$('canvas.bk-canvas');
                        this.canvas_events = this.$('div.bk-canvas-events');
                        this.canvas_overlay = this.$('div.bk-canvas-overlays');
                        this.map_div = (_ref1 = this.$('div.bk-canvas-map')) != null ? _ref1 : null;
                        return logger.debug("CanvasView initialized");
                      };
                
                      CanvasView.prototype.render = function(force) {
                        var backingStoreRatio, devicePixelRatio, height, ratio, width;
                        if (force == null) {
                          force = false;
                        }
                        if (!this.model.new_bounds && !force) {
                          return;
                        }
                        this.ctx = this.canvas[0].getContext('2d');
                        if (this.mget('use_hidpi')) {
                          devicePixelRatio = window.devicePixelRatio || 1;
                          backingStoreRatio = this.ctx.webkitBackingStorePixelRatio || this.ctx.mozBackingStorePixelRatio || this.ctx.msBackingStorePixelRatio || this.ctx.oBackingStorePixelRatio || this.ctx.backingStorePixelRatio || 1;
                          ratio = devicePixelRatio / backingStoreRatio;
                        } else {
                          ratio = 1;
                        }
                        width = this.mget('width');
                        height = this.mget('height');
                        this.canvas.width = width * this.dpi_ratio;
                        this.canvas.height = height * this.dpi_ratio;
                        this.$el.attr('style', "z-index: 50; width:" + width + "px; height:" + height + "px");
                        this.canvas.attr('style', "width:" + width + "px;height:" + height + "px");
                        this.canvas.attr('width', width * ratio).attr('height', height * ratio);
                        this.$el.attr("width", width).attr('height', height);
                        this.canvas_events.attr('style', "z-index:100; position:absolute; top:0; left:0; width:" + width + "px; height:" + height + "px;");
                        this.canvas_overlay.attr('style', "z-index:75; position:absolute; top:0; left:0; width:" + width + "px; height:" + height + "px;");
                        this.ctx.scale(ratio, ratio);
                        this.ctx.translate(0.5, 0.5);
                        this._fixup_line_dash(this.ctx);
                        this._fixup_line_dash_offset(this.ctx);
                        this._fixup_image_smoothing(this.ctx);
                        this._fixup_measure_text(this.ctx);
                        return this.model.new_bounds = false;
                      };
                
                      CanvasView.prototype._fixup_line_dash = function(ctx) {
                        if (!ctx.setLineDash) {
                          ctx.setLineDash = function(dash) {
                            ctx.mozDash = dash;
                            return ctx.webkitLineDash = dash;
                          };
                        }
                        if (!ctx.getLineDash) {
                          return ctx.getLineDash = function() {
                            return ctx.mozDash;
                          };
                        }
                      };
                
                      CanvasView.prototype._fixup_line_dash_offset = function(ctx) {
                        ctx.setLineDashOffset = function(dash_offset) {
                          ctx.lineDashOffset = dash_offset;
                          ctx.mozDashOffset = dash_offset;
                          return ctx.webkitLineDashOffset = dash_offset;
                        };
                        return ctx.getLineDashOffset = function() {
                          return ctx.mozDashOffset;
                        };
                      };
                
                      CanvasView.prototype._fixup_image_smoothing = function(ctx) {
                        ctx.setImageSmoothingEnabled = function(value) {
                          ctx.imageSmoothingEnabled = value;
                          ctx.mozImageSmoothingEnabled = value;
                          ctx.oImageSmoothingEnabled = value;
                          return ctx.webkitImageSmoothingEnabled = value;
                        };
                        return ctx.getImageSmoothingEnabled = function() {
                          var _ref1;
                          return (_ref1 = ctx.imageSmoothingEnabled) != null ? _ref1 : true;
                        };
                      };
                
                      CanvasView.prototype._fixup_measure_text = function(ctx) {
                        if (ctx.measureText && (ctx.html5MeasureText == null)) {
                          ctx.html5MeasureText = ctx.measureText;
                          return ctx.measureText = function(text) {
                            var textMetrics;
                            textMetrics = ctx.html5MeasureText(text);
                            textMetrics.ascent = ctx.html5MeasureText("m").width * 1.6;
                            return textMetrics;
                          };
                        }
                      };
                
                      return CanvasView;
                
                    })(ContinuumView);
                    Canvas = (function(_super) {
                      __extends(Canvas, _super);
                
                      function Canvas() {
                        _ref1 = Canvas.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Canvas.prototype.type = 'Canvas';
                
                      Canvas.prototype.default_view = CanvasView;
                
                      Canvas.prototype.initialize = function(attr, options) {
                        var solver;
                        solver = new Solver();
                        this.set('solver', solver);
                        Canvas.__super__.initialize.call(this, attr, options);
                        this.new_bounds = true;
                        solver.add_constraint(new Constraint(new Expr(this._left), EQ));
                        solver.add_constraint(new Constraint(new Expr(this._bottom), EQ));
                        this._set_dims([this.get('canvas_width'), this.get('canvas_height')]);
                        return logger.debug("Canvas initialized");
                      };
                
                      Canvas.prototype.vx_to_sx = function(x) {
                        return x;
                      };
                
                      Canvas.prototype.vy_to_sy = function(y) {
                        return this.get('height') - y;
                      };
                
                      Canvas.prototype.v_vx_to_sx = function(xx) {
                        var idx, x, _i, _len;
                        for (idx = _i = 0, _len = xx.length; _i < _len; idx = ++_i) {
                          x = xx[idx];
                          xx[idx] = x;
                        }
                        return xx;
                      };
                
                      Canvas.prototype.v_vy_to_sy = function(yy) {
                        var canvas_height, idx, y, _i, _len;
                        canvas_height = this.get('height');
                        for (idx = _i = 0, _len = yy.length; _i < _len; idx = ++_i) {
                          y = yy[idx];
                          yy[idx] = canvas_height - y;
                        }
                        return yy;
                      };
                
                      Canvas.prototype.sx_to_vx = function(x) {
                        return x;
                      };
                
                      Canvas.prototype.sy_to_vy = function(y) {
                        return this.get('height') - y;
                      };
                
                      Canvas.prototype.v_sx_to_vx = function(xx) {
                        var idx, x, _i, _len;
                        for (idx = _i = 0, _len = xx.length; _i < _len; idx = ++_i) {
                          x = xx[idx];
                          xx[idx] = x;
                        }
                        return xx;
                      };
                
                      Canvas.prototype.v_sy_to_vy = function(yy) {
                        var canvas_height, idx, y, _i, _len;
                        canvas_height = this.get('height');
                        for (idx = _i = 0, _len = yy.length; _i < _len; idx = ++_i) {
                          y = yy[idx];
                          yy[idx] = canvas_height - y;
                        }
                        return yy;
                      };
                
                      Canvas.prototype._set_width = function(width, update) {
                        if (update == null) {
                          update = true;
                        }
                        if (this._width_constraint != null) {
                          this.solver.remove_constraint(this._width_constraint);
                        }
                        this._width_constraint = new Constraint(new Expr(this._width, -width), EQ);
                        this.solver.add_constraint(this._width_constraint);
                        if (update) {
                          this.solver.update_variables();
                        }
                        return this.new_bounds = true;
                      };
                
                      Canvas.prototype._set_height = function(height, update) {
                        if (update == null) {
                          update = true;
                        }
                        if (this._height_constraint != null) {
                          this.solver.remove_constraint(this._height_constraint);
                        }
                        this._height_constraint = new Constraint(new Expr(this._height, -height), EQ);
                        this.solver.add_constraint(this._height_constraint);
                        if (update) {
                          this.solver.update_variables();
                        }
                        return this.new_bounds = true;
                      };
                
                      Canvas.prototype._set_dims = function(dims) {
                        this._set_width(dims[0], false);
                        this._set_height(dims[1], false);
                        return this.solver.update_variables();
                      };
                
                      Canvas.prototype.defaults = function() {
                        return _.extend({}, Canvas.__super__.defaults.call(this), {
                          width: 300,
                          height: 300,
                          map: false,
                          mousedown_callbacks: [],
                          mousemove_callbacks: [],
                          use_hidpi: true
                        });
                      };
                
                      return Canvas;
                
                    })(LayoutBox.Model);
                    Canvases = (function(_super) {
                      __extends(Canvases, _super);
                
                      function Canvases() {
                        _ref2 = Canvases.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Canvases.prototype.model = Canvas;
                
                      return Canvases;
                
                    })(Collection);
                    return {
                      "Model": Canvas,
                      "Collection": new Canvases()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=canvas.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('mapper/linear_mapper',["common/collection", "common/has_properties"], function(Collection, HasProperties) {
                    var LinearMapper, LinearMappers, _ref, _ref1;
                    LinearMapper = (function(_super) {
                      __extends(LinearMapper, _super);
                
                      function LinearMapper() {
                        _ref = LinearMapper.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LinearMapper.prototype.initialize = function(attrs, options) {
                        LinearMapper.__super__.initialize.call(this, attrs, options);
                        this.register_property('mapper_state', this._mapper_state, true);
                        this.add_dependencies('mapper_state', this, ['source_range', 'target_range']);
                        this.add_dependencies('mapper_state', this.get('source_range'), ['start', 'end']);
                        return this.add_dependencies('mapper_state', this.get('target_range'), ['start', 'end']);
                      };
                
                      LinearMapper.prototype.map_to_target = function(x) {
                        var offset, scale, _ref1;
                        _ref1 = this.get('mapper_state'), scale = _ref1[0], offset = _ref1[1];
                        return scale * x + offset;
                      };
                
                      LinearMapper.prototype.v_map_to_target = function(xs) {
                        var idx, offset, result, scale, x, _i, _len, _ref1;
                        _ref1 = this.get('mapper_state'), scale = _ref1[0], offset = _ref1[1];
                        result = new Float64Array(xs.length);
                        for (idx = _i = 0, _len = xs.length; _i < _len; idx = ++_i) {
                          x = xs[idx];
                          result[idx] = scale * x + offset;
                        }
                        return result;
                      };
                
                      LinearMapper.prototype.map_from_target = function(xprime) {
                        var offset, scale, _ref1;
                        _ref1 = this.get('mapper_state'), scale = _ref1[0], offset = _ref1[1];
                        return (xprime - offset) / scale;
                      };
                
                      LinearMapper.prototype.v_map_from_target = function(xprimes) {
                        var idx, offset, result, scale, xprime, _i, _len, _ref1;
                        _ref1 = this.get('mapper_state'), scale = _ref1[0], offset = _ref1[1];
                        result = new Float64Array(xprimes.length);
                        for (idx = _i = 0, _len = xprimes.length; _i < _len; idx = ++_i) {
                          xprime = xprimes[idx];
                          result[idx] = (xprime - offset) / scale;
                        }
                        return result;
                      };
                
                      LinearMapper.prototype._mapper_state = function() {
                        var offset, scale, source_end, source_start, target_end, target_start;
                        source_start = this.get('source_range').get('start');
                        source_end = this.get('source_range').get('end');
                        target_start = this.get('target_range').get('start');
                        target_end = this.get('target_range').get('end');
                        scale = (target_end - target_start) / (source_end - source_start);
                        offset = -(scale * source_start) + target_start;
                        return [scale, offset];
                      };
                
                      return LinearMapper;
                
                    })(HasProperties);
                    LinearMappers = (function(_super) {
                      __extends(LinearMappers, _super);
                
                      function LinearMappers() {
                        _ref1 = LinearMappers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LinearMappers.prototype.model = LinearMapper;
                
                      return LinearMappers;
                
                    })(Collection);
                    return {
                      "Model": LinearMapper,
                      "Collection": new LinearMappers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=linear_mapper.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('mapper/log_mapper',["common/collection", "common/has_properties"], function(Collection, HasProperties) {
                    var LogMapper, LogMappers, _ref, _ref1;
                    LogMapper = (function(_super) {
                      __extends(LogMapper, _super);
                
                      function LogMapper() {
                        _ref = LogMapper.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LogMapper.prototype.initialize = function(attrs, options) {
                        LogMapper.__super__.initialize.call(this, attrs, options);
                        this.register_property('mapper_state', this._mapper_state, true);
                        this.add_dependencies('mapper_state', this, ['source_range', 'target_range']);
                        this.add_dependencies('mapper_state', this.get('source_range'), ['start', 'end']);
                        return this.add_dependencies('mapper_state', this.get('target_range'), ['start', 'end']);
                      };
                
                      LogMapper.prototype.map_to_target = function(x) {
                        var error, inter_offset, inter_scale, intermediate, offset, result, scale, _ref1;
                        _ref1 = this.get('mapper_state'), scale = _ref1[0], offset = _ref1[1], inter_scale = _ref1[2], inter_offset = _ref1[3];
                        intermediate = 0;
                        result = 0;
                        if (inter_scale === 0) {
                          intermediate = 0;
                        } else {
                          try {
                            intermediate = (Math.log(x) - inter_offset) / inter_scale;
                            if (isNaN(intermediate)) {
                              throw "NaN";
                            }
                            if (isFinite(intermediate) === false) {
                              throw "Infinite";
                            }
                          } catch (_error) {
                            error = _error;
                            intermediate = 0;
                          }
                        }
                        result = intermediate * scale + offset;
                        return result;
                      };
                
                      LogMapper.prototype.v_map_to_target = function(xs) {
                        var error, i, idx, inter_offset, inter_scale, intermediate, mask, mask1, mask2, offset, result, scale, x, _i, _j, _len, _len1, _ref1;
                        _ref1 = this.get('mapper_state'), scale = _ref1[0], offset = _ref1[1], inter_scale = _ref1[2], inter_offset = _ref1[3];
                        intermediate = new Float64Array(xs.length);
                        result = new Float64Array(xs.length);
                        if (inter_scale === 0) {
                          intermediate = xs.map(function(i) {
                            return i * 0;
                          });
                        } else {
                          try {
                            mask1 = xs.map(function(i) {
                              return i <= 0;
                            });
                            mask2 = xs.map(function(i) {
                              return isNaN(i);
                            });
                            mask = (function() {
                              var _i, _ref2, _results;
                              _results = [];
                              for (i = _i = 0, _ref2 = xs.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                                _results.push(mask1[i] | mask2[i]);
                              }
                              return _results;
                            })();
                            mask = mask.reduce(function(x, y) {
                              return x || y;
                            });
                            if (mask === 1) {
                              xs[mask] = 1;
                            }
                            intermediate = xs.map(function(i) {
                              return (Math.log(i) - inter_offset) / inter_scale;
                            });
                            for (idx = _i = 0, _len = intermediate.length; _i < _len; idx = ++_i) {
                              x = intermediate[idx];
                              if (isNaN(intermediate[idx])) {
                                throw "NaN";
                              }
                              if (isFinite(intermediate[idx]) === false) {
                                throw "Infinite";
                              }
                            }
                          } catch (_error) {
                            error = _error;
                            intermediate = xs.map(function(i) {
                              return i * 0;
                            });
                          }
                        }
                        for (idx = _j = 0, _len1 = xs.length; _j < _len1; idx = ++_j) {
                          x = xs[idx];
                          result[idx] = intermediate[idx] * scale + offset;
                        }
                        return result;
                      };
                
                      LogMapper.prototype.map_from_target = function(xprime) {
                        var inter_offset, inter_scale, intermediate, offset, scale, _ref1;
                        _ref1 = this.get('mapper_state'), scale = _ref1[0], offset = _ref1[1], inter_scale = _ref1[2], inter_offset = _ref1[3];
                        intermediate = (xprime - offset) / scale;
                        intermediate = Math.exp(inter_scale * intermediate + inter_offset);
                        return intermediate;
                      };
                
                      LogMapper.prototype.v_map_from_target = function(xprimes) {
                        var inter_offset, inter_scale, intermediate, offset, scale, _ref1;
                        _ref1 = this.get('mapper_state'), scale = _ref1[0], offset = _ref1[1], inter_scale = _ref1[2], inter_offset = _ref1[3];
                        intermediate = xprimes.map(function(i) {
                          return (i - offset) / scale;
                        });
                        intermediate = intermediate.map(function(i) {
                          return Math.exp(inter_scale * i + inter_offset);
                        });
                        return intermediate;
                      };
                
                      LogMapper.prototype._get_safe_scale = function(orig_start, orig_end) {
                        var end, log_val, start;
                        if (orig_start < 0) {
                          start = 0;
                        } else {
                          start = orig_start;
                        }
                        if (orig_end < 0) {
                          end = 0;
                        } else {
                          end = orig_end;
                        }
                        if (start === end) {
                          if (start === 0) {
                            start = 1;
                            end = 10;
                          } else {
                            log_val = Math.log(start) / Math.log(10);
                            start = Math.pow(10, Math.floor(log_val));
                            if (Math.ceil(log_val) !== Math.floor(log_val)) {
                              end = Math.pow(10, Math.ceil(log_val));
                            } else {
                              end = Math.pow(10, Math.ceil(log_val) + 1);
                            }
                          }
                        }
                        return [start, end];
                      };
                
                      LogMapper.prototype._mapper_state = function() {
                        var end, inter_offset, inter_scale, offset, scale, screen_range, source_end, source_start, start, target_end, target_start, _ref1;
                        source_start = this.get('source_range').get('start');
                        source_end = this.get('source_range').get('end');
                        target_start = this.get('target_range').get('start');
                        target_end = this.get('target_range').get('end');
                        screen_range = target_end - target_start;
                        _ref1 = this._get_safe_scale(source_start, source_end), start = _ref1[0], end = _ref1[1];
                        if (start === 0) {
                          inter_scale = Math.log(end);
                          inter_offset = 0;
                        } else {
                          inter_scale = Math.log(end) - Math.log(start);
                          inter_offset = Math.log(start);
                        }
                        scale = screen_range;
                        offset = target_start;
                        return [scale, offset, inter_scale, inter_offset];
                      };
                
                      return LogMapper;
                
                    })(HasProperties);
                    LogMappers = (function(_super) {
                      __extends(LogMappers, _super);
                
                      function LogMappers() {
                        _ref1 = LogMappers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LogMappers.prototype.model = LogMapper;
                
                      return LogMappers;
                
                    })(Collection);
                    return {
                      "Model": LogMapper,
                      "Collection": new LogMappers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=log_mapper.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('mapper/categorical_mapper',["common/collection", "./linear_mapper"], function(Collection, LinearMapper) {
                    var CategoricalMapper, CategoricalMappers, _ref, _ref1;
                    CategoricalMapper = (function(_super) {
                      __extends(CategoricalMapper, _super);
                
                      function CategoricalMapper() {
                        _ref = CategoricalMapper.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CategoricalMapper.prototype.map_to_target = function(x) {
                        var factor, factors, percent, _ref1;
                        if (typeof x === 'number') {
                          return CategoricalMapper.__super__.map_to_target.call(this, x);
                        }
                        factors = this.get('source_range').get('factors');
                        if (x.indexOf(':') >= 0) {
                          _ref1 = x.split(':'), factor = _ref1[0], percent = _ref1[1];
                          percent = parseFloat(percent);
                          return CategoricalMapper.__super__.map_to_target.call(this, factors.indexOf(factor) + 0.5 + percent);
                        }
                        return CategoricalMapper.__super__.map_to_target.call(this, factors.indexOf(x) + 1);
                      };
                
                      CategoricalMapper.prototype.v_map_to_target = function(xs) {
                        var factor, factors, i, percent, results, x, _i, _ref1, _ref2;
                        if (typeof xs[0] === 'number') {
                          return CategoricalMapper.__super__.v_map_to_target.call(this, xs);
                        }
                        factors = this.get('source_range').get('factors');
                        results = Array(xs.length);
                        for (i = _i = 0, _ref1 = xs.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          x = xs[i];
                          if (x.indexOf(':') >= 0) {
                            _ref2 = x.split(':'), factor = _ref2[0], percent = _ref2[1];
                            percent = parseFloat(percent);
                            results[i] = factors.indexOf(factor) + 0.5 + percent;
                          } else {
                            results[i] = factors.indexOf(x) + 1;
                          }
                        }
                        return CategoricalMapper.__super__.v_map_to_target.call(this, results);
                      };
                
                      CategoricalMapper.prototype.map_from_target = function(xprime) {
                        var factors;
                        xprime = CategoricalMapper.__super__.map_from_target.call(this, xprime) - 0.5;
                        factors = this.get('source_range').get('factors');
                        return factors[Math.floor(xprime)];
                      };
                
                      CategoricalMapper.prototype.v_map_from_target = function(xprimes) {
                        var factors, i, result, _i, _ref1;
                        result = CategoricalMapper.__super__.v_map_from_target.call(this, xprimes);
                        factors = this.get('source_range').get('factors');
                        for (i = _i = 0, _ref1 = result.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          result[i] = factors[Math.floor(result[i] - 0.5)];
                        }
                        return result;
                      };
                
                      return CategoricalMapper;
                
                    })(LinearMapper.Model);
                    CategoricalMappers = (function(_super) {
                      __extends(CategoricalMappers, _super);
                
                      function CategoricalMappers() {
                        _ref1 = CategoricalMappers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CategoricalMappers.prototype.model = CategoricalMapper;
                
                      return CategoricalMappers;
                
                    })(Collection);
                    return {
                      "Model": CategoricalMapper,
                      "Collection": new CategoricalMappers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=categorical_mapper.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('mapper/grid_mapper',["common/collection", "common/has_properties"], function(Collection, HasProperties) {
                    var GridMapper, GridMappers, _ref, _ref1;
                    GridMapper = (function(_super) {
                      __extends(GridMapper, _super);
                
                      function GridMapper() {
                        _ref = GridMapper.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      GridMapper.prototype.map_to_target = function(x, y) {
                        var xprime, yprime;
                        xprime = this.get('domain_mapper').map_to_target(x);
                        yprime = this.get('codomain_mapper').map_to_target(y);
                        return [xprime, yprime];
                      };
                
                      GridMapper.prototype.v_map_to_target = function(xs, ys) {
                        var xprimes, yprimes;
                        xprimes = this.get('domain_mapper').v_map_to_target(xs);
                        yprimes = this.get('codomain_mapper').v_map_to_target(ys);
                        return [xprimes, yprimes];
                      };
                
                      GridMapper.prototype.map_from_target = function(xprime, yprime) {
                        var x, y;
                        x = this.get('domain_mapper').map_from_target(xprime);
                        y = this.get('codomain_mapper').map_from_target(yprime);
                        return [x, y];
                      };
                
                      GridMapper.prototype.v_map_from_target = function(xprimes, yprimes) {
                        var xs, ys;
                        xs = this.get('domain_mapper').v_map_from_target(xprimes);
                        ys = this.get('codomain_mapper').v_map_from_target(yprimes);
                        return [xs, ys];
                      };
                
                      return GridMapper;
                
                    })(HasProperties);
                    GridMappers = (function(_super) {
                      __extends(GridMappers, _super);
                
                      function GridMappers() {
                        _ref1 = GridMappers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      GridMappers.prototype.model = GridMapper;
                
                      return GridMappers;
                
                    })(Collection);
                    return {
                      "Model": GridMapper,
                      "Collection": new GridMappers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=grid_mapper.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/cartesian_frame',["underscore", "./collection", "./layout_box", "./logging", "mapper/linear_mapper", "mapper/log_mapper", "mapper/categorical_mapper", "mapper/grid_mapper"], function(_, Collection, LayoutBox, Logging, LinearMapper, LogMapper, CategoricalMapper, GridMapper) {
                    var CartesianFrame, CartesianFrames, logger, _ref, _ref1;
                    logger = Logging.logger;
                    CartesianFrame = (function(_super) {
                      __extends(CartesianFrame, _super);
                
                      function CartesianFrame() {
                        _ref = CartesianFrame.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CartesianFrame.prototype.type = 'CartesianFrame';
                
                      CartesianFrame.prototype.initialize = function(attrs, options) {
                        CartesianFrame.__super__.initialize.call(this, attrs, options);
                        this.register_property('x_ranges', function() {
                          return this._get_ranges('x');
                        }, true);
                        this.add_dependencies('x_ranges', this, ['x_range', 'extra_x_ranges']);
                        this.register_property('y_ranges', function() {
                          return this._get_ranges('y');
                        }, true);
                        this.add_dependencies('y_ranges', this, ['y_range', 'extra_y_ranges']);
                        this.register_property('x_mappers', function() {
                          return this._get_mappers('x', this.get('x_ranges'), this.get('h_range'));
                        }, true);
                        this.add_dependencies('x_ranges', this, ['x_ranges', 'h_range']);
                        this.register_property('y_mappers', function() {
                          return this._get_mappers('y', this.get('y_ranges'), this.get('v_range'));
                        }, true);
                        this.add_dependencies('y_ranges', this, ['y_ranges', 'v_range']);
                        this.register_property('mapper', function() {
                          return new GridMapper.Model({
                            domain_mapper: this.get('x_mapper'),
                            codomain_mapper: this.get('y_mapper')
                          });
                        }, true);
                        this.add_dependencies('mapper', this, ['x_mapper', 'y_mapper']);
                        return this.listenTo(this.solver, 'layout_update', this._update_mappers);
                      };
                
                      CartesianFrame.prototype.map_to_screen = function(x, x_units, y, y_units, canvas, x_name, y_name) {
                        var sx, sy, vx, vy;
                        if (x_name == null) {
                          x_name = 'default';
                        }
                        if (y_name == null) {
                          y_name = 'default';
                        }
                        if (x_units === 'screen') {
                          if (_.isArray(x)) {
                            vx = x.slice(0);
                          } else {
                            vx = new Float64Array(x.length);
                            vx.set(x);
                          }
                        } else {
                          vx = this.get('x_mappers')[x_name].v_map_to_target(x);
                        }
                        if (y_units === 'screen') {
                          if (_.isArray(y)) {
                            vy = y.slice(0);
                          } else {
                            vy = new Float64Array(y.length);
                            vy.set(y);
                          }
                        } else {
                          vy = this.get('y_mappers')[y_name].v_map_to_target(y);
                        }
                        sx = canvas.v_vx_to_sx(vx);
                        sy = canvas.v_vy_to_sy(vy);
                        return [sx, sy];
                      };
                
                      CartesianFrame.prototype.map_from_screen = function(sx, sy, units, canvas) {
                        var dx, dy, x, y, _ref1;
                        if (_.isArray(sx)) {
                          dx = sx.slice(0);
                        } else {
                          dx = new Float64Array(sx.length);
                          dx.set(sx);
                        }
                        if (_.isArray(sy)) {
                          dy = sy.slice(0);
                        } else {
                          dy = new Float64Array(sy.length);
                          dy.set(sy);
                        }
                        sx = canvas.v_sx_to_vx(dx);
                        sy = canvas.v_sy_to_vy(dy);
                        if (units === 'screen') {
                          x = sx;
                          y = sy;
                        } else {
                          _ref1 = this.mapper.v_map_from_target(sx, sy), x = _ref1[0], y = _ref1[1];
                        }
                        return [x, y];
                      };
                
                      CartesianFrame.prototype._get_ranges = function(dim) {
                        var extra_ranges, name, range, ranges;
                        ranges = {};
                        ranges['default'] = this.get("" + dim + "_range");
                        extra_ranges = this.get("extra_" + dim + "_ranges");
                        if (extra_ranges != null) {
                          for (name in extra_ranges) {
                            range = extra_ranges[name];
                            ranges[name] = this.resolve_ref(range);
                          }
                        }
                        return ranges;
                      };
                
                      CartesianFrame.prototype._get_mappers = function(dim, ranges, frame_range) {
                        var mapper_type, mappers, name, range;
                        mappers = {};
                        for (name in ranges) {
                          range = ranges[name];
                          if (range.type === "Range1d" || range.type === "DataRange1d") {
                            if (this.get("" + dim + "_mapper_type") === "log") {
                              mapper_type = LogMapper.Model;
                            } else {
                              mapper_type = LinearMapper.Model;
                            }
                          } else if (range.type === "FactorRange") {
                            mapper_type = CategoricalMapper.Model;
                          } else {
                            logger.warn("unknown range type for range '" + name + "': " + range);
                            return null;
                          }
                          mappers[name] = new mapper_type({
                            source_range: range,
                            target_range: frame_range
                          });
                        }
                        return mappers;
                      };
                
                      CartesianFrame.prototype._update_mappers = function() {
                        var mapper, name, _ref1, _ref2, _results;
                        _ref1 = this.get('x_mappers');
                        for (name in _ref1) {
                          mapper = _ref1[name];
                          mapper.set('target_range', this.get('h_range'));
                        }
                        _ref2 = this.get('y_mappers');
                        _results = [];
                        for (name in _ref2) {
                          mapper = _ref2[name];
                          _results.push(mapper.set('target_range', this.get('v_range')));
                        }
                        return _results;
                      };
                
                      CartesianFrame.prototype.defaults = function() {
                        return _.extend({}, CartesianFrame.__super__.defaults.call(this), {
                          extra_x_ranges: {},
                          extra_y_ranges: {}
                        });
                      };
                
                      return CartesianFrame;
                
                    })(LayoutBox.Model);
                    CartesianFrames = (function(_super) {
                      __extends(CartesianFrames, _super);
                
                      function CartesianFrames() {
                        _ref1 = CartesianFrames.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CartesianFrames.prototype.model = CartesianFrame;
                
                      return CartesianFrames;
                
                    })(Collection);
                    return {
                      "Model": CartesianFrame,
                      "Collection": new CartesianFrames()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=cartesian_frame.js.map
                */;
                (function() {
                  define('common/build_views',["underscore"], function(_) {
                    var build_views;
                    return build_views = function(view_storage, view_models, options, view_types) {
                      var created_views, i_model, key, model, newmodels, to_remove, view_specific_option, _i, _j, _len, _len1;
                      if (view_types == null) {
                        view_types = [];
                      }
                      created_views = [];
                      newmodels = _.filter(view_models, function(x) {
                        return !_.has(view_storage, x.id);
                      });
                      for (i_model = _i = 0, _len = newmodels.length; _i < _len; i_model = ++_i) {
                        model = newmodels[i_model];
                        view_specific_option = _.extend({}, options, {
                          'model': model
                        });
                        if (i_model < view_types.length) {
                          view_storage[model.id] = new view_types[i_model](view_specific_option);
                        } else {
                          view_storage[model.id] = new model.default_view(view_specific_option);
                        }
                        created_views.push(view_storage[model.id]);
                      }
                      to_remove = _.difference(_.keys(view_storage), _.pluck(view_models, 'id'));
                      for (_j = 0, _len1 = to_remove.length; _j < _len1; _j++) {
                        key = to_remove[_j];
                        view_storage[key].remove();
                        delete view_storage[key];
                      }
                      return created_views;
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=build_views.js.map
                */;
                /*! Hammer.JS - v2.0.4 - 2014-09-28
                 * http://hammerjs.github.io/
                 *
                 * Copyright (c) 2014 Jorik Tangelder;
                 * Licensed under the MIT license */
                !function(a,b,c,d){function e(a,b,c){return setTimeout(k(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function i(a,b){return h(a,b,!0)}function j(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&h(d,c)}function k(a,b){return function(){return a.apply(b,arguments)}}function l(a,b){return typeof a==kb?a.apply(b?b[0]||d:d,b):a}function m(a,b){return a===d?b:a}function n(a,b,c){g(r(b),function(b){a.addEventListener(b,c,!1)})}function o(a,b,c){g(r(b),function(b){a.removeEventListener(b,c,!1)})}function p(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function q(a,b){return a.indexOf(b)>-1}function r(a){return a.trim().split(/\s+/g)}function s(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function t(a){return Array.prototype.slice.call(a,0)}function u(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];s(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function v(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ib.length;){if(c=ib[g],e=c?c+f:b,e in a)return e;g++}return d}function w(){return ob++}function x(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function y(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){l(a.options.enable,[a])&&c.handler(b)},this.init()}function z(a){var b,c=a.options.inputClass;return new(b=c?c:rb?N:sb?Q:qb?S:M)(a,A)}function A(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&yb&&d-e===0,g=b&(Ab|Bb)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,B(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function B(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=E(b)),e>1&&!c.firstMultiple?c.firstMultiple=E(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=F(d);b.timeStamp=nb(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=J(h,i),b.distance=I(h,i),C(c,b),b.offsetDirection=H(b.deltaX,b.deltaY),b.scale=g?L(g.pointers,d):1,b.rotation=g?K(g.pointers,d):0,D(c,b);var j=a.element;p(b.srcEvent.target,j)&&(j=b.srcEvent.target),b.target=j}function C(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===yb||f.eventType===Ab)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function D(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Bb&&(i>xb||h.velocity===d)){var j=h.deltaX-b.deltaX,k=h.deltaY-b.deltaY,l=G(i,j,k);e=l.x,f=l.y,c=mb(l.x)>mb(l.y)?l.x:l.y,g=H(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function E(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:lb(a.pointers[c].clientX),clientY:lb(a.pointers[c].clientY)},c++;return{timeStamp:nb(),pointers:b,center:F(b),deltaX:a.deltaX,deltaY:a.deltaY}}function F(a){var b=a.length;if(1===b)return{x:lb(a[0].clientX),y:lb(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:lb(c/b),y:lb(d/b)}}function G(a,b,c){return{x:b/a||0,y:c/a||0}}function H(a,b){return a===b?Cb:mb(a)>=mb(b)?a>0?Db:Eb:b>0?Fb:Gb}function I(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function J(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function K(a,b){return J(b[1],b[0],Lb)-J(a[1],a[0],Lb)}function L(a,b){return I(b[0],b[1],Lb)/I(a[0],a[1],Lb)}function M(){this.evEl=Nb,this.evWin=Ob,this.allow=!0,this.pressed=!1,y.apply(this,arguments)}function N(){this.evEl=Rb,this.evWin=Sb,y.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function O(){this.evTarget=Ub,this.evWin=Vb,this.started=!1,y.apply(this,arguments)}function P(a,b){var c=t(a.touches),d=t(a.changedTouches);return b&(Ab|Bb)&&(c=u(c.concat(d),"identifier",!0)),[c,d]}function Q(){this.evTarget=Xb,this.targetIds={},y.apply(this,arguments)}function R(a,b){var c=t(a.touches),d=this.targetIds;if(b&(yb|zb)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=t(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return p(a.target,i)}),b===yb)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ab|Bb)&&delete d[g[e].identifier],e++;return h.length?[u(f.concat(h),"identifier",!0),h]:void 0}function S(){y.apply(this,arguments);var a=k(this.handler,this);this.touch=new Q(this.manager,a),this.mouse=new M(this.manager,a)}function T(a,b){this.manager=a,this.set(b)}function U(a){if(q(a,bc))return bc;var b=q(a,cc),c=q(a,dc);return b&&c?cc+" "+dc:b||c?b?cc:dc:q(a,ac)?ac:_b}function V(a){this.id=w(),this.manager=null,this.options=i(a||{},this.defaults),this.options.enable=m(this.options.enable,!0),this.state=ec,this.simultaneous={},this.requireFail=[]}function W(a){return a&jc?"cancel":a&hc?"end":a&gc?"move":a&fc?"start":""}function X(a){return a==Gb?"down":a==Fb?"up":a==Db?"left":a==Eb?"right":""}function Y(a,b){var c=b.manager;return c?c.get(a):a}function Z(){V.apply(this,arguments)}function $(){Z.apply(this,arguments),this.pX=null,this.pY=null}function _(){Z.apply(this,arguments)}function ab(){V.apply(this,arguments),this._timer=null,this._input=null}function bb(){Z.apply(this,arguments)}function cb(){Z.apply(this,arguments)}function db(){V.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function eb(a,b){return b=b||{},b.recognizers=m(b.recognizers,eb.defaults.preset),new fb(a,b)}function fb(a,b){b=b||{},this.options=i(b,eb.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=z(this),this.touchAction=new T(this,this.options.touchAction),gb(this,!0),g(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function gb(a,b){var c=a.element;g(a.options.cssProps,function(a,d){c.style[v(c.style,d)]=b?a:""})}function hb(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var ib=["","webkit","moz","MS","ms","o"],jb=b.createElement("div"),kb="function",lb=Math.round,mb=Math.abs,nb=Date.now,ob=1,pb=/mobile|tablet|ip(ad|hone|od)|android/i,qb="ontouchstart"in a,rb=v(a,"PointerEvent")!==d,sb=qb&&pb.test(navigator.userAgent),tb="touch",ub="pen",vb="mouse",wb="kinect",xb=25,yb=1,zb=2,Ab=4,Bb=8,Cb=1,Db=2,Eb=4,Fb=8,Gb=16,Hb=Db|Eb,Ib=Fb|Gb,Jb=Hb|Ib,Kb=["x","y"],Lb=["clientX","clientY"];y.prototype={handler:function(){},init:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(x(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&o(this.element,this.evEl,this.domHandler),this.evTarget&&o(this.target,this.evTarget,this.domHandler),this.evWin&&o(x(this.element),this.evWin,this.domHandler)}};var Mb={mousedown:yb,mousemove:zb,mouseup:Ab},Nb="mousedown",Ob="mousemove mouseup";j(M,y,{handler:function(a){var b=Mb[a.type];b&yb&&0===a.button&&(this.pressed=!0),b&zb&&1!==a.which&&(b=Ab),this.pressed&&this.allow&&(b&Ab&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:vb,srcEvent:a}))}});var Pb={pointerdown:yb,pointermove:zb,pointerup:Ab,pointercancel:Bb,pointerout:Bb},Qb={2:tb,3:ub,4:vb,5:wb},Rb="pointerdown",Sb="pointermove pointerup pointercancel";a.MSPointerEvent&&(Rb="MSPointerDown",Sb="MSPointerMove MSPointerUp MSPointerCancel"),j(N,y,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Pb[d],f=Qb[a.pointerType]||a.pointerType,g=f==tb,h=s(b,a.pointerId,"pointerId");e&yb&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ab|Bb)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Tb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Ub="touchstart",Vb="touchstart touchmove touchend touchcancel";j(O,y,{handler:function(a){var b=Tb[a.type];if(b===yb&&(this.started=!0),this.started){var c=P.call(this,a,b);b&(Ab|Bb)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}});var Wb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Xb="touchstart touchmove touchend touchcancel";j(Q,y,{handler:function(a){var b=Wb[a.type],c=R.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}),j(S,y,{handler:function(a,b,c){var d=c.pointerType==tb,e=c.pointerType==vb;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Ab|Bb)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Yb=v(jb.style,"touchAction"),Zb=Yb!==d,$b="compute",_b="auto",ac="manipulation",bc="none",cc="pan-x",dc="pan-y";T.prototype={set:function(a){a==$b&&(a=this.compute()),Zb&&(this.manager.element.style[Yb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){l(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),U(a.join(" "))},preventDefaults:function(a){if(!Zb){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=q(d,bc),f=q(d,dc),g=q(d,cc);return e||f&&c&Hb||g&&c&Ib?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var ec=1,fc=2,gc=4,hc=8,ic=hc,jc=16,kc=32;V.prototype={defaults:{},set:function(a){return h(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=Y(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=Y(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=Y(a,this),-1===s(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=Y(a,this);var b=s(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(c.options.event+(b?W(d):""),a)}var c=this,d=this.state;hc>d&&b(!0),b(),d>=hc&&b(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=kc)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(kc|ec)))return!1;a++}return!0},recognize:function(a){var b=h({},a);return l(this.options.enable,[this,b])?(this.state&(ic|jc|kc)&&(this.state=ec),this.state=this.process(b),void(this.state&(fc|gc|hc|jc)&&this.tryEmit(b))):(this.reset(),void(this.state=kc))},process:function(){},getTouchAction:function(){},reset:function(){}},j(Z,V,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(fc|gc),e=this.attrTest(a);return d&&(c&Bb||!e)?b|jc:d||e?c&Ab?b|hc:b&fc?b|gc:fc:kc}}),j($,Z,{defaults:{event:"pan",threshold:10,pointers:1,direction:Jb},getTouchAction:function(){var a=this.options.direction,b=[];return a&Hb&&b.push(dc),a&Ib&&b.push(cc),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Hb?(e=0===f?Cb:0>f?Db:Eb,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Cb:0>g?Fb:Gb,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return Z.prototype.attrTest.call(this,a)&&(this.state&fc||!(this.state&fc)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),j(_,Z,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&fc)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),j(ab,V,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[_b]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ab|Bb)&&!f)this.reset();else if(a.eventType&yb)this.reset(),this._timer=e(function(){this.state=ic,this.tryEmit()},b.time,this);else if(a.eventType&Ab)return ic;return kc},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===ic&&(a&&a.eventType&Ab?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=nb(),this.manager.emit(this.options.event,this._input)))}}),j(bb,Z,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&fc)}}),j(cb,Z,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:Hb|Ib,pointers:1},getTouchAction:function(){return $.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Hb|Ib)?b=a.velocity:c&Hb?b=a.velocityX:c&Ib&&(b=a.velocityY),this._super.attrTest.call(this,a)&&c&a.direction&&a.distance>this.options.threshold&&mb(b)>this.options.velocity&&a.eventType&Ab},emit:function(a){var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),j(db,V,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[ac]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&yb&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ab)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||I(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=ic,this.tryEmit()},b.interval,this),fc):ic}return kc},failTimeout:function(){return this._timer=e(function(){this.state=kc},this.options.interval,this),kc},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==ic&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),eb.VERSION="2.0.4",eb.defaults={domEvents:!1,touchAction:$b,enable:!0,inputTarget:null,inputClass:null,preset:[[bb,{enable:!1}],[_,{enable:!1},["rotate"]],[cb,{direction:Hb}],[$,{direction:Hb},["swipe"]],[db],[db,{event:"doubletap",taps:2},["tap"]],[ab]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var lc=1,mc=2;fb.prototype={set:function(a){return h(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?mc:lc},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&ic)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===mc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(fc|gc|hc)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof V)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(s(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return g(r(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return g(r(a),function(a){b?c[a].splice(s(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&hb(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&gb(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},h(eb,{INPUT_START:yb,INPUT_MOVE:zb,INPUT_END:Ab,INPUT_CANCEL:Bb,STATE_POSSIBLE:ec,STATE_BEGAN:fc,STATE_CHANGED:gc,STATE_ENDED:hc,STATE_RECOGNIZED:ic,STATE_CANCELLED:jc,STATE_FAILED:kc,DIRECTION_NONE:Cb,DIRECTION_LEFT:Db,DIRECTION_RIGHT:Eb,DIRECTION_UP:Fb,DIRECTION_DOWN:Gb,DIRECTION_HORIZONTAL:Hb,DIRECTION_VERTICAL:Ib,DIRECTION_ALL:Jb,Manager:fb,Input:y,TouchAction:T,TouchInput:Q,MouseInput:M,PointerEventInput:N,TouchMouseInput:S,SingleTouchInput:O,Recognizer:V,AttrRecognizer:Z,Tap:db,Pan:$,Swipe:cb,Pinch:_,Rotate:bb,Press:ab,on:n,off:o,each:g,merge:i,extend:h,inherit:j,bindFn:k,prefixed:v}),typeof define==kb&&define.amd?define('hammer',[],function(){return eb}):"undefined"!=typeof module&&module.exports?module.exports=eb:a[c]=eb}(window,document,"Hammer");
                //# sourceMappingURL=hammer.min.map;
                /*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
                 * Licensed under the MIT License (LICENSE.txt).
                 *
                 * Version: 3.1.12
                 *
                 * Requires: jQuery 1.2.2+
                 */
                !function(a){"function"==typeof define&&define.amd?define('jquery_mousewheel',["jquery"],a):"object"==typeof exports?module.exports=a:a(jQuery)}(function(a){function b(b){var g=b||window.event,h=i.call(arguments,1),j=0,l=0,m=0,n=0,o=0,p=0;if(b=a.event.fix(g),b.type="mousewheel","detail"in g&&(m=-1*g.detail),"wheelDelta"in g&&(m=g.wheelDelta),"wheelDeltaY"in g&&(m=g.wheelDeltaY),"wheelDeltaX"in g&&(l=-1*g.wheelDeltaX),"axis"in g&&g.axis===g.HORIZONTAL_AXIS&&(l=-1*m,m=0),j=0===m?l:m,"deltaY"in g&&(m=-1*g.deltaY,j=m),"deltaX"in g&&(l=g.deltaX,0===m&&(j=-1*l)),0!==m||0!==l){if(1===g.deltaMode){var q=a.data(this,"mousewheel-line-height");j*=q,m*=q,l*=q}else if(2===g.deltaMode){var r=a.data(this,"mousewheel-page-height");j*=r,m*=r,l*=r}if(n=Math.max(Math.abs(m),Math.abs(l)),(!f||f>n)&&(f=n,d(g,n)&&(f/=40)),d(g,n)&&(j/=40,l/=40,m/=40),j=Math[j>=1?"floor":"ceil"](j/f),l=Math[l>=1?"floor":"ceil"](l/f),m=Math[m>=1?"floor":"ceil"](m/f),k.settings.normalizeOffset&&this.getBoundingClientRect){var s=this.getBoundingClientRect();o=b.clientX-s.left,p=b.clientY-s.top}return b.deltaX=l,b.deltaY=m,b.deltaFactor=f,b.offsetX=o,b.offsetY=p,b.deltaMode=0,h.unshift(b,j,l,m),e&&clearTimeout(e),e=setTimeout(c,200),(a.event.dispatch||a.event.handle).apply(this,h)}}function c(){f=null}function d(a,b){return k.settings.adjustOldDeltas&&"mousewheel"===a.type&&b%120===0}var e,f,g=["wheel","mousewheel","DOMMouseScroll","MozMousePixelScroll"],h="onwheel"in document||document.documentMode>=9?["wheel"]:["mousewheel","DomMouseScroll","MozMousePixelScroll"],i=Array.prototype.slice;if(a.event.fixHooks)for(var j=g.length;j;)a.event.fixHooks[g[--j]]=a.event.mouseHooks;var k=a.event.special.mousewheel={version:"3.1.12",setup:function(){if(this.addEventListener)for(var c=h.length;c;)this.addEventListener(h[--c],b,!1);else this.onmousewheel=b;a.data(this,"mousewheel-line-height",k.getLineHeight(this)),a.data(this,"mousewheel-page-height",k.getPageHeight(this))},teardown:function(){if(this.removeEventListener)for(var c=h.length;c;)this.removeEventListener(h[--c],b,!1);else this.onmousewheel=null;a.removeData(this,"mousewheel-line-height"),a.removeData(this,"mousewheel-page-height")},getLineHeight:function(b){var c=a(b),d=c["offsetParent"in a.fn?"offsetParent":"parent"]();return d.length||(d=a("body")),parseInt(d.css("fontSize"),10)||parseInt(c.css("fontSize"),10)||16},getPageHeight:function(b){return a(b).height()},settings:{adjustOldDeltas:!0,normalizeOffset:!0}};a.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})});
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/ui_events',["backbone", "hammer", "jquery_mousewheel", "common/logging"], function(Backbone, Hammer, mousewheel, Logging) {
                    var UIEvents, logger, _ref;
                    logger = Logging.logger;
                    return UIEvents = (function(_super) {
                      __extends(UIEvents, _super);
                
                      function UIEvents() {
                        _ref = UIEvents.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      UIEvents.prototype.initialize = function(attrs, options) {
                        var hit_area,
                          _this = this;
                        UIEvents.__super__.initialize.call(this, attrs, options);
                        hit_area = this.get('hit_area');
                        this.hammer = new Hammer(hit_area[0]);
                        this.hammer.get('doubletap').recognizeWith('tap');
                        this.hammer.get('tap').requireFailure('doubletap');
                        this.hammer.get('doubletap').dropRequireFailure('tap');
                        this.hammer.on('doubletap', function(e) {
                          return _this._doubletap(e);
                        });
                        this.hammer.on('tap', function(e) {
                          return _this._tap(e);
                        });
                        this.hammer.on('press', function(e) {
                          return _this._press(e);
                        });
                        this.hammer.get('pan').set({
                          direction: Hammer.DIRECTION_ALL
                        });
                        this.hammer.on('panstart', function(e) {
                          return _this._pan_start(e);
                        });
                        this.hammer.on('pan', function(e) {
                          return _this._pan(e);
                        });
                        this.hammer.on('panend', function(e) {
                          return _this._pan_end(e);
                        });
                        this.hammer.get('pinch').set({
                          enable: true
                        });
                        this.hammer.on('pinchstart', function(e) {
                          return _this._pinch_start(e);
                        });
                        this.hammer.on('pinch', function(e) {
                          return _this._pinch(e);
                        });
                        this.hammer.on('pinchend', function(e) {
                          return _this._pinch_end(e);
                        });
                        this.hammer.get('rotate').set({
                          enable: true
                        });
                        this.hammer.on('rotatestart', function(e) {
                          return _this._rotate_start(e);
                        });
                        this.hammer.on('rotate', function(e) {
                          return _this._rotate(e);
                        });
                        this.hammer.on('rotateend', function(e) {
                          return _this._rotate_end(e);
                        });
                        hit_area.mousemove(function(e) {
                          return _this._mouse_move(e);
                        });
                        hit_area.mouseenter(function(e) {
                          return _this._mouse_enter(e);
                        });
                        hit_area.mouseleave(function(e) {
                          return _this._mouse_exit(e);
                        });
                        hit_area.mousewheel(function(e, delta) {
                          return _this._mouse_wheel(e, delta);
                        });
                        $(document).keydown(function(e) {
                          return _this._key_down(e);
                        });
                        return $(document).keyup(function(e) {
                          return _this._key_up(e);
                        });
                      };
                
                      UIEvents.prototype.register_tool = function(tool_view) {
                        var et, id, type;
                        et = tool_view.mget('event_type');
                        id = tool_view.mget('id');
                        type = tool_view.model.type;
                        if (et == null) {
                          logger.debug("Button tool: " + type);
                          return;
                        }
                        if (et === 'pan' || et === 'pinch' || et === 'rotate') {
                          logger.debug("Registering tool: " + type + " for event '" + et + "'");
                          if (tool_view["_" + et + "_start"] != null) {
                            tool_view.listenTo(this, "" + et + ":start:" + id, tool_view["_" + et + "_start"]);
                          }
                          if (tool_view["_" + et]) {
                            tool_view.listenTo(this, "" + et + ":" + id, tool_view["_" + et]);
                          }
                          if (tool_view["_" + et + "_end"]) {
                            tool_view.listenTo(this, "" + et + ":end:" + id, tool_view["_" + et + "_end"]);
                          }
                        } else if (et === "move") {
                          logger.debug("Registering tool: " + type + " for event '" + et + "'");
                          if (tool_view._move_enter != null) {
                            tool_view.listenTo(this, "move:enter", tool_view._move_enter);
                          }
                          tool_view.listenTo(this, "move", tool_view["_move"]);
                          if (tool_view._move_exit != null) {
                            tool_view.listenTo(this, "move:exit", tool_view._move_exit);
                          }
                        } else {
                          logger.debug("Registering tool: " + type + " for event '" + et + "'");
                          tool_view.listenTo(this, "" + et + ":" + id, tool_view["_" + et]);
                        }
                        if (tool_view._keydown != null) {
                          logger.debug("Registering tool: " + type + " for event 'keydown'");
                          tool_view.listenTo(this, "keydown", tool_view._keydown);
                        }
                        if (tool_view._keyup != null) {
                          logger.debug("Registering tool: " + type + " for event 'keyup'");
                          tool_view.listenTo(this, "keyup", tool_view._keyup);
                        }
                        if (tool_view._doubletap != null) {
                          logger.debug("Registering tool: " + type + " for event 'doubletap'");
                          return tool_view.listenTo(this, "doubletap", tool_view._doubletap);
                        }
                      };
                
                      UIEvents.prototype._trigger = function(event_type, e) {
                        var active, base_event_type, gestures, tm;
                        tm = this.get('tool_manager');
                        base_event_type = event_type.split(":")[0];
                        gestures = tm.get('gestures');
                        active = gestures[base_event_type].active;
                        if (active != null) {
                          return this.trigger("" + event_type + ":" + active.id, e);
                        }
                      };
                
                      UIEvents.prototype._bokify_hammer = function(e) {
                        var left, offset, top, _ref1, _ref2;
                        if (e.pointerType === "mouse") {
                          offset = $(e.target).offset();
                          left = (_ref1 = offset.left) != null ? _ref1 : 0;
                          top = (_ref2 = offset.top) != null ? _ref2 : 0;
                          return e.bokeh = {
                            sx: e.srcEvent.pageX - left,
                            sy: e.srcEvent.pageY - top
                          };
                        } else {
                          return e.bokeh = {
                            sx: e.center.x,
                            sy: e.center.y
                          };
                        }
                      };
                
                      UIEvents.prototype._bokify_jq = function(e) {
                        var left, offset, top, _ref1, _ref2;
                        offset = $(e.currentTarget).offset();
                        left = (_ref1 = offset.left) != null ? _ref1 : 0;
                        top = (_ref2 = offset.top) != null ? _ref2 : 0;
                        return e.bokeh = {
                          sx: e.pageX - left,
                          sy: e.pageY - top
                        };
                      };
                
                      UIEvents.prototype._tap = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('tap', e);
                      };
                
                      UIEvents.prototype._doubletap = function(e) {
                        this._bokify_hammer(e);
                        return this.trigger('doubletap', e);
                      };
                
                      UIEvents.prototype._press = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('press', e);
                      };
                
                      UIEvents.prototype._pan_start = function(e) {
                        this._bokify_hammer(e);
                        e.bokeh.sx -= e.deltaX;
                        e.bokeh.sy -= e.deltaY;
                        return this._trigger('pan:start', e);
                      };
                
                      UIEvents.prototype._pan = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('pan', e);
                      };
                
                      UIEvents.prototype._pan_end = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('pan:end', e);
                      };
                
                      UIEvents.prototype._pinch_start = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('pinch:start', e);
                      };
                
                      UIEvents.prototype._pinch = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('pinch', e);
                      };
                
                      UIEvents.prototype._pinch_end = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('pinch:end', e);
                      };
                
                      UIEvents.prototype._rotate_start = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('rotate:start', e);
                      };
                
                      UIEvents.prototype._rotate = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('rotate', e);
                      };
                
                      UIEvents.prototype._rotate_end = function(e) {
                        this._bokify_hammer(e);
                        return this._trigger('rotate:end', e);
                      };
                
                      UIEvents.prototype._mouse_enter = function(e) {
                        this._bokify_jq(e);
                        return this.trigger('move:enter', e);
                      };
                
                      UIEvents.prototype._mouse_move = function(e) {
                        this._bokify_jq(e);
                        return this.trigger('move', e);
                      };
                
                      UIEvents.prototype._mouse_exit = function(e) {
                        this._bokify_jq(e);
                        return this.trigger('move:exit', e);
                      };
                
                      UIEvents.prototype._mouse_wheel = function(e, delta) {
                        this._bokify_jq(e);
                        e.bokeh.delta = delta;
                        this._trigger('scroll', e);
                        e.preventDefault();
                        return e.stopPropagation();
                      };
                
                      UIEvents.prototype._key_down = function(e) {
                        return this.trigger('keydown', e);
                      };
                
                      UIEvents.prototype._key_up = function(e) {
                        return this.trigger('keyup', e);
                      };
                
                      return UIEvents;
                
                    })(Backbone.Model);
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=ui_events.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/has_parent',["underscore", "./has_properties"], function(_, HasProperties) {
                    var HasParent, _ref;
                    HasParent = (function(_super) {
                      __extends(HasParent, _super);
                
                      function HasParent() {
                        _ref = HasParent.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      HasParent.prototype.initialize = function(attrs, options) {
                        HasParent.__super__.initialize.call(this, attrs, options);
                        return this._parent = HasProperties.prototype.get.apply(this, ['parent']);
                      };
                
                      HasParent.prototype.get = function(attr) {
                        var val;
                        if (!this._display_defaults) {
                          this._display_defaults = this.display_defaults();
                        }
                        if (attr === 'parent') {
                          return this._parent;
                        }
                        val = HasParent.__super__.get.call(this, attr);
                        if (!_.isUndefined(val)) {
                          return val;
                        }
                        if (this._parent && _.indexOf(this._parent.parent_properties, attr) >= 0) {
                          val = this._parent.get(attr);
                          if (!_.isUndefined(val)) {
                            return val;
                          }
                        }
                        return this._display_defaults[attr];
                      };
                
                      HasParent.prototype.display_defaults = function() {
                        return {};
                      };
                
                      return HasParent;
                
                    })(HasProperties);
                    return HasParent;
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=has_parent.js.map
                */;
                (function() {
                  define('common/plot_utils',[], function() {
                    var LEVELS, delay_animation, throttle_animation, _delay_animation;
                    LEVELS = ['image', 'underlay', 'glyph', 'overlay', 'annotation', 'tool'];
                    _delay_animation = function(f) {
                      return f();
                    };
                    delay_animation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || _delay_animation;
                    throttle_animation = function(func, wait) {
                      var args, context, later, pending, previous, result, timeout, _ref;
                      _ref = [null, null, null, null], context = _ref[0], args = _ref[1], timeout = _ref[2], result = _ref[3];
                      previous = 0;
                      pending = false;
                      later = function() {
                        previous = new Date;
                        timeout = null;
                        pending = false;
                        return result = func.apply(context, args);
                      };
                      return function() {
                        var now, remaining;
                        now = new Date;
                        remaining = wait - (now - previous);
                        context = this;
                        args = arguments;
                        if (remaining <= 0 && !pending) {
                          clearTimeout(timeout);
                          pending = true;
                          delay_animation(later);
                        } else if (!timeout) {
                          timeout = setTimeout((function() {
                            return delay_animation(later);
                          }), remaining);
                        }
                        return result;
                      };
                    };
                    return {
                      "LEVELS": LEVELS,
                      "throttle_animation": throttle_animation
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=plot_utils.js.map
                */;
                define('bootstrap/dropdown',["jquery"], function(jQuery) {
                
                /* ========================================================================
                 * Bootstrap: dropdown.js v3.1.1
                 * http://getbootstrap.com/javascript/#dropdowns
                 * ========================================================================
                 * Copyright 2011-2014 Twitter, Inc.
                 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
                 * ======================================================================== */
                
                
                +function ($) {
                  
                
                  // DROPDOWN CLASS DEFINITION
                  // =========================
                
                  var backdrop = '.bk-bs-dropdown-backdrop'
                  var toggle   = '[data-bk-bs-toggle=dropdown]'
                  var Dropdown = function (element) {
                    $(element).on('click.bk-bs.dropdown', this.toggle)
                  }
                
                  Dropdown.prototype.toggle = function (e) {
                    var $this = $(this)
                
                    if ($this.is('.bk-bs-disabled, :disabled')) return
                
                    var $parent  = getParent($this)
                    var isActive = $parent.hasClass('bk-bs-open')
                
                    clearMenus()
                
                    if (!isActive) {
                      if ('ontouchstart' in document.documentElement && !$parent.closest('.bk-bs-navbar-nav').length) {
                        // if mobile we use a backdrop because click events don't delegate
                        $('<div class="bk-bs-dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus)
                      }
                
                      var relatedTarget = { relatedTarget: this }
                      $parent.trigger(e = $.Event('show.bk-bs.dropdown', relatedTarget))
                
                      if (e.isDefaultPrevented()) return
                
                      $parent
                        .toggleClass('bk-bs-open')
                        .trigger('shown.bk-bs.dropdown', relatedTarget)
                
                      $this.focus()
                    }
                
                    return false
                  }
                
                  Dropdown.prototype.keydown = function (e) {
                    if (!/(38|40|27)/.test(e.keyCode)) return
                
                    var $this = $(this)
                
                    e.preventDefault()
                    e.stopPropagation()
                
                    if ($this.is('.bk-bs-disabled, :disabled')) return
                
                    var $parent  = getParent($this)
                    var isActive = $parent.hasClass('bk-bs-open')
                
                    if (!isActive || (isActive && e.keyCode == 27)) {
                      if (e.which == 27) $parent.find(toggle).focus()
                      return $this.click()
                    }
                
                    var desc = ' li:not(.bk-bs-divider):visible a'
                    var $items = $parent.find('[role=menu]' + desc + ', [role=listbox]' + desc)
                
                    if (!$items.length) return
                
                    var index = $items.index($items.filter(':focus'))
                
                    if (e.keyCode == 38 && index > 0)                 index--                        // up
                    if (e.keyCode == 40 && index < $items.length - 1) index++                        // down
                    if (!~index)                                      index = 0
                
                    $items.eq(index).focus()
                  }
                
                  function clearMenus(e) {
                    $(backdrop).remove()
                    $(toggle).each(function () {
                      var $parent = getParent($(this))
                      var relatedTarget = { relatedTarget: this }
                      if (!$parent.hasClass('bk-bs-open')) return
                      $parent.trigger(e = $.Event('hide.bk-bs.dropdown', relatedTarget))
                      if (e.isDefaultPrevented()) return
                      $parent.removeClass('bk-bs-open').trigger('hidden.bk-bs.dropdown', relatedTarget)
                    })
                  }
                
                  function getParent($this) {
                    var selector = $this.attr('data-bk-bs-target')
                
                    if (!selector) {
                      selector = $this.attr('href')
                      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
                    }
                
                    var $parent = selector && $(selector)
                
                    return $parent && $parent.length ? $parent : $this.parent()
                  }
                
                
                  // DROPDOWN PLUGIN DEFINITION
                  // ==========================
                
                  var old = $.fn.dropdown
                
                  $.fn.dropdown = function (option) {
                    return this.each(function () {
                      var $this = $(this)
                      var data  = $this.data('bk-bs.dropdown')
                
                      if (!data) $this.data('bk-bs.dropdown', (data = new Dropdown(this)))
                      if (typeof option == 'string') data[option].call($this)
                    })
                  }
                
                  $.fn.dropdown.Constructor = Dropdown
                
                
                  // DROPDOWN NO CONFLICT
                  // ====================
                
                  $.fn.dropdown.noConflict = function () {
                    $.fn.dropdown = old
                    return this
                  }
                
                
                  // APPLY TO STANDARD DROPDOWN ELEMENTS
                  // ===================================
                
                  $(document)
                    .on('click.bk-bs.dropdown.data-api', clearMenus)
                    .on('click.bk-bs.dropdown.data-api', '.bk-bs-dropdown form', function (e) { e.stopPropagation() })
                    .on('click.bk-bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
                    .on('keydown.bk-bs.dropdown.data-api', toggle + ', [role=menu], [role=listbox]', Dropdown.prototype.keydown)
                
                }(jQuery);
                
                });
                
                define('common/toolbar_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<a href=\'http://bokeh.pydata.org/\' target=\'_blank\' class=\'bk-logo bk-logo-small\'></a>\n<div class=\'bk-button-bar\'>\n  <ul class=\'bk-button-bar-list\' type="pan" />\n  <ul class=\'bk-button-bar-list\' type="scroll" />\n  <ul class=\'bk-button-bar-list\' type="pinch" />\n  <ul class=\'bk-button-bar-list\' type="tap" />\n  <ul class=\'bk-button-bar-list\' type="press" />\n  <ul class=\'bk-button-bar-list\' type="rotate" />\n  <ul class=\'bk-button-bar-list\' type="actions" />\n  <div class=\'bk-button-bar-list bk-bs-dropdown\' type="inspectors" />\n  <ul class=\'bk-button-bar-list\' type="help">\n    <li>\n  \t  <button class="bk-toolbar-button help" title="Help">\n\t    <img class="bk-btn-icon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzIwRUFGMDYyMjE2ODExOTdBNUNBNjVEQTY5OTRDRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozMjFERDhDRjIwQjIxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozMjFERDhDRTIwQjIxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTdFQUZCRjQ4NjIxNjgxMTk3QTVDQTY1REE2OTk0Q0UiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NzcyMEVBRjA2MjIxNjgxMTk3QTVDQTY1REE2OTk0Q0UiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6QBYrgAAABb0lEQVR42ozTwUeEQRjH8W3bKEs6JkpESqfVpS4RHaJL2b2sLepUh3To0KFVIjp0iegQUdG21WmVvUWsKBGRlIiU7Q+IVaT0ffi9eY33peFj7cw8zzvzzEzV7v5hxGltGEUvutR3hwvs4ck/OeoET6KACrJolaz6Cprz12L6rcEOajGEFyfxtRxhDX0Yx5e3ggV8IqlgW/4J3vCKddRrLKm5894KOjGCHiVrwDZ+sKKvpRQ0pzkzuETeEqSxpT1aa8ezCmbyuEW3b0sVxaQtQT+mfINXGPT9T+n3xqnLKTYsQQseI8FtWnstYdEZs9o0eqdQZxUNSWD9YwHj36i2UyijOWQFVvmPkOR2P8qW4AwDIQma0BEyZjGlqCo9gXjA1+0ePAQExxWTtwT3KOqG/bfZ3GOL9W7ikrIe6FSsvQdswcZymrvsf0xWpIzqYauZRcIXmFBfUUea8Qobc5a2qQtiz3nVec7nGHaf868AAwDKW1RIPmvhEQAAAABJRU5ErkJggg==">\n\t    <span class="tip">\n\t\t  <span>For Pan tool, left click and drag.<br/><br/>\n\t\t  For Wheel Zoom, hold shift and scroll or select the Wheel Zoom tool and scroll.<br/><br/></span>\n\t\t  <a href="http://bokeh.pydata.org" target="_blank">Learn More</a>\n\t    </span>\n\t  </button>\n    </li>\n  </ul>\n</div>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/plot_widget',["./continuum_view"], function(ContinuumView) {
                    var PlotWidget, _ref;
                    return PlotWidget = (function(_super) {
                      __extends(PlotWidget, _super);
                
                      function PlotWidget() {
                        _ref = PlotWidget.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PlotWidget.prototype.tagName = 'div';
                
                      PlotWidget.prototype.initialize = function(options) {
                        this.plot_model = options.plot_model;
                        return this.plot_view = options.plot_view;
                      };
                
                      PlotWidget.prototype.bind_bokeh_events = function() {};
                
                      PlotWidget.prototype.request_render = function() {
                        return this.plot_view.request_render();
                      };
                
                      return PlotWidget;
                
                    })(ContinuumView);
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=plot_widget.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/tool',["common/plot_widget", "common/has_properties", "common/logging"], function(PlotWidget, HasProperties, Logging) {
                    var Tool, ToolView, logger, _ref, _ref1;
                    logger = Logging.logger;
                    ToolView = (function(_super) {
                      __extends(ToolView, _super);
                
                      function ToolView() {
                        _ref = ToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ToolView.prototype.bind_bokeh_events = function() {
                        var _this = this;
                        return this.listenTo(this.model, 'change:active', function() {
                          if (_this.mget('active')) {
                            return _this.activate();
                          } else {
                            return _this.deactivate();
                          }
                        });
                      };
                
                      ToolView.prototype.activate = function() {};
                
                      ToolView.prototype.deactivate = function() {};
                
                      return ToolView;
                
                    })(PlotWidget);
                    Tool = (function(_super) {
                      __extends(Tool, _super);
                
                      function Tool() {
                        _ref1 = Tool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Tool.prototype._check_dims = function(dims, tool_name) {
                        var hdim, wdim, _ref2;
                        _ref2 = [false, false], wdim = _ref2[0], hdim = _ref2[1];
                        if (dims.length === 0) {
                          logger.warn("" + tool_name + " given empty dimensions");
                        } else if (dims.length === 1) {
                          if (dims[0] !== 'width' && dims[0] !== 'height') {
                            logger.warn("" + tool_name + " given unrecognized dimensions: " + dims);
                          }
                        } else if (dims.length === 2) {
                          if (dims.indexOf('width') < 0 || dims.indexOf('height') < 0) {
                            logger.warn("" + tool_name + " given unrecognized dimensions: " + dims);
                          }
                        } else {
                          logger.warn("" + tool_name + " given more than two dimensions: " + dims);
                        }
                        if (dims.indexOf('width') >= 0) {
                          wdim = true;
                        }
                        if (dims.indexOf('height') >= 0) {
                          hdim = true;
                        }
                        return [wdim, hdim];
                      };
                
                      Tool.prototype._get_dim_tooltip = function(name, _arg) {
                        var hdim, wdim;
                        wdim = _arg[0], hdim = _arg[1];
                        if (wdim && !hdim) {
                          return "" + name + " (x-axis)";
                        } else if (hdim && !wdim) {
                          return "" + name + " (y-axis)";
                        } else {
                          return name;
                        }
                      };
                
                      Tool.prototype._get_dim_limits = function(_arg, _arg1, frame, dims) {
                        var hr, vr, vx0, vx1, vxlim, vy0, vy1, vylim;
                        vx0 = _arg[0], vy0 = _arg[1];
                        vx1 = _arg1[0], vy1 = _arg1[1];
                        hr = frame.get('h_range');
                        if (dims.indexOf('width') >= 0) {
                          vxlim = [_.min([vx0, vx1]), _.max([vx0, vx1])];
                          vxlim = [_.max([vxlim[0], hr.get('min')]), _.min([vxlim[1], hr.get('max')])];
                        } else {
                          vxlim = [hr.get('min'), hr.get('max')];
                        }
                        vr = frame.get('v_range');
                        if (dims.indexOf('height') >= 0) {
                          vylim = [_.min([vy0, vy1]), _.max([vy0, vy1])];
                          vylim = [_.max([vylim[0], vr.get('min')]), _.min([vylim[1], vr.get('max')])];
                        } else {
                          vylim = [vr.get('min'), vr.get('max')];
                        }
                        return [vxlim, vylim];
                      };
                
                      Tool.prototype.defaults = function() {
                        return _.extend({}, Tool.__super__.defaults.call(this), {
                          tool_name: this.tool_name,
                          level: 'overlay'
                        });
                      };
                
                      return Tool;
                
                    })(HasProperties);
                    return {
                      "Model": Tool,
                      "View": ToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=tool.js.map
                */;
                define('tool/button_tool_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<button type="button" class="bk-toolbar-button hover">\n  <img class=\'bk-btn-icon\' src='));
                    
                      _print(this.icon);
                    
                      _print(_safe(' />\n  <span class=\'tip\'>'));
                    
                      _print(this.tooltip);
                    
                      _print(_safe('</span>\n</button>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/button_tool',["backbone", "./tool", "./button_tool_template"], function(Backbone, Tool, button_tool_template) {
                    var ButtonTool, ButtonToolButtonView, ButtonToolView, _ref, _ref1, _ref2;
                    ButtonToolButtonView = (function(_super) {
                      __extends(ButtonToolButtonView, _super);
                
                      function ButtonToolButtonView() {
                        _ref = ButtonToolButtonView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ButtonToolButtonView.prototype.tagName = "li";
                
                      ButtonToolButtonView.prototype.template = button_tool_template;
                
                      ButtonToolButtonView.prototype.events = function() {
                        if ('ontouchstart' in document) {
                          return {
                            'touchstart .bk-toolbar-button': '_clicked'
                          };
                        } else {
                          return {
                            'click .bk-toolbar-button': '_clicked'
                          };
                        }
                      };
                
                      ButtonToolButtonView.prototype.initialize = function(options) {
                        ButtonToolButtonView.__super__.initialize.call(this, options);
                        this.$el.html(this.template(this.model.attrs_and_props()));
                        this.listenTo(this.model, 'change:active', this.render);
                        return this.render();
                      };
                
                      ButtonToolButtonView.prototype.render = function() {
                        if (this.model.get('active')) {
                          this.$el.children('button').addClass('active');
                        } else {
                          this.$el.children('button').removeClass('active');
                        }
                        return this;
                      };
                
                      ButtonToolButtonView.prototype._clicked = function(e) {};
                
                      return ButtonToolButtonView;
                
                    })(Backbone.View);
                    ButtonToolView = (function(_super) {
                      __extends(ButtonToolView, _super);
                
                      function ButtonToolView() {
                        _ref1 = ButtonToolView.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      return ButtonToolView;
                
                    })(Tool.View);
                    ButtonTool = (function(_super) {
                      __extends(ButtonTool, _super);
                
                      function ButtonTool() {
                        _ref2 = ButtonTool.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      ButtonTool.prototype.initialize = function(attrs, options) {
                        ButtonTool.__super__.initialize.call(this, attrs, options);
                        return this.register_property('tooltip', function() {
                          return this.get('tool_name');
                        });
                      };
                
                      ButtonTool.prototype.defaults = function() {
                        return _.extend({}, ButtonTool.__super__.defaults.call(this), {
                          active: false,
                          tool_name: this.tool_name,
                          icon: this.icon
                        });
                      };
                
                      return ButtonTool;
                
                    })(Tool.Model);
                    return {
                      "Model": ButtonTool,
                      "View": ButtonToolView,
                      "ButtonView": ButtonToolButtonView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=button_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/actions/action_tool',["backbone", "tool/button_tool"], function(Backbone, ButtonTool) {
                    var ActionTool, ActionToolButtonView, ActionToolView, _ref, _ref1, _ref2;
                    ActionToolButtonView = (function(_super) {
                      __extends(ActionToolButtonView, _super);
                
                      function ActionToolButtonView() {
                        _ref = ActionToolButtonView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ActionToolButtonView.prototype._clicked = function() {
                        return this.model.trigger('do');
                      };
                
                      return ActionToolButtonView;
                
                    })(ButtonTool.ButtonView);
                    ActionToolView = (function(_super) {
                      __extends(ActionToolView, _super);
                
                      function ActionToolView() {
                        _ref1 = ActionToolView.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ActionToolView.prototype.initialize = function(options) {
                        ActionToolView.__super__.initialize.call(this, options);
                        return this.listenTo(this.model, 'do', this["do"]);
                      };
                
                      return ActionToolView;
                
                    })(ButtonTool.View);
                    ActionTool = (function(_super) {
                      __extends(ActionTool, _super);
                
                      function ActionTool() {
                        _ref2 = ActionTool.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      return ActionTool;
                
                    })(ButtonTool.Model);
                    return {
                      "Model": ActionTool,
                      "View": ActionToolView,
                      "ButtonView": ActionToolButtonView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=action_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/gesture_tool',["backbone", "tool/button_tool"], function(Backbone, ButtonTool) {
                    var GestureTool, GestureToolButtonView, GestureToolView, _ref, _ref1, _ref2;
                    GestureToolButtonView = (function(_super) {
                      __extends(GestureToolButtonView, _super);
                
                      function GestureToolButtonView() {
                        _ref = GestureToolButtonView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      GestureToolButtonView.prototype._clicked = function() {
                        return this.model.set('active', true);
                      };
                
                      return GestureToolButtonView;
                
                    })(ButtonTool.ButtonView);
                    GestureToolView = (function(_super) {
                      __extends(GestureToolView, _super);
                
                      function GestureToolView() {
                        _ref1 = GestureToolView.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      return GestureToolView;
                
                    })(ButtonTool.View);
                    GestureTool = (function(_super) {
                      __extends(GestureTool, _super);
                
                      function GestureTool() {
                        _ref2 = GestureTool.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      GestureTool.prototype.defaults = function() {
                        return _.extend({}, GestureTool.__super__.defaults.call(this), {
                          event_type: this.event_type,
                          default_order: this.default_order
                        });
                      };
                
                      return GestureTool;
                
                    })(ButtonTool.Model);
                    return {
                      "Model": GestureTool,
                      "View": GestureToolView,
                      "ButtonView": GestureToolButtonView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=gesture_tool.js.map
                */;
                define('tool/inspectors/inspect_tool_list_item_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<input type="checkbox" '));
                    
                      _print(this.active ? _print(_safe('checked')) : void 0);
                    
                      _print(_safe('>'));
                    
                      _print(this.tool_name);
                    
                      _print(_safe('</input>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/inspectors/inspect_tool',["backbone", "common/logging", "tool/tool", "./inspect_tool_list_item_template"], function(Backbone, Logging, Tool, inspect_tool_list_item_template) {
                    var InspectTool, InspectToolListItemView, InspectToolView, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    InspectToolListItemView = (function(_super) {
                      __extends(InspectToolListItemView, _super);
                
                      function InspectToolListItemView() {
                        _ref = InspectToolListItemView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      InspectToolListItemView.prototype.className = "bk-toolbar-inspector";
                
                      InspectToolListItemView.prototype.template = inspect_tool_list_item_template;
                
                      InspectToolListItemView.prototype.events = {
                        'click [type="checkbox"]': '_clicked'
                      };
                
                      InspectToolListItemView.prototype.initialize = function(options) {
                        this.listenTo(this.model, 'change:active', this.render);
                        return this.render();
                      };
                
                      InspectToolListItemView.prototype.render = function() {
                        this.$el.html(this.template(this.model.attrs_and_props()));
                        return this;
                      };
                
                      InspectToolListItemView.prototype._clicked = function(e) {
                        var active;
                        active = this.model.get('active');
                        return this.model.set('active', !active);
                      };
                
                      return InspectToolListItemView;
                
                    })(Backbone.View);
                    InspectToolView = (function(_super) {
                      __extends(InspectToolView, _super);
                
                      function InspectToolView() {
                        _ref1 = InspectToolView.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      return InspectToolView;
                
                    })(Tool.View);
                    InspectTool = (function(_super) {
                      __extends(InspectTool, _super);
                
                      function InspectTool() {
                        _ref2 = InspectTool.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      InspectTool.prototype.event_type = "move";
                
                      InspectTool.prototype.bind_bokeh_events = function() {
                        InspectTool.__super__.bind_bokeh_events.call(this);
                        return this.listenTo(events, 'move', this._inspect);
                      };
                
                      InspectTool.prototype.initialize = function(attrs, options) {
                        var all_renderers, names, r, renderers, _i, _len, _results;
                        InspectTool.__super__.initialize.call(this, attrs, options);
                        names = this.get('names');
                        renderers = this.get('renderers');
                        if (renderers.length === 0) {
                          all_renderers = this.get('plot').get('renderers');
                          renderers = (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = all_renderers.length; _i < _len; _i++) {
                              r = all_renderers[_i];
                              if (r.type === "GlyphRenderer") {
                                _results.push(r);
                              }
                            }
                            return _results;
                          })();
                        }
                        if (names.length > 0) {
                          renderers = (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = renderers.length; _i < _len; _i++) {
                              r = renderers[_i];
                              if (names.indexOf(r.get('name')) >= 0) {
                                _results.push(r);
                              }
                            }
                            return _results;
                          })();
                        }
                        this.set('renderers', renderers);
                        logger.debug("setting " + renderers.length + " renderers for " + this.type + " " + this.id);
                        _results = [];
                        for (_i = 0, _len = renderers.length; _i < _len; _i++) {
                          r = renderers[_i];
                          _results.push(logger.debug("- " + r.type + " " + r.id));
                        }
                        return _results;
                      };
                
                      InspectTool.prototype._inspect = function(vx, vy, e) {};
                
                      InspectTool.prototype._exit_inner = function() {};
                
                      InspectTool.prototype._exit_outer = function() {};
                
                      InspectTool.prototype.defaults = function() {
                        return _.extend({}, InspectTool.__super__.defaults.call(this), {
                          renderers: [],
                          names: [],
                          inner_only: true,
                          active: true,
                          event_type: 'move'
                        });
                      };
                
                      return InspectTool;
                
                    })(Tool.Model);
                    return {
                      "Model": InspectTool,
                      "View": InspectToolView,
                      "ListItemView": InspectToolListItemView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=inspect_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
                    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
                
                  define('common/tool_manager',["underscore", "jquery", "bootstrap/dropdown", "backbone", "./logging", "./toolbar_template", "common/has_properties", "tool/actions/action_tool", "tool/gestures/gesture_tool", "tool/inspectors/inspect_tool"], function(_, $, $$1, Backbone, Logging, toolbar_template, HasProperties, ActionTool, GestureTool, InspectTool) {
                    var ToolManager, ToolManagerView, logger, _ref, _ref1;
                    logger = Logging.logger;
                    ToolManagerView = (function(_super) {
                      __extends(ToolManagerView, _super);
                
                      function ToolManagerView() {
                        _ref = ToolManagerView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ToolManagerView.prototype.template = toolbar_template;
                
                      ToolManagerView.prototype.initialize = function(options) {
                        ToolManagerView.__super__.initialize.call(this, options);
                        this.listenTo(this.model, 'change', this.render);
                        return this.render();
                      };
                
                      ToolManagerView.prototype.render = function() {
                        var anchor, button_bar_list, et, gestures, inspectors, ul,
                          _this = this;
                        this.$el.html(this.template());
                        this.$el.addClass("bk-sidebar");
                        this.$el.addClass("bk-toolbar-active");
                        button_bar_list = this.$('.bk-button-bar-list');
                        inspectors = this.model.get('inspectors');
                        button_bar_list = this.$(".bk-bs-dropdown[type='inspectors']");
                        if (inspectors.length === 0) {
                          button_bar_list.hide();
                        } else {
                          anchor = $('<a href="#" data-bk-bs-toggle="dropdown" class="bk-bs-dropdown-toggle">inspect <span class="bk-bs-caret"></a>');
                          anchor.appendTo(button_bar_list);
                          ul = $('<ul class="bk-bs-dropdown-menu" />');
                          _.each(inspectors, function(tool) {
                            var item;
                            item = $('<li />');
                            item.append(new InspectTool.ListItemView({
                              model: tool
                            }).el);
                            return item.appendTo(ul);
                          });
                          ul.on('click', function(e) {
                            return e.stopPropagation();
                          });
                          ul.appendTo(button_bar_list);
                          anchor.dropdown();
                        }
                        button_bar_list = this.$(".bk-button-bar-list[type='actions']");
                        _.each(this.model.get('actions'), function(item) {
                          return button_bar_list.append(new ActionTool.ButtonView({
                            model: item
                          }).el);
                        });
                        gestures = this.model.get('gestures');
                        for (et in gestures) {
                          button_bar_list = this.$(".bk-button-bar-list[type='" + et + "']");
                          _.each(gestures[et].tools, function(item) {
                            return button_bar_list.append(new GestureTool.ButtonView({
                              model: item
                            }).el);
                          });
                        }
                        return this;
                      };
                
                      return ToolManagerView;
                
                    })(Backbone.View);
                    ToolManager = (function(_super) {
                      __extends(ToolManager, _super);
                
                      function ToolManager() {
                        this._active_change = __bind(this._active_change, this);
                        _ref1 = ToolManager.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ToolManager.prototype.initialize = function(attrs, options) {
                        ToolManager.__super__.initialize.call(this, attrs, options);
                        return this._init_tools();
                      };
                
                      ToolManager.prototype._init_tools = function() {
                        var actions, et, gestures, inspectors, tool, tools, _i, _len, _ref2, _results;
                        gestures = this.get('gestures');
                        _ref2 = this.get('tools');
                        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                          tool = _ref2[_i];
                          if (tool instanceof InspectTool.Model) {
                            inspectors = this.get('inspectors');
                            inspectors.push(tool);
                            this.set('inspectors', inspectors);
                          } else if (tool instanceof ActionTool.Model) {
                            actions = this.get('actions');
                            actions.push(tool);
                            this.set('actions', actions);
                          } else if (tool instanceof GestureTool.Model) {
                            et = tool.get('event_type');
                            if (!(et in gestures)) {
                              logger.warn("ToolManager: unknown event type '" + et + "' for tool: " + tool.type + " (" + tool.id + ")");
                              continue;
                            }
                            gestures[et].tools.push(tool);
                            this.listenTo(tool, 'change:active', _.bind(this._active_change, tool));
                          }
                        }
                        _results = [];
                        for (et in gestures) {
                          tools = gestures[et].tools;
                          if (tools.length === 0) {
                            continue;
                          }
                          gestures[et].tools = _.sortBy(tools, function(tool) {
                            return tool.get('default_order');
                          });
                          _results.push(gestures[et].tools[0].set('active', true));
                        }
                        return _results;
                      };
                
                      ToolManager.prototype._active_change = function(tool) {
                        var active, et, gestures, prev;
                        et = tool.get('event_type');
                        active = tool.get('active');
                        if (!active) {
                          return null;
                        }
                        gestures = this.get('gestures');
                        prev = gestures[et].active;
                        if (prev != null) {
                          logger.debug("ToolManager: deactivating tool: " + prev.type + " (" + prev.id + ") for event type '" + et + "'");
                          prev.set('active', false);
                        }
                        gestures[et].active = tool;
                        this.set('gestures', gestures);
                        logger.debug("ToolManager: activating tool: " + tool.type + " (" + tool.id + ") for event type '" + et + "'");
                        return null;
                      };
                
                      ToolManager.prototype.defaults = function() {
                        return {
                          gestures: {
                            pan: {
                              tools: [],
                              active: null
                            },
                            tap: {
                              tools: [],
                              active: null
                            },
                            doubletap: {
                              tools: [],
                              active: null
                            },
                            scroll: {
                              tools: [],
                              active: null
                            },
                            pinch: {
                              tools: [],
                              active: null
                            },
                            press: {
                              tools: [],
                              active: null
                            },
                            rotate: {
                              tools: [],
                              active: null
                            }
                          },
                          actions: [],
                          inspectors: []
                        };
                      };
                
                      return ToolManager;
                
                    })(HasProperties);
                    return {
                      "Model": ToolManager,
                      "View": ToolManagerView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=tool_manager.js.map
                */;
                define('common/plot_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<div class=\'bk-plot-wrapper\'>\n\t<table>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td class=\'bk-plot-above\'></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td class="bk-plot-left"></td>\n\t\t\t<td class=\'bk-plot-canvas-wrapper\'></td>\n\t\t\t<td class="bk-plot-right"></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td class=\'bk-plot-below\'></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t</table>\n</div>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  define('common/svg_colors',[], function() {
                    var svg_colors;
                    return svg_colors = {
                      indianred: "#CD5C5C",
                      lightcoral: "#F08080",
                      salmon: "#FA8072",
                      darksalmon: "#E9967A",
                      lightsalmon: "#FFA07A",
                      crimson: "#DC143C",
                      red: "#FF0000",
                      firebrick: "#B22222",
                      darkred: "#8B0000",
                      pink: "#FFC0CB",
                      lightpink: "#FFB6C1",
                      hotpink: "#FF69B4",
                      deeppink: "#FF1493",
                      mediumvioletred: "#C71585",
                      palevioletred: "#DB7093",
                      lightsalmon: "#FFA07A",
                      coral: "#FF7F50",
                      tomato: "#FF6347",
                      orangered: "#FF4500",
                      darkorange: "#FF8C00",
                      orange: "#FFA500",
                      gold: "#FFD700",
                      yellow: "#FFFF00",
                      lightyellow: "#FFFFE0",
                      lemonchiffon: "#FFFACD",
                      lightgoldenrodyellow: "#FAFAD2",
                      papayawhip: "#FFEFD5",
                      moccasin: "#FFE4B5",
                      peachpuff: "#FFDAB9",
                      palegoldenrod: "#EEE8AA",
                      khaki: "#F0E68C",
                      darkkhaki: "#BDB76B",
                      lavender: "#E6E6FA",
                      thistle: "#D8BFD8",
                      plum: "#DDA0DD",
                      violet: "#EE82EE",
                      orchid: "#DA70D6",
                      fuchsia: "#FF00FF",
                      magenta: "#FF00FF",
                      mediumorchid: "#BA55D3",
                      mediumpurple: "#9370DB",
                      blueviolet: "#8A2BE2",
                      darkviolet: "#9400D3",
                      darkorchid: "#9932CC",
                      darkmagenta: "#8B008B",
                      purple: "#800080",
                      indigo: "#4B0082",
                      slateblue: "#6A5ACD",
                      darkslateblue: "#483D8B",
                      mediumslateblue: "#7B68EE",
                      greenyellow: "#ADFF2F",
                      chartreuse: "#7FFF00",
                      lawngreen: "#7CFC00",
                      lime: "#00FF00",
                      limegreen: "#32CD32",
                      palegreen: "#98FB98",
                      lightgreen: "#90EE90",
                      mediumspringgreen: "#00FA9A",
                      springgreen: "#00FF7F",
                      mediumseagreen: "#3CB371",
                      seagreen: "#2E8B57",
                      forestgreen: "#228B22",
                      green: "#008000",
                      darkgreen: "#006400",
                      yellowgreen: "#9ACD32",
                      olivedrab: "#6B8E23",
                      olive: "#808000",
                      darkolivegreen: "#556B2F",
                      mediumaquamarine: "#66CDAA",
                      darkseagreen: "#8FBC8F",
                      lightseagreen: "#20B2AA",
                      darkcyan: "#008B8B",
                      teal: "#008080",
                      aqua: "#00FFFF",
                      cyan: "#00FFFF",
                      lightcyan: "#E0FFFF",
                      paleturquoise: "#AFEEEE",
                      aquamarine: "#7FFFD4",
                      turquoise: "#40E0D0",
                      mediumturquoise: "#48D1CC",
                      darkturquoise: "#00CED1",
                      cadetblue: "#5F9EA0",
                      steelblue: "#4682B4",
                      lightsteelblue: "#B0C4DE",
                      powderblue: "#B0E0E6",
                      lightblue: "#ADD8E6",
                      skyblue: "#87CEEB",
                      lightskyblue: "#87CEFA",
                      deepskyblue: "#00BFFF",
                      dodgerblue: "#1E90FF",
                      cornflowerblue: "#6495ED",
                      mediumslateblue: "#7B68EE",
                      royalblue: "#4169E1",
                      blue: "#0000FF",
                      mediumblue: "#0000CD",
                      darkblue: "#00008B",
                      navy: "#000080",
                      midnightblue: "#191970",
                      cornsilk: "#FFF8DC",
                      blanchedalmond: "#FFEBCD",
                      bisque: "#FFE4C4",
                      navajowhite: "#FFDEAD",
                      wheat: "#F5DEB3",
                      burlywood: "#DEB887",
                      tan: "#D2B48C",
                      rosybrown: "#BC8F8F",
                      sandybrown: "#F4A460",
                      goldenrod: "#DAA520",
                      darkgoldenrod: "#B8860B",
                      peru: "#CD853F",
                      chocolate: "#D2691E",
                      saddlebrown: "#8B4513",
                      sienna: "#A0522D",
                      brown: "#A52A2A",
                      maroon: "#800000",
                      white: "#FFFFFF",
                      snow: "#FFFAFA",
                      honeydew: "#F0FFF0",
                      mintcream: "#F5FFFA",
                      azure: "#F0FFFF",
                      aliceblue: "#F0F8FF",
                      ghostwhite: "#F8F8FF",
                      whitesmoke: "#F5F5F5",
                      seashell: "#FFF5EE",
                      beige: "#F5F5DC",
                      oldlace: "#FDF5E6",
                      floralwhite: "#FFFAF0",
                      ivory: "#FFFFF0",
                      antiquewhite: "#FAEBD7",
                      linen: "#FAF0E6",
                      lavenderblush: "#FFF0F5",
                      mistyrose: "#FFE4E1",
                      gainsboro: "#DCDCDC",
                      lightgrey: "#D3D3D3",
                      silver: "#C0C0C0",
                      darkgray: "#A9A9A9",
                      darkgrey: "#A9A9A9",
                      gray: "#808080",
                      grey: "#808080",
                      dimgray: "#696969",
                      dimgrey: "#696969",
                      lightslategray: "#778899",
                      lightslategrey: "#778899",
                      slategray: "#708090",
                      darkslategray: "#2F4F4F",
                      darkslategrey: "#2F4F4F",
                      black: "#000000"
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=svg_colors.js.map
                */;
                (function() {
                  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/properties',["underscore", "common/logging", "common/svg_colors"], function(_, Logging, svg_colors) {
                    var FillProperties, GlyphProperties, LineProperties, Properties, TextProperties, logger;
                    logger = Logging.logger;
                    Properties = (function() {
                      function Properties() {}
                
                      Properties.prototype.source_v_select = function(attrname, datasource) {
                        var i, obj, value, _i, _ref, _results;
                        obj = this[attrname];
                        if (obj == null) {
                          throw new Error("requested vector selection of unknown property '" + attrname + "'");
                        } else if ((obj.field != null) && (obj.field in datasource.get('data'))) {
                          return datasource.get_column(obj.field);
                        } else if (_.isObject(obj)) {
                          value = obj.value != null ? obj.value : NaN;
                          _results = [];
                          for (i = _i = 0, _ref = datasource.get_length(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                            _results.push(value);
                          }
                          return _results;
                        } else {
                          throw new Error("requested vector selection of '" + attrname + "' failed for " + obj);
                        }
                      };
                
                      Properties.prototype._fix_singleton_array_value = function(obj) {
                        var value;
                        if (obj.value != null) {
                          value = obj.value;
                          if (_.isArray(value)) {
                            if (value.length === 1) {
                              return _.extend({}, obj, {
                                value: value[0]
                              });
                            } else {
                              throw new Error("expected an array of length 1, got " + value);
                            }
                          }
                        }
                        return obj;
                      };
                
                      Properties.prototype.string = function(styleprovider, attrname) {
                        var value;
                        this[attrname] = {};
                        value = styleprovider.mget(attrname);
                        if (value == null) {
                          return this[attrname].value = null;
                        } else if (_.isString(value)) {
                          return this[attrname].value = value;
                        } else if (_.isObject(value)) {
                          value = this._fix_singleton_array_value(value);
                          return this[attrname] = _.extend(this[attrname], value);
                        } else {
                          return logger.warn("string property '" + attrname + "' given invalid value: " + value);
                        }
                      };
                
                      Properties.prototype.boolean = function(styleprovider, attrname) {
                        var value;
                        this[attrname] = {};
                        value = styleprovider.mget(attrname);
                        if (value == null) {
                          return this[attrname].value = null;
                        } else if (_.isBoolean(value)) {
                          return this[attrname].value = value;
                        } else if (_.isString(value)) {
                          return this[attrname].field = value;
                        } else if (_.isObject(value)) {
                          value = this._fix_singleton_array_value(value);
                          return this[attrname] = _.extend(this[attrname], value);
                        } else {
                          return logger.warn("boolean property '" + attrname + "' given invalid value: " + value);
                        }
                      };
                
                      Properties.prototype.number = function(styleprovider, attrname) {
                        var units_value, value, _ref;
                        this[attrname] = {};
                        units_value = (_ref = styleprovider.mget(attrname + '_units')) != null ? _ref : 'data';
                        this[attrname].units = units_value;
                        value = styleprovider.mget(attrname);
                        if (value == null) {
                          return this[attrname].value = null;
                        } else if (_.isNumber(value)) {
                          return this[attrname].value = value;
                        } else if (_.isString(value)) {
                          return this[attrname].field = value;
                        } else if (_.isObject(value)) {
                          value = this._fix_singleton_array_value(value);
                          return this[attrname] = _.extend(this[attrname], value);
                        } else {
                          return logger.warn("number property '" + attrname + "' given invalid value: " + value);
                        }
                      };
                
                      Properties.prototype.color = function(styleprovider, attrname) {
                        var value;
                        this[attrname] = {};
                        value = styleprovider.mget(attrname);
                        if (value == null) {
                          return this[attrname].value = null;
                        } else if (_.isString(value)) {
                          if ((svg_colors[value] != null) || value.substring(0, 1) === "#") {
                            return this[attrname].value = value;
                          } else {
                            return this[attrname].field = value;
                          }
                        } else if (_.isObject(value)) {
                          value = this._fix_singleton_array_value(value);
                          return this[attrname] = _.extend(this[attrname], value);
                        } else {
                          return logger.warn("color property '" + attrname + "' given invalid value: " + value);
                        }
                      };
                
                      Properties.prototype.array = function(styleprovider, attrname) {
                        var units_value, value, _ref;
                        this[attrname] = {};
                        units_value = (_ref = styleprovider.mget(attrname + "_units")) != null ? _ref : 'data';
                        this[attrname].units = units_value;
                        value = styleprovider.mget(attrname);
                        if (value == null) {
                          return this[attrname].value = null;
                        } else if (_.isString(value)) {
                          return this[attrname].field = value;
                        } else if (_.isArray(value)) {
                          return this[attrname].value = value;
                        } else if (_.isObject(value)) {
                          value = this._fix_singleton_array_value(value);
                          return this[attrname] = _.extend(this[attrname], value);
                        } else {
                          return logger.warn("array property '" + attrname + "' given invalid value: " + value);
                        }
                      };
                
                      Properties.prototype["enum"] = function(styleprovider, attrname, vals) {
                        var levels, value;
                        this[attrname] = {};
                        levels = vals.split(" ");
                        value = styleprovider.mget(attrname);
                        if (value == null) {
                          return this[attrname].value = null;
                        } else if (_.isString(value)) {
                          if (__indexOf.call(levels, value) >= 0) {
                            return this[attrname].value = value;
                          } else {
                            return this[attrname].field = value;
                          }
                        } else if (_.isObject(value)) {
                          value = this._fix_singleton_array_value(value);
                          return this[attrname] = _.extend(this[attrname], value);
                        } else {
                          logger.warn("enum property '" + attrname + "' given invalid value: " + value);
                          return logger.warn(" - acceptable values:" + levels);
                        }
                      };
                
                      Properties.prototype.setattr = function(styleprovider, attrname, attrtype) {
                        var values, _ref;
                        values = null;
                        if (attrtype.indexOf(":") > -1) {
                          _ref = attrtype.split(":"), attrtype = _ref[0], values = _ref[1];
                        }
                        if (attrtype === "string") {
                          return this.string(styleprovider, attrname);
                        } else if (attrtype === "boolean") {
                          return this.boolean(styleprovider, attrname);
                        } else if (attrtype === "number") {
                          return this.number(styleprovider, attrname);
                        } else if (attrtype === "color") {
                          return this.color(styleprovider, attrname);
                        } else if (attrtype === "array") {
                          return this.array(styleprovider, attrname);
                        } else if (attrtype === "enum" && values) {
                          return this["enum"](styleprovider, attrname, values);
                        } else {
                          return logger.warn("Unknown type '" + attrtype + "' for glyph property: " + attrname);
                        }
                      };
                
                      Properties.prototype.select = function(attrname, obj) {
                        if (!(attrname in this)) {
                          logger.warn("requested selection of unknown property '" + attrname + "' on object: " + obj);
                          return;
                        }
                        if ((this[attrname].field != null) && (this[attrname].field in obj)) {
                          return obj[this[attrname].field];
                        }
                        if (this[attrname].value != null) {
                          return this[attrname].value;
                        }
                        if (obj.get && obj.get(attrname)) {
                          return obj.get(attrname);
                        }
                        if (obj.mget && obj.mget(attrname)) {
                          return obj.mget(attrname);
                        }
                        if (obj[attrname] != null) {
                          return obj[attrname];
                        }
                        return logger.warn("selection for attribute '" + attrname + "' failed on object: " + obj);
                      };
                
                      return Properties;
                
                    })();
                    LineProperties = (function(_super) {
                      __extends(LineProperties, _super);
                
                      function LineProperties(styleprovider, prefix) {
                        if (prefix == null) {
                          prefix = "";
                        }
                        this.line_color_name = "" + prefix + "line_color";
                        this.line_width_name = "" + prefix + "line_width";
                        this.line_alpha_name = "" + prefix + "line_alpha";
                        this.line_join_name = "" + prefix + "line_join";
                        this.line_cap_name = "" + prefix + "line_cap";
                        this.line_dash_name = "" + prefix + "line_dash";
                        this.line_dash_offset_name = "" + prefix + "line_dash_offset";
                        this.color(styleprovider, this.line_color_name);
                        this.number(styleprovider, this.line_width_name);
                        this.number(styleprovider, this.line_alpha_name);
                        this["enum"](styleprovider, this.line_join_name, "miter round bevel");
                        this["enum"](styleprovider, this.line_cap_name, "butt round square");
                        this.array(styleprovider, this.line_dash_name);
                        this.number(styleprovider, this.line_dash_offset_name);
                        this.do_stroke = true;
                        if (!_.isUndefined(this[this.line_color_name].value)) {
                          if (_.isNull(this[this.line_color_name].value)) {
                            this.do_stroke = false;
                          }
                        }
                      }
                
                      LineProperties.prototype.set = function(ctx, obj) {
                        ctx.strokeStyle = this.select(this.line_color_name, obj);
                        ctx.globalAlpha = this.select(this.line_alpha_name, obj);
                        ctx.lineWidth = this.select(this.line_width_name, obj);
                        ctx.lineJoin = this.select(this.line_join_name, obj);
                        ctx.lineCap = this.select(this.line_cap_name, obj);
                        ctx.setLineDash(this.select(this.line_dash_name, obj));
                        return ctx.setLineDashOffset(this.select(this.line_dash_offset_name, obj));
                      };
                
                      LineProperties.prototype.set_prop_cache = function(datasource) {
                        this.cache = {};
                        this.cache.strokeStyle = this.source_v_select(this.line_color_name, datasource);
                        this.cache.globalAlpha = this.source_v_select(this.line_alpha_name, datasource);
                        this.cache.lineWidth = this.source_v_select(this.line_width_name, datasource);
                        this.cache.lineJoin = this.source_v_select(this.line_join_name, datasource);
                        this.cache.lineCap = this.source_v_select(this.line_cap_name, datasource);
                        this.cache.setLineDash = this.source_v_select(this.line_dash_name, datasource);
                        return this.cache.setLineDashOffset = this.source_v_select(this.line_dash_offset_name, datasource);
                      };
                
                      LineProperties.prototype.clear_prop_cache = function() {
                        return this.cache = {};
                      };
                
                      LineProperties.prototype.set_vectorize = function(ctx, i) {
                        var did_change;
                        did_change = false;
                        if ((this.cache.strokeStyle[i] != null) && ctx.strokeStyle !== this.cache.strokeStyle[i]) {
                          ctx.strokeStyle = this.cache.strokeStyle[i];
                          did_change = true;
                        }
                        if ((this.cache.globalAlpha[i] != null) && ctx.globalAlpha !== this.cache.globalAlpha[i]) {
                          ctx.globalAlpha = this.cache.globalAlpha[i];
                          did_change = true;
                        }
                        if ((this.cache.lineWidth[i] != null) && ctx.lineWidth !== this.cache.lineWidth[i]) {
                          ctx.lineWidth = this.cache.lineWidth[i];
                          did_change = true;
                        }
                        if ((this.cache.lineJoin[i] != null) && ctx.lineJoin !== this.cache.lineJoin[i]) {
                          ctx.lineJoin = this.cache.lineJoin[i];
                          did_change = true;
                        }
                        if ((this.cache.lineCap[i] != null) && ctx.lineCap !== this.cache.lineCap[i]) {
                          ctx.lineCap = this.cache.lineCap[i];
                          did_change = true;
                        }
                        if ((this.cache.setLineDash[i] != null) && ctx.getLineDash() !== this.cache.setLineDash[i]) {
                          ctx.setLineDash(this.cache.setLineDash[i]);
                          did_change = true;
                        }
                        if ((this.cache.setLineDashOffset[i] != null) && ctx.getLineDashOffset() !== this.cache.setLineDashOffset[i]) {
                          ctx.setLineDashOffset(this.cache.setLineDashOffset[i]);
                          did_change = true;
                        }
                        return did_change;
                      };
                
                      return LineProperties;
                
                    })(Properties);
                    FillProperties = (function(_super) {
                      __extends(FillProperties, _super);
                
                      function FillProperties(styleprovider, prefix) {
                        if (prefix == null) {
                          prefix = "";
                        }
                        this.fill_color_name = "" + prefix + "fill_color";
                        this.fill_alpha_name = "" + prefix + "fill_alpha";
                        this.color(styleprovider, this.fill_color_name);
                        this.number(styleprovider, this.fill_alpha_name);
                        this.do_fill = true;
                        if (!_.isUndefined(this[this.fill_color_name].value)) {
                          if (_.isNull(this[this.fill_color_name].value)) {
                            this.do_fill = false;
                          }
                        }
                      }
                
                      FillProperties.prototype.set = function(ctx, obj) {
                        ctx.fillStyle = this.select(this.fill_color_name, obj);
                        return ctx.globalAlpha = this.select(this.fill_alpha_name, obj);
                      };
                
                      FillProperties.prototype.set_prop_cache = function(datasource) {
                        this.cache = {};
                        this.cache.fillStyle = this.source_v_select(this.fill_color_name, datasource);
                        return this.cache.globalAlpha = this.source_v_select(this.fill_alpha_name, datasource);
                      };
                
                      FillProperties.prototype.set_vectorize = function(ctx, i) {
                        var did_change;
                        did_change = false;
                        if (ctx.fillStyle !== this.cache.fillStyle[i]) {
                          ctx.fillStyle = this.cache.fillStyle[i];
                          did_change = true;
                        }
                        if (ctx.globalAlpha !== this.cache.globalAlpha[i]) {
                          ctx.globalAlpha = this.cache.globalAlpha[i];
                          did_change = true;
                        }
                        return did_change;
                      };
                
                      return FillProperties;
                
                    })(Properties);
                    TextProperties = (function(_super) {
                      __extends(TextProperties, _super);
                
                      function TextProperties(styleprovider, prefix) {
                        if (prefix == null) {
                          prefix = "";
                        }
                        this.text_font_name = "" + prefix + "text_font";
                        this.text_font_size_name = "" + prefix + "text_font_size";
                        this.text_font_style_name = "" + prefix + "text_font_style";
                        this.text_color_name = "" + prefix + "text_color";
                        this.text_alpha_name = "" + prefix + "text_alpha";
                        this.text_align_name = "" + prefix + "text_align";
                        this.text_baseline_name = "" + prefix + "text_baseline";
                        this.string(styleprovider, this.text_font_name);
                        this.string(styleprovider, this.text_font_size_name);
                        this["enum"](styleprovider, this.text_font_style_name, "normal italic bold");
                        this.color(styleprovider, this.text_color_name);
                        this.number(styleprovider, this.text_alpha_name);
                        this["enum"](styleprovider, this.text_align_name, "left right center");
                        this["enum"](styleprovider, this.text_baseline_name, "top middle bottom alphabetic hanging");
                      }
                
                      TextProperties.prototype.font = function(obj, font_size) {
                        var font, font_style;
                        if (font_size == null) {
                          font_size = this.select(this.text_font_size_name, obj);
                        }
                        font = this.select(this.text_font_name, obj);
                        font_style = this.select(this.text_font_style_name, obj);
                        font = font_style + " " + font_size + " " + font;
                        return font;
                      };
                
                      TextProperties.prototype.set = function(ctx, obj) {
                        ctx.font = this.font(obj);
                        ctx.fillStyle = this.select(this.text_color_name, obj);
                        ctx.globalAlpha = this.select(this.text_alpha_name, obj);
                        ctx.textAlign = this.select(this.text_align_name, obj);
                        return ctx.textBaseline = this.select(this.text_baseline_name, obj);
                      };
                
                      TextProperties.prototype.set_prop_cache = function(datasource) {
                        var font, font_size, font_style, i;
                        this.cache = {};
                        font_size = this.source_v_select(this.text_font_size_name, datasource);
                        font = this.source_v_select(this.text_font_name, datasource);
                        font_style = this.source_v_select(this.text_font_style_name, datasource);
                        this.cache.font = (function() {
                          var _i, _ref, _results;
                          _results = [];
                          for (i = _i = 0, _ref = font.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                            _results.push("" + font_style[i] + " " + font_size[i] + " " + font[i]);
                          }
                          return _results;
                        })();
                        this.cache.fillStyle = this.source_v_select(this.text_color_name, datasource);
                        this.cache.globalAlpha = this.source_v_select(this.text_alpha_name, datasource);
                        this.cache.textAlign = this.source_v_select(this.text_align_name, datasource);
                        return this.cache.textBaseline = this.source_v_select(this.text_baseline_name, datasource);
                      };
                
                      TextProperties.prototype.clear_prop_cache = function() {
                        return this.cache = {};
                      };
                
                      TextProperties.prototype.set_vectorize = function(ctx, i) {
                        var did_change;
                        did_change = false;
                        if (ctx.font !== this.cache.font[i]) {
                          ctx.font = this.cache.font[i];
                          did_change = true;
                        }
                        if (ctx.fillStyle !== this.cache.fillStyle[i]) {
                          ctx.fillStyle = this.cache.fillStyle[i];
                          did_change = true;
                        }
                        if (ctx.globalAlpha !== this.cache.globalAlpha[i]) {
                          ctx.globalAlpha = this.cache.globalAlpha[i];
                          did_change = true;
                        }
                        if (ctx.textAlign !== this.cache.textAlign[i]) {
                          ctx.textAlign = this.cache.textAlign[i];
                          did_change = true;
                        }
                        if (ctx.textBaseline !== this.cache.textBaseline[i]) {
                          ctx.textBaseline = this.cache.textBaseline[i];
                          did_change = true;
                        }
                        return did_change;
                      };
                
                      return TextProperties;
                
                    })(Properties);
                    GlyphProperties = (function(_super) {
                      __extends(GlyphProperties, _super);
                
                      function GlyphProperties(styleprovider, attrnames) {
                        var attrname, attrtype, _i, _len, _ref;
                        for (_i = 0, _len = attrnames.length; _i < _len; _i++) {
                          attrname = attrnames[_i];
                          attrtype = "number";
                          if (attrname.indexOf(":") > -1) {
                            _ref = attrname.split(":"), attrname = _ref[0], attrtype = _ref[1];
                          }
                          this.setattr(styleprovider, attrname, attrtype);
                        }
                      }
                
                      return GlyphProperties;
                
                    })(Properties);
                    return {
                      Glyph: GlyphProperties,
                      Fill: FillProperties,
                      Line: LineProperties,
                      Text: TextProperties
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=properties.js.map
                */;
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/plot',["underscore", "backbone", "kiwi", "./build_views", "./canvas", "./cartesian_frame", "./continuum_view", "./collection", "./ui_events", "./has_parent", "./layout_box", "./logging", "./plot_utils", "./solver", "./tool_manager", "./plot_template", "renderer/properties"], function(_, Backbone, kiwi, build_views, Canvas, CartesianFrame, ContinuumView, Collection, UIEvents, HasParent, LayoutBox, Logging, plot_utils, Solver, ToolManager, plot_template, properties) {
                    var Constraint, EQ, Expr, GE, LE, Plot, PlotView, Plots, logger, _ref, _ref1, _ref2;
                    Expr = kiwi.Expression;
                    Constraint = kiwi.Constraint;
                    EQ = kiwi.Operator.Eq;
                    LE = kiwi.Operator.Le;
                    GE = kiwi.Operator.Ge;
                    logger = Logging.logger;
                    PlotView = (function(_super) {
                      __extends(PlotView, _super);
                
                      function PlotView() {
                        this.request_render = __bind(this.request_render, this);
                        _ref = PlotView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PlotView.prototype.className = "bk-plot";
                
                      PlotView.prototype.template = plot_template;
                
                      PlotView.prototype.view_options = function() {
                        return _.extend({
                          plot_model: this.model,
                          plot_view: this
                        }, this.options);
                      };
                
                      PlotView.prototype.pause = function() {
                        return this.is_paused = true;
                      };
                
                      PlotView.prototype.unpause = function() {
                        this.is_paused = false;
                        return this.request_render();
                      };
                
                      PlotView.prototype.request_render = function() {
                        if (!this.is_paused) {
                          this.throttled_render(true);
                        }
                      };
                
                      PlotView.prototype.initialize = function(options) {
                        var id, level, tool_view, toolbar_location, toolbar_selector, _i, _len, _ref1, _ref2;
                        PlotView.__super__.initialize.call(this, options);
                        this.pause();
                        this.model.initialize_layout(this.model.solver);
                        this.frame = this.mget('frame');
                        this.x_range = this.frame.get('x_ranges')['default'];
                        this.y_range = this.frame.get('y_ranges')['default'];
                        this.xmapper = this.frame.get('x_mappers')['default'];
                        this.ymapper = this.frame.get('y_mappers')['default'];
                        this.$el.html(this.template());
                        this.canvas = this.mget('canvas');
                        this.canvas_view = new this.canvas.default_view({
                          'model': this.canvas
                        });
                        this.$('.bk-plot-canvas-wrapper').append(this.canvas_view.el);
                        this.canvas_view.render();
                        this.throttled_render = plot_utils.throttle_animation(this.render, 15);
                        this.outline_props = new properties.Line(this, 'outline_');
                        this.title_props = new properties.Text(this, 'title_');
                        this.renderers = {};
                        this.tools = {};
                        this.levels = {};
                        _ref1 = plot_utils.LEVELS;
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          level = _ref1[_i];
                          this.levels[level] = {};
                        }
                        this.build_levels();
                        this.bind_bokeh_events();
                        this.model.add_constraints(this.canvas.solver);
                        this.listenTo(this.canvas.solver, 'layout_update', this.request_render);
                        this.ui_event_bus = new UIEvents({
                          tool_manager: this.mget('tool_manager'),
                          hit_area: this.canvas_view.$el
                        });
                        _ref2 = this.tools;
                        for (id in _ref2) {
                          tool_view = _ref2[id];
                          this.ui_event_bus.register_tool(tool_view);
                        }
                        toolbar_location = this.mget('toolbar_location');
                        if (toolbar_location != null) {
                          toolbar_selector = '.bk-plot-' + toolbar_location;
                          logger.debug("attaching toolbar to " + toolbar_selector + " for plot " + this.model.id);
                          this.tm_view = new ToolManager.View({
                            model: this.mget('tool_manager'),
                            el: this.$(toolbar_selector)
                          });
                        }
                        this.unpause();
                        this.request_render();
                        logger.debug("PlotView initialized");
                        return this;
                      };
                
                      PlotView.prototype.map_to_screen = function(x, x_units, y, y_units, x_name, y_name) {
                        if (x_name == null) {
                          x_name = 'default';
                        }
                        if (y_name == null) {
                          y_name = 'default';
                        }
                        return this.frame.map_to_screen(x, x_units, y, y_units, this.canvas, x_name, y_name);
                      };
                
                      PlotView.prototype.map_from_screen = function(sx, sy, units) {
                        return this.frame.map_from_screen(sx, sy, units, this.canvas, name);
                      };
                
                      PlotView.prototype.update_range = function(range_info) {
                        var name, rng, _ref1, _ref2;
                        if (range_info == null) {
                          range_info = this.initial_range_info;
                        }
                        this.pause();
                        _ref1 = this.frame.get('x_ranges');
                        for (name in _ref1) {
                          rng = _ref1[name];
                          rng.set(range_info.xrs[name]);
                        }
                        _ref2 = this.frame.get('y_ranges');
                        for (name in _ref2) {
                          rng = _ref2[name];
                          rng.set(range_info.yrs[name]);
                        }
                        return this.unpause();
                      };
                
                      PlotView.prototype.build_levels = function() {
                        var id_, level, old_renderers, renderers_to_remove, t, tools, v, views, _i, _j, _k, _len, _len1, _len2;
                        old_renderers = _.keys(this.renderers);
                        views = build_views(this.renderers, this.mget('renderers'), this.view_options());
                        renderers_to_remove = _.difference(old_renderers, _.pluck(this.mget('renderers'), 'id'));
                        for (_i = 0, _len = renderers_to_remove.length; _i < _len; _i++) {
                          id_ = renderers_to_remove[_i];
                          delete this.levels.glyph[id_];
                        }
                        tools = build_views(this.tools, this.mget('tools'), this.view_options());
                        for (_j = 0, _len1 = views.length; _j < _len1; _j++) {
                          v = views[_j];
                          level = v.mget('level');
                          this.levels[level][v.model.id] = v;
                          v.bind_bokeh_events();
                        }
                        for (_k = 0, _len2 = tools.length; _k < _len2; _k++) {
                          t = tools[_k];
                          level = t.mget('level');
                          this.levels[level][t.model.id] = t;
                          t.bind_bokeh_events();
                        }
                        return this;
                      };
                
                      PlotView.prototype.bind_bokeh_events = function() {
                        var name, rng, _ref1, _ref2,
                          _this = this;
                        _ref1 = this.mget('frame').get('x_ranges');
                        for (name in _ref1) {
                          rng = _ref1[name];
                          this.listenTo(rng, 'change', this.request_render);
                        }
                        _ref2 = this.mget('frame').get('y_ranges');
                        for (name in _ref2) {
                          rng = _ref2[name];
                          this.listenTo(rng, 'change', this.request_render);
                        }
                        this.listenTo(this.model, 'change:renderers', this.build_levels);
                        this.listenTo(this.model, 'change:tool', this.build_levels);
                        this.listenTo(this.model, 'change', this.request_render);
                        return this.listenTo(this.model, 'destroy', function() {
                          return _this.remove();
                        });
                      };
                
                      PlotView.prototype.set_initial_range = function() {
                        var good_vals, name, rng, xrs, yrs, _ref1, _ref2;
                        good_vals = true;
                        xrs = {};
                        _ref1 = this.frame.get('x_ranges');
                        for (name in _ref1) {
                          rng = _ref1[name];
                          if ((rng.get('start') == null) || (rng.get('end') == null) || _.isNaN(rng.get('start') + rng.get('end'))) {
                            good_vals = false;
                            break;
                          }
                          xrs[name] = {
                            start: rng.get('start'),
                            end: rng.get('end')
                          };
                        }
                        if (good_vals) {
                          yrs = {};
                          _ref2 = this.frame.get('y_ranges');
                          for (name in _ref2) {
                            rng = _ref2[name];
                            if ((rng.get('start') == null) || (rng.get('end') == null) || _.isNaN(rng.get('start') + rng.get('end'))) {
                              good_vals = false;
                              break;
                            }
                            yrs[name] = {
                              start: rng.get('start'),
                              end: rng.get('end')
                            };
                          }
                        }
                        if (good_vals) {
                          this.initial_range_info = {
                            xrs: xrs,
                            yrs: yrs
                          };
                          return logger.debug("initial ranges set");
                        } else {
                          return logger.warn('could not set initial ranges');
                        }
                      };
                
                      PlotView.prototype.render = function(force_canvas) {
                        var canvas, ctx, frame, frame_box, k, sx, sy, th, title, v, _ref1;
                        if (force_canvas == null) {
                          force_canvas = false;
                        }
                        logger.trace("Plot.render(force_canvas=" + force_canvas + ")");
                        PlotView.__super__.render.call(this);
                        this.canvas_view.render(force_canvas);
                        if (this.tm_view != null) {
                          this.tm_view.render();
                        }
                        ctx = this.canvas_view.ctx;
                        frame = this.model.get('frame');
                        canvas = this.model.get('canvas');
                        _ref1 = this.renderers;
                        for (k in _ref1) {
                          v = _ref1[k];
                          if (v.model.update_layout != null) {
                            v.model.update_layout(v, this.canvas.solver);
                          }
                        }
                        title = this.mget('title');
                        if (title) {
                          this.title_props.set(this.canvas_view.ctx, {});
                          th = ctx.measureText(this.mget('title')).ascent + this.model.get('title_standoff');
                          if (th !== this.model.title_panel.get('height')) {
                            this.model.title_panel.set('height', th);
                          }
                        }
                        this.model.get('frame').set('width', canvas.get('width'));
                        this.model.get('frame').set('height', canvas.get('height'));
                        this.canvas.solver.update_variables(false);
                        this.model.get('frame')._update_mappers();
                        if (this.initial_range_info == null) {
                          this.set_initial_range();
                        }
                        frame_box = [this.canvas.vx_to_sx(this.frame.get('left')), this.canvas.vy_to_sy(this.frame.get('top')), this.frame.get('width'), this.frame.get('height')];
                        this._map_hook(ctx, frame_box);
                        this._paint_empty(ctx, frame_box);
                        if (this.outline_props.do_stroke) {
                          this.outline_props.set(ctx, {});
                          ctx.strokeRect.apply(ctx, frame_box);
                        }
                        this._render_levels(ctx, ['image', 'underlay', 'glyph'], frame_box);
                        this._render_levels(ctx, ['overlay', 'tool']);
                        if (title) {
                          sx = this.canvas.vx_to_sx(this.canvas.get('width') / 2);
                          sy = this.canvas.vy_to_sy(this.model.title_panel.get('bottom') + this.model.get('title_standoff'));
                          this.title_props.set(ctx, {});
                          return ctx.fillText(title, sx, sy);
                        }
                      };
                
                      PlotView.prototype._render_levels = function(ctx, levels, clip_region) {
                        var k, level, renderers, v, _i, _len;
                        ctx.save();
                        if (clip_region != null) {
                          ctx.beginPath();
                          ctx.rect.apply(ctx, clip_region);
                          ctx.clip();
                          ctx.beginPath();
                        }
                        for (_i = 0, _len = levels.length; _i < _len; _i++) {
                          level = levels[_i];
                          renderers = this.levels[level];
                          for (k in renderers) {
                            v = renderers[k];
                            v.render();
                          }
                        }
                        return ctx.restore();
                      };
                
                      PlotView.prototype._map_hook = function(ctx, frame_box) {};
                
                      PlotView.prototype._paint_empty = function(ctx, frame_box) {
                        ctx.fillStyle = this.mget('border_fill');
                        ctx.fillRect(0, 0, this.canvas_view.mget('canvas_width'), this.canvas_view.mget('canvas_height'));
                        ctx.fillStyle = this.mget('background_fill');
                        return ctx.fillRect.apply(ctx, frame_box);
                      };
                
                      return PlotView;
                
                    })(ContinuumView);
                    Plot = (function(_super) {
                      __extends(Plot, _super);
                
                      function Plot() {
                        _ref1 = Plot.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Plot.prototype.type = 'Plot';
                
                      Plot.prototype.default_view = PlotView;
                
                      Plot.prototype.initialize = function(attrs, options) {
                        var canvas, r, _i, _len, _ref2, _ref3;
                        Plot.__super__.initialize.call(this, attrs, options);
                        canvas = new Canvas.Model({
                          map: (_ref2 = this.use_map) != null ? _ref2 : false,
                          canvas_width: this.get('plot_width'),
                          canvas_height: this.get('plot_height'),
                          hidpi: this.get('hidpi'),
                          solver: new Solver()
                        });
                        this.set('canvas', canvas);
                        this.solver = canvas.get('solver');
                        _ref3 = this.get('renderers');
                        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                          r = _ref3[_i];
                          r.set('parent', this);
                        }
                        this.set('tool_manager', new ToolManager.Model({
                          tools: this.get('tools'),
                          toolbar_location: this.get('toolbar_location')
                        }));
                        return logger.debug("Plot initialized");
                      };
                
                      Plot.prototype.initialize_layout = function(solver) {
                        var canvas, elts, frame;
                        canvas = this.get('canvas');
                        frame = new CartesianFrame.Model({
                          x_range: this.get('x_range'),
                          extra_x_ranges: this.get('extra_x_ranges'),
                          x_mapper_type: this.get('x_mapper_type'),
                          y_range: this.get('y_range'),
                          extra_y_ranges: this.get('extra_y_ranges'),
                          y_mapper_type: this.get('y_mapper_type'),
                          solver: solver
                        });
                        this.set('frame', frame);
                        this.title_panel = new LayoutBox.Model({
                          solver: solver
                        });
                        LayoutBox.Collection.add(this.title_panel);
                        this.title_panel._anchor = this.title_panel._bottom;
                        elts = this.get('above');
                        elts.push(this.title_panel);
                        return this.set('above', elts);
                      };
                
                      Plot.prototype.add_constraints = function(solver) {
                        var do_side, min_border_bottom, min_border_left, min_border_right, min_border_top, _ref2, _ref3, _ref4, _ref5,
                          _this = this;
                        min_border_top = (_ref2 = this.get('min_border_top')) != null ? _ref2 : this.get('min_border');
                        min_border_bottom = (_ref3 = this.get('min_border_bottom')) != null ? _ref3 : this.get('min_border');
                        min_border_left = (_ref4 = this.get('min_border_left')) != null ? _ref4 : this.get('min_border');
                        min_border_right = (_ref5 = this.get('min_border_right')) != null ? _ref5 : this.get('min_border');
                        do_side = function(solver, min_size, side, cnames, dim, op) {
                          var box, c0, c1, canvas, elts, frame, last, padding, r, _i, _len, _ref6;
                          canvas = _this.get('canvas');
                          frame = _this.get('frame');
                          box = new LayoutBox.Model({
                            solver: solver
                          });
                          c0 = '_' + cnames[0];
                          c1 = '_' + cnames[1];
                          solver.add_constraint(new Constraint(new Expr(box['_' + dim], -min_size), GE), kiwi.Strength.strong);
                          solver.add_constraint(new Constraint(new Expr(frame[c0], [-1, box[c1]]), EQ));
                          solver.add_constraint(new Constraint(new Expr(box[c0], [-1, canvas[c0]]), EQ));
                          last = frame;
                          elts = _this.get(side);
                          for (_i = 0, _len = elts.length; _i < _len; _i++) {
                            r = elts[_i];
                            if ((_ref6 = r.get('location')) != null ? _ref6 : 'auto' === 'auto') {
                              r.set('location', side, {
                                'silent': true
                              });
                            }
                            if (r.initialize_layout != null) {
                              r.initialize_layout(solver);
                            }
                            solver.add_constraint(new Constraint(new Expr(last[c0], [-1, r[c1]]), EQ), kiwi.Strength.strong);
                            last = r;
                          }
                          padding = new LayoutBox.Model({
                            solver: solver
                          });
                          solver.add_constraint(new Constraint(new Expr(last[c0], [-1, padding[c1]]), EQ), kiwi.Strength.strong);
                          return solver.add_constraint(new Constraint(new Expr(padding[c0], [-1, canvas[c0]]), EQ), kiwi.Strength.strong);
                        };
                        do_side(solver, min_border_top, 'above', ['top', 'bottom'], 'height', LE);
                        do_side(solver, min_border_bottom, 'below', ['bottom', 'top'], 'height', GE);
                        do_side(solver, min_border_left, 'left', ['left', 'right'], 'width', GE);
                        return do_side(solver, min_border_right, 'right', ['right', 'left'], 'width', LE);
                      };
                
                      Plot.prototype.add_renderers = function(new_renderers) {
                        var renderers;
                        renderers = this.get('renderers');
                        renderers = renderers.concat(new_renderers);
                        return this.set('renderers', renderers);
                      };
                
                      Plot.prototype.parent_properties = ['background_fill', 'border_fill', 'min_border', 'min_border_top', 'min_border_bottom', 'min_border_left', 'min_border_right'];
                
                      Plot.prototype.defaults = function() {
                        return _.extend({}, Plot.__super__.defaults.call(this), {
                          renderers: [],
                          tools: [],
                          h_symmetry: true,
                          v_symmetry: false,
                          x_mapper_type: 'auto',
                          y_mapper_type: 'auto',
                          plot_width: 600,
                          plot_height: 600,
                          title: 'Plot',
                          above: [],
                          below: [],
                          left: [],
                          right: [],
                          toolbar_location: "above"
                        });
                      };
                
                      Plot.prototype.display_defaults = function() {
                        return _.extend({}, Plot.__super__.display_defaults.call(this), {
                          hidpi: true,
                          background_fill: "#fff",
                          border_fill: "#fff",
                          min_border: 40,
                          title_standoff: 8,
                          title_text_font: "helvetica",
                          title_text_font_size: "20pt",
                          title_text_font_style: "normal",
                          title_text_color: "#444444",
                          title_text_alpha: 1.0,
                          title_text_align: "center",
                          title_text_baseline: "alphabetic",
                          outline_line_color: '#aaaaaa',
                          outline_line_width: 1,
                          outline_line_alpha: 1.0,
                          outline_line_join: 'miter',
                          outline_line_cap: 'butt',
                          outline_line_dash: [],
                          outline_line_dash_offset: 0
                        });
                      };
                
                      return Plot;
                
                    })(HasParent);
                    Plots = (function(_super) {
                      __extends(Plots, _super);
                
                      function Plots() {
                        _ref2 = Plots.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Plots.prototype.model = Plot;
                
                      return Plots;
                
                    })(Collection);
                    return {
                      "Model": Plot,
                      "Collection": new Plots(),
                      "View": PlotView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=plot.js.map
                */;
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/gmap_plot',["underscore", "./collection", "./solver", "./plot"], function(_, Collection, Solver, Plot) {
                    var GMapPlot, GMapPlotView, GMapPlots, _ref, _ref1, _ref2;
                    GMapPlotView = (function(_super) {
                      __extends(GMapPlotView, _super);
                
                      function GMapPlotView() {
                        this.bounds_change = __bind(this.bounds_change, this);
                        _ref = GMapPlotView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      GMapPlotView.prototype.initialize = function(options) {
                        GMapPlotView.__super__.initialize.call(this, _.defaults(options, this.default_options));
                        return this.zoom_count = null;
                      };
                
                      GMapPlotView.prototype.update_range = function(range_info) {
                        var center, ne_lat, ne_lng, sw_lat, sw_lng, xr, yr;
                        if (range_info == null) {
                          range_info = this.initial_range_info;
                        }
                        this.pause();
                        if (range_info.sdx != null) {
                          this.map.panBy(range_info.sdx, range_info.sdy);
                        } else {
                          xr = range_info.xrs["default"];
                          yr = range_info.yrs["default"];
                          sw_lng = Math.min(xr.start, xr.end);
                          ne_lng = Math.max(xr.start, xr.end);
                          sw_lat = Math.min(yr.start, yr.end);
                          ne_lat = Math.max(yr.start, yr.end);
                          center = new google.maps.LatLng((ne_lat + sw_lat) / 2, (ne_lng + sw_lng) / 2);
                          if (range_info.factor == null) {
                            this.map.setCenter(center);
                            this.map.setZoom(this.initial_zoom);
                          } else if (range_info.factor > 0) {
                            this.zoom_count += 1;
                            if (this.zoom_count === 10) {
                              this.map.setZoom(this.map.getZoom() + 1);
                              this.zoom_count = 0;
                            }
                          } else {
                            this.zoom_count -= 1;
                            if (this.zoom_count === -10) {
                              this.map.setCenter(center);
                              this.map.setZoom(this.map.getZoom() - 1);
                              this.map.setCenter(center);
                              this.zoom_count = 0;
                            }
                          }
                        }
                        return this.unpause();
                      };
                
                      GMapPlotView.prototype.bind_bokeh_events = function() {
                        var build_map, height, left, script, top, width,
                          _this = this;
                        GMapPlotView.__super__.bind_bokeh_events.call(this);
                        width = this.frame.get('width');
                        height = this.frame.get('height');
                        left = this.canvas.vx_to_sx(this.frame.get('left'));
                        top = this.canvas.vy_to_sy(this.frame.get('top'));
                        this.canvas_view.map_div.attr("style", "top: " + top + "px; left: " + left + "px; position: absolute");
                        this.canvas_view.map_div.attr('style', "width:" + width + "px;");
                        this.canvas_view.map_div.attr('style', "height:" + height + "px;");
                        this.canvas_view.map_div.width("" + width + "px").height("" + height + "px");
                        this.initial_zoom = this.mget('map_options').zoom;
                        build_map = function() {
                          var map_options, map_types, maps, mo;
                          maps = window.google.maps;
                          map_types = {
                            "satellite": maps.MapTypeId.SATELLITE,
                            "terrain": maps.MapTypeId.TERRAIN,
                            "roadmap": maps.MapTypeId.ROADMAP,
                            "hybrid": maps.MapTypeId.HYBRID
                          };
                          mo = _this.mget('map_options');
                          map_options = {
                            center: new maps.LatLng(mo.lat, mo.lng),
                            zoom: mo.zoom,
                            disableDefaultUI: true,
                            mapTypeId: map_types[mo.map_type]
                          };
                          _this.map = new maps.Map(_this.canvas_view.map_div[0], map_options);
                          return maps.event.addListener(_this.map, 'bounds_changed', _this.bounds_change);
                        };
                        if (window._bokeh_gmap_loads == null) {
                          window._bokeh_gmap_loads = [];
                        }
                        if ((window.google != null) && (window.google.maps != null)) {
                          return _.defer(build_map);
                        } else if (window._bokeh_gmap_callback != null) {
                          return window._bokeh_gmap_loads.push(build_map);
                        } else {
                          window._bokeh_gmap_loads.push(build_map);
                          window._bokeh_gmap_callback = function() {
                            return _.each(window._bokeh_gmap_loads, _.defer);
                          };
                          script = document.createElement('script');
                          script.type = 'text/javascript';
                          script.src = 'https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false&callback=_bokeh_gmap_callback';
                          return document.body.appendChild(script);
                        }
                      };
                
                      GMapPlotView.prototype.bounds_change = function() {
                        var bds, ne, sw;
                        bds = this.map.getBounds();
                        ne = bds.getNorthEast();
                        sw = bds.getSouthWest();
                        this.x_range.set({
                          start: sw.lng(),
                          end: ne.lng(),
                          silent: true
                        });
                        this.y_range.set({
                          start: sw.lat(),
                          end: ne.lat(),
                          silent: true
                        });
                        if (this.initial_range_info == null) {
                          this.initial_range_info = {
                            xr: {
                              start: this.x_range.get('start'),
                              end: this.x_range.get('end')
                            },
                            yr: {
                              start: this.y_range.get('start'),
                              end: this.y_range.get('end')
                            }
                          };
                        }
                        return this.render();
                      };
                
                      GMapPlotView.prototype._map_hook = function(ctx, frame_box) {
                        var height, left, top, width;
                        left = frame_box[0], top = frame_box[1], width = frame_box[2], height = frame_box[3];
                        this.canvas_view.map_div.attr("style", "top: " + top + "px; left: " + left + "px;");
                        return this.canvas_view.map_div.width("" + width + "px").height("" + height + "px");
                      };
                
                      GMapPlotView.prototype._paint_empty = function(ctx, frame_box) {
                        var ih, iw, left, oh, ow, top;
                        ow = this.canvas.get('width');
                        oh = this.canvas.get('height');
                        left = frame_box[0], top = frame_box[1], iw = frame_box[2], ih = frame_box[3];
                        ctx.clearRect(0, 0, ow, oh);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, oh);
                        ctx.lineTo(ow, oh);
                        ctx.lineTo(ow, 0);
                        ctx.lineTo(0, 0);
                        ctx.moveTo(left, top);
                        ctx.lineTo(left + iw, top);
                        ctx.lineTo(left + iw, top + ih);
                        ctx.lineTo(left, top + ih);
                        ctx.lineTo(left, top);
                        ctx.closePath();
                        ctx.fillStyle = this.mget('border_fill');
                        return ctx.fill();
                      };
                
                      return GMapPlotView;
                
                    })(Plot.View);
                    GMapPlot = (function(_super) {
                      __extends(GMapPlot, _super);
                
                      function GMapPlot() {
                        _ref1 = GMapPlot.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      GMapPlot.prototype.type = 'GMapPlot';
                
                      GMapPlot.prototype.default_view = GMapPlotView;
                
                      GMapPlot.prototype.initialize = function(attrs, options) {
                        this.use_map = true;
                        return GMapPlot.__super__.initialize.call(this, attrs, options);
                      };
                
                      GMapPlot.prototype.parent_properties = ['border_fill', 'min_border', 'min_border_top', 'min_border_bottom', 'min_border_left', 'min_border_right'];
                
                      GMapPlot.prototype.defaults = function() {
                        return _.extend({}, GMapPlot.__super__.defaults.call(this), {
                          title: 'GMapPlot'
                        });
                      };
                
                      GMapPlot.prototype.display_defaults = function() {
                        return _.extend({}, GMapPlot.__super__.display_defaults.call(this), {
                          border_fill: "#fff"
                        });
                      };
                
                      return GMapPlot;
                
                    })(Plot.Model);
                    GMapPlots = (function(_super) {
                      __extends(GMapPlots, _super);
                
                      function GMapPlots() {
                        _ref2 = GMapPlots.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      GMapPlots.prototype.model = GMapPlot;
                
                      return GMapPlots;
                
                    })(Collection);
                    return {
                      "Model": GMapPlot,
                      "Collection": new GMapPlots(),
                      "View": GMapPlotView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=gmap_plot.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/geojs_plot',["underscore", "./collection", "./solver", "./plot"], function(_, Collection, Solver, Plot) {
                    var GeoJSPlot, GeoJSPlotView, GeoJSPlots, _ref, _ref1, _ref2;
                    GeoJSPlotView = (function(_super) {
                      __extends(GeoJSPlotView, _super);
                
                      function GeoJSPlotView() {
                        _ref = GeoJSPlotView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      GeoJSPlotView.prototype.initialize = function(options) {
                        GeoJSPlotView.__super__.initialize.call(this, _.defaults(options, this.default_options));
                        return this.zoom_count = null;
                      };
                
                      GeoJSPlotView.prototype.bind_bokeh_events = function() {
                        var build_map, height, left, top, width,
                          _this = this;
                        GeoJSPlotView.__super__.bind_bokeh_events.call(this);
                        width = this.frame.get('width');
                        height = this.frame.get('height');
                        left = this.canvas.vx_to_sx(this.frame.get('left'));
                        top = this.canvas.vy_to_sy(this.frame.get('top'));
                        this.canvas_view.map_div.attr("style", "top: " + top + "px; left: " + left + "px; position: absolute");
                        this.canvas_view.map_div.attr('style', "width:" + width + "px;");
                        this.canvas_view.map_div.attr('style', "height:" + height + "px;");
                        this.canvas_view.map_div.width("" + width + "px").height("" + height + "px");
                        this.initial_zoom = this.mget('map_options').zoom;
                        build_map = function() {
                          var map_options, mo;
                          mo = _this.mget('map_options');
                          map_options = {
                            center: [mo.lat, mo.lng],
                            zoom: mo.zoom,
                            node: _this.canvas_view.map_div[0]
                          };
                          _this.map = geo.map(map_options);
                          return _this.map.createLayer('osm');
                        };
                        return $.getScript("http://opengeoscience.github.io/geojs/lib/gl-matrix.js", function() {
                          return $.getScript("http://opengeoscience.github.io/geojs/lib/d3.v3.min.js", function() {
                            return $.getScript("http://opengeoscience.github.io/geojs/lib/proj4.js", function() {
                              return $.getScript("http://opengeoscience.github.io/geojs/lib/vgl.js", function() {
                                return $.getScript("http://opengeoscience.github.io/geojs/lib/geo.js", function() {
                                  return build_map();
                                });
                              });
                            });
                          });
                        });
                      };
                
                      GeoJSPlotView.prototype._map_hook = function(ctx, frame_box) {
                        var height, left, top, width;
                        left = frame_box[0], top = frame_box[1], width = frame_box[2], height = frame_box[3];
                        this.canvas_view.map_div.attr("style", "top: " + top + "px; left: " + left + "px;");
                        return this.canvas_view.map_div.width("" + width + "px").height("" + height + "px");
                      };
                
                      GeoJSPlotView.prototype._paint_empty = function(ctx, frame_box) {
                        var ih, iw, left, oh, ow, top;
                        ow = this.canvas.get('width');
                        oh = this.canvas.get('height');
                        left = frame_box[0], top = frame_box[1], iw = frame_box[2], ih = frame_box[3];
                        ctx.clearRect(0, 0, ow, oh);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, oh);
                        ctx.lineTo(ow, oh);
                        ctx.lineTo(ow, 0);
                        ctx.lineTo(0, 0);
                        ctx.moveTo(left, top);
                        ctx.lineTo(left + iw, top);
                        ctx.lineTo(left + iw, top + ih);
                        ctx.lineTo(left, top + ih);
                        ctx.lineTo(left, top);
                        ctx.closePath();
                        ctx.fillStyle = this.mget('border_fill');
                        return ctx.fill();
                      };
                
                      return GeoJSPlotView;
                
                    })(Plot.View);
                    GeoJSPlot = (function(_super) {
                      __extends(GeoJSPlot, _super);
                
                      function GeoJSPlot() {
                        _ref1 = GeoJSPlot.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      GeoJSPlot.prototype.type = 'GeoJSPlot';
                
                      GeoJSPlot.prototype.default_view = GeoJSPlotView;
                
                      GeoJSPlot.prototype.initialize = function(attrs, options) {
                        this.use_map = true;
                        return GeoJSPlot.__super__.initialize.call(this, attrs, options);
                      };
                
                      GeoJSPlot.prototype.parent_properties = ['border_fill', 'min_border', 'min_border_top', 'min_border_bottom', 'min_border_left', 'min_border_right'];
                
                      GeoJSPlot.prototype.defaults = function() {
                        return _.extend({}, GeoJSPlot.__super__.defaults.call(this), {
                          title: 'GeoJSPlot'
                        });
                      };
                
                      GeoJSPlot.prototype.display_defaults = function() {
                        return _.extend({}, GeoJSPlot.__super__.display_defaults.call(this), {
                          border_fill: "#fff"
                        });
                      };
                
                      return GeoJSPlot;
                
                    })(Plot.Model);
                    GeoJSPlots = (function(_super) {
                      __extends(GeoJSPlots, _super);
                
                      function GeoJSPlots() {
                        _ref2 = GeoJSPlots.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      GeoJSPlots.prototype.model = GeoJSPlot;
                
                      return GeoJSPlots;
                
                    })(Collection);
                    return {
                      "Model": GeoJSPlot,
                      "Collection": new GeoJSPlots(),
                      "View": GeoJSPlotView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=geojs_plot.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
                    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
                
                  define('common/grid_plot',["underscore", "backbone", "./build_views", "./continuum_view", "./collection", "./has_properties", "./logging", "./tool_manager", "./plot_template", "renderer/properties"], function(_, Backbone, build_views, ContinuumView, Collection, HasProperties, Logging, ToolManager, plot_template, Properties) {
                    var GridPlot, GridPlotView, GridPlots, GridToolManager, GridViewState, logger, _ToolProxy, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
                    logger = Logging.logger;
                    _ToolProxy = (function(_super) {
                      __extends(_ToolProxy, _super);
                
                      function _ToolProxy() {
                        _ref = _ToolProxy.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      _ToolProxy.prototype.attrs_and_props = function() {
                        return this.attributes.tools[0].attrs_and_props();
                      };
                
                      _ToolProxy.prototype.get = function(attr) {
                        return this.attributes.tools[0].get(attr);
                      };
                
                      _ToolProxy.prototype.set = function(attr, value) {
                        var tool, _i, _len, _ref1, _results;
                        _ToolProxy.__super__.set.call(this, attr, value);
                        _ref1 = this.attributes.tools;
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          tool = _ref1[_i];
                          _results.push(tool.set(attr, value));
                        }
                        return _results;
                      };
                
                      return _ToolProxy;
                
                    })(Backbone.Model);
                    GridToolManager = (function(_super) {
                      __extends(GridToolManager, _super);
                
                      function GridToolManager() {
                        this._active_change = __bind(this._active_change, this);
                        _ref1 = GridToolManager.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      GridToolManager.prototype._init_tools = function() {
                        var actions, et, gestures, info, inspectors, proxy, tm, tool, tools, typ, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _results;
                        inspectors = {};
                        actions = {};
                        gestures = {};
                        _ref2 = this.get('tool_managers');
                        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                          tm = _ref2[_i];
                          _ref3 = tm.get('gestures');
                          for (et in _ref3) {
                            info = _ref3[et];
                            if (!(et in gestures)) {
                              gestures[et] = {};
                            }
                            _ref4 = info.tools;
                            for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                              tool = _ref4[_j];
                              if (!(tool.type in gestures[et])) {
                                gestures[et][tool.type] = [];
                              }
                              gestures[et][tool.type].push(tool);
                            }
                          }
                          _ref5 = tm.get('inspectors');
                          for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
                            tool = _ref5[_k];
                            if (!(tool.type in inspectors)) {
                              inspectors[tool.type] = [];
                            }
                            inspectors[tool.type].push(tool);
                          }
                          _ref6 = this.get('actions');
                          for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
                            tool = _ref6[_l];
                            if (!(tool.type in actions)) {
                              actions[tool.type] = [];
                            }
                            actions[tool.type].push(tool);
                          }
                        }
                        for (et in gestures) {
                          _ref7 = gestures[et];
                          for (typ in _ref7) {
                            tools = _ref7[typ];
                            if (tools.length !== this.get('num_plots')) {
                              continue;
                            }
                            proxy = new _ToolProxy({
                              tools: tools
                            });
                            this.get('gestures')[et].tools.push(proxy);
                            this.listenTo(proxy, 'change:active', _.bind(this._active_change, proxy));
                          }
                        }
                        for (typ in actions) {
                          tools = actions[typ];
                          if (tools.length !== this.get('num_plots')) {
                            continue;
                          }
                          proxy = new _ToolProxy({
                            tools: tools
                          });
                          this.get('actions').tools.push(proxy);
                        }
                        for (typ in inspectors) {
                          tools = inspectors[typ];
                          if (tools.length !== this.get('num_plots')) {
                            continue;
                          }
                          proxy = new _ToolProxy({
                            tools: tools
                          });
                          this.get('inspectors').tools.push(proxy);
                        }
                        _ref8 = this.get('gestures');
                        _results = [];
                        for (et in _ref8) {
                          info = _ref8[et];
                          tools = info.tools;
                          if (tools.length === 0) {
                            continue;
                          }
                          info.tools = _.sortBy(tools, function(tool) {
                            return tool.get('default_order');
                          });
                          _results.push(info.tools[0].set('active', true));
                        }
                        return _results;
                      };
                
                      GridToolManager.prototype._active_change = function(tool) {
                        var active, et, gestures, prev;
                        et = tool.get('event_type');
                        active = tool.get('active');
                        if (!active) {
                          return null;
                        }
                        gestures = this.get('gestures');
                        prev = gestures[et].active;
                        if (prev != null) {
                          logger.debug("GridToolManager: deactivating tool: " + prev.type + " (for event type '" + et + "'");
                          prev.set('active', false);
                        }
                        gestures[et].active = tool;
                        this.set('gestures', gestures);
                        logger.debug("GridToolManager: activating tool: " + tool.type + " (for event type '" + et + "'");
                        return null;
                      };
                
                      GridToolManager.prototype.defaults = function() {
                        return _.extend({}, GridToolManager.__super__.defaults.call(this), {
                          tool_manangers: []
                        });
                      };
                
                      return GridToolManager;
                
                    })(ToolManager.Model);
                    GridViewState = (function(_super) {
                      __extends(GridViewState, _super);
                
                      function GridViewState() {
                        this.layout_widths = __bind(this.layout_widths, this);
                        this.layout_heights = __bind(this.layout_heights, this);
                        this.setup_layout_properties = __bind(this.setup_layout_properties, this);
                        _ref2 = GridViewState.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      GridViewState.prototype.setup_layout_properties = function() {
                        var row, viewstate, _i, _len, _ref3, _results;
                        this.register_property('layout_heights', this.layout_heights, false);
                        this.register_property('layout_widths', this.layout_widths, false);
                        _ref3 = this.get('viewstates');
                        _results = [];
                        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                          row = _ref3[_i];
                          _results.push((function() {
                            var _j, _len1, _results1;
                            _results1 = [];
                            for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
                              viewstate = row[_j];
                              this.add_dependencies('layout_heights', viewstate, 'height');
                              _results1.push(this.add_dependencies('layout_widths', viewstate, 'width'));
                            }
                            return _results1;
                          }).call(this));
                        }
                        return _results;
                      };
                
                      GridViewState.prototype.initialize = function(attrs, options) {
                        GridViewState.__super__.initialize.call(this, attrs, options);
                        this.setup_layout_properties();
                        this.listenTo(this, 'change:viewstates', this.setup_layout_properties);
                        this.register_property('height', function() {
                          return _.reduce(this.get('layout_heights'), (function(x, y) {
                            return x + y;
                          }), 0);
                        }, false);
                        this.add_dependencies('height', this, 'layout_heights');
                        this.register_property('width', function() {
                          return _.reduce(this.get('layout_widths'), (function(x, y) {
                            return x + y;
                          }), 0);
                        }, false);
                        return this.add_dependencies('width', this, 'layout_widths');
                      };
                
                      GridViewState.prototype.position_child_x = function(offset, childsize) {
                        return offset;
                      };
                
                      GridViewState.prototype.position_child_y = function(offset, childsize) {
                        return this.get('height') - offset - childsize;
                      };
                
                      GridViewState.prototype.maxdim = function(dim, row) {
                        if (row.length === 0) {
                          return 0;
                        } else {
                          return _.max(_.map(row, function(x) {
                            if (x != null) {
                              return x.get(dim);
                            }
                            return 0;
                          }));
                        }
                      };
                
                      GridViewState.prototype.layout_heights = function() {
                        var row, row_heights;
                        row_heights = (function() {
                          var _i, _len, _ref3, _results;
                          _ref3 = this.get('viewstates');
                          _results = [];
                          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                            row = _ref3[_i];
                            _results.push(this.maxdim('height', row));
                          }
                          return _results;
                        }).call(this);
                        return row_heights;
                      };
                
                      GridViewState.prototype.layout_widths = function() {
                        var col, col_widths, columns, n, num_cols, row;
                        num_cols = this.get('viewstates')[0].length;
                        columns = (function() {
                          var _i, _len, _ref3, _results;
                          _ref3 = _.range(num_cols);
                          _results = [];
                          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                            n = _ref3[_i];
                            _results.push((function() {
                              var _j, _len1, _ref4, _results1;
                              _ref4 = this.get('viewstates');
                              _results1 = [];
                              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                                row = _ref4[_j];
                                _results1.push(row[n]);
                              }
                              return _results1;
                            }).call(this));
                          }
                          return _results;
                        }).call(this);
                        col_widths = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = columns.length; _i < _len; _i++) {
                            col = columns[_i];
                            _results.push(this.maxdim('width', col));
                          }
                          return _results;
                        }).call(this);
                        return col_widths;
                      };
                
                      GridViewState.prototype.defaults = function() {
                        return _.extend({}, GridViewState.__super__.defaults.call(this), {
                          viewstates: [[]],
                          border_space: 0
                        });
                      };
                
                      return GridViewState;
                
                    })(HasProperties);
                    GridPlotView = (function(_super) {
                      __extends(GridPlotView, _super);
                
                      function GridPlotView() {
                        _ref3 = GridPlotView.__super__.constructor.apply(this, arguments);
                        return _ref3;
                      }
                
                      GridPlotView.prototype.className = "";
                
                      GridPlotView.prototype.template = plot_template;
                
                      GridPlotView.prototype.initialize = function(options) {
                        var toolbar_location, toolbar_selector;
                        GridPlotView.__super__.initialize.call(this, options);
                        this.viewstate = new GridViewState();
                        this.child_views = {};
                        this.build_children();
                        this.bind_bokeh_events();
                        this.$el.html(this.template());
                        toolbar_location = this.mget('toolbar_location');
                        if (toolbar_location != null) {
                          toolbar_selector = '.bk-plot-' + toolbar_location;
                          logger.debug("attaching toolbar to " + toolbar_selector + " for plot " + this.model.id);
                          this.tm_view = new ToolManager.View({
                            model: this.mget('tool_manager'),
                            el: this.$(toolbar_selector)
                          });
                        }
                        this.render();
                        return this;
                      };
                
                      GridPlotView.prototype.bind_bokeh_events = function() {
                        this.listenTo(this.model, 'change:children', this.build_children);
                        this.listenTo(this.model, 'change', this.render);
                        this.listenTo(this.viewstate, 'change', this.render);
                        return this.listenTo(this.model, 'destroy', this.remove);
                      };
                
                      GridPlotView.prototype.build_children = function() {
                        var childmodels, plot, row, viewstates, vsrow, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref4, _ref5, _ref6, _results;
                        childmodels = [];
                        _ref4 = this.mget('children');
                        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                          row = _ref4[_i];
                          for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
                            plot = row[_j];
                            plot.set('toolbar_location', null);
                            childmodels.push(plot);
                          }
                        }
                        build_views(this.child_views, childmodels, {});
                        viewstates = [];
                        _ref5 = this.mget('children');
                        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
                          row = _ref5[_k];
                          vsrow = (function() {
                            var _l, _len3, _results;
                            _results = [];
                            for (_l = 0, _len3 = row.length; _l < _len3; _l++) {
                              x = row[_l];
                              _results.push(this.child_views[x.id].canvas);
                            }
                            return _results;
                          }).call(this);
                          viewstates.push(vsrow);
                        }
                        this.viewstate.set('viewstates', viewstates);
                        _ref6 = this.mget('children');
                        _results = [];
                        for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
                          row = _ref6[_l];
                          _results.push((function() {
                            var _len4, _m, _results1;
                            _results1 = [];
                            for (_m = 0, _len4 = row.length; _m < _len4; _m++) {
                              plot = row[_m];
                              _results1.push(this.listenTo(plot.solver, 'layout_update', this.render));
                            }
                            return _results1;
                          }).call(this));
                        }
                        return _results;
                      };
                
                      GridPlotView.prototype.render = function() {
                        var add, cidx, col_widths, div, height, last_plot, plot_divs, plot_wrapper, plotspec, ridx, row, row_heights, toolbar_location, toolbar_selector, total_height, view, width, x_coords, xpos, y_coords, ypos, _i, _j, _k, _len, _len1, _len2, _ref4, _ref5;
                        GridPlotView.__super__.render.call(this);
                        _ref4 = _.values(this.child_views);
                        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                          view = _ref4[_i];
                          view.$el.detach();
                        }
                        div = $('<div />');
                        this.$('.bk-plot-canvas-wrapper').empty();
                        this.$('.bk-plot-canvas-wrapper').append(div);
                        toolbar_location = this.mget('toolbar_location');
                        if (toolbar_location != null) {
                          toolbar_selector = '.bk-plot-' + toolbar_location;
                          this.tm_view = new ToolManager.View({
                            model: this.mget('tool_manager'),
                            el: this.$(toolbar_selector)
                          });
                          this.tm_view.render();
                        }
                        row_heights = this.viewstate.get('layout_heights');
                        col_widths = this.viewstate.get('layout_widths');
                        y_coords = [0];
                        _.reduceRight(row_heights.slice(1), function(x, y) {
                          var val;
                          val = x + y;
                          y_coords.push(val);
                          return val;
                        }, 0);
                        y_coords.reverse();
                        x_coords = [0];
                        _.reduce(col_widths.slice(0), function(x, y) {
                          var val;
                          val = x + y;
                          x_coords.push(val);
                          return val;
                        }, 0);
                        plot_divs = [];
                        last_plot = null;
                        _ref5 = this.mget('children');
                        for (ridx = _j = 0, _len1 = _ref5.length; _j < _len1; ridx = ++_j) {
                          row = _ref5[ridx];
                          for (cidx = _k = 0, _len2 = row.length; _k < _len2; cidx = ++_k) {
                            plotspec = row[cidx];
                            view = this.child_views[plotspec.id];
                            ypos = this.viewstate.position_child_y(y_coords[ridx], view.canvas.get('height'));
                            xpos = this.viewstate.position_child_x(x_coords[cidx], view.canvas.get('width'));
                            plot_wrapper = $("<div class='gp_plotwrapper'></div>");
                            plot_wrapper.attr('style', "position: absolute; left:" + xpos + "px; top:" + ypos + "px");
                            plot_wrapper.append(view.$el);
                            div.append(plot_wrapper);
                          }
                        }
                        add = function(a, b) {
                          return a + b;
                        };
                        total_height = _.reduce(row_heights, add, 0);
                        height = total_height;
                        width = _.reduce(col_widths, add, 0);
                        return div.attr('style', "position:relative; height:" + height + "px;width:" + width + "px");
                      };
                
                      return GridPlotView;
                
                    })(ContinuumView);
                    GridPlot = (function(_super) {
                      __extends(GridPlot, _super);
                
                      function GridPlot() {
                        _ref4 = GridPlot.__super__.constructor.apply(this, arguments);
                        return _ref4;
                      }
                
                      GridPlot.prototype.type = 'GridPlot';
                
                      GridPlot.prototype.default_view = GridPlotView;
                
                      GridPlot.prototype.initialize = function(attrs, options) {
                        GridPlot.__super__.initialize.call(this, attrs, options);
                        return this.register_property('tool_manager', function() {
                          var plot;
                          return new GridToolManager({
                            tool_managers: (function() {
                              var _i, _len, _ref5, _results;
                              _ref5 = _.flatten(this.get('children'));
                              _results = [];
                              for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
                                plot = _ref5[_i];
                                _results.push(plot.get('tool_manager'));
                              }
                              return _results;
                            }).call(this),
                            toolbar_location: this.get('toolbar_location'),
                            num_plots: _.flatten(this.get('children')).length
                          });
                        }, true);
                      };
                
                      GridPlot.prototype.defaults = function() {
                        return _.extend({}, GridPlot.__super__.defaults.call(this), {
                          children: [[]],
                          toolbar_location: "left"
                        });
                      };
                
                      return GridPlot;
                
                    })(HasProperties);
                    GridPlots = (function(_super) {
                      __extends(GridPlots, _super);
                
                      function GridPlots() {
                        _ref5 = GridPlots.__super__.constructor.apply(this, arguments);
                        return _ref5;
                      }
                
                      GridPlots.prototype.model = GridPlot;
                
                      return GridPlots;
                
                    })(Collection);
                    return {
                      "Model": GridPlot,
                      "Collection": new GridPlots(),
                      "View": GridPlotView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=grid_plot.js.map
                */;
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/plot_context',["underscore", "./collection", "./build_views", "./has_parent", "./continuum_view"], function(_, Collection, build_views, HasParent, ContinuumView) {
                    var PlotContext, PlotContextView, PlotContexts, _ref, _ref1, _ref2;
                    PlotContextView = (function(_super) {
                      __extends(PlotContextView, _super);
                
                      function PlotContextView() {
                        this.removeplot = __bind(this.removeplot, this);
                        this.closeall = __bind(this.closeall, this);
                        _ref = PlotContextView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PlotContextView.prototype.initialize = function(options) {
                        this.views = {};
                        this.child_models = [];
                        PlotContextView.__super__.initialize.call(this, options);
                        return this.render();
                      };
                
                      PlotContextView.prototype.delegateEvents = function() {
                        this.listenTo(this.model, 'destroy', this.remove);
                        this.listenTo(this.model, 'change', this.render);
                        return PlotContextView.__super__.delegateEvents.call(this);
                      };
                
                      PlotContextView.prototype.build_children = function() {
                        var created_views;
                        created_views = build_views(this.views, this.mget('children'), {});
                        window.pc_created_views = created_views;
                        window.pc_views = this.views;
                        return null;
                      };
                
                      PlotContextView.prototype.size_textarea = function(textarea) {
                        var scrollHeight;
                        scrollHeight = $(textarea).height(0).prop('scrollHeight');
                        return $(textarea).height(scrollHeight);
                      };
                
                      PlotContextView.prototype.closeall = function(e) {
                        this.mset('children', []);
                        return this.model.save();
                      };
                
                      PlotContextView.prototype.removeplot = function(e) {
                        var newchildren, plotnum, s_pc, view, x;
                        plotnum = parseInt($(e.currentTarget).parent().attr('data-plot_num'));
                        s_pc = this.mget('children')[plotnum];
                        view = this.views[s_pc.get('id')];
                        view.remove();
                        newchildren = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.mget('children');
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            x = _ref1[_i];
                            if (x.id !== view.model.id) {
                              _results.push(x);
                            }
                          }
                          return _results;
                        }).call(this);
                        this.mset('children', newchildren);
                        this.model.save();
                        return false;
                      };
                
                      PlotContextView.prototype.render = function() {
                        var index, key, modelref, node, numplots, tab_names, to_render, val, view, _i, _len, _ref1, _ref2,
                          _this = this;
                        PlotContextView.__super__.render.call(this);
                        this.build_children();
                        _ref1 = this.views;
                        for (key in _ref1) {
                          if (!__hasProp.call(_ref1, key)) continue;
                          val = _ref1[key];
                          val.$el.detach();
                        }
                        this.$el.html('');
                        numplots = _.keys(this.views).length;
                        to_render = [];
                        tab_names = {};
                        _ref2 = this.mget('children');
                        for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {
                          modelref = _ref2[index];
                          view = this.views[modelref.id];
                          node = $("<div class='jsp' data-plot_num='" + index + "'></div>");
                          this.$el.append(node);
                          node.append(view.el);
                        }
                        _.defer(function() {
                          var textarea, _j, _len1, _ref3, _results;
                          _ref3 = _this.$el.find('.plottitle');
                          _results = [];
                          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                            textarea = _ref3[_j];
                            _results.push(_this.size_textarea($(textarea)));
                          }
                          return _results;
                        });
                        return null;
                      };
                
                      return PlotContextView;
                
                    })(ContinuumView);
                    PlotContext = (function(_super) {
                      __extends(PlotContext, _super);
                
                      function PlotContext() {
                        _ref1 = PlotContext.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      PlotContext.prototype.type = 'PlotContext';
                
                      PlotContext.prototype.default_view = PlotContextView;
                
                      PlotContext.prototype.url = function() {
                        return PlotContext.__super__.url.call(this);
                      };
                
                      PlotContext.prototype.defaults = function() {
                        return _.extend({}, PlotContext.__super__.defaults.call(this), {
                          children: []
                        });
                      };
                
                      return PlotContext;
                
                    })(HasParent);
                    PlotContexts = (function(_super) {
                      __extends(PlotContexts, _super);
                
                      function PlotContexts() {
                        _ref2 = PlotContexts.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      PlotContexts.prototype.model = PlotContext;
                
                      return PlotContexts;
                
                    })(Collection);
                    return {
                      "Model": PlotContext,
                      "Collection": new PlotContexts(),
                      "View": PlotContextView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=plot_context.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/selector',["underscore", "./has_properties", "./logging"], function(_, HasProperties, Logging) {
                    var Selector, logger, _ref;
                    logger = Logging.logger;
                    return Selector = (function(_super) {
                      __extends(Selector, _super);
                
                      function Selector() {
                        _ref = Selector.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      Selector.prototype.type = 'Selector';
                
                      Selector.prototype.update = function(indices, final, append) {
                        this.set('timestamp', new Date());
                        this.set('final', final);
                        if (append) {
                          indices = _.union(this.get('indices'), indices);
                        }
                        return this.set('indices', indices);
                      };
                
                      Selector.prototype.clear = function() {
                        this.set('timestamp', new Date());
                        this.set('final', true);
                        return this.set('indices', []);
                      };
                
                      Selector.prototype.defaults = function() {
                        return _.extend({}, Selector.__super__.defaults.call(this), {
                          indices: []
                        });
                      };
                
                      return Selector;
                
                    })(HasProperties);
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=selector.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/selection_manager',["underscore", "./has_properties", "./logging", "./selector"], function(_, HasProperties, Logging, Selector) {
                    var SelectionManager, logger, _ref;
                    logger = Logging.logger;
                    return SelectionManager = (function(_super) {
                      __extends(SelectionManager, _super);
                
                      function SelectionManager() {
                        _ref = SelectionManager.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SelectionManager.prototype.type = 'SelectionManager';
                
                      SelectionManager.prototype.initialize = function(attrs, options) {
                        SelectionManager.__super__.initialize.call(this, attrs, options);
                        return this.selectors = {};
                      };
                
                      SelectionManager.prototype.set_selection = function(indices) {
                        this._save_indices(indices);
                        return source.trigger('select');
                      };
                
                      SelectionManager.prototype.select = function(tool, renderer_view, geometry, final, append) {
                        var indices, selector, source;
                        if (append == null) {
                          append = false;
                        }
                        source = this.get('source');
                        if (source !== renderer_view.mget('data_source')) {
                          logger.warn('select called with mis-matched data sources');
                        }
                        indices = renderer_view.hit_test(geometry);
                        selector = this._get_selector(tool);
                        selector.update(indices, final, append);
                        this._save_indices(selector.get('indices'));
                        source.trigger('select');
                        return source.trigger('select-' + renderer_view.mget('id'));
                      };
                
                      SelectionManager.prototype.inspect = function(tool, renderer_view, geometry, data) {
                        var indices, source;
                        source = this.get('source');
                        if (source !== renderer_view.mget('data_source')) {
                          logger.warn('inspect called with mis-matched data sources');
                        }
                        indices = renderer_view.hit_test(geometry);
                        if (indices != null) {
                          source.trigger('inspect', indices, tool, renderer_view, source, data);
                          return source.trigger('inspect' + renderer_view.mget('id'), indices, tool, renderer_view, source, data);
                        }
                      };
                
                      SelectionManager.prototype.clear = function(tool) {
                        var selector;
                        if (tool != null) {
                          selector = this._get_selector(tool);
                          selector.clear();
                        }
                        return this._save_indices([]);
                      };
                
                      SelectionManager.prototype._get_selector = function(tool) {
                        _.setdefault(this.selectors, tool.model.id, new Selector());
                        return this.selectors[tool.model.id];
                      };
                
                      SelectionManager.prototype._save_indices = function(indices) {
                        return this.get('source').save({
                          "selected": indices
                        }, {
                          patch: true
                        });
                      };
                
                      return SelectionManager;
                
                    })(HasProperties);
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=selection_manager.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/tool_events',["backbone", "common/has_properties", "common/logging"], function(Backbone, HasProperties, Logging) {
                    var ToolEvents, ToolEventsCollection, logger, _ref, _ref1;
                    logger = Logging.logger;
                    ToolEvents = (function(_super) {
                      __extends(ToolEvents, _super);
                
                      function ToolEvents() {
                        _ref = ToolEvents.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ToolEvents.prototype.type = 'ToolEvents';
                
                      return ToolEvents;
                
                    })(HasProperties);
                    ToolEventsCollection = (function(_super) {
                      __extends(ToolEventsCollection, _super);
                
                      function ToolEventsCollection() {
                        _ref1 = ToolEventsCollection.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ToolEventsCollection.prototype.model = ToolEvents;
                
                      return ToolEventsCollection;
                
                    })(Backbone.Collection);
                    return {
                      "Model": ToolEvents,
                      "Collection": new ToolEventsCollection()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=tool_events.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('mapper/linear_color_mapper',["underscore", "common/collection", "common/has_properties"], function(_, Collection, HasProperties) {
                    var LinearColorMapper, LinearColorMappers, _ref, _ref1;
                    LinearColorMapper = (function(_super) {
                      __extends(LinearColorMapper, _super);
                
                      function LinearColorMapper() {
                        _ref = LinearColorMapper.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LinearColorMapper.prototype.initialize = function(attrs, options) {
                        LinearColorMapper.__super__.initialize.call(this, attrs, options);
                        this.palette = this._build_palette(this.get('palette'));
                        this.little_endian = this._is_little_endian();
                        if (this.get('reserve_color') != null) {
                          this.reserve_color = parseInt(this.get('reserve_color').slice(1), 16);
                          return this.reserve_val = this.get('reserve_val');
                        }
                      };
                
                      LinearColorMapper.prototype.v_map_screen = function(data) {
                        var N, buf, color, d, high, i, low, offset, scale, value, _i, _j, _ref1, _ref2, _ref3, _ref4;
                        buf = new ArrayBuffer(data.length * 4);
                        color = new Uint32Array(buf);
                        low = (_ref1 = this.get('low')) != null ? _ref1 : _.min(data);
                        high = (_ref2 = this.get('high')) != null ? _ref2 : _.max(data);
                        N = this.palette.length - 1;
                        scale = N / (high - low);
                        offset = -scale * low;
                        if (this.little_endian) {
                          for (i = _i = 0, _ref3 = data.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {
                            d = data[i];
                            if (d === this.reserve_val) {
                              value = this.reserve_color;
                            } else {
                              if (d > high) {
                                d = high;
                              }
                              if (d < low) {
                                d = low;
                              }
                              value = this.palette[Math.floor(d * scale + offset)];
                            }
                            color[i] = (0xff << 24) | ((value & 0xff0000) >> 16) | (value & 0xff00) | ((value & 0xff) << 16);
                          }
                        } else {
                          for (i = _j = 0, _ref4 = data.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; i = 0 <= _ref4 ? ++_j : --_j) {
                            d = data[i];
                            if (d === this.reserve_val) {
                              value = this.reserve_color;
                            } else {
                              if (d > high) {
                                d = high;
                              }
                              if (d < low) {
                                d = low;
                              }
                              value = this.palette[Math.floor(d * scale + offset)];
                            }
                            color[i] = (value << 8) | 0xff;
                          }
                        }
                        return buf;
                      };
                
                      LinearColorMapper.prototype._is_little_endian = function() {
                        var buf, buf32, buf8, little_endian;
                        buf = new ArrayBuffer(4);
                        buf8 = new Uint8ClampedArray(buf);
                        buf32 = new Uint32Array(buf);
                        buf32[1] = 0x0a0b0c0d;
                        little_endian = true;
                        if (buf8[4] === 0x0a && buf8[5] === 0x0b && buf8[6] === 0x0c && buf8[7] === 0x0d) {
                          little_endian = false;
                        }
                        return little_endian;
                      };
                
                      LinearColorMapper.prototype._build_palette = function(palette) {
                        var i, new_palette, _i, _ref1;
                        new_palette = new Uint32Array(palette.length + 1);
                        for (i = _i = 0, _ref1 = palette.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (_.isNumber(palette[i])) {
                            new_palette[i] = palette[i];
                          } else {
                            new_palette[i] = parseInt(palette[i].slice(1), 16);
                          }
                        }
                        new_palette[new_palette.length - 1] = palette[palette.length - 1];
                        return new_palette;
                      };
                
                      return LinearColorMapper;
                
                    })(HasProperties);
                    LinearColorMappers = (function(_super) {
                      __extends(LinearColorMappers, _super);
                
                      function LinearColorMappers() {
                        _ref1 = LinearColorMappers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LinearColorMappers.prototype.model = LinearColorMapper;
                
                      return LinearColorMappers;
                
                    })(Collection);
                    return {
                      "Model": LinearColorMapper,
                      "Collection": new LinearColorMappers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=linear_color_mapper.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('range/factor_range',["common/collection", "common/has_properties"], function(Collection, HasProperties) {
                    var FactorRange, FactorRanges, _ref, _ref1;
                    FactorRange = (function(_super) {
                      __extends(FactorRange, _super);
                
                      function FactorRange() {
                        _ref = FactorRange.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      FactorRange.prototype.type = 'FactorRange';
                
                      FactorRange.prototype.initialize = function(attrs, options) {
                        FactorRange.__super__.initialize.call(this, attrs, options);
                        this.register_property('end', function() {
                          return this.get('factors').length + 0.5;
                        }, true);
                        this.add_dependencies('end', this, ['factors']);
                        this.register_property('min', function() {
                          return this.get('start');
                        }, true);
                        this.add_dependencies('min', this, ['factors']);
                        this.register_property('max', function() {
                          return this.get('end');
                        }, true);
                        return this.add_dependencies('max', this, ['factors']);
                      };
                
                      FactorRange.prototype.defaults = function() {
                        return _.extend({}, FactorRange.__super__.defaults.call(this), {
                          start: 0.5,
                          factors: []
                        });
                      };
                
                      return FactorRange;
                
                    })(HasProperties);
                    FactorRanges = (function(_super) {
                      __extends(FactorRanges, _super);
                
                      function FactorRanges() {
                        _ref1 = FactorRanges.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      FactorRanges.prototype.model = FactorRange;
                
                      return FactorRanges;
                
                    })(Collection);
                    return {
                      "Model": FactorRange,
                      "Collection": new FactorRanges()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=factor_range.js.map
                */;
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('range/data_factor_range',["underscore", "common/collection", "range/factor_range"], function(_, Collection, FactorRange) {
                    var DataFactorRange, DataFactorRanges, _ref, _ref1;
                    DataFactorRange = (function(_super) {
                      __extends(DataFactorRange, _super);
                
                      function DataFactorRange() {
                        this._get_values = __bind(this._get_values, this);
                        _ref = DataFactorRange.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DataFactorRange.prototype.type = 'DataFactorRange';
                
                      DataFactorRange.prototype._get_values = function() {
                        var columns, temp, uniques, val, x, _i, _len;
                        columns = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.get('columns');
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            x = _ref1[_i];
                            _results.push(this.get('data_source').get_column(x));
                          }
                          return _results;
                        }).call(this);
                        columns = _.reduce(columns, (function(x, y) {
                          return x.concat(y);
                        }), []);
                        temp = {};
                        for (_i = 0, _len = columns.length; _i < _len; _i++) {
                          val = columns[_i];
                          temp[val] = true;
                        }
                        uniques = _.keys(temp);
                        uniques = _.sortBy(uniques, (function(x) {
                          return x;
                        }));
                        return uniques;
                      };
                
                      DataFactorRange.prototype.initialize = function(attrs, options) {
                        DataFactorRange.__super__.initialize.call(this, attrs, options);
                        this.register_property;
                        this.register_property('values', this._get_values, true);
                        this.add_dependencies('values', this, ['data_source', 'columns']);
                        return this.add_dependencies('values', this.get('data_source'), ['data_source', 'columns']);
                      };
                
                      DataFactorRange.prototype.defaults = function() {
                        return _.extend({}, DataFactorRange.__super__.defaults.call(this), {
                          values: [],
                          columns: [],
                          data_source: null
                        });
                      };
                
                      return DataFactorRange;
                
                    })(FactorRange.Model);
                    DataFactorRanges = (function(_super) {
                      __extends(DataFactorRanges, _super);
                
                      function DataFactorRanges() {
                        _ref1 = DataFactorRanges.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DataFactorRanges.prototype.model = DataFactorRange;
                
                      return DataFactorRanges;
                
                    })(Collection);
                    return {
                      "Model": DataFactorRange,
                      "Collection": new DataFactorRanges
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=data_factor_range.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('range/data_range1d',["underscore", "common/collection", "range/range1d"], function(_, Collection, Range1d) {
                    var DataRange1d, DataRange1ds, _ref, _ref1;
                    DataRange1d = (function(_super) {
                      __extends(DataRange1d, _super);
                
                      function DataRange1d() {
                        _ref = DataRange1d.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DataRange1d.prototype.type = 'DataRange1d';
                
                      DataRange1d.prototype._get_minmax = function() {
                        var center, colname, columns, max, min, source, sourceobj, span, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
                        columns = [];
                        _ref1 = this.get('sources');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          source = _ref1[_i];
                          sourceobj = this.resolve_ref(source['source']);
                          _ref2 = source['columns'];
                          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                            colname = _ref2[_j];
                            columns.push(sourceobj.get_column(colname));
                          }
                        }
                        columns = _.flatten(columns);
                        columns = _.filter(columns, function(x) {
                          return typeof x !== "string";
                        });
                        columns = _.reject(columns, function(x) {
                          return isNaN(x);
                        });
                        _ref3 = [_.min(columns), _.max(columns)], min = _ref3[0], max = _ref3[1];
                        if (max !== min) {
                          span = (max - min) * (1 + this.get('rangepadding'));
                        } else {
                          if (max !== 0) {
                            span = Math.abs(max) * (1 + this.get('rangepadding'));
                          } else {
                            span = 2;
                          }
                        }
                        center = (max + min) / 2.0;
                        _ref4 = [center - span / 2.0, center + span / 2.0], min = _ref4[0], max = _ref4[1];
                        return [min, max];
                      };
                
                      DataRange1d.prototype._get_start = function() {
                        if (!_.isNullOrUndefined(this.get('_start'))) {
                          return this.get('_start');
                        } else {
                          return this.get('minmax')[0];
                        }
                      };
                
                      DataRange1d.prototype._set_start = function(start) {
                        return this.set('_start', start);
                      };
                
                      DataRange1d.prototype._get_end = function() {
                        if (!_.isNullOrUndefined(this.get('_end'))) {
                          return this.get('_end');
                        } else {
                          return this.get('minmax')[1];
                        }
                      };
                
                      DataRange1d.prototype._set_end = function(end) {
                        return this.set('_end', end);
                      };
                
                      DataRange1d.prototype.initialize = function(attrs, options) {
                        var columns_ref, source, _i, _len, _ref1;
                        this.register_property('minmax', this._get_minmax, true);
                        this.add_dependencies('minmax', this, ['sources'], ['rangepadding']);
                        _ref1 = this.get('sources');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          columns_ref = _ref1[_i];
                          source = this.resolve_ref(columns_ref.source);
                          this.add_dependencies('minmax', source, 'data');
                        }
                        this.register_property('start', this._get_start, true);
                        this.register_setter('start', this._set_start);
                        this.add_dependencies('start', this, ['minmax', '_start']);
                        this.register_property('end', this._get_end, true);
                        this.register_setter('end', this._set_end);
                        this.add_dependencies('end', this, ['minmax', '_end']);
                        return DataRange1d.__super__.initialize.call(this, attrs, options);
                      };
                
                      DataRange1d.prototype.defaults = function() {
                        return _.extend({}, DataRange1d.__super__.defaults.call(this), {
                          sources: [],
                          rangepadding: 0.1
                        });
                      };
                
                      return DataRange1d;
                
                    })(Range1d.Model);
                    DataRange1ds = (function(_super) {
                      __extends(DataRange1ds, _super);
                
                      function DataRange1ds() {
                        _ref1 = DataRange1ds.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DataRange1ds.prototype.model = DataRange1d;
                
                      return DataRange1ds;
                
                    })(Collection);
                    return {
                      "Model": DataRange1d,
                      "Collection": new DataRange1ds()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=data_range1d.js.map
                */;
                (function() {
                  define('common/textutils',[], function() {
                    var cache, getTextHeight;
                    cache = {};
                    getTextHeight = function(font) {
                      var block, body, div, result, text;
                      if (cache[font] != null) {
                        return cache[font];
                      }
                      text = $('<span>Hg</span>').css({
                        font: font
                      });
                      block = $('<div style="display: inline-block; width: 1px; height: 0px;"></div>');
                      div = $('<div></div>');
                      div.append(text, block);
                      body = $('body');
                      body.append(div);
                      try {
                        result = {};
                        block.css({
                          verticalAlign: 'baseline'
                        });
                        result.ascent = block.offset().top - text.offset().top;
                        block.css({
                          verticalAlign: 'bottom'
                        });
                        result.height = block.offset().top - text.offset().top;
                        result.descent = result.height - result.ascent;
                      } finally {
                        div.remove();
                      }
                      cache[font] = result;
                      return result;
                    };
                    return {
                      "getTextHeight": getTextHeight
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=textutils.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/annotation/legend',["underscore", "common/has_parent", "common/plot_widget", "common/collection", "common/textutils", "renderer/properties"], function(_, HasParent, PlotWidget, Collection, textutils, properties) {
                    var Legend, LegendView, Legends, _ref, _ref1, _ref2;
                    LegendView = (function(_super) {
                      __extends(LegendView, _super);
                
                      function LegendView() {
                        _ref = LegendView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LegendView.prototype.initialize = function(options) {
                        LegendView.__super__.initialize.call(this, options);
                        this.label_props = new properties.Text(this, 'label_');
                        this.border_props = new properties.Line(this, 'border_');
                        this.need_calc_dims = true;
                        return this.listenTo(this.plot_model.solver, 'layout_update', function() {
                          return this.need_calc_dims = true;
                        });
                      };
                
                      LegendView.prototype.calc_dims = function(options) {
                        var ctx, glyphs, h_range, label_height, label_width, legend_name, legend_names, legend_padding, legend_spacing, orientation, text_width, text_widths, v_range, x, y, _ref1;
                        legend_names = (function() {
                          var _i, _len, _ref1, _ref2, _results;
                          _ref1 = this.mget("legends");
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            _ref2 = _ref1[_i], legend_name = _ref2[0], glyphs = _ref2[1];
                            _results.push(legend_name);
                          }
                          return _results;
                        }).call(this);
                        label_height = this.mget('label_height');
                        this.glyph_height = this.mget('glyph_height');
                        label_width = this.mget('label_width');
                        this.glyph_width = this.mget('glyph_width');
                        legend_spacing = this.mget('legend_spacing');
                        this.label_height = _.max([textutils.getTextHeight(this.label_props.font(this)), label_height, this.glyph_height]);
                        this.legend_height = this.label_height;
                        this.legend_height = legend_names.length * this.legend_height + (1 + legend_names.length) * legend_spacing;
                        ctx = this.plot_view.canvas_view.ctx;
                        ctx.save();
                        this.label_props.set(ctx, this);
                        text_widths = _.map(legend_names, function(txt) {
                          return ctx.measureText(txt).width;
                        });
                        ctx.restore();
                        text_width = _.max(text_widths);
                        this.label_width = _.max([text_width, label_width]);
                        this.legend_width = this.label_width + this.glyph_width + 3 * legend_spacing;
                        orientation = this.mget('orientation');
                        legend_padding = this.mget('legend_padding');
                        h_range = this.plot_view.frame.get('h_range');
                        v_range = this.plot_view.frame.get('v_range');
                        if (orientation === "top_right") {
                          x = h_range.get('end') - legend_padding - this.legend_width;
                          y = v_range.get('end') - legend_padding;
                        } else if (orientation === "top_left") {
                          x = h_range.get('start') + legend_padding;
                          y = v_range.get('end') - legend_padding;
                        } else if (orientation === "bottom_left") {
                          x = h_range.get('start') + legend_padding;
                          y = v_range.get('start') + legend_padding + this.legend_height;
                        } else if (orientation === "bottom_right") {
                          x = h_range.get('end') - legend_padding - this.legend_width;
                          y = v_range.get('start') + legend_padding + this.legend_height;
                        } else if (orientation === "absolute") {
                          _ref1 = this.absolute_coords, x = _ref1[0], y = _ref1[1];
                        }
                        x = this.plot_view.canvas.vx_to_sx(x);
                        y = this.plot_view.canvas.vy_to_sy(y);
                        return this.box_coords = [x, y];
                      };
                
                      LegendView.prototype.render = function() {
                        var ctx, glyphs, idx, legend_name, legend_spacing, renderer, view, x, x1, x2, y, y1, y2, yoffset, yspacing, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
                        if (this.need_calc_dims) {
                          this.calc_dims();
                          this.need_calc_dims = false;
                        }
                        ctx = this.plot_view.canvas_view.ctx;
                        ctx.save();
                        ctx.fillStyle = this.plot_model.get('background_fill');
                        this.border_props.set(ctx, this);
                        ctx.beginPath();
                        ctx.rect(this.box_coords[0], this.box_coords[1], this.legend_width, this.legend_height);
                        ctx.fill();
                        ctx.stroke();
                        legend_spacing = this.mget('legend_spacing');
                        _ref1 = this.mget("legends");
                        for (idx = _i = 0, _len = _ref1.length; _i < _len; idx = ++_i) {
                          _ref2 = _ref1[idx], legend_name = _ref2[0], glyphs = _ref2[1];
                          yoffset = idx * this.label_height;
                          yspacing = (1 + idx) * legend_spacing;
                          y = this.box_coords[1] + this.label_height / 2.0 + yoffset + yspacing;
                          x = this.box_coords[0] + legend_spacing;
                          x1 = this.box_coords[0] + 2 * legend_spacing + this.label_width;
                          x2 = x1 + this.glyph_width;
                          y1 = this.box_coords[1] + yoffset + yspacing;
                          y2 = y1 + this.glyph_height;
                          this.label_props.set(ctx, this);
                          ctx.fillText(legend_name, x, y);
                          _ref3 = this.model.resolve_ref(glyphs);
                          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                            renderer = _ref3[_j];
                            view = this.plot_view.renderers[renderer.id];
                            view.draw_legend(ctx, x1, x2, y1, y2);
                          }
                        }
                        return ctx.restore();
                      };
                
                      return LegendView;
                
                    })(PlotWidget);
                    Legend = (function(_super) {
                      __extends(Legend, _super);
                
                      function Legend() {
                        _ref1 = Legend.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Legend.prototype.default_view = LegendView;
                
                      Legend.prototype.type = 'Legend';
                
                      Legend.prototype.defaults = function() {
                        return _.extend({}, Legend.__super__.defaults.call(this), {
                          legends: []
                        });
                      };
                
                      Legend.prototype.display_defaults = function() {
                        return _.extend({}, Legend.__super__.display_defaults.call(this), {
                          level: 'overlay',
                          border_line_color: 'black',
                          border_line_width: 1,
                          border_line_alpha: 1.0,
                          border_line_join: 'miter',
                          border_line_cap: 'butt',
                          border_line_dash: [],
                          border_line_dash_offset: 0,
                          label_standoff: 15,
                          label_text_font: "helvetica",
                          label_text_font_size: "10pt",
                          label_text_font_style: "normal",
                          label_text_color: "#444444",
                          label_text_alpha: 1.0,
                          label_text_align: "left",
                          label_text_baseline: "middle",
                          glyph_height: 20,
                          glyph_width: 20,
                          label_height: 20,
                          label_width: 50,
                          legend_padding: 10,
                          legend_spacing: 3,
                          orientation: "top_right",
                          datapoint: null
                        });
                      };
                
                      return Legend;
                
                    })(HasParent);
                    Legends = (function(_super) {
                      __extends(Legends, _super);
                
                      function Legends() {
                        _ref2 = Legends.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Legends.prototype.model = Legend;
                
                      return Legends;
                
                    })(Collection);
                    return {
                      "Model": Legend,
                      "Collection": new Legends(),
                      "View": LegendView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=legend.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/annotation/span',["underscore", "common/has_parent", "common/plot_widget", "common/collection", "common/logging"], function(_, HasParent, PlotWidget, Collection, Logging) {
                    var Span, SpanView, Spans, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    SpanView = (function(_super) {
                      __extends(SpanView, _super);
                
                      function SpanView() {
                        _ref = SpanView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SpanView.prototype.initialize = function(options) {
                        SpanView.__super__.initialize.call(this, options);
                        this.$el.appendTo(this.plot_view.$el.find('div.bk-canvas-overlays'));
                        this.$el.css({
                          position: 'absolute'
                        });
                        return this.$el.hide();
                      };
                
                      SpanView.prototype.bind_bokeh_events = function() {
                        return this.listenTo(this.model, 'change:location', this._draw_span);
                      };
                
                      SpanView.prototype.render = function() {
                        return this._draw_span();
                      };
                
                      SpanView.prototype._draw_span = function() {
                        var canvas, frame, height, left, top, width;
                        if (this.mget('location') == null) {
                          this.$el.hide();
                          return;
                        }
                        frame = this.plot_model.get('frame');
                        canvas = this.plot_model.get('canvas');
                        if (this.mget('dimension') === 'width') {
                          top = canvas.vy_to_sy(this.mget('location'));
                          left = canvas.vx_to_sx(frame.get('left'));
                          width = "" + (frame.get('width')) + "px";
                          height = "1px";
                        } else {
                          top = canvas.vy_to_sy(frame.get('top'));
                          left = canvas.vx_to_sx(this.mget('location'));
                          width = "1px";
                          height = "" + (frame.get('height')) + "px";
                        }
                        this.$el.css({
                          'top': top,
                          'left': left,
                          'width': width,
                          'height': height,
                          'z-index': 1000,
                          'background-color': this.mget('color')
                        });
                        return this.$el.show();
                      };
                
                      return SpanView;
                
                    })(PlotWidget);
                    Span = (function(_super) {
                      __extends(Span, _super);
                
                      function Span() {
                        _ref1 = Span.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Span.prototype.default_view = SpanView;
                
                      Span.prototype.type = 'Span';
                
                      Span.prototype.defaults = function() {
                        return _.extend({}, Span.__super__.defaults.call(this), {
                          level: "overlay",
                          dimension: "width",
                          units: "screen",
                          color: "black"
                        });
                      };
                
                      return Span;
                
                    })(HasParent);
                    Spans = (function(_super) {
                      __extends(Spans, _super);
                
                      function Spans() {
                        _ref2 = Spans.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Spans.prototype.model = Span;
                
                      return Spans;
                
                    })(Collection);
                    return {
                      "Model": Span,
                      "Collection": new Spans(),
                      "View": SpanView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=span.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/annotation/tooltip',["underscore", "common/has_parent", "common/plot_widget", "common/collection", "common/logging"], function(_, HasParent, PlotWidget, Collection, Logging) {
                    var Tooltip, TooltipView, Tooltips, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    TooltipView = (function(_super) {
                      __extends(TooltipView, _super);
                
                      function TooltipView() {
                        _ref = TooltipView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      TooltipView.prototype.className = "bk-tooltip";
                
                      TooltipView.prototype.initialize = function(options) {
                        TooltipView.__super__.initialize.call(this, options);
                        this.$el.appendTo(this.plot_view.$el.find('div.bk-canvas-overlays'));
                        this.$el.css({
                          'z-index': 1010
                        });
                        return this.$el.hide();
                      };
                
                      TooltipView.prototype.bind_bokeh_events = function() {
                        return this.listenTo(this.model, 'change:data', this._draw_tips);
                      };
                
                      TooltipView.prototype.render = function() {
                        return this._draw_tips();
                      };
                
                      TooltipView.prototype._draw_tips = function() {
                        var content, left, ow, side, sx, sy, tip, top, val, vx, vy, _i, _len, _ref1;
                        this.$el.empty();
                        this.$el.hide();
                        if (_.isEmpty(this.mget('data'))) {
                          return;
                        }
                        _ref1 = this.mget('data');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          val = _ref1[_i];
                          vx = val[0], vy = val[1], content = val[2];
                          if (this.mget('inner_only') && !this.plot_view.frame.contains(vx, vy)) {
                            continue;
                          }
                          tip = $('<div />').appendTo(this.$el);
                          tip.append(content);
                        }
                        sx = this.plot_view.mget('canvas').vx_to_sx(vx);
                        sy = this.plot_view.mget('canvas').vy_to_sy(vy);
                        side = this.mget('side');
                        if (side === 'auto') {
                          ow = this.plot_view.frame.get('width');
                          if (vx - this.plot_view.frame.get('left') < ow / 2) {
                            side = 'right';
                          } else {
                            side = 'left';
                          }
                        }
                        this.$el.removeClass('right');
                        this.$el.removeClass('left');
                        if (side === "right") {
                          this.$el.addClass("left");
                          top = sy - this.$el.height() / 2;
                          left = sx + 18;
                        } else if (side === "left") {
                          this.$el.addClass("right");
                          top = sy - this.$el.height() / 2;
                          left = sx - this.$el.width() - 23;
                        } else {
                          logger.warn("invalid tooltip side: '" + side + "'");
                          return;
                        }
                        if (this.$el.children().length > 0) {
                          this.$el.css({
                            top: top,
                            left: left
                          });
                          return this.$el.show();
                        }
                      };
                
                      return TooltipView;
                
                    })(PlotWidget);
                    Tooltip = (function(_super) {
                      __extends(Tooltip, _super);
                
                      function Tooltip() {
                        _ref1 = Tooltip.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Tooltip.prototype.default_view = TooltipView;
                
                      Tooltip.prototype.type = 'Tooltip';
                
                      Tooltip.prototype.clear = function() {
                        return this.set('data', []);
                      };
                
                      Tooltip.prototype.add = function(vx, vy, content) {
                        var data;
                        data = this.get('data');
                        data.push([vx, vy, content]);
                        return this.set('data', data);
                      };
                
                      Tooltip.prototype.defaults = function() {
                        return _.extend({}, Tooltip.__super__.defaults.call(this), {
                          level: 'overlay',
                          side: "auto",
                          inner_only: true
                        });
                      };
                
                      return Tooltip;
                
                    })(HasParent);
                    Tooltips = (function(_super) {
                      __extends(Tooltips, _super);
                
                      function Tooltips() {
                        _ref2 = Tooltips.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Tooltips.prototype.model = Tooltip;
                
                      return Tooltips;
                
                    })(Collection);
                    return {
                      "Model": Tooltip,
                      "Collection": new Tooltips(),
                      "View": TooltipView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=tooltip.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/glyph_renderer',["underscore", "common/logging", "common/has_parent", "common/collection", "common/plot_widget", "range/factor_range"], function(_, Logging, HasParent, Collection, PlotWidget, FactorRange) {
                    var GlyphRenderer, GlyphRendererView, GlyphRenderers, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    GlyphRendererView = (function(_super) {
                      __extends(GlyphRendererView, _super);
                
                      function GlyphRendererView() {
                        _ref = GlyphRendererView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      GlyphRendererView.prototype.initialize = function(options) {
                        GlyphRendererView.__super__.initialize.call(this, options);
                        this.glyph = this.build_glyph(this.mget("glyph"));
                        this.selection_glyph = this.build_glyph(this.mget("selection_glyph") || this.mget("glyph"));
                        this.nonselection_glyph = this.build_glyph(this.mget("nonselection_glyph") || this.mget("glyph"));
                        this.need_set_data = true;
                        this.xmapper = this.plot_view.frame.get('x_mappers')[this.mget("x_range_name")];
                        this.ymapper = this.plot_view.frame.get('y_mappers')[this.mget("y_range_name")];
                        if (this.mget('server_data_source')) {
                          this.setup_server_data();
                        }
                        return this.listenTo(this, 'change:server_data_source', this.setup_server_data);
                      };
                
                      GlyphRendererView.prototype.build_glyph = function(model) {
                        return new model.default_view({
                          model: model,
                          renderer: this
                        });
                      };
                
                      GlyphRendererView.prototype.bind_bokeh_events = function() {
                        this.listenTo(this.model, 'change', this.request_render);
                        this.listenTo(this.mget('data_source'), 'change', this.set_data);
                        return this.listenTo(this.mget('data_source'), 'select', this.request_render);
                      };
                
                      GlyphRendererView.prototype.have_selection_glyphs = function() {
                        return (this.mget("selection_glyph") != null) || (this.mget("nonselection_glyph") != null);
                      };
                
                      GlyphRendererView.prototype.setup_server_data = function() {
                        var data, domain, resample_op, serversource, transform_params, x_range, y_range;
                        serversource = this.mget('server_data_source');
                        data = _.extend({}, this.mget('data_source').get('data'), serversource.get('data'));
                        this.mget('data_source').set('data', data);
                        this.set_data(false);
                        transform_params = serversource.attributes['transform'];
                        resample_op = transform_params['resample'];
                        x_range = this.plot_view.frame.get('h_range');
                        y_range = this.plot_view.frame.get('v_range');
                        if (resample_op === 'line1d') {
                          domain = transform_params['domain'];
                          if (domain === 'x') {
                            return serversource.listen_for_line1d_updates(this.mget('data_source'), x_range, y_range, this.plot_view.x_range, this.plot_view.y_range, x_range, this.glyph.y.field, this.glyph.x.field, [this.glyph.y.field], transform_params);
                          } else {
                            throw new Error("Domains other than 'x' not supported yet.");
                          }
                        } else if (resample_op === 'heatmap') {
                          return serversource.listen_for_heatmap_updates(this.mget('data_source'), x_range, y_range, this.plot_view.x_range, this.plot_view.y_range, transform_params);
                        } else if (resample_op === 'abstract rendering') {
                          return serversource.listen_for_ar_updates(this.plot_view, this.mget('data_source'), x_range, y_range, this.plot_view.x_range, this.plot_view.y_range, transform_params);
                        } else {
                          return logger.warn("unknown resample op: '" + resample_op + "'");
                        }
                      };
                
                      GlyphRendererView.prototype.set_data = function(request_render) {
                        var dt, source, t0;
                        if (request_render == null) {
                          request_render = true;
                        }
                        source = this.mget('data_source');
                        t0 = Date.now();
                        this.all_indices = this.glyph.set_data(source);
                        this.selection_glyph.set_data(source);
                        this.nonselection_glyph.set_data(source);
                        dt = Date.now() - t0;
                        logger.debug("" + this.glyph.model.type + " glyph (" + this.glyph.model.id + "): set_data finished in " + dt + "ms");
                        this.have_new_data = true;
                        if (request_render) {
                          return this.request_render();
                        }
                      };
                
                      GlyphRendererView.prototype.render = function() {
                        var ctx, do_render, dt, i, idx, indices, nonselected, selected, selected_indices, selected_mask, selection, t0, _i, _j, _len, _len1,
                          _this = this;
                        if (this.need_set_data) {
                          this.set_data(false);
                          this.need_set_data = false;
                        }
                        this.glyph._map_data();
                        this.selection_glyph._map_data();
                        this.nonselection_glyph._map_data();
                        if ((this._mask_data != null) && !(this.plot_view.x_range instanceof FactorRange.Model) && !(this.plot_view.y_range instanceof FactorRange.Model)) {
                          indices = this._mask_data();
                        } else {
                          indices = this.all_indices;
                        }
                        ctx = this.plot_view.canvas_view.ctx;
                        ctx.save();
                        do_render = function(ctx, indices, glyph) {
                          if (_this.have_new_data) {
                            glyph.update_data(_this.mget('data_source'));
                          }
                          return glyph.render(ctx, indices);
                        };
                        selection = this.mget('data_source').get('selected');
                        if ((selection != null) && selection.length > 0) {
                          selected_indices = selection;
                        } else {
                          selected_indices = [];
                        }
                        t0 = Date.now();
                        if (!(selected_indices && selected_indices.length && this.have_selection_glyphs())) {
                          do_render(ctx, indices, this.glyph);
                        } else {
                          selected_mask = (function() {
                            var _i, _len, _ref1, _results;
                            _ref1 = this.all_indices;
                            _results = [];
                            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                              i = _ref1[_i];
                              _results.push(false);
                            }
                            return _results;
                          }).call(this);
                          for (_i = 0, _len = selected_indices.length; _i < _len; _i++) {
                            idx = selected_indices[_i];
                            selected_mask[idx] = true;
                          }
                          selected = new Array();
                          nonselected = new Array();
                          for (_j = 0, _len1 = indices.length; _j < _len1; _j++) {
                            i = indices[_j];
                            if (selected_mask[i]) {
                              selected.push(i);
                            } else {
                              nonselected.push(i);
                            }
                          }
                          do_render(ctx, selected, this.selection_glyph);
                          do_render(ctx, nonselected, this.nonselection_glyph);
                        }
                        dt = Date.now() - t0;
                        logger.trace("" + this.glyph.model.type + " glyph (" + this.glyph.model.id + "): do_render calls finished in " + dt + "ms");
                        this.have_new_data = false;
                        return ctx.restore();
                      };
                
                      GlyphRendererView.prototype.xrange = function() {
                        return this.plot_view.x_range;
                      };
                
                      GlyphRendererView.prototype.yrange = function() {
                        return this.plot_view.y_range;
                      };
                
                      GlyphRendererView.prototype.map_to_screen = function(x, x_units, y, y_units) {
                        return this.plot_view.map_to_screen(x, x_units, y, y_units, this.mget("x_range_name"), this.mget("y_range_name"));
                      };
                
                      GlyphRendererView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this.glyph.draw_legend(ctx, x0, x1, y0, y1);
                      };
                
                      GlyphRendererView.prototype.hit_test = function(geometry) {
                        return this.glyph.hit_test(geometry);
                      };
                
                      return GlyphRendererView;
                
                    })(PlotWidget);
                    GlyphRenderer = (function(_super) {
                      __extends(GlyphRenderer, _super);
                
                      function GlyphRenderer() {
                        _ref1 = GlyphRenderer.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      GlyphRenderer.prototype.default_view = GlyphRendererView;
                
                      GlyphRenderer.prototype.type = 'GlyphRenderer';
                
                      GlyphRenderer.prototype.defaults = function() {
                        return _.extend({}, GlyphRenderer.__super__.defaults.call(this), {
                          x_range_name: "default",
                          y_range_name: "default",
                          data_source: null
                        });
                      };
                
                      GlyphRenderer.prototype.display_defaults = function() {
                        return _.extend({}, GlyphRenderer.__super__.display_defaults.call(this), {
                          level: 'glyph'
                        });
                      };
                
                      return GlyphRenderer;
                
                    })(HasParent);
                    GlyphRenderers = (function(_super) {
                      __extends(GlyphRenderers, _super);
                
                      function GlyphRenderers() {
                        _ref2 = GlyphRenderers.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      GlyphRenderers.prototype.model = GlyphRenderer;
                
                      return GlyphRenderers;
                
                    })(Collection);
                    return {
                      Model: GlyphRenderer,
                      View: GlyphRendererView,
                      Collection: new GlyphRenderers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=glyph_renderer.js.map
                */;
                /*
                 (c) 2013, Vladimir Agafonkin
                 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
                 https://github.com/mourner/rbush
                */
                
                (function () { 
                
                function rbush(maxEntries, format) {
                
                    // jshint newcap: false, validthis: true
                    if (!(this instanceof rbush)) return new rbush(maxEntries, format);
                
                    // max entries in a node is 9 by default; min node fill is 40% for best performance
                    this._maxEntries = Math.max(4, maxEntries || 9);
                    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
                
                    if (format) {
                        this._initFormat(format);
                    }
                
                    this.clear();
                }
                
                rbush.prototype = {
                
                    all: function () {
                        return this._all(this.data, []);
                    },
                
                    search: function (bbox) {
                
                        var node = this.data,
                            result = [],
                            toBBox = this.toBBox;
                
                        if (!intersects(bbox, node.bbox)) return result;
                
                        var nodesToSearch = [],
                            i, len, child, childBBox;
                
                        while (node) {
                            for (i = 0, len = node.children.length; i < len; i++) {
                
                                child = node.children[i];
                                childBBox = node.leaf ? toBBox(child) : child.bbox;
                
                                if (intersects(bbox, childBBox)) {
                                    if (node.leaf) result.push(child);
                                    else if (contains(bbox, childBBox)) this._all(child, result);
                                    else nodesToSearch.push(child);
                                }
                            }
                            node = nodesToSearch.pop();
                        }
                
                        return result;
                    },
                
                    load: function (data) {
                        if (!(data && data.length)) return this;
                
                        if (data.length < this._minEntries) {
                            for (var i = 0, len = data.length; i < len; i++) {
                                this.insert(data[i]);
                            }
                            return this;
                        }
                
                        // recursively build the tree with the given data from stratch using OMT algorithm
                        var node = this._build(data.slice(), 0, data.length - 1, 0);
                
                        if (!this.data.children.length) {
                            // save as is if tree is empty
                            this.data = node;
                
                        } else if (this.data.height === node.height) {
                            // split root if trees have the same height
                            this._splitRoot(this.data, node);
                
                        } else {
                            if (this.data.height < node.height) {
                                // swap trees if inserted one is bigger
                                var tmpNode = this.data;
                                this.data = node;
                                node = tmpNode;
                            }
                
                            // insert the small tree into the large tree at appropriate level
                            this._insert(node, this.data.height - node.height - 1, true);
                        }
                
                        return this;
                    },
                
                    insert: function (item) {
                        if (item) this._insert(item, this.data.height - 1);
                        return this;
                    },
                
                    clear: function () {
                        this.data = {
                            children: [],
                            height: 1,
                            bbox: empty(),
                            leaf: true
                        };
                        return this;
                    },
                
                    remove: function (item) {
                        if (!item) return this;
                
                        var node = this.data,
                            bbox = this.toBBox(item),
                            path = [],
                            indexes = [],
                            i, parent, index, goingUp;
                
                        // depth-first iterative tree traversal
                        while (node || path.length) {
                
                            if (!node) { // go up
                                node = path.pop();
                                parent = path[path.length - 1];
                                i = indexes.pop();
                                goingUp = true;
                            }
                
                            if (node.leaf) { // check current node
                                index = node.children.indexOf(item);
                
                                if (index !== -1) {
                                    // item found, remove the item and condense tree upwards
                                    node.children.splice(index, 1);
                                    path.push(node);
                                    this._condense(path);
                                    return this;
                                }
                            }
                
                            if (!goingUp && !node.leaf && contains(node.bbox, bbox)) { // go down
                                path.push(node);
                                indexes.push(i);
                                i = 0;
                                parent = node;
                                node = node.children[0];
                
                            } else if (parent) { // go right
                                i++;
                                node = parent.children[i];
                                goingUp = false;
                
                            } else node = null; // nothing found
                        }
                
                        return this;
                    },
                
                    toBBox: function (item) { return item; },
                
                    compareMinX: function (a, b) { return a[0] - b[0]; },
                    compareMinY: function (a, b) { return a[1] - b[1]; },
                
                    toJSON: function () { return this.data; },
                
                    fromJSON: function (data) {
                        this.data = data;
                        return this;
                    },
                
                    _all: function (node, result) {
                        var nodesToSearch = [];
                        while (node) {
                            if (node.leaf) result.push.apply(result, node.children);
                            else nodesToSearch.push.apply(nodesToSearch, node.children);
                
                            node = nodesToSearch.pop();
                        }
                        return result;
                    },
                
                    _build: function (items, left, right, level, height) {
                
                        var N = right - left + 1,
                            M = this._maxEntries,
                            node;
                
                        if (N <= M) {
                            node = {
                                children: items.slice(left, right + 1),
                                height: 1,
                                bbox: null,
                                leaf: true
                            };
                            calcBBox(node, this.toBBox);
                            return node;
                        }
                
                        if (!level) {
                            // target height of the bulk-loaded tree
                            height = Math.ceil(Math.log(N) / Math.log(M));
                
                            // target number of root entries to maximize storage utilization
                            M = Math.ceil(N / Math.pow(M, height - 1));
                        }
                
                        // TODO eliminate recursion?
                
                        node = {
                            children: [],
                            height: height,
                            bbox: null
                        };
                
                        var N2 = Math.ceil(N / M),
                            N1 = N2 * Math.ceil(Math.sqrt(M)),
                            i, j, right2, childNode;
                
                        // split the items into M mostly square tiles
                        for (i = left; i <= right; i += N1) {
                
                            if (i + N1 <= right) partitionSort(items, i, right, i + N1, this.compareMinX);
                            right2 = Math.min(i + N1 - 1, right);
                
                            for (j = i; j <= right2; j += N2) {
                
                                if (j + N2 <= right2) partitionSort(items, j, right2, j + N2, this.compareMinY);
                
                                // pack each entry recursively
                                childNode = this._build(items, j, Math.min(j + N2 - 1, right2), level + 1, height - 1);
                                node.children.push(childNode);
                            }
                        }
                
                        calcBBox(node, this.toBBox);
                
                        return node;
                    },
                
                    _chooseSubtree: function (bbox, node, level, path) {
                
                        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
                
                        while (true) {
                            path.push(node);
                
                            if (node.leaf || path.length - 1 === level) break;
                
                            minArea = minEnlargement = Infinity;
                
                            for (i = 0, len = node.children.length; i < len; i++) {
                                child = node.children[i];
                                area = bboxArea(child.bbox);
                                enlargement = enlargedArea(bbox, child.bbox) - area;
                
                                // choose entry with the least area enlargement
                                if (enlargement < minEnlargement) {
                                    minEnlargement = enlargement;
                                    minArea = area < minArea ? area : minArea;
                                    targetNode = child;
                
                                } else if (enlargement === minEnlargement) {
                                    // otherwise choose one with the smallest area
                                    if (area < minArea) {
                                        minArea = area;
                                        targetNode = child;
                                    }
                                }
                            }
                
                            node = targetNode;
                        }
                
                        return node;
                    },
                
                    _insert: function (item, level, isNode) {
                
                        var toBBox = this.toBBox,
                            bbox = isNode ? item.bbox : toBBox(item),
                            insertPath = [];
                
                        // find the best node for accommodating the item, saving all nodes along the path too
                        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
                
                        // put the item into the node
                        node.children.push(item);
                        extend(node.bbox, bbox);
                
                        // split on node overflow; propagate upwards if necessary
                        while (level >= 0) {
                            if (insertPath[level].children.length > this._maxEntries) {
                                this._split(insertPath, level);
                                level--;
                            } else break;
                        }
                
                        // adjust bboxes along the insertion path
                        this._adjustParentBBoxes(bbox, insertPath, level);
                    },
                
                    // split overflowed node into two
                    _split: function (insertPath, level) {
                
                        var node = insertPath[level],
                            M = node.children.length,
                            m = this._minEntries;
                
                        this._chooseSplitAxis(node, m, M);
                
                        var newNode = {
                            children: node.children.splice(this._chooseSplitIndex(node, m, M)),
                            height: node.height
                        };
                
                        if (node.leaf) newNode.leaf = true;
                
                        calcBBox(node, this.toBBox);
                        calcBBox(newNode, this.toBBox);
                
                        if (level) insertPath[level - 1].children.push(newNode);
                        else this._splitRoot(node, newNode);
                    },
                
                    _splitRoot: function (node, newNode) {
                        // split root node
                        this.data = {
                            children: [node, newNode],
                            height: node.height + 1
                        };
                        calcBBox(this.data, this.toBBox);
                    },
                
                    _chooseSplitIndex: function (node, m, M) {
                
                        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
                
                        minOverlap = minArea = Infinity;
                
                        for (i = m; i <= M - m; i++) {
                            bbox1 = distBBox(node, 0, i, this.toBBox);
                            bbox2 = distBBox(node, i, M, this.toBBox);
                
                            overlap = intersectionArea(bbox1, bbox2);
                            area = bboxArea(bbox1) + bboxArea(bbox2);
                
                            // choose distribution with minimum overlap
                            if (overlap < minOverlap) {
                                minOverlap = overlap;
                                index = i;
                
                                minArea = area < minArea ? area : minArea;
                
                            } else if (overlap === minOverlap) {
                                // otherwise choose distribution with minimum area
                                if (area < minArea) {
                                    minArea = area;
                                    index = i;
                                }
                            }
                        }
                
                        return index;
                    },
                
                    // sorts node children by the best axis for split
                    _chooseSplitAxis: function (node, m, M) {
                
                        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                            xMargin = this._allDistMargin(node, m, M, compareMinX),
                            yMargin = this._allDistMargin(node, m, M, compareMinY);
                
                        // if total distributions margin value is minimal for x, sort by minX,
                        // otherwise it's already sorted by minY
                        if (xMargin < yMargin) node.children.sort(compareMinX);
                    },
                
                    // total margin of all possible split distributions where each node is at least m full
                    _allDistMargin: function (node, m, M, compare) {
                
                        node.children.sort(compare);
                
                        var toBBox = this.toBBox,
                            leftBBox = distBBox(node, 0, m, toBBox),
                            rightBBox = distBBox(node, M - m, M, toBBox),
                            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                            i, child;
                
                        for (i = m; i < M - m; i++) {
                            child = node.children[i];
                            extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
                            margin += bboxMargin(leftBBox);
                        }
                
                        for (i = M - m - 1; i >= m; i--) {
                            child = node.children[i];
                            extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
                            margin += bboxMargin(rightBBox);
                        }
                
                        return margin;
                    },
                
                    _adjustParentBBoxes: function (bbox, path, level) {
                        // adjust bboxes along the given tree path
                        for (var i = level; i >= 0; i--) {
                            extend(path[i].bbox, bbox);
                        }
                    },
                
                    _condense: function (path) {
                        // go through the path, removing empty nodes and updating bboxes
                        for (var i = path.length - 1, siblings; i >= 0; i--) {
                            if (path[i].children.length === 0) {
                                if (i > 0) {
                                    siblings = path[i - 1].children;
                                    siblings.splice(siblings.indexOf(path[i]), 1);
                
                                } else this.clear();
                
                            } else calcBBox(path[i], this.toBBox);
                        }
                    },
                
                    _initFormat: function (format) {
                        // data format (minX, minY, maxX, maxY accessors)
                
                        // uses eval-type function compilation instead of just accepting a toBBox function
                        // because the algorithms are very sensitive to sorting functions performance,
                        // so they should be dead simple and without inner calls
                
                        // jshint evil: true
                
                        var compareArr = ['return a', ' - b', ';'];
                
                        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
                        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
                
                        this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
                    }
                };
                
                // calculate node's bbox from bboxes of its children
                function calcBBox(node, toBBox) {
                    node.bbox = distBBox(node, 0, node.children.length, toBBox);
                }
                
                // min bounding rectangle of node children from k to p-1
                function distBBox(node, k, p, toBBox) {
                    var bbox = empty();
                
                    for (var i = k, child; i < p; i++) {
                        child = node.children[i];
                        extend(bbox, node.leaf ? toBBox(child) : child.bbox);
                    }
                
                    return bbox;
                }
                
                
                function empty() { return [Infinity, Infinity, -Infinity, -Infinity]; }
                
                function extend(a, b) {
                    a[0] = Math.min(a[0], b[0]);
                    a[1] = Math.min(a[1], b[1]);
                    a[2] = Math.max(a[2], b[2]);
                    a[3] = Math.max(a[3], b[3]);
                    return a;
                }
                
                function compareNodeMinX(a, b) { return a.bbox[0] - b.bbox[0]; }
                function compareNodeMinY(a, b) { return a.bbox[1] - b.bbox[1]; }
                
                function bboxArea(a)   { return (a[2] - a[0]) * (a[3] - a[1]); }
                function bboxMargin(a) { return (a[2] - a[0]) + (a[3] - a[1]); }
                
                function enlargedArea(a, b) {
                    return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
                           (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
                }
                
                function intersectionArea (a, b) {
                    var minX = Math.max(a[0], b[0]),
                        minY = Math.max(a[1], b[1]),
                        maxX = Math.min(a[2], b[2]),
                        maxY = Math.min(a[3], b[3]);
                
                    return Math.max(0, maxX - minX) *
                           Math.max(0, maxY - minY);
                }
                
                function contains(a, b) {
                    return a[0] <= b[0] &&
                           a[1] <= b[1] &&
                           b[2] <= a[2] &&
                           b[3] <= a[3];
                }
                
                function intersects (a, b) {
                    return b[0] <= a[2] &&
                           b[1] <= a[3] &&
                           b[2] >= a[0] &&
                           b[3] >= a[1];
                }
                
                
                function partitionSort(arr, left, right, k, compare) {
                    var pivot;
                
                    while (true) {
                        pivot = Math.floor((left + right) / 2);
                        pivot = partition(arr, left, right, pivot, compare);
                
                        if (k === pivot) break;
                        else if (k < pivot) right = pivot - 1;
                        else left = pivot + 1;
                    }
                
                    partition(arr, left, right, k, compare);
                }
                
                function partition(arr, left, right, pivot, compare) {
                    var k = left,
                        value = arr[pivot];
                
                    swap(arr, pivot, right);
                
                    for (var i = left; i < right; i++) {
                        if (compare(arr[i], value) < 0) {
                            swap(arr, k, i);
                            k++;
                        }
                    }
                    swap(arr, right, k);
                
                    return k;
                }
                
                function swap(arr, i, j) {
                    var tmp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = tmp;
                }
                
                
                // export as AMD/CommonJS module or global variable
                if (typeof define === 'function' && define.amd) define('rbush',[],function() { return rbush; });
                else if (typeof module !== 'undefined') module.exports = rbush;
                else if (typeof self !== 'undefined') self.rbush = rbush;
                else window.rbush = rbush;
                
                })();
                (function() {
                  define('common/mathutils',[], function() {
                    var angle_between, angle_dist, angle_norm;
                    angle_norm = function(angle) {
                      while (angle < 0) {
                        angle += 2 * Math.PI;
                      }
                      while (angle > 2 * Math.PI) {
                        angle -= 2 * Math.PI;
                      }
                      return angle;
                    };
                    angle_dist = function(lhs, rhs) {
                      return Math.abs(angle_norm(lhs - rhs));
                    };
                    angle_between = function(mid, lhs, rhs, direction) {
                      var d;
                      mid = angle_norm(mid);
                      d = angle_dist(lhs, rhs);
                      if (direction === "anticlock") {
                        return angle_dist(lhs, mid) <= d && angle_dist(mid, rhs) <= d;
                      } else {
                        return !(angle_dist(lhs, mid) <= d && angle_dist(mid, rhs) <= d);
                      }
                    };
                    return {
                      "angle_norm": angle_norm,
                      "angle_dist": angle_dist,
                      "angle_between": angle_between
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=mathutils.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
                    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
                
                  define('renderer/glyph/glyph',["underscore", "common/logging", "common/has_parent", "common/collection", "common/continuum_view", "renderer/properties"], function(_, Logging, HasParent, Collection, ContinuumView, properties) {
                    var Glyph, GlyphView, Glyphs, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    GlyphView = (function(_super) {
                      __extends(GlyphView, _super);
                
                      function GlyphView() {
                        _ref = GlyphView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      GlyphView.prototype.initialize = function(options) {
                        GlyphView.__super__.initialize.call(this, options);
                        this.renderer = options.renderer;
                        this.glyph = new properties.Glyph(this, this._fields);
                        this.props = {};
                        if (__indexOf.call(this._properties, 'line') >= 0) {
                          this.props.line = new properties.Line(this);
                        }
                        if (__indexOf.call(this._properties, 'fill') >= 0) {
                          this.props.fill = new properties.Fill(this);
                        }
                        if (__indexOf.call(this._properties, 'text') >= 0) {
                          return this.props.text = new properties.Text(this);
                        }
                      };
                
                      GlyphView.prototype.render = function(ctx, indicies) {
                        return this._render(ctx, indicies);
                      };
                
                      GlyphView.prototype._map_data = function() {
                        return null;
                      };
                
                      GlyphView.prototype.update_data = function(source) {
                        if ((this.props.fill != null) && this.props.fill.do_fill) {
                          this.props.fill.set_prop_cache(source);
                        }
                        if ((this.props.line != null) && this.props.line.do_stroke) {
                          this.props.line.set_prop_cache(source);
                        }
                        if (this.props.text != null) {
                          return this.props.text.set_prop_cache(source);
                        }
                      };
                
                      GlyphView.prototype.set_data = function(source) {
                        var dir, field, i, junk, values, x, _i, _j, _k, _len, _ref1, _ref2, _ref3, _ref4, _results;
                        _ref1 = this._fields;
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          field = _ref1[_i];
                          if (field.indexOf(":") > -1) {
                            _ref2 = field.split(":"), field = _ref2[0], junk = _ref2[1];
                          }
                          this[field] = this.glyph.source_v_select(field, source);
                          if (field === "direction") {
                            values = new Uint8Array(this.direction.length);
                            for (i = _j = 0, _ref3 = this.direction.length; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
                              dir = this.direction[i];
                              if (dir === 'clock') {
                                values[i] = false;
                              } else if (dir === 'anticlock') {
                                values[i] = true;
                              } else {
                                values = NaN;
                              }
                            }
                            this.direction = values;
                          }
                          if (field.indexOf("angle") > -1) {
                            this[field] = (function() {
                              var _k, _len1, _ref4, _results;
                              _ref4 = this[field];
                              _results = [];
                              for (_k = 0, _len1 = _ref4.length; _k < _len1; _k++) {
                                x = _ref4[_k];
                                _results.push(-x);
                              }
                              return _results;
                            }).call(this);
                          }
                        }
                        this._set_data();
                        return (function() {
                          _results = [];
                          for (var _k = 0, _ref4 = this[field].length; 0 <= _ref4 ? _k < _ref4 : _k > _ref4; 0 <= _ref4 ? _k++ : _k--){ _results.push(_k); }
                          return _results;
                        }).apply(this);
                      };
                
                      GlyphView.prototype._set_data = function() {
                        return null;
                      };
                
                      GlyphView.prototype.distance_vector = function(pt, span_prop_name, position, dilate) {
                        var d, halfspan, i, local_select, mapper, pt0, pt1, pt_units, ptc, source, span, span_units, spt0, spt1,
                          _this = this;
                        if (dilate == null) {
                          dilate = false;
                        }
                        " returns an array ";
                        pt_units = this.glyph[pt].units;
                        span_units = this.glyph[span_prop_name].units;
                        if (pt === 'x') {
                          mapper = this.renderer.xmapper;
                        } else if (pt === 'y') {
                          mapper = this.renderer.ymapper;
                        }
                        source = this.renderer.mget('data_source');
                        local_select = function(prop_name) {
                          return _this.glyph.source_v_select(prop_name, source);
                        };
                        span = local_select(span_prop_name);
                        if (span_units === 'screen') {
                          return span;
                        }
                        if (position === 'center') {
                          halfspan = (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = span.length; _i < _len; _i++) {
                              d = span[_i];
                              _results.push(d / 2);
                            }
                            return _results;
                          })();
                          ptc = local_select(pt);
                          if (pt_units === 'screen') {
                            ptc = mapper.v_map_from_target(ptc);
                          }
                          if (typeof ptc[0] === 'string') {
                            ptc = mapper.v_map_to_target(ptc);
                          }
                          pt0 = (function() {
                            var _i, _ref1, _results;
                            _results = [];
                            for (i = _i = 0, _ref1 = ptc.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                              _results.push(ptc[i] - halfspan[i]);
                            }
                            return _results;
                          })();
                          pt1 = (function() {
                            var _i, _ref1, _results;
                            _results = [];
                            for (i = _i = 0, _ref1 = ptc.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                              _results.push(ptc[i] + halfspan[i]);
                            }
                            return _results;
                          })();
                        } else {
                          pt0 = local_select(pt);
                          if (pt_units === 'screen') {
                            pt0 = mapper.v_map_from_target(pt0);
                          }
                          pt1 = (function() {
                            var _i, _ref1, _results;
                            _results = [];
                            for (i = _i = 0, _ref1 = pt0.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                              _results.push(pt0[i] + span[i]);
                            }
                            return _results;
                          })();
                        }
                        spt0 = mapper.v_map_to_target(pt0);
                        spt1 = mapper.v_map_to_target(pt1);
                        if (dilate) {
                          return (function() {
                            var _i, _ref1, _results;
                            _results = [];
                            for (i = _i = 0, _ref1 = spt0.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                              _results.push(Math.ceil(Math.abs(spt1[i] - spt0[i])));
                            }
                            return _results;
                          })();
                        } else {
                          return (function() {
                            var _i, _ref1, _results;
                            _results = [];
                            for (i = _i = 0, _ref1 = spt0.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                              _results.push(Math.abs(spt1[i] - spt0[i]));
                            }
                            return _results;
                          })();
                        }
                      };
                
                      GlyphView.prototype.hit_test = function(geometry) {
                        var result, type;
                        result = null;
                        if (geometry.type === "point") {
                          if (this._hit_point != null) {
                            result = this._hit_point(geometry);
                          } else if (this._point_hit_warned == null) {
                            type = this.model.type;
                            logger.warn("'point' selection not available on " + type + " renderer");
                            this._point_hit_warned = true;
                          }
                        } else if (geometry.type === "rect") {
                          if (this._hit_rect != null) {
                            result = this._hit_rect(geometry);
                          } else if (this._rect_hit_warned == null) {
                            type = this.model.type;
                            logger.warn("'rect' selection not available on " + type + " renderer");
                            this._rect_hit_warned = true;
                          }
                        } else if (geometry.type === "poly") {
                          if (this._hit_poly != null) {
                            result = this._hit_poly(geometry);
                          } else if (this._poly_hit_warned == null) {
                            type = this.model.type;
                            logger.warn("'poly' selection not available on " + type + " renderer");
                            this._poly_hit_warned = true;
                          }
                        } else {
                          logger.error("unrecognized selection geometry type '" + geometry.type + "'");
                        }
                        return result;
                      };
                
                      GlyphView.prototype.get_reference_point = function() {
                        var reference_point;
                        reference_point = this.mget('reference_point');
                        if (_.isNumber(reference_point)) {
                          return this.data[reference_point];
                        } else {
                          return reference_point;
                        }
                      };
                
                      GlyphView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return null;
                      };
                
                      GlyphView.prototype._generic_line_legend = function(ctx, x0, x1, y0, y1) {
                        var reference_point, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x0, (y0 + y1) / 2);
                        ctx.lineTo(x1, (y0 + y1) / 2);
                        if (this.props.line.do_stroke) {
                          this.props.line.set_vectorize(ctx, reference_point);
                          ctx.stroke();
                        }
                        return ctx.restore();
                      };
                
                      GlyphView.prototype._generic_area_legend = function(ctx, x0, x1, y0, y1) {
                        var dh, dw, h, indices, reference_point, sx0, sx1, sy0, sy1, w, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        indices = [reference_point];
                        w = Math.abs(x1 - x0);
                        dw = w * 0.1;
                        h = Math.abs(y1 - y0);
                        dh = h * 0.1;
                        sx0 = x0 + dw;
                        sx1 = x1 - dw;
                        sy0 = y0 + dh;
                        sy1 = y1 - dh;
                        if (this.props.fill.do_fill) {
                          this.props.fill.set_vectorize(ctx, reference_point);
                          ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);
                        }
                        if (this.props.line.do_stroke) {
                          ctx.beginPath();
                          ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);
                          this.props.line.set_vectorize(ctx, reference_point);
                          return ctx.stroke();
                        }
                      };
                
                      return GlyphView;
                
                    })(ContinuumView);
                    Glyph = (function(_super) {
                      __extends(Glyph, _super);
                
                      function Glyph() {
                        _ref1 = Glyph.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Glyph.prototype.fill_defaults = {
                        fill_color: 'gray',
                        fill_alpha: 1.0
                      };
                
                      Glyph.prototype.line_defaults = {
                        line_color: 'black',
                        line_width: 1,
                        line_alpha: 1.0,
                        line_join: 'miter',
                        line_cap: 'butt',
                        line_dash: [],
                        line_dash_offset: 0
                      };
                
                      Glyph.prototype.defaults = function() {
                        return _.extend({}, Glyph.__super__.defaults.call(this), {
                          size_units: 'screen',
                          radius_units: 'data',
                          length_units: 'screen',
                          angle_units: 'deg',
                          start_angle_units: 'deg',
                          end_angle_units: 'deg'
                        });
                      };
                
                      return Glyph;
                
                    })(HasParent);
                    Glyphs = (function(_super) {
                      __extends(Glyphs, _super);
                
                      function Glyphs() {
                        _ref2 = Glyphs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      return Glyphs;
                
                    })(Collection);
                    return {
                      Model: Glyph,
                      View: GlyphView,
                      Collection: Glyphs
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=glyph.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/annular_wedge',["underscore", "rbush", "common/mathutils", "renderer/properties", "./glyph"], function(_, rbush, mathutils, Properties, Glyph) {
                    var AnnularWedge, AnnularWedgeView, AnnularWedges, _ref, _ref1, _ref2;
                    AnnularWedgeView = (function(_super) {
                      __extends(AnnularWedgeView, _super);
                
                      function AnnularWedgeView() {
                        _ref = AnnularWedgeView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      AnnularWedgeView.prototype._fields = ['x', 'y', 'inner_radius', 'outer_radius', 'start_angle', 'end_angle', 'direction:string'];
                
                      AnnularWedgeView.prototype._properties = ['line', 'fill'];
                
                      AnnularWedgeView.prototype._set_data = function() {
                        var i, pts, _i, _ref1;
                        this.max_radius = _.max(this.outer_radius);
                        this.index = rbush();
                        pts = [];
                        for (i = _i = 0, _ref1 = this.x.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (!isNaN(this.x[i] + this.y[i])) {
                            pts.push([
                              this.x[i], this.y[i], this.x[i], this.y[i], {
                                'i': i
                              }
                            ]);
                          }
                        }
                        return this.index.load(pts);
                      };
                
                      AnnularWedgeView.prototype._map_data = function() {
                        var i, _i, _ref1, _ref2, _results;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        this.inner_radius = this.distance_vector('x', 'inner_radius', 'edge');
                        this.outer_radius = this.distance_vector('x', 'outer_radius', 'edge');
                        this.angle = new Float32Array(this.start_angle.length);
                        _results = [];
                        for (i = _i = 0, _ref2 = this.start_angle.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                          _results.push(this.angle[i] = this.end_angle[i] - this.start_angle[i]);
                        }
                        return _results;
                      };
                
                      AnnularWedgeView.prototype._render = function(ctx, indices, sx, sy, inner_radius, outer_radius) {
                        var i, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (inner_radius == null) {
                          inner_radius = this.inner_radius;
                        }
                        if (outer_radius == null) {
                          outer_radius = this.outer_radius;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + inner_radius[i] + outer_radius[i] + this.start_angle[i] + this.angle[i])) {
                            continue;
                          }
                          ctx.translate(sx[i], sy[i]);
                          ctx.rotate(this.start_angle[i]);
                          ctx.moveTo(outer_radius[i], 0);
                          ctx.beginPath();
                          ctx.arc(0, 0, outer_radius[i], 0, this.angle[i], this.direction[i]);
                          ctx.rotate(this.angle[i]);
                          ctx.lineTo(inner_radius[i], 0);
                          ctx.arc(0, 0, inner_radius[i], 0, -this.angle[i], !this.direction[i]);
                          ctx.closePath();
                          ctx.rotate(-this.angle[i] - this.start_angle[i]);
                          ctx.translate(-sx[i], -sy[i]);
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      AnnularWedgeView.prototype._hit_point = function(geometry) {
                        var angle, candidates, candidates2, candidates3, dist, hits, i, pt, r2, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        x = this.renderer.xmapper.map_from_target(vx);
                        y = this.renderer.ymapper.map_from_target(vy);
                        if (this.outer_radius_units === "screen") {
                          vx0 = vx - this.max_radius;
                          vx1 = vx + this.max_radius;
                          _ref2 = this.renderer.xmapper.v_map_from_target([vx0, vx1]), x0 = _ref2[0], x1 = _ref2[1];
                          vy0 = vy - this.max_radius;
                          vy1 = vy + this.max_radius;
                          _ref3 = this.renderer.ymapper.v_map_from_target([vy0, vy1]), y0 = _ref3[0], y1 = _ref3[1];
                        } else {
                          x0 = x - this.max_radius;
                          x1 = x + this.max_radius;
                          y0 = y - this.max_radius;
                          y1 = y + this.max_radius;
                        }
                        candidates = (function() {
                          var _i, _len, _ref4, _results;
                          _ref4 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                            pt = _ref4[_i];
                            _results.push(pt[4].i);
                          }
                          return _results;
                        }).call(this);
                        candidates2 = [];
                        if (this.outer_radius_units === "screen") {
                          sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          for (_i = 0, _len = candidates.length; _i < _len; _i++) {
                            i = candidates[_i];
                            r2 = Math.pow(this.outer_radius[i], 2);
                            dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);
                            if (dist <= r2) {
                              candidates2.push([i, dist]);
                            }
                          }
                        } else {
                          for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
                            i = candidates[_j];
                            r2 = Math.pow(this.outer_radius[i], 2);
                            sx0 = this.renderer.xmapper.map_to_target(x);
                            sx1 = this.renderer.xmapper.map_to_target(this.x[i]);
                            sy0 = this.renderer.ymapper.map_to_target(y);
                            sy1 = this.renderer.ymapper.map_to_target(this.y[i]);
                            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                            if (dist <= r2) {
                              candidates2.push([i, dist]);
                            }
                          }
                        }
                        candidates3 = [];
                        if (this.inner_radius_units === "screen") {
                          sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          for (_k = 0, _len2 = candidates2.length; _k < _len2; _k++) {
                            _ref4 = candidates2[_k], i = _ref4[0], dist = _ref4[1];
                            r2 = Math.pow(this.inner_radius[i], 2);
                            if (dist >= r2) {
                              candidates3.push([i, dist]);
                            }
                          }
                        } else {
                          for (_l = 0, _len3 = candidates2.length; _l < _len3; _l++) {
                            _ref5 = candidates2[_l], i = _ref5[0], dist = _ref5[1];
                            r2 = Math.pow(this.inner_radius[i], 2);
                            sx0 = this.renderer.xmapper.map_to_target(x);
                            sx1 = this.renderer.xmapper.map_to_target(this.x[i]);
                            sy0 = this.renderer.ymapper.map_to_target(y);
                            sy1 = this.renderer.ymapper.map_to_target(this.y[i]);
                            if (dist >= r2) {
                              candidates3.push([i, dist]);
                            }
                          }
                        }
                        hits = [];
                        for (_m = 0, _len4 = candidates3.length; _m < _len4; _m++) {
                          _ref6 = candidates3[_m], i = _ref6[0], dist = _ref6[1];
                          sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);
                          if (mathutils.angle_between(-angle, -this.start_angle[i], -this.end_angle[i], this.direction[i])) {
                            hits.push([i, dist]);
                          }
                        }
                        hits = _.chain(hits).sortBy(function(elt) {
                          return elt[1];
                        }).map(function(elt) {
                          return elt[0];
                        }).value();
                        return hits;
                      };
                
                      AnnularWedgeView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        var indices, inner_radius, outer_radius, r, reference_point, sx, sy, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        indices = [reference_point];
                        sx = {};
                        sx[reference_point] = (x0 + x1) / 2;
                        sy = {};
                        sy[reference_point] = (y0 + y1) / 2;
                        r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;
                        inner_radius = {};
                        inner_radius[reference_point] = r * 0.25;
                        outer_radius = {};
                        outer_radius[reference_point] = r * 0.8;
                        return this._render(ctx, indices, sx, sy, inner_radius, outer_radius);
                      };
                
                      return AnnularWedgeView;
                
                    })(Glyph.View);
                    AnnularWedge = (function(_super) {
                      __extends(AnnularWedge, _super);
                
                      function AnnularWedge() {
                        _ref1 = AnnularWedge.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      AnnularWedge.prototype.default_view = AnnularWedgeView;
                
                      AnnularWedge.prototype.type = 'AnnularWedge';
                
                      AnnularWedge.prototype.display_defaults = function() {
                        return _.extend({}, AnnularWedge.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults, {
                          direction: 'anticlock'
                        });
                      };
                
                      return AnnularWedge;
                
                    })(Glyph.Model);
                    AnnularWedges = (function(_super) {
                      __extends(AnnularWedges, _super);
                
                      function AnnularWedges() {
                        _ref2 = AnnularWedges.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      AnnularWedges.prototype.model = AnnularWedge;
                
                      return AnnularWedges;
                
                    })(Glyph.Collection);
                    return {
                      Model: AnnularWedge,
                      View: AnnularWedgeView,
                      Collection: new AnnularWedges()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=annular_wedge.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/annulus',["underscore", "rbush", "renderer/properties", "./glyph"], function(_, rbush, Properties, Glyph) {
                    var Annulus, AnnulusView, Annuluses, _ref, _ref1, _ref2;
                    AnnulusView = (function(_super) {
                      __extends(AnnulusView, _super);
                
                      function AnnulusView() {
                        _ref = AnnulusView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      AnnulusView.prototype._fields = ['x', 'y', 'inner_radius', 'outer_radius'];
                
                      AnnulusView.prototype._properties = ['line', 'fill'];
                
                      AnnulusView.prototype._set_data = function() {
                        var i, pts, _i, _ref1;
                        this.max_radius = _.max(this.outer_radius);
                        this.index = rbush();
                        pts = [];
                        for (i = _i = 0, _ref1 = this.x.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (!isNaN(this.x[i] + this.y[i])) {
                            pts.push([
                              this.x[i], this.y[i], this.x[i], this.y[i], {
                                'i': i
                              }
                            ]);
                          }
                        }
                        return this.index.load(pts);
                      };
                
                      AnnulusView.prototype._map_data = function() {
                        var _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        this.inner_radius = this.distance_vector('x', 'inner_radius', 'edge');
                        return this.outer_radius = this.distance_vector('x', 'outer_radius', 'edge');
                      };
                
                      AnnulusView.prototype._render = function(ctx, indices, sx, sy, inner_radius, outer_radius) {
                        var i, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (inner_radius == null) {
                          inner_radius = this.inner_radius;
                        }
                        if (outer_radius == null) {
                          outer_radius = this.outer_radius;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + inner_radius[i] + outer_radius[i])) {
                            continue;
                          }
                          ctx.beginPath();
                          ctx.arc(sx[i], sy[i], inner_radius[i], 0, 2 * Math.PI * 2, false);
                          ctx.moveTo(sx[i] + outer_radius[i], sy[i]);
                          ctx.arc(sx[i], sy[i], outer_radius[i], 0, 2 * Math.PI * 2, true);
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      AnnulusView.prototype._hit_point = function(geometry) {
                        var candidates, candidates2, dist, hits, i, pt, r2, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4, _ref5;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        x = this.renderer.xmapper.map_from_target(vx);
                        y = this.renderer.ymapper.map_from_target(vy);
                        if (this.outer_radius_units === "screen") {
                          vx0 = vx - this.max_radius;
                          vx1 = vx + this.max_radius;
                          _ref2 = this.renderer.xmapper.v_map_from_target([vx0, vx1]), x0 = _ref2[0], x1 = _ref2[1];
                          vy0 = vy - this.max_radius;
                          vy1 = vy + this.max_radius;
                          _ref3 = this.renderer.ymapper.v_map_from_target([vy0, vy1]), y0 = _ref3[0], y1 = _ref3[1];
                        } else {
                          x0 = x - this.max_radius;
                          x1 = x + this.max_radius;
                          y0 = y - this.max_radius;
                          y1 = y + this.max_radius;
                        }
                        candidates = (function() {
                          var _i, _len, _ref4, _results;
                          _ref4 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                            pt = _ref4[_i];
                            _results.push(pt[4].i);
                          }
                          return _results;
                        }).call(this);
                        candidates2 = [];
                        if (this.outer_radius_units === "screen") {
                          sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          for (_i = 0, _len = candidates.length; _i < _len; _i++) {
                            i = candidates[_i];
                            r2 = Math.pow(this.outer_radius[i], 2);
                            dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);
                            if (dist <= r2) {
                              candidates2.push([i, dist]);
                            }
                          }
                        } else {
                          for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
                            i = candidates[_j];
                            r2 = Math.pow(this.outer_radius[i], 2);
                            sx0 = this.renderer.xmapper.map_to_target(x);
                            sx1 = this.renderer.xmapper.map_to_target(this.x[i]);
                            sy0 = this.renderer.ymapper.map_to_target(y);
                            sy1 = this.renderer.ymapper.map_to_target(this.y[i]);
                            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                            if (dist <= r2) {
                              candidates2.push([i, dist]);
                            }
                          }
                        }
                        hits = [];
                        if (this.inner_radius_units === "screen") {
                          sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          for (_k = 0, _len2 = candidates2.length; _k < _len2; _k++) {
                            _ref4 = candidates2[_k], i = _ref4[0], dist = _ref4[1];
                            r2 = Math.pow(this.inner_radius[i], 2);
                            if (dist >= r2) {
                              hits.push([i, dist]);
                            }
                          }
                        } else {
                          for (_l = 0, _len3 = candidates2.length; _l < _len3; _l++) {
                            _ref5 = candidates2[_l], i = _ref5[0], dist = _ref5[1];
                            r2 = Math.pow(this.inner_radius[i], 2);
                            sx0 = this.renderer.xmapper.map_to_target(x);
                            sx1 = this.renderer.xmapper.map_to_target(this.x[i]);
                            sy0 = this.renderer.ymapper.map_to_target(y);
                            sy1 = this.renderer.ymapper.map_to_target(this.y[i]);
                            if (dist >= r2) {
                              hits.push([i, dist]);
                            }
                          }
                        }
                        hits = _.chain(hits).sortBy(function(elt) {
                          return elt[1];
                        }).map(function(elt) {
                          return elt[0];
                        }).value();
                        return hits;
                      };
                
                      AnnulusView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        var indices, inner_radius, outer_radius, r, reference_point, sx, sy, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        indices = [reference_point];
                        sx = {};
                        sx[reference_point] = (x0 + x1) / 2;
                        sy = {};
                        sy[reference_point] = (y0 + y1) / 2;
                        r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;
                        inner_radius = {};
                        inner_radius[reference_point] = r * 0.4;
                        outer_radius = {};
                        outer_radius[reference_point] = r * 0.8;
                        return this._render(ctx, indices, sx, sy, inner_radius, outer_radius);
                      };
                
                      return AnnulusView;
                
                    })(Glyph.View);
                    Annulus = (function(_super) {
                      __extends(Annulus, _super);
                
                      function Annulus() {
                        _ref1 = Annulus.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Annulus.prototype.default_view = AnnulusView;
                
                      Annulus.prototype.type = 'Annulus';
                
                      Annulus.prototype.display_defaults = function() {
                        return _.extend({}, Annulus.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return Annulus;
                
                    })(Glyph.Model);
                    Annuluses = (function(_super) {
                      __extends(Annuluses, _super);
                
                      function Annuluses() {
                        _ref2 = Annuluses.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Annuluses.prototype.model = Annulus;
                
                      return Annuluses;
                
                    })(Glyph.Collection);
                    return {
                      Model: Annulus,
                      View: AnnulusView,
                      Collection: new Annuluses()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=annulus.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/arc',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var Arc, ArcView, Arcs, _ref, _ref1, _ref2;
                    ArcView = (function(_super) {
                      __extends(ArcView, _super);
                
                      function ArcView() {
                        _ref = ArcView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ArcView.prototype._fields = ['x', 'y', 'radius', 'start_angle', 'end_angle', 'direction:string'];
                
                      ArcView.prototype._properties = ['line'];
                
                      ArcView.prototype._map_data = function() {
                        var _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        return this.radius = this.distance_vector('x', 'radius', 'edge');
                      };
                
                      ArcView.prototype._render = function(ctx, indices, sx, sy, radius) {
                        var i, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (radius == null) {
                          radius = this.radius;
                        }
                        if (this.props.line.do_stroke) {
                          _results = [];
                          for (_i = 0, _len = indices.length; _i < _len; _i++) {
                            i = indices[_i];
                            if (isNaN(sx[i] + sy[i] + radius[i] + this.start_angle[i] + this.end_angle[i] + this.direction[i])) {
                              continue;
                            }
                            ctx.beginPath();
                            ctx.arc(sx[i], sy[i], radius[i], this.start_angle[i], this.end_angle[i], this.direction[i]);
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          }
                          return _results;
                        }
                      };
                
                      ArcView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        var indices, radius, reference_point, sx, sy, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        indices = [reference_point];
                        sx = {};
                        sx[reference_point] = (x0 + x1) / 2;
                        sy = {};
                        sy[reference_point] = (y0 + y1) / 2;
                        radius = {};
                        radius[reference_point] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;
                        return this._render(ctx, indices, sx, sy, radius);
                      };
                
                      return ArcView;
                
                    })(Glyph.View);
                    Arc = (function(_super) {
                      __extends(Arc, _super);
                
                      function Arc() {
                        _ref1 = Arc.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Arc.prototype.default_view = ArcView;
                
                      Arc.prototype.type = 'Arc';
                
                      Arc.prototype.display_defaults = function() {
                        return _.extend({}, Arc.__super__.display_defaults.call(this), this.line_defaults, {
                          direction: 'anticlock'
                        });
                      };
                
                      return Arc;
                
                    })(Glyph.Model);
                    Arcs = (function(_super) {
                      __extends(Arcs, _super);
                
                      function Arcs() {
                        _ref2 = Arcs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Arcs.prototype.model = Arc;
                
                      return Arcs;
                
                    })(Glyph.Collection);
                    return {
                      Model: Arc,
                      View: ArcView,
                      Collection: new Arcs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=arc.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/bezier',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var Bezier, BezierView, Beziers, _ref, _ref1, _ref2;
                    BezierView = (function(_super) {
                      __extends(BezierView, _super);
                
                      function BezierView() {
                        _ref = BezierView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      BezierView.prototype._fields = ['x0', 'y0', 'x1', 'y1', 'cx0', 'cy0', 'cx1', 'cy1'];
                
                      BezierView.prototype._properties = ['line'];
                
                      BezierView.prototype._map_data = function() {
                        var _ref1, _ref2, _ref3, _ref4;
                        _ref1 = this.renderer.map_to_screen(this.x0, this.glyph.x0.units, this.y0, this.glyph.y0.units), this.sx0 = _ref1[0], this.sy0 = _ref1[1];
                        _ref2 = this.renderer.map_to_screen(this.x1, this.glyph.x1.units, this.y1, this.glyph.y1.units), this.sx1 = _ref2[0], this.sy1 = _ref2[1];
                        _ref3 = this.renderer.map_to_screen(this.cx0, this.glyph.cx0.units, this.cy0, this.glyph.cy0.units), this.scx0 = _ref3[0], this.scy0 = _ref3[1];
                        return _ref4 = this.renderer.map_to_screen(this.cx1, this.glyph.cx1.units, this.cy1, this.glyph.cy1.units), this.scx1 = _ref4[0], this.scy1 = _ref4[1], _ref4;
                      };
                
                      BezierView.prototype._render = function(ctx, indices) {
                        var i, _i, _len, _results;
                        if (this.props.line.do_stroke) {
                          _results = [];
                          for (_i = 0, _len = indices.length; _i < _len; _i++) {
                            i = indices[_i];
                            if (isNaN(this.sx0[i] + this.sy0[i] + this.sx1[i] + this.sy1[i] + this.scx0[i] + this.scy0[i] + this.scx1[i] + this.scy1[i])) {
                              continue;
                            }
                            ctx.beginPath();
                            ctx.moveTo(this.sx0[i], this.sy0[i]);
                            ctx.bezierCurveTo(this.scx0[i], this.scy0[i], this.scx1[i], this.scy1[i], this.sx1[i], this.sy1[i]);
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          }
                          return _results;
                        }
                      };
                
                      BezierView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_line_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return BezierView;
                
                    })(Glyph.View);
                    Bezier = (function(_super) {
                      __extends(Bezier, _super);
                
                      function Bezier() {
                        _ref1 = Bezier.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Bezier.prototype.default_view = BezierView;
                
                      Bezier.prototype.type = 'Bezier';
                
                      Bezier.prototype.display_defaults = function() {
                        return _.extend({}, Bezier.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return Bezier;
                
                    })(Glyph.Model);
                    Beziers = (function(_super) {
                      __extends(Beziers, _super);
                
                      function Beziers() {
                        _ref2 = Beziers.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Beziers.prototype.model = Bezier;
                
                      return Beziers;
                
                    })(Glyph.Collection);
                    return {
                      Model: Bezier,
                      View: BezierView,
                      Collection: new Beziers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=bezier.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/circle',["underscore", "rbush", "renderer/properties", "./glyph"], function(_, rbush, Properties, Glyph) {
                    var Circle, CircleView, Circles, point_in_poly, _ref, _ref1, _ref2;
                    point_in_poly = function(x, y, px, py) {
                      var i, inside, x1, x2, y1, y2, _i, _ref;
                      inside = false;
                      x1 = px[px.length - 1];
                      y1 = py[py.length - 1];
                      for (i = _i = 0, _ref = px.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                        x2 = px[i];
                        y2 = py[i];
                        if ((y1 < y) !== (y2 < y)) {
                          if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x) {
                            inside = !inside;
                          }
                        }
                        x1 = x2;
                        y1 = y2;
                      }
                      return inside;
                    };
                    CircleView = (function(_super) {
                      __extends(CircleView, _super);
                
                      function CircleView() {
                        _ref = CircleView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CircleView.prototype._properties = ['line', 'fill'];
                
                      CircleView.prototype.initialize = function(options) {
                        if (this.mget("radius") != null) {
                          this._fields = ['x', 'y', 'radius'];
                        } else {
                          this._fields = ['x', 'y', 'size'];
                        }
                        return CircleView.__super__.initialize.call(this, options);
                      };
                
                      CircleView.prototype._set_data = function() {
                        var i, pts, _i, _ref1;
                        if (this.size) {
                          this.max_radius = _.max(this.size) / 2;
                        } else {
                          this.max_radius = _.max(this.radius);
                        }
                        this.index = rbush();
                        pts = [];
                        for (i = _i = 0, _ref1 = this.x.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (!isNaN(this.x[i] + this.y[i])) {
                            pts.push([
                              this.x[i], this.y[i], this.x[i], this.y[i], {
                                'i': i
                              }
                            ]);
                          }
                        }
                        return this.index.load(pts);
                      };
                
                      CircleView.prototype._map_data = function() {
                        var s, _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        if (this.size) {
                          this.radius = (function() {
                            var _i, _len, _ref2, _results;
                            _ref2 = this.distance_vector('x', 'size', 'edge');
                            _results = [];
                            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                              s = _ref2[_i];
                              _results.push(s / 2);
                            }
                            return _results;
                          }).call(this);
                          return this.radius_units = this.glyph.size.units;
                        } else {
                          return this.radius = this.distance_vector('x', 'radius', 'edge');
                        }
                      };
                
                      CircleView.prototype._mask_data = function() {
                        var hr, sx0, sx1, sy0, sy1, vr, x, x0, x1, y0, y1, _ref1, _ref2, _ref3, _ref4;
                        hr = this.renderer.plot_view.frame.get('h_range');
                        vr = this.renderer.plot_view.frame.get('v_range');
                        if (this.radius_units === "screen") {
                          sx0 = hr.get('start') - this.max_radius;
                          sx1 = hr.get('end') - this.max_radius;
                          _ref1 = this.renderer.xmapper.v_map_from_target([sx0, sx1]), x0 = _ref1[0], x1 = _ref1[1];
                          sy0 = vr.get('start') - this.max_radius;
                          sy1 = vr.get('end') - this.max_radius;
                          _ref2 = this.renderer.ymapper.v_map_from_target([sy0, sy1]), y0 = _ref2[0], y1 = _ref2[1];
                        } else {
                          sx0 = hr.get('start');
                          sx1 = hr.get('end');
                          _ref3 = this.renderer.xmapper.v_map_from_target([sx0, sx1]), x0 = _ref3[0], x1 = _ref3[1];
                          x0 -= this.max_radius;
                          x1 += this.max_radius;
                          sy0 = vr.get('start');
                          sy1 = vr.get('end');
                          _ref4 = this.renderer.ymapper.v_map_from_target([sy0, sy1]), y0 = _ref4[0], y1 = _ref4[1];
                          y0 -= this.max_radius;
                          y1 += this.max_radius;
                        }
                        return (function() {
                          var _i, _len, _ref5, _results;
                          _ref5 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
                            x = _ref5[_i];
                            _results.push(x[4].i);
                          }
                          return _results;
                        }).call(this);
                      };
                
                      CircleView.prototype._render = function(ctx, indices, sx, sy, radius) {
                        var i, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (radius == null) {
                          radius = this.radius;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + radius[i])) {
                            continue;
                          }
                          ctx.beginPath();
                          ctx.arc(sx[i], sy[i], radius[i], 0, 2 * Math.PI, false);
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      CircleView.prototype._hit_point = function(geometry) {
                        var candidates, dist, hits, i, pt, r2, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        x = this.renderer.xmapper.map_from_target(vx);
                        y = this.renderer.ymapper.map_from_target(vy);
                        if (this.radius_units === "screen") {
                          vx0 = vx - this.max_radius;
                          vx1 = vx + this.max_radius;
                          _ref2 = this.renderer.xmapper.v_map_from_target([vx0, vx1]), x0 = _ref2[0], x1 = _ref2[1];
                          vy0 = vy - this.max_radius;
                          vy1 = vy + this.max_radius;
                          _ref3 = this.renderer.ymapper.v_map_from_target([vy0, vy1]), y0 = _ref3[0], y1 = _ref3[1];
                        } else {
                          x0 = x - this.max_radius;
                          x1 = x + this.max_radius;
                          y0 = y - this.max_radius;
                          y1 = y + this.max_radius;
                        }
                        candidates = (function() {
                          var _i, _len, _ref4, _results;
                          _ref4 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                            pt = _ref4[_i];
                            _results.push(pt[4].i);
                          }
                          return _results;
                        }).call(this);
                        hits = [];
                        if (this.radius_units === "screen") {
                          sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          for (_i = 0, _len = candidates.length; _i < _len; _i++) {
                            i = candidates[_i];
                            r2 = Math.pow(this.radius[i], 2);
                            dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);
                            if (dist <= r2) {
                              hits.push([i, dist]);
                            }
                          }
                        } else {
                          for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
                            i = candidates[_j];
                            r2 = Math.pow(this.radius[i], 2);
                            sx0 = this.renderer.xmapper.map_to_target(x);
                            sx1 = this.renderer.xmapper.map_to_target(this.x[i]);
                            sy0 = this.renderer.ymapper.map_to_target(y);
                            sy1 = this.renderer.ymapper.map_to_target(this.y[i]);
                            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                            if (dist <= r2) {
                              hits.push([i, dist]);
                            }
                          }
                        }
                        hits = _.chain(hits).sortBy(function(elt) {
                          return elt[1];
                        }).map(function(elt) {
                          return elt[0];
                        }).value();
                        return hits;
                      };
                
                      CircleView.prototype._hit_rect = function(geometry) {
                        var x, x0, x1, y0, y1, _ref1, _ref2;
                        _ref1 = this.renderer.xmapper.v_map_from_target([geometry.vx0, geometry.vx1]), x0 = _ref1[0], x1 = _ref1[1];
                        _ref2 = this.renderer.ymapper.v_map_from_target([geometry.vy0, geometry.vy1]), y0 = _ref2[0], y1 = _ref2[1];
                        return (function() {
                          var _i, _len, _ref3, _results;
                          _ref3 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                            x = _ref3[_i];
                            _results.push(x[4].i);
                          }
                          return _results;
                        }).call(this);
                      };
                
                      CircleView.prototype._hit_poly = function(geometry) {
                        var candidates, hits, i, idx, sx, sy, vx, vy, _i, _j, _ref1, _ref2, _ref3, _results;
                        _ref1 = [_.clone(geometry.vx), _.clone(geometry.vy)], vx = _ref1[0], vy = _ref1[1];
                        sx = this.renderer.plot_view.canvas.v_vx_to_sx(vx);
                        sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);
                        candidates = (function() {
                          _results = [];
                          for (var _i = 0, _ref2 = this.sx.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
                          return _results;
                        }).apply(this);
                        hits = [];
                        for (i = _j = 0, _ref3 = candidates.length; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
                          idx = candidates[i];
                          if (point_in_poly(this.sx[i], this.sy[i], sx, sy)) {
                            hits.push(idx);
                          }
                        }
                        return hits;
                      };
                
                      CircleView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        var indices, radius, reference_point, sx, sy, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        indices = [reference_point];
                        sx = {};
                        sx[reference_point] = (x0 + x1) / 2;
                        sy = {};
                        sy[reference_point] = (y0 + y1) / 2;
                        radius = {};
                        radius[reference_point] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;
                        return this._render(ctx, indices, sx, sy, radius);
                      };
                
                      return CircleView;
                
                    })(Glyph.View);
                    Circle = (function(_super) {
                      __extends(Circle, _super);
                
                      function Circle() {
                        _ref1 = Circle.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Circle.prototype.default_view = CircleView;
                
                      Circle.prototype.type = 'Circle';
                
                      Circle.prototype.display_defaults = function() {
                        return _.extend({}, Circle.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults, {
                          size: 4
                        });
                      };
                
                      return Circle;
                
                    })(Glyph.Model);
                    Circles = (function(_super) {
                      __extends(Circles, _super);
                
                      function Circles() {
                        _ref2 = Circles.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Circles.prototype.model = Circle;
                
                      return Circles;
                
                    })(Glyph.Collection);
                    return {
                      Model: Circle,
                      View: CircleView,
                      Collection: new Circles()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=circle.js.map
                */;
                define('gear_utils',[],function() {
                /*==========================================================================*
                  Filename: gearUtils-04.js
                  By: Dr A.R.Collins
                
                  JavaScript involute gear drawing utilities.
                  Requires:
                  'involuteBezCoeffs' can stand alone,
                  'createGearTooth' and 'createIntGearTooth' generate draw commands for use
                  in Cango graphics library but may be simply converted for use in SVG.
                
                  Kindly give credit to Dr A.R.Collins <http://www.arc.id.au/>
                  Report bugs to tony at arc.id.au
                
                  Date   |Description                                                   |By
                  --------------------------------------------------------------------------
                  20Feb13 First public release                                           ARC
                  21Feb13 Clarified variable names of start and end parameters           ARC
                  06Mar13 Fixed Rf and filletAngle calculations                          ARC
                  25Jun13 Code tidy for JSLint, use strict                               ARC
                 *==========================================================================*/
                
                  // exposed globals
                  var involuteBezCoeffs, createGearTooth, createIntGearTooth;
                
                (function()
                {
                  
                /* ----------------------------------------------------------
                 * involuteBezCoeffs
                 *
                 * JavaScript calculation of Bezier coefficients for
                 * Higuchi et al. approximation to an involute.
                 * ref: YNU Digital Eng Lab Memorandum 05-1
                 *
                 * Parameters:
                 * module - sets the size of teeth (see gear design texts)
                 * numTeeth - number of teeth on the gear
                 * pressure angle - angle in degrees, usually 14.5 or 20
                 * order - the order of the Bezier curve to be fitted [3, 4, 5, ..]
                 * fstart - fraction of distance along tooth profile to start
                 * fstop - fraction of distance along profile to stop
                 *-----------------------------------------------------------*/
                involuteBezCoeffs = function(module, numTeeth, pressureAngle, order, fstart, fstop)
                {
                  var PI = Math.PI,
                      Rpitch = module*numTeeth/2,       // pitch circle radius
                      phi = pressureAngle || 20,        // pressure angle
                      Rb = Rpitch*Math.cos(phi*PI/180), // base circle radius
                      Ra = Rpitch+module,               // addendum radius (outer radius)
                      p = order || 3,                   // order of Bezier approximation
                      ta = Math.sqrt(Ra*Ra-Rb*Rb)/Rb,   // involute angle at addendum
                      stop = fstop || 1,
                      start = 0.01,
                      te, ts,
                      bzCoeffs = [],
                      i, bcoeff;
                
                  function chebyExpnCoeffs(j, func)
                  {
                    var N = 50,      // a suitably large number  N>>p
                        c = 0,
                        k;
                
                    for (k=1; k<=N; k++)
                    {
                      c += func(Math.cos(PI*(k-0.5)/N)) * Math.cos(PI*j*(k-0.5)/N);
                    }
                    return 2*c/N;
                  }
                
                  function chebyPolyCoeffs(p, func)
                  {
                    var coeffs = [],
                        fnCoeff = [],
                        T = [[], []],
                        i, j, k, pwr;
                
                    // populate 1st 2 rows of T
                    for (i=0; i<p+1; i++)
                    {
                      T[0][i] = 0;
                      T[1][i] = 0;
                    }
                    T[0][0] = 1;
                    T[1][1] = 1;
                    /* now generate the Chebyshev polynomial coefficient using
                       formula T(k+1) = 2xT(k) - T(k-1) which yields
                    T = [ [ 1,  0,  0,  0,  0,  0],    // T0(x) =  +1
                          [ 0,  1,  0,  0,  0,  0],    // T1(x) =   0  +x
                          [-1,  0,  2,  0,  0,  0],    // T2(x) =  -1  0  +2xx
                          [ 0, -3,  0,  4,  0,  0],    // T3(x) =   0 -3x    0   +4xxx
                          [ 1,  0, -8,  0,  8,  0],    // T4(x) =  +1  0  -8xx       0  +8xxxx
                          [ 0,  5,  0,-20,  0, 16],    // T5(x) =   0  5x    0  -20xxx       0  +16xxxxx
                          ...                     ];
                    */
                    for (k=1; k<p+1; k++)
                    {
                      T[k+1] = [0];
                      for (j=0; j<T[k].length-1; j++)
                      {
                        T[k+1][j+1] = 2*T[k][j];
                      }
                      for (j=0; j<T[k-1].length; j++)
                      {
                        T[k+1][j] -= T[k-1][j];
                      }
                    }
                    // convert the chebyshev function series into a simple polynomial
                    // and collect like terms, out T polynomial coefficients
                    for (k=0; k<=p; k++)
                    {
                      fnCoeff[k] = chebyExpnCoeffs(k, func);
                      coeffs[k] = 0;
                    }
                    for (k=0; k<=p; k++)
                    {
                      for (pwr=0; pwr<=p; pwr++)    // loop thru powers of x
                      {
                        coeffs[pwr] += fnCoeff[k]*T[k][pwr];
                      }
                    }
                    coeffs[0] -= chebyExpnCoeffs(0, func)/2;  // fix the 0th coeff
                
                    return coeffs;
                  }
                
                  // Equation of involute using the Bezier parameter t as variable
                  function involuteXbez(t)
                  {
                    // map t (0 <= t <= 1) onto x (where -1 <= x <= 1)
                    var x = t*2-1;
                    //map theta (where ts <= theta <= te) from x (-1 <=x <= 1)
                    var theta = x*(te-ts)/2 + (ts + te)/2;
                    return Rb*(Math.cos(theta)+theta*Math.sin(theta));
                  }
                
                  function involuteYbez(t)
                  {
                    // map t (0 <= t <= 1) onto x (where -1 <= x <= 1)
                    var x = t*2-1;
                    //map theta (where ts <= theta <= te) from x (-1 <=x <= 1)
                    var theta = x*(te-ts)/2 + (ts + te)/2;
                    return Rb*(Math.sin(theta)-theta*Math.cos(theta));
                  }
                
                  function binom(n, k)
                  {
                    var coeff = 1;
                    var i;
                    for (i = n-k+1; i <= n; i++)
                    {
                      coeff *= i;
                    }
                    for (i = 1; i <= k; i++)
                    {
                      coeff /= i;
                    }
                
                    return coeff;
                  }
                
                  function bezCoeff(i, func)
                  {
                    // generate the polynomial coeffs in one go
                    var polyCoeffs = chebyPolyCoeffs(p, func),
                        bc, j;
                
                    for (bc=0, j=0; j<=i; j++)
                    {
                      bc += binom(i,j)*polyCoeffs[j]/binom(p,j);
                    }
                    return bc;
                  }
                
                  if ((fstart !== undefined)&&(fstart<stop))
                  {
                    start = fstart;
                  }
                  te = Math.sqrt(stop)*ta;          // involute angle, theta, at end of approx
                  ts = Math.sqrt(start)*ta;         // involute angle, theta, at start of approx
                  // calc Bezier coeffs
                  for (i=0; i<=p; i++)
                  {
                    bcoeff = {};
                    bcoeff.x = bezCoeff(i, involuteXbez);
                    bcoeff.y = bezCoeff(i, involuteYbez);
                    bzCoeffs.push(bcoeff);
                  }
                
                  return bzCoeffs;
                };
                
                /*----------------------------------------------------------
                  createGearTooth
                  Create an array of drawing commands and their coordinates
                  to draw a single spur gear tooth based on a circle
                  involute using the metric gear standards.
                
                  Requires Cango graphics library Rev 2.08 or later
                 ----------------------------------------------------------*/
                createGearTooth = function(module, teeth, pressureAngle)
                {
                  function genInvolutePolar(Rb, R)  // Rb = base circle radius
                  {
                    // returns the involute angle as function of radius R.
                    return (Math.sqrt(R*R - Rb*Rb)/Rb) - Math.acos(Rb/R);
                  }
                
                  function rotate(pt, rads)  // rotate pt by rads radians about origin
                  {
                    var sinA = Math.sin(rads);
                    var cosA = Math.cos(rads);
                    return {x: pt.x*cosA - pt.y*sinA,
                            y: pt.x*sinA + pt.y*cosA};
                  }
                
                  function toCartesian(radius, angle)   // convert polar coords to cartesian
                  {
                    return {x: radius*Math.cos(angle),
                            y: radius*Math.sin(angle)};
                  }
                  // ****** external gear specifications
                  var m = module,                                     // Module = mm of pitch diameter per tooth
                      Z = teeth,                                      // Number of teeth
                      phi = pressureAngle || 20,                      // pressure angle (degrees)
                      addendum = m,                                   // distance from pitch circle to tip circle
                      dedendum = 1.25*m,                              // pitch circle to root, sets clearance
                      clearance = dedendum - addendum,
                      // Calculate radii
                      Rpitch = Z*m/2,                                 // pitch circle radius
                      Rb = Rpitch*Math.cos(phi*Math.PI/180),          // base circle radius
                      Ra = Rpitch + addendum,                         // tip (addendum) circle radius
                      Rroot = Rpitch - dedendum,                      // root circle radius
                      fRad = 1.5*clearance,                           // fillet radius, max 1.5*clearance
                      Rf,                                             // radius at top of fillet
                      // ****** calculate angles (all in radians)
                      pitchAngle = 2*Math.PI/Z,                       // angle subtended by whole tooth (rads)
                      baseToPitchAngle = genInvolutePolar(Rb, Rpitch),
                      pitchToFilletAngle = baseToPitchAngle,          // profile starts at base circle
                      filletAngle = Math.atan(fRad/(fRad+Rroot)),     // radians
                      fe, fs, fm,
                      dedBz, addBz, inv, invR,
                      fillet, filletR, filletNext,
                      rootR, rootNext,
                      pt, i, data;
                
                  Rf = Math.sqrt((Rroot+fRad)*(Rroot+fRad)-(fRad*fRad)); // radius at top of fillet
                  if (Rb < Rf)
                  {
                    Rf = Rroot+clearance;
                  }
                  if (Rf > Rb)                   // start profile at top of fillet (if its greater)
                  {
                    pitchToFilletAngle -= genInvolutePolar(Rb, Rf);
                  }
                  // ****** generate Higuchi involute approximation
                  fe = 1;                    // fraction of profile length at end of approx
                  fs = 0.01;                 // fraction of length offset from base to avoid singularity
                  if (Rf > Rb)
                  {
                    fs = (Rf*Rf-Rb*Rb)/(Ra*Ra-Rb*Rb);  // offset start to top of fillet
                  }
                  // approximate in 2 sections, split 25% along the involute
                  fm = fs+(fe-fs)/4;         // fraction of length at junction (25% along profile)
                  dedBz = involuteBezCoeffs(m, Z, phi, 3, fs, fm);
                  addBz = involuteBezCoeffs(m, Z, phi, 3, fm, fe);
                  // join the 2 sets of coeffs (skip duplicate mid point)
                  inv = dedBz.concat(addBz.slice(1));
                  //create the back profile of tooth (mirror image)
                  invR = [];                // involute profile along back of tooth
                  for (i=0; i<inv.length; i++)
                  {
                    // rotate all points to put pitch point at y = 0
                    pt = rotate(inv[i], -baseToPitchAngle-pitchAngle/4);
                    inv[i] = pt;
                    // generate the back of tooth profile nodes, mirror coords in X axis
                    invR[i] = {x:pt.x, y:-pt.y};
                  }
                  // ****** calculate section junction points R=back of tooth, Next=front of next tooth)
                  fillet = toCartesian(Rf, -pitchAngle/4-pitchToFilletAngle); // top of fillet
                  filletR = {x:fillet.x, y:-fillet.y};   // flip to make same point on back of tooth
                  rootR = toCartesian(Rroot, pitchAngle/4+pitchToFilletAngle+filletAngle);
                  rootNext = toCartesian(Rroot, 3*pitchAngle/4-pitchToFilletAngle-filletAngle);
                  filletNext = rotate(fillet, pitchAngle);  // top of fillet, front of next tooth
                  // ****** create the drawing command data array for the tooth
                  data = [];
                  data.push("M", fillet.x, fillet.y);           // start at top of fillet
                  if (Rf < Rb)
                  {
                    data.push("L", inv[0].x, inv[0].y);         // line from fillet up to base circle
                  }
                  data.push("C", inv[1].x, inv[1].y, inv[2].x, inv[2].y, inv[3].x, inv[3].y,
                                 inv[4].x, inv[4].y, inv[5].x, inv[5].y, inv[6].x, inv[6].y);
                  data.push("A", Ra, Ra, 0, 0, 0, invR[6].x, invR[6].y); // arc across addendum circle
                  data.push("C", invR[5].x, invR[5].y, invR[4].x, invR[4].y, invR[3].x, invR[3].y,
                                 invR[2].x, invR[2].y, invR[1].x, invR[1].y, invR[0].x, invR[0].y);
                  if (Rf < Rb)
                  {
                    data.push("L", filletR.x, filletR.y);       // line down to top of fillet
                  }
                  if (rootNext.y > rootR.y)    // is there a section of root circle between fillets?
                  {
                    data.push("A", fRad, fRad, 0, 0, 1, rootR.x, rootR.y);// back fillet
                    data.push("A", Rroot, Rroot, 0, 0, 0, rootNext.x, rootNext.y); // root circle arc
                  }
                  data.push("A", fRad, fRad, 0, 0, 1, filletNext.x, filletNext.y);
                
                  return data;  // return an array of Cango (SVG) format draw commands
                };
                
                /*----------------------------------------------------------
                  createIntGearTooth
                  Create an array of drawing commands and their coordinates
                  to draw a single internal (ring)gear tooth based on a
                  circle involute using the metric gear standards.
                
                  Requires Cango graphics library Rev 2.08 or later
                 ----------------------------------------------------------*/
                createIntGearTooth = function(module, teeth, pressureAngle)
                {
                  // ****** gear specifications
                  var m = module,                               // Module = mm of pitch diameter per tooth
                      Z = teeth,                                // Number of teeth
                      phi = pressureAngle || 20,                // pressure angle (degrees)
                      addendum = 0.6*m,                         // pitch circle to tip circle (ref G.M.Maitra)
                      dedendum = 1.25*m,                        // pitch circle to root radius, sets clearance
                      // Calculate radii
                      Rpitch = Z*m/2,                           // pitch radius
                      Rb = Rpitch*Math.cos(phi*Math.PI/180),    // base radius
                      Ra = Rpitch - addendum,                   // addendum radius
                      Rroot = Rpitch + dedendum,                // root radius
                      clearance = 0.25*m,                       // gear dedendum - pinion addendum
                      Rf = Rroot - clearance,                   // radius of top of fillet (end of profile)
                      fRad = 1.5*clearance,                     // fillet radius, 1 .. 1.5*clearance
                      pitchAngle,                               // angle between teeth (rads)
                      baseToPitchAngle,
                      tipToPitchAngle,
                      pitchToFilletAngle,
                      filletAngle,
                      fe, fs, fm,
                      addBz, dedBz,
                      inv, invR,
                      pt, i, data,
                      fillet, filletNext,
                      tip, tipR,
                      rootR, rootNext;
                
                  function genInvolutePolar(Rb, R)  // Rb = base circle radius
                  {
                    // returns the involute angle as function of radius R.
                    return (Math.sqrt(R*R - Rb*Rb)/Rb) - Math.acos(Rb/R);
                  }
                
                  function rotate(pt, rads)  // rotate pt by rads radians about origin
                  {
                    var sinA = Math.sin(rads);
                    var cosA = Math.cos(rads);
                    return {x: pt.x*cosA - pt.y*sinA,
                            y: pt.x*sinA + pt.y*cosA};
                  }
                
                  function toCartesian(radius, angle)   // convert polar coords to cartesian
                  {
                    return {x: radius*Math.cos(angle),
                            y: radius*Math.sin(angle)};
                  }
                
                  // ****** calculate subtended angles
                  pitchAngle = 2*Math.PI/Z;                       // angle between teeth (rads)
                  baseToPitchAngle = genInvolutePolar(Rb, Rpitch);
                  tipToPitchAngle = baseToPitchAngle;             // profile starts from base circle
                  if (Ra > Rb)
                  {
                    tipToPitchAngle -= genInvolutePolar(Rb, Ra);  // start profile from addendum
                  }
                  pitchToFilletAngle = genInvolutePolar(Rb, Rf) - baseToPitchAngle;
                  filletAngle = 1.414*clearance/Rf;               // to make fillet tangential to root
                  // ****** generate Higuchi involute approximation
                  fe = 1;                   // fraction of involute length at end of approx (fillet circle)
                  fs = 0.01;                 // fraction of length offset from base to avoid singularity
                  if (Ra > Rb)
                  {
                    fs = (Ra*Ra-Rb*Rb)/(Rf*Rf-Rb*Rb);    // start profile from addendum (tip circle)
                  }
                  // approximate in 2 sections, split 25% along the profile
                  fm = fs+(fe-fs)/4;        //
                  addBz = involuteBezCoeffs(m, Z, phi, 3, fs, fm);
                  dedBz = involuteBezCoeffs(m, Z, phi, 3, fm, fe);
                  // join the 2 sets of coeffs (skip duplicate mid point)
                  invR = addBz.concat(dedBz.slice(1));
                  //create the front profile of tooth (mirror image)
                  inv = [];         // back involute profile
                  for (i=0; i<invR.length; i++)
                  {
                    // rotate involute to put center of tooth at y = 0
                    pt = rotate(invR[i], pitchAngle/4-baseToPitchAngle);
                    invR[i] = pt;
                    // generate the back of tooth profile, flip Y coords
                    inv[i] = {x:pt.x, y:-pt.y};
                  }
                  // ****** calculate coords of section junctions
                  fillet = {x:inv[6].x, y:inv[6].y};    // top of fillet, front of tooth
                  tip = toCartesian(Ra, -pitchAngle/4+tipToPitchAngle);  // tip, front of tooth
                  tipR = {x:tip.x, y:-tip.y};  // addendum, back of tooth
                  rootR = toCartesian(Rroot, pitchAngle/4+pitchToFilletAngle+filletAngle);
                  rootNext = toCartesian(Rroot, 3*pitchAngle/4-pitchToFilletAngle-filletAngle);
                  filletNext = rotate(fillet, pitchAngle);  // top of fillet, front of next tooth
                  // ****** create the drawing command data array for the tooth
                  data = [];
                  data.push("M", inv[6].x, inv[6].y);  // start at top of front profile
                  data.push("C", inv[5].x, inv[5].y, inv[4].x, inv[4].y, inv[3].x, inv[3].y,
                                 inv[2].x, inv[2].y, inv[1].x, inv[1].y, inv[0].x, inv[0].y);
                  if (Ra < Rb)
                  {
                    data.push("L", tip.x, tip.y);  // line from end of involute to addendum (tip)
                  }
                  data.push("A", Ra, Ra, 0, 0, 0, tipR.x, tipR.y); // arc across tip circle
                  if (Ra < Rb)
                  {
                    data.push("L", invR[0].x, invR[0].y);  // line from addendum to start of involute
                  }
                  data.push("C", invR[1].x, invR[1].y, invR[2].x, invR[2].y, invR[3].x, invR[3].y,
                                 invR[4].x, invR[4].y, invR[5].x, invR[5].y, invR[6].x, invR[6].y);
                  if (rootR.y < rootNext.y)    // there is a section of root circle between fillets
                  {
                    data.push("A", fRad, fRad, 0, 0, 0, rootR.x, rootR.y); // fillet on back of tooth
                    data.push("A", Rroot, Rroot, 0, 0, 0, rootNext.x, rootNext.y); // root circle arc
                  }
                  data.push("A", fRad, fRad, 0, 0, 0, filletNext.x, filletNext.y); // fillet on next
                
                  return data;  // return an array of Cango (SVG) format draw commands
                };
                
                }());
                
                return { create_gear_tooth: createGearTooth, create_internal_gear_tooth: createIntGearTooth };
                });
                
                (function() {
                  define('util/bezier',[], function() {
                    var arc_to_bezier, segment_to_bezier;
                    segment_to_bezier = function(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {
                      var a00, a01, a10, a11, t, th_half, x1, x2, x3, y1, y2, y3;
                      a00 = cos_th * rx;
                      a01 = -sin_th * ry;
                      a10 = sin_th * rx;
                      a11 = cos_th * ry;
                      th_half = 0.5 * (th1 - th0);
                      t = (8 / 3) * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
                      x1 = cx + Math.cos(th0) - t * Math.sin(th0);
                      y1 = cy + Math.sin(th0) + t * Math.cos(th0);
                      x3 = cx + Math.cos(th1);
                      y3 = cy + Math.sin(th1);
                      x2 = x3 + t * Math.sin(th1);
                      y2 = y3 - t * Math.cos(th1);
                      return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
                    };
                    arc_to_bezier = function(ox, oy, radx, rady, rotateX, large, sweep, x, y) {
                      var a00, a01, a10, a11, cos_th, d, i, pl, px, py, result, rx, ry, segments, sfactor, sfactor_sq, sin_th, th, th0, th1, th2, th3, th_arc, x0, x1, xc, y0, y1, yc;
                      th = rotateX * (Math.PI / 180);
                      sin_th = Math.sin(th);
                      cos_th = Math.cos(th);
                      rx = Math.abs(radx);
                      ry = Math.abs(rady);
                      px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
                      py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
                      pl = (px * px) / (rx * rx) + (py * py) / (ry * ry);
                      if (pl > 1) {
                        pl = Math.sqrt(pl);
                        rx *= pl;
                        ry *= pl;
                      }
                      a00 = cos_th / rx;
                      a01 = sin_th / rx;
                      a10 = -sin_th / ry;
                      a11 = cos_th / ry;
                      x0 = a00 * ox + a01 * oy;
                      y0 = a10 * ox + a11 * oy;
                      x1 = a00 * x + a01 * y;
                      y1 = a10 * x + a11 * y;
                      d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
                      sfactor_sq = 1 / d - 0.25;
                      if (sfactor_sq < 0) {
                        sfactor_sq = 0;
                      }
                      sfactor = Math.sqrt(sfactor_sq);
                      if (sweep === large) {
                        sfactor = -sfactor;
                      }
                      xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
                      yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
                      th0 = Math.atan2(y0 - yc, x0 - xc);
                      th1 = Math.atan2(y1 - yc, x1 - xc);
                      th_arc = th1 - th0;
                      if (th_arc < 0 && sweep === 1) {
                        th_arc += 2 * Math.PI;
                      } else if (th_arc > 0 && sweep === 0) {
                        th_arc -= 2 * Math.PI;
                      }
                      segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
                      result = (function() {
                        var _i, _results;
                        _results = [];
                        for (i = _i = 0; 0 <= segments ? _i < segments : _i > segments; i = 0 <= segments ? ++_i : --_i) {
                          th2 = th0 + i * th_arc / segments;
                          th3 = th0 + (i + 1) * th_arc / segments;
                          _results.push(segment_to_bezier(xc, yc, th2, th3, rx, ry, sin_th, cos_th));
                        }
                        return _results;
                      })();
                      return result;
                    };
                    return {
                      arc_to_bezier: arc_to_bezier
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=bezier.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/gear',["underscore", "gear_utils", "renderer/properties", "util/bezier", "./glyph"], function(_, GearUtils, Properties, Bezier, Glyph) {
                    var Gear, GearView, Gears, _ref, _ref1, _ref2;
                    GearView = (function(_super) {
                      __extends(GearView, _super);
                
                      function GearView() {
                        _ref = GearView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      GearView.prototype._fields = ['x', 'y', 'angle', 'module', 'teeth', 'pressure_angle', 'shaft_size', 'internal:boolean'];
                
                      GearView.prototype._properties = ['line', 'fill'];
                
                      GearView.prototype._map_data = function() {
                        var _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        return this.smodule = this.distance_vector('x', 'module', 'edge');
                      };
                
                      GearView.prototype._render = function(ctx, indices) {
                        var M, angle, fn, i, internal, j, module, pitch_radius, pressure_angle, rim_radius, rot, seq, seq0, shaft_radius, shaft_size, sx, sy, teeth, x, y, _i, _j, _len, _ref1, _ref2;
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          _ref1 = [this.sx[i], this.sy[i], this.angle[i], this.smodule[i], this.teeth[i], this.pressure_angle[i], this.shaft_size[i], this.internal[i]], sx = _ref1[0], sy = _ref1[1], angle = _ref1[2], module = _ref1[3], teeth = _ref1[4], pressure_angle = _ref1[5], shaft_size = _ref1[6], internal = _ref1[7];
                          if (isNaN(sx + sy + angle + module + teeth + pressure_angle + shaft_size + internal)) {
                            continue;
                          }
                          pitch_radius = module * teeth / 2;
                          if (internal) {
                            fn = GearUtils.create_internal_gear_tooth;
                          } else {
                            fn = GearUtils.create_gear_tooth;
                          }
                          seq0 = fn(module, teeth, pressure_angle);
                          _ref2 = seq0.slice(0, 3), M = _ref2[0], x = _ref2[1], y = _ref2[2];
                          seq = seq0.slice(3);
                          ctx.save();
                          ctx.translate(sx, sy);
                          ctx.rotate(angle);
                          ctx.beginPath();
                          rot = 2 * Math.PI / teeth;
                          ctx.moveTo(x, y);
                          for (j = _j = 0; 0 <= teeth ? _j < teeth : _j > teeth; j = 0 <= teeth ? ++_j : --_j) {
                            this._render_seq(ctx, seq);
                            ctx.rotate(rot);
                          }
                          ctx.closePath();
                          if (internal) {
                            rim_radius = pitch_radius + 2.75 * module;
                            ctx.moveTo(rim_radius, 0);
                            ctx.arc(0, 0, rim_radius, 0, 2 * Math.PI, true);
                          } else if (shaft_size > 0) {
                            shaft_radius = pitch_radius * shaft_size;
                            ctx.moveTo(shaft_radius, 0);
                            ctx.arc(0, 0, shaft_radius, 0, 2 * Math.PI, true);
                          }
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            ctx.stroke();
                          }
                          ctx.restore();
                        }
                      };
                
                      GearView.prototype._render_seq = function(ctx, seq) {
                        var c, cx0, cx1, cy0, cy1, i, large_arc, px, py, rx, ry, segments, sweep, x, x_rotation, y, _i, _len, _ref1, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
                        i = 0;
                        while (i < seq.length) {
                          if (_.isString(seq[i])) {
                            c = seq[i];
                            i += 1;
                          }
                          switch (c) {
                            case "M":
                              _ref1 = seq.slice(i, i + 2), x = _ref1[0], y = _ref1[1];
                              ctx.moveTo(x, y);
                              _ref2 = [x, y], px = _ref2[0], py = _ref2[1];
                              i += 2;
                              break;
                            case "L":
                              _ref3 = seq.slice(i, i + 2), x = _ref3[0], y = _ref3[1];
                              ctx.lineTo(x, y);
                              _ref4 = [x, y], px = _ref4[0], py = _ref4[1];
                              i += 2;
                              break;
                            case "C":
                              _ref5 = seq.slice(i, i + 6), cx0 = _ref5[0], cy0 = _ref5[1], cx1 = _ref5[2], cy1 = _ref5[3], x = _ref5[4], y = _ref5[5];
                              ctx.bezierCurveTo(cx0, cy0, cx1, cy1, x, y);
                              _ref6 = [x, y], px = _ref6[0], py = _ref6[1];
                              i += 6;
                              break;
                            case "Q":
                              _ref7 = seq.slice(i, i + 4), cx0 = _ref7[0], cy0 = _ref7[1], x = _ref7[2], y = _ref7[3];
                              ctx.quadraticCurveTo(cx0, cy0, x, y);
                              _ref8 = [x, y], px = _ref8[0], py = _ref8[1];
                              i += 4;
                              break;
                            case "A":
                              _ref9 = seq.slice(i, i + 7), rx = _ref9[0], ry = _ref9[1], x_rotation = _ref9[2], large_arc = _ref9[3], sweep = _ref9[4], x = _ref9[5], y = _ref9[6];
                              segments = Bezier.arc_to_bezier(px, py, rx, ry, -x_rotation, large_arc, 1 - sweep, x, y);
                              for (_i = 0, _len = segments.length; _i < _len; _i++) {
                                _ref10 = segments[_i], cx0 = _ref10[0], cy0 = _ref10[1], cx1 = _ref10[2], cy1 = _ref10[3], x = _ref10[4], y = _ref10[5];
                                ctx.bezierCurveTo(cx0, cy0, cx1, cy1, x, y);
                              }
                              _ref11 = [x, y], px = _ref11[0], py = _ref11[1];
                              i += 7;
                              break;
                            default:
                              throw new Error("unexpected command: " + c);
                          }
                        }
                      };
                
                      GearView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_line_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return GearView;
                
                    })(Glyph.View);
                    Gear = (function(_super) {
                      __extends(Gear, _super);
                
                      function Gear() {
                        _ref1 = Gear.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Gear.prototype.default_view = GearView;
                
                      Gear.prototype.type = 'Gear';
                
                      Gear.prototype.defaults = function() {
                        return _.extend({}, Gear.__super__.defaults.call(this), {
                          x: void 0,
                          y: void 0,
                          angle: 0,
                          module: void 0,
                          teeth: void 0,
                          pressure_angle: 20,
                          shaft_size: 0.3,
                          internal: false
                        });
                      };
                
                      Gear.prototype.display_defaults = function() {
                        return _.extend({}, Gear.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return Gear;
                
                    })(Glyph.Model);
                    Gears = (function(_super) {
                      __extends(Gears, _super);
                
                      function Gears() {
                        _ref2 = Gears.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Gears.prototype.model = Gear;
                
                      return Gears;
                
                    })(Glyph.Collection);
                    return {
                      Model: Gear,
                      View: GearView,
                      Collection: new Gears()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=gear.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/image',["underscore", "renderer/properties", "mapper/linear_color_mapper", "./glyph"], function(_, Properties, LinearColorMapper, Glyph) {
                    var Image, ImageView, Images, _ref, _ref1, _ref2;
                    ImageView = (function(_super) {
                      __extends(ImageView, _super);
                
                      function ImageView() {
                        _ref = ImageView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ImageView.prototype._properties = [];
                
                      ImageView.prototype.initialize = function(options) {
                        if (this.mget("rows") != null) {
                          this._fields = ['image:array', 'rows', 'cols', 'x', 'y', 'dw', 'dh', 'palette:string'];
                        } else {
                          this._fields = ['image:array', 'x', 'y', 'dw', 'dh', 'palette:string'];
                        }
                        return ImageView.__super__.initialize.call(this, options);
                      };
                
                      ImageView.prototype._set_data = function() {
                        var buf, buf8, canvas, cmap, ctx, i, image_data, img, _i, _ref1, _results;
                        if ((this.image_data == null) || this.image_data.length !== this.image.length) {
                          this.image_data = new Array(this.image.length);
                        }
                        if ((this.width == null) || this.width.length !== this.image.length) {
                          this.width = new Array(this.image.length);
                        }
                        if ((this.height == null) || this.height.length !== this.image.length) {
                          this.height = new Array(this.image.length);
                        }
                        _results = [];
                        for (i = _i = 0, _ref1 = this.image.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (this.rows != null) {
                            this.height[i] = this.rows[i];
                            this.width[i] = this.cols[i];
                          } else {
                            this.height[i] = this.image[i].length;
                            this.width[i] = this.image[i][0].length;
                          }
                          canvas = document.createElement('canvas');
                          canvas.width = this.width[i];
                          canvas.height = this.height[i];
                          ctx = canvas.getContext('2d');
                          image_data = ctx.getImageData(0, 0, this.width[i], this.height[i]);
                          cmap = this.mget('color_mapper');
                          if (this.rows != null) {
                            img = this.image[i];
                          } else {
                            img = _.flatten(this.image[i]);
                          }
                          buf = cmap.v_map_screen(img);
                          buf8 = new Uint8ClampedArray(buf);
                          image_data.data.set(buf8);
                          ctx.putImageData(image_data, 0, 0);
                          _results.push(this.image_data[i] = canvas);
                        }
                        return _results;
                      };
                
                      ImageView.prototype._map_data = function() {
                        var _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        this.sw = this.distance_vector('x', 'dw', 'edge', this.mget('dilate'));
                        return this.sh = this.distance_vector('y', 'dh', 'edge', this.mget('dilate'));
                      };
                
                      ImageView.prototype._render = function(ctx, indices) {
                        var i, old_smoothing, y_offset, _i, _len;
                        old_smoothing = ctx.getImageSmoothingEnabled();
                        ctx.setImageSmoothingEnabled(false);
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (this.image_data[i] == null) {
                            continue;
                          }
                          if (isNaN(this.sx[i] + this.sy[i] + this.sw[i] + this.sh[i])) {
                            continue;
                          }
                          y_offset = this.sy[i];
                          ctx.translate(0, y_offset);
                          ctx.scale(1, -1);
                          ctx.translate(0, -y_offset);
                          ctx.drawImage(this.image_data[i], this.sx[i] | 0, this.sy[i] | 0, this.sw[i], this.sh[i]);
                          ctx.translate(0, y_offset);
                          ctx.scale(1, -1);
                          ctx.translate(0, -y_offset);
                        }
                        return ctx.setImageSmoothingEnabled(old_smoothing);
                      };
                
                      return ImageView;
                
                    })(Glyph.View);
                    Image = (function(_super) {
                      __extends(Image, _super);
                
                      function Image() {
                        _ref1 = Image.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Image.prototype.default_view = ImageView;
                
                      Image.prototype.type = 'Image';
                
                      Image.prototype.display_defaults = function() {
                        return _.extend({}, Image.__super__.display_defaults.call(this), {
                          level: 'underlay',
                          dilate: false
                        });
                      };
                
                      return Image;
                
                    })(Glyph.Model);
                    Images = (function(_super) {
                      __extends(Images, _super);
                
                      function Images() {
                        _ref2 = Images.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Images.prototype.model = Image;
                
                      return Images;
                
                    })(Glyph.Collection);
                    return {
                      Model: Image,
                      View: ImageView,
                      Collection: new Images()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=image.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/image_rgba',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var ImageRGBA, ImageRGBAView, ImageRGBAs, _ref, _ref1, _ref2;
                    ImageRGBAView = (function(_super) {
                      __extends(ImageRGBAView, _super);
                
                      function ImageRGBAView() {
                        _ref = ImageRGBAView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ImageRGBAView.prototype._properties = [];
                
                      ImageRGBAView.prototype.initialize = function(options) {
                        if (this.mget("rows") != null) {
                          this._fields = ['image:array', 'rows', 'cols', 'x', 'y', 'dw', 'dh'];
                        } else {
                          this._fields = ['image:array', 'x', 'y', 'dw', 'dh'];
                        }
                        return ImageRGBAView.__super__.initialize.call(this, options);
                      };
                
                      ImageRGBAView.prototype._set_data = function() {
                        var buf, buf8, canvas, color, ctx, flat, i, image_data, j, _i, _j, _ref1, _ref2, _results;
                        if ((this.image_data == null) || this.image_data.length !== this.image.length) {
                          this.image_data = new Array(this.image.length);
                        }
                        if ((this.width == null) || this.width.length !== this.image.length) {
                          this.width = new Array(this.image.length);
                        }
                        if ((this.height == null) || this.height.length !== this.image.length) {
                          this.height = new Array(this.image.length);
                        }
                        _results = [];
                        for (i = _i = 0, _ref1 = this.image.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (this.rows != null) {
                            this.height[i] = this.rows[i];
                            this.width[i] = this.cols[i];
                          } else {
                            this.height[i] = this.image[i].length;
                            this.width[i] = this.image[i][0].length;
                          }
                          canvas = document.createElement('canvas');
                          canvas.width = this.width[i];
                          canvas.height = this.height[i];
                          ctx = canvas.getContext('2d');
                          image_data = ctx.getImageData(0, 0, this.width[i], this.height[i]);
                          if (this.rows != null) {
                            image_data.data.set(new Uint8ClampedArray(this.image[i]));
                          } else {
                            flat = _.flatten(this.image[i]);
                            buf = new ArrayBuffer(flat.length * 4);
                            color = new Uint32Array(buf);
                            for (j = _j = 0, _ref2 = flat.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
                              color[j] = flat[j];
                            }
                            buf8 = new Uint8ClampedArray(buf);
                            image_data.data.set(buf8);
                          }
                          ctx.putImageData(image_data, 0, 0);
                          _results.push(this.image_data[i] = canvas);
                        }
                        return _results;
                      };
                
                      ImageRGBAView.prototype._map_data = function() {
                        var _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        this.sw = this.distance_vector('x', 'dw', 'edge', this.mget('dilate'));
                        return this.sh = this.distance_vector('y', 'dh', 'edge', this.mget('dilate'));
                      };
                
                      ImageRGBAView.prototype._render = function(ctx, indices) {
                        var i, old_smoothing, y_offset, _i, _len;
                        old_smoothing = ctx.getImageSmoothingEnabled();
                        ctx.setImageSmoothingEnabled(false);
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(this.sx[i] + this.sy[i] + this.sw[i] + this.sh[i])) {
                            continue;
                          }
                          y_offset = this.sy[i];
                          ctx.translate(0, y_offset);
                          ctx.scale(1, -1);
                          ctx.translate(0, -y_offset);
                          ctx.drawImage(this.image_data[i], this.sx[i] | 0, this.sy[i] | 0, this.sw[i], this.sh[i]);
                          ctx.translate(0, y_offset);
                          ctx.scale(1, -1);
                          ctx.translate(0, -y_offset);
                        }
                        return ctx.setImageSmoothingEnabled(old_smoothing);
                      };
                
                      return ImageRGBAView;
                
                    })(Glyph.View);
                    ImageRGBA = (function(_super) {
                      __extends(ImageRGBA, _super);
                
                      function ImageRGBA() {
                        _ref1 = ImageRGBA.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ImageRGBA.prototype.default_view = ImageRGBAView;
                
                      ImageRGBA.prototype.type = 'ImageRGBA';
                
                      ImageRGBA.prototype.display_defaults = function() {
                        return _.extend({}, ImageRGBA.__super__.display_defaults.call(this), {
                          level: 'underlay',
                          dilate: false
                        });
                      };
                
                      return ImageRGBA;
                
                    })(Glyph.Model);
                    ImageRGBAs = (function(_super) {
                      __extends(ImageRGBAs, _super);
                
                      function ImageRGBAs() {
                        _ref2 = ImageRGBAs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      ImageRGBAs.prototype.model = ImageRGBA;
                
                      return ImageRGBAs;
                
                    })(Glyph.Collection);
                    return {
                      Model: ImageRGBA,
                      View: ImageRGBAView,
                      Collection: new ImageRGBAs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=image_rgba.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/image_url',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var ImageURL, ImageURLView, ImageURLs, _ref, _ref1, _ref2;
                    ImageURLView = (function(_super) {
                      __extends(ImageURLView, _super);
                
                      function ImageURLView() {
                        _ref = ImageURLView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ImageURLView.prototype._fields = ['url:string', 'x', 'y', 'w', 'h', 'angle'];
                
                      ImageURLView.prototype._properties = [];
                
                      ImageURLView.prototype._set_data = function() {
                        var img;
                        this.image = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.url;
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            img = _ref1[_i];
                            _results.push(null);
                          }
                          return _results;
                        }).call(this);
                        this.need_load = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.url;
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            img = _ref1[_i];
                            _results.push(true);
                          }
                          return _results;
                        }).call(this);
                        return this.loaded = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.url;
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            img = _ref1[_i];
                            _results.push(false);
                          }
                          return _results;
                        }).call(this);
                      };
                
                      ImageURLView.prototype._map_data = function() {
                        var _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        this.sw = this.distance_vector('x', 'w', 'edge', this.mget('dilate'));
                        return this.sh = this.distance_vector('y', 'h', 'edge', this.mget('dilate'));
                      };
                
                      ImageURLView.prototype._render = function(ctx, indices) {
                        var i, img, _i, _len, _results,
                          _this = this;
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(this.sx[i] + this.sy[i] + this.angle[i])) {
                            continue;
                          }
                          if (this.need_load[i]) {
                            img = new Image();
                            img.onload = (function(img, i) {
                              return function() {
                                var frame;
                                _this.loaded[i] = true;
                                _this.image[i] = img;
                                ctx.save();
                                ctx.beginPath();
                                frame = _this.renderer.plot_view.frame;
                                ctx.rect(frame.get('left') + 1, frame.get('bottom') + 1, frame.get('width') - 2, frame.get('height') - 2);
                                ctx.clip();
                                _this._render_image(ctx, i, img);
                                return ctx.restore();
                              };
                            })(img, i);
                            img.src = this.url[i];
                            _results.push(this.need_load[i] = false);
                          } else if (this.loaded[i]) {
                            _results.push(this._render_image(ctx, i, this.image[i]));
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      ImageURLView.prototype._final_sx_sy = function() {
                        var anchor,
                          _this = this;
                        anchor = this.mget('anchor') || "top_left";
                        switch (anchor) {
                          case "top_left":
                            return function(i) {
                              return [_this.sx[i], _this.sy[i]];
                            };
                          case "top_center":
                            return function(i) {
                              return [_this.sx[i] - _this.sw[i] / 2, _this.sy[i]];
                            };
                          case "top_right":
                            return function(i) {
                              return [_this.sx[i] - _this.sw[i], _this.sy[i]];
                            };
                          case "right_center":
                            return function(i) {
                              return [_this.sx[i] - _this.sw[i], _this.sy[i] - _this.sh[i] / 2];
                            };
                          case "bottom_right":
                            return function(i) {
                              return [_this.sx[i] - _this.sw[i], _this.sy[i] - _this.sh[i]];
                            };
                          case "bottom_center":
                            return function(i) {
                              return [_this.sx[i] - _this.sw[i] / 2, _this.sy[i] - _this.sh[i]];
                            };
                          case "bottom_left":
                            return function(i) {
                              return [_this.sx[i], _this.sy[i] - _this.sh[i]];
                            };
                          case "left_center":
                            return function(i) {
                              return [_this.sx[i], _this.sy[i] - _this.sh[i] / 2];
                            };
                          case "center":
                            return function(i) {
                              return [_this.sx[i] - _this.sw[i] / 2, _this.sy[i] - _this.sh[i] / 2];
                            };
                        }
                      };
                
                      ImageURLView.prototype._render_image = function(ctx, i, img) {
                        var sx, sy, _ref1;
                        if (isNaN(this.sw[i])) {
                          this.sw[i] = img.width;
                        }
                        if (isNaN(this.sh[i])) {
                          this.sh[i] = img.height;
                        }
                        _ref1 = this._final_sx_sy()(i), sx = _ref1[0], sy = _ref1[1];
                        if (this.angle[i]) {
                          ctx.translate(sx, sy);
                          ctx.rotate(this.angle[i]);
                          ctx.drawImage(img, 0, 0, this.sw[i], this.sh[i]);
                          ctx.rotate(-this.angle[i]);
                          return ctx.translate(-sx, -sy);
                        } else {
                          return ctx.drawImage(img, sx, sy, this.sw[i], this.sh[i]);
                        }
                      };
                
                      return ImageURLView;
                
                    })(Glyph.View);
                    ImageURL = (function(_super) {
                      __extends(ImageURL, _super);
                
                      function ImageURL() {
                        _ref1 = ImageURL.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ImageURL.prototype.default_view = ImageURLView;
                
                      ImageURL.prototype.type = 'ImageURL';
                
                      ImageURL.prototype.display_defaults = function() {
                        return _.extend({}, ImageURL.__super__.display_defaults.call(this), {
                          level: 'underlay'
                        });
                      };
                
                      return ImageURL;
                
                    })(Glyph.Model);
                    ImageURLs = (function(_super) {
                      __extends(ImageURLs, _super);
                
                      function ImageURLs() {
                        _ref2 = ImageURLs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      ImageURLs.prototype.model = ImageURL;
                
                      return ImageURLs;
                
                    })(Glyph.Collection);
                    return {
                      Model: ImageURL,
                      View: ImageURLView,
                      Collection: new ImageURLs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=image_url.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/line',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var Line, LineView, Lines, _ref, _ref1, _ref2;
                    LineView = (function(_super) {
                      __extends(LineView, _super);
                
                      function LineView() {
                        _ref = LineView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LineView.prototype._fields = ['x', 'y'];
                
                      LineView.prototype._properties = ['line'];
                
                      LineView.prototype._map_data = function() {
                        var _ref1;
                        return _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1], _ref1;
                      };
                
                      LineView.prototype._render = function(ctx, indices) {
                        var drawing, i, _i, _len;
                        drawing = false;
                        this.props.line.set(ctx, this.props);
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(this.sx[i] + this.sy[i]) && drawing) {
                            ctx.stroke();
                            ctx.beginPath();
                            drawing = false;
                            continue;
                          }
                          if (drawing) {
                            ctx.lineTo(this.sx[i], this.sy[i]);
                          } else {
                            ctx.beginPath();
                            ctx.moveTo(this.sx[i], this.sy[i]);
                            drawing = true;
                          }
                        }
                        if (drawing) {
                          return ctx.stroke();
                        }
                      };
                
                      LineView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_line_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return LineView;
                
                    })(Glyph.View);
                    Line = (function(_super) {
                      __extends(Line, _super);
                
                      function Line() {
                        _ref1 = Line.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Line.prototype.default_view = LineView;
                
                      Line.prototype.type = 'Line';
                
                      Line.prototype.display_defaults = function() {
                        return _.extend({}, Line.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return Line;
                
                    })(Glyph.Model);
                    Lines = (function(_super) {
                      __extends(Lines, _super);
                
                      function Lines() {
                        _ref2 = Lines.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Lines.prototype.model = Line;
                
                      return Lines;
                
                    })(Glyph.Collection);
                    return {
                      Model: Line,
                      View: LineView,
                      Collection: new Lines()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=line.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/multi_line',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var MultiLine, MultiLineView, MultiLines, _ref, _ref1, _ref2;
                    MultiLineView = (function(_super) {
                      __extends(MultiLineView, _super);
                
                      function MultiLineView() {
                        _ref = MultiLineView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      MultiLineView.prototype._fields = ['xs', 'ys'];
                
                      MultiLineView.prototype._properties = ['line'];
                
                      MultiLineView.prototype._render = function(ctx, indices) {
                        var i, j, sx, sy, x, y, _i, _j, _len, _ref1, _ref2, _results;
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          x = this.xs[i];
                          y = this.ys[i];
                          _ref1 = this.renderer.map_to_screen(this.xs[i], this.glyph.xs.units, this.ys[i], this.glyph.ys.units), sx = _ref1[0], sy = _ref1[1];
                          this.props.line.set_vectorize(ctx, i);
                          for (j = _j = 0, _ref2 = sx.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
                            if (j === 0) {
                              ctx.beginPath();
                              ctx.moveTo(sx[j], sy[j]);
                              continue;
                            } else if (isNaN(sx[j]) || isNaN(sy[j])) {
                              ctx.stroke();
                              ctx.beginPath();
                              continue;
                            } else {
                              ctx.lineTo(sx[j], sy[j]);
                            }
                          }
                          _results.push(ctx.stroke());
                        }
                        return _results;
                      };
                
                      MultiLineView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_line_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return MultiLineView;
                
                    })(Glyph.View);
                    MultiLine = (function(_super) {
                      __extends(MultiLine, _super);
                
                      function MultiLine() {
                        _ref1 = MultiLine.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      MultiLine.prototype.default_view = MultiLineView;
                
                      MultiLine.prototype.type = 'MultiLine';
                
                      MultiLine.prototype.display_defaults = function() {
                        return _.extend({}, MultiLine.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return MultiLine;
                
                    })(Glyph.Model);
                    MultiLines = (function(_super) {
                      __extends(MultiLines, _super);
                
                      function MultiLines() {
                        _ref2 = MultiLines.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      MultiLines.prototype.model = MultiLine;
                
                      return MultiLines;
                
                    })(Glyph.Collection);
                    return {
                      Model: MultiLine,
                      View: MultiLineView,
                      Collection: new MultiLines()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=multi_line.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/oval',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var Oval, OvalView, Ovals, _ref, _ref1, _ref2;
                    OvalView = (function(_super) {
                      __extends(OvalView, _super);
                
                      function OvalView() {
                        _ref = OvalView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      OvalView.prototype._fields = ['x', 'y', 'width', 'height', 'angle'];
                
                      OvalView.prototype._properties = ['line', 'fill'];
                
                      OvalView.prototype._map_data = function() {
                        var _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        this.sw = this.distance_vector('x', 'width', 'center');
                        return this.sh = this.distance_vector('y', 'height', 'center');
                      };
                
                      OvalView.prototype._render = function(ctx, indices, sx, sy, sw, sh) {
                        var i, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (sw == null) {
                          sw = this.sw;
                        }
                        if (sh == null) {
                          sh = this.sh;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this.angle[i])) {
                            continue;
                          }
                          ctx.translate(sx[i], sy[i]);
                          ctx.rotate(this.angle[i]);
                          ctx.beginPath();
                          ctx.moveTo(0, -sh[i] / 2);
                          ctx.bezierCurveTo(sw[i] / 2, -sh[i] / 2, sw[i] / 2, sh[i] / 2, 0, sh[i] / 2);
                          ctx.bezierCurveTo(-sw[i] / 2, sh[i] / 2, -sw[i] / 2, -sh[i] / 2, 0, -sh[i] / 2);
                          ctx.closePath();
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            ctx.stroke();
                          }
                          ctx.rotate(-this.angle[i]);
                          _results.push(ctx.translate(-sx[i], -sy[i]));
                        }
                        return _results;
                      };
                
                      OvalView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        var d, indices, reference_point, scale, sh, sw, sx, sy, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        indices = [reference_point];
                        sx = {};
                        sx[reference_point] = (x0 + x1) / 2;
                        sy = {};
                        sy[reference_point] = (y0 + y1) / 2;
                        scale = this.sw[reference_point] / this.sh[reference_point];
                        d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;
                        sw = {};
                        sh = {};
                        if (scale > 1) {
                          sw[reference_point] = d;
                          sh[reference_point] = d / scale;
                        } else {
                          sw[reference_point] = d * scale;
                          sh[reference_point] = d;
                        }
                        return this._render(ctx, indices, sx, sy, sw, sh);
                      };
                
                      return OvalView;
                
                    })(Glyph.View);
                    Oval = (function(_super) {
                      __extends(Oval, _super);
                
                      function Oval() {
                        _ref1 = Oval.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Oval.prototype.default_view = OvalView;
                
                      Oval.prototype.type = 'Oval';
                
                      Oval.prototype.display_defaults = function() {
                        return _.extend({}, Oval.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults, {
                          angle: 0.0
                        });
                      };
                
                      return Oval;
                
                    })(Glyph.Model);
                    Ovals = (function(_super) {
                      __extends(Ovals, _super);
                
                      function Ovals() {
                        _ref2 = Ovals.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Ovals.prototype.model = Oval;
                
                      return Ovals;
                
                    })(Glyph.Collection);
                    return {
                      Model: Oval,
                      View: OvalView,
                      Collection: new Ovals()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=oval.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/patch',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var Patch, PatchView, Patches, _ref, _ref1, _ref2;
                    PatchView = (function(_super) {
                      __extends(PatchView, _super);
                
                      function PatchView() {
                        _ref = PatchView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PatchView.prototype._fields = ['x', 'y'];
                
                      PatchView.prototype._properties = ['line', 'fill'];
                
                      PatchView.prototype._map_data = function() {
                        var _ref1;
                        return _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1], _ref1;
                      };
                
                      PatchView.prototype._render = function(ctx, indices) {
                        var i, _i, _j, _len, _len1;
                        if (this.props.fill.do_fill) {
                          this.props.fill.set(ctx, this.props);
                          for (_i = 0, _len = indices.length; _i < _len; _i++) {
                            i = indices[_i];
                            if (i === 0) {
                              ctx.beginPath();
                              ctx.moveTo(this.sx[i], this.sy[i]);
                              continue;
                            } else if (isNaN(this.sx[i] + this.sy[i])) {
                              ctx.closePath();
                              ctx.fill();
                              ctx.beginPath();
                              continue;
                            } else {
                              ctx.lineTo(this.sx[i], this.sy[i]);
                            }
                          }
                          ctx.closePath();
                          ctx.fill();
                        }
                        if (this.props.line.do_stroke) {
                          this.props.line.set(ctx, this.props);
                          for (_j = 0, _len1 = indices.length; _j < _len1; _j++) {
                            i = indices[_j];
                            if (i === 0) {
                              ctx.beginPath();
                              ctx.moveTo(this.sx[i], this.sy[i]);
                              continue;
                            } else if (isNaN(this.sx[i] + this.sy[i])) {
                              ctx.closePath();
                              ctx.stroke();
                              ctx.beginPath();
                              continue;
                            } else {
                              ctx.lineTo(this.sx[i], this.sy[i]);
                            }
                          }
                          ctx.closePath();
                          return ctx.stroke();
                        }
                      };
                
                      PatchView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_area_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return PatchView;
                
                    })(Glyph.View);
                    Patch = (function(_super) {
                      __extends(Patch, _super);
                
                      function Patch() {
                        _ref1 = Patch.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Patch.prototype.default_view = PatchView;
                
                      Patch.prototype.type = 'Patch';
                
                      Patch.prototype.display_defaults = function() {
                        return _.extend({}, Patch.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return Patch;
                
                    })(Glyph.Model);
                    Patches = (function(_super) {
                      __extends(Patches, _super);
                
                      function Patches() {
                        _ref2 = Patches.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Patches.prototype.model = Patch;
                
                      return Patches;
                
                    })(Glyph.Collection);
                    return {
                      Model: Patch,
                      View: PatchView,
                      Collection: new Patches()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=patch.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/patches',["underscore", "rbush", "renderer/properties", "./glyph"], function(_, rbush, Properties, Glyph) {
                    var Patches, PatchesView, Patcheses, point_in_poly, _ref, _ref1, _ref2;
                    point_in_poly = function(x, y, px, py) {
                      var i, inside, x1, x2, y1, y2, _i, _ref;
                      inside = false;
                      x1 = px[px.length - 1];
                      y1 = py[py.length - 1];
                      for (i = _i = 0, _ref = px.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                        x2 = px[i];
                        y2 = py[i];
                        if ((y1 < y) !== (y2 < y)) {
                          if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x) {
                            inside = !inside;
                          }
                        }
                        x1 = x2;
                        y1 = y2;
                      }
                      return inside;
                    };
                    PatchesView = (function(_super) {
                      __extends(PatchesView, _super);
                
                      function PatchesView() {
                        _ref = PatchesView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PatchesView.prototype._fields = ['xs', 'ys'];
                
                      PatchesView.prototype._properties = ['line', 'fill'];
                
                      PatchesView.prototype._set_data = function() {
                        var i, pts, x, xs, y, ys, _i, _ref1;
                        this.max_size = _.max(this.size);
                        this.index = rbush();
                        pts = [];
                        for (i = _i = 0, _ref1 = this.xs.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          xs = (function() {
                            var _j, _len, _ref2, _results;
                            _ref2 = this.xs[i];
                            _results = [];
                            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
                              x = _ref2[_j];
                              if (!_.isNaN(x)) {
                                _results.push(x);
                              }
                            }
                            return _results;
                          }).call(this);
                          ys = (function() {
                            var _j, _len, _ref2, _results;
                            _ref2 = this.ys[i];
                            _results = [];
                            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
                              y = _ref2[_j];
                              if (!_.isNaN(y)) {
                                _results.push(y);
                              }
                            }
                            return _results;
                          }).call(this);
                          if (xs.length === 0) {
                            continue;
                          }
                          pts.push([
                            _.min(xs), _.min(ys), _.max(xs), _.max(ys), {
                              'i': i
                            }
                          ]);
                        }
                        return this.index.load(pts);
                      };
                
                      PatchesView.prototype._map_data = function() {
                        var i, sx, sy, _i, _ref1, _ref2, _results;
                        this.sxs = [];
                        this.sys = [];
                        _results = [];
                        for (i = _i = 0, _ref1 = this.xs.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          _ref2 = this.renderer.map_to_screen(this.xs[i], this.glyph.xs.units, this.ys[i], this.glyph.ys.units), sx = _ref2[0], sy = _ref2[1];
                          this.sxs.push(sx);
                          _results.push(this.sys.push(sy));
                        }
                        return _results;
                      };
                
                      PatchesView.prototype._mask_data = function() {
                        var x, x0, x1, xr, y0, y1, yr, _ref1, _ref2;
                        if (this.glyph.xs.units === "screen" || this.glyph.ys.units === "screen") {
                          return this.all_indices;
                        }
                        xr = this.renderer.plot_view.x_range;
                        _ref1 = [xr.get('start'), xr.get('end')], x0 = _ref1[0], x1 = _ref1[1];
                        yr = this.renderer.plot_view.y_range;
                        _ref2 = [yr.get('start'), yr.get('end')], y0 = _ref2[0], y1 = _ref2[1];
                        return (function() {
                          var _i, _len, _ref3, _results;
                          _ref3 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                            x = _ref3[_i];
                            _results.push(x[4].i);
                          }
                          return _results;
                        }).call(this);
                      };
                
                      PatchesView.prototype._render = function(ctx, indices) {
                        var i, j, sx, sy, _i, _j, _k, _len, _ref1, _ref2, _ref3, _results;
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          _ref1 = [this.sxs[i], this.sys[i]], sx = _ref1[0], sy = _ref1[1];
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            for (j = _j = 0, _ref2 = sx.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
                              if (j === 0) {
                                ctx.beginPath();
                                ctx.moveTo(sx[j], sy[j]);
                                continue;
                              } else if (isNaN(sx[j] + sy[j])) {
                                ctx.closePath();
                                ctx.fill();
                                ctx.beginPath();
                                continue;
                              } else {
                                ctx.lineTo(sx[j], sy[j]);
                              }
                            }
                            ctx.closePath();
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            for (j = _k = 0, _ref3 = sx.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; j = 0 <= _ref3 ? ++_k : --_k) {
                              if (j === 0) {
                                ctx.beginPath();
                                ctx.moveTo(sx[j], sy[j]);
                                continue;
                              } else if (isNaN(sx[j] + sy[j])) {
                                ctx.closePath();
                                ctx.stroke();
                                ctx.beginPath();
                                continue;
                              } else {
                                ctx.lineTo(sx[j], sy[j]);
                              }
                            }
                            ctx.closePath();
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      PatchesView.prototype._hit_point = function(geometry) {
                        var candidates, hits, i, idx, sx, sy, vx, vy, x, y, _i, _ref1, _ref2;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                        x = this.renderer.xmapper.map_from_target(vx);
                        y = this.renderer.ymapper.map_from_target(vy);
                        candidates = (function() {
                          var _i, _len, _ref2, _results;
                          _ref2 = this.index.search([x, y, x, y]);
                          _results = [];
                          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                            x = _ref2[_i];
                            _results.push(x[4].i);
                          }
                          return _results;
                        }).call(this);
                        hits = [];
                        for (i = _i = 0, _ref2 = candidates.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                          idx = candidates[i];
                          if (point_in_poly(sx, sy, this.sxs[idx], this.sys[idx])) {
                            hits.push(idx);
                          }
                        }
                        return hits;
                      };
                
                      PatchesView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_area_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return PatchesView;
                
                    })(Glyph.View);
                    Patches = (function(_super) {
                      __extends(Patches, _super);
                
                      function Patches() {
                        _ref1 = Patches.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Patches.prototype.default_view = PatchesView;
                
                      Patches.prototype.type = 'Patches';
                
                      Patches.prototype.display_defaults = function() {
                        return _.extend({}, Patches.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return Patches;
                
                    })(Glyph.Model);
                    Patcheses = (function(_super) {
                      __extends(Patcheses, _super);
                
                      function Patcheses() {
                        _ref2 = Patcheses.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Patcheses.prototype.model = Patches;
                
                      return Patcheses;
                
                    })(Glyph.Collection);
                    return {
                      Model: Patches,
                      View: PatchesView,
                      Collection: new Patcheses()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=patches.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/quad',["underscore", "rbush", "renderer/properties", "./glyph"], function(_, rbush, Properties, Glyph) {
                    var Quad, QuadView, Quads, _ref, _ref1, _ref2;
                    QuadView = (function(_super) {
                      __extends(QuadView, _super);
                
                      function QuadView() {
                        _ref = QuadView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      QuadView.prototype._fields = ['right', 'left', 'bottom', 'top'];
                
                      QuadView.prototype._properties = ['line', 'fill'];
                
                      QuadView.prototype._map_data = function() {
                        var _ref1, _ref2;
                        _ref1 = this.renderer.map_to_screen(this.left, this.glyph.left.units, this.top, this.glyph.top.units), this.sx0 = _ref1[0], this.sy0 = _ref1[1];
                        return _ref2 = this.renderer.map_to_screen(this.right, this.glyph.right.units, this.bottom, this.glyph.bottom.units), this.sx1 = _ref2[0], this.sy1 = _ref2[1], _ref2;
                      };
                
                      QuadView.prototype._render = function(ctx, indices, sx0, sx1, sy0, sy1) {
                        var i, _i, _len, _results;
                        if (sx0 == null) {
                          sx0 = this.sx0;
                        }
                        if (sx1 == null) {
                          sx1 = this.sx1;
                        }
                        if (sy0 == null) {
                          sy0 = this.sy0;
                        }
                        if (sy1 == null) {
                          sy1 = this.sy1;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i])) {
                            continue;
                          }
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fillRect(sx0[i], sy0[i], sx1[i] - sx0[i], sy1[i] - sy0[i]);
                          }
                          if (this.props.line.do_stroke) {
                            ctx.beginPath();
                            ctx.rect(sx0[i], sy0[i], sx1[i] - sx0[i], sy1[i] - sy0[i]);
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      QuadView.prototype._hit_point = function(geometry) {
                        var hits, i, sx, sy, vx, vy, _i, _ref1, _ref2;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                        hits = [];
                        for (i = _i = 0, _ref2 = this.sx0.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                          if (sx >= this.sx0[i] && sx <= this.sx1[i] && sy >= this.sy0[i] && sy < this.sy1[i]) {
                            hits.push(i);
                          }
                        }
                        return hits;
                      };
                
                      QuadView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_area_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return QuadView;
                
                    })(Glyph.View);
                    Quad = (function(_super) {
                      __extends(Quad, _super);
                
                      function Quad() {
                        _ref1 = Quad.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Quad.prototype.default_view = QuadView;
                
                      Quad.prototype.type = 'Quad';
                
                      Quad.prototype.display_defaults = function() {
                        return _.extend({}, Quad.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return Quad;
                
                    })(Glyph.Model);
                    Quads = (function(_super) {
                      __extends(Quads, _super);
                
                      function Quads() {
                        _ref2 = Quads.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Quads.prototype.model = Quad;
                
                      return Quads;
                
                    })(Glyph.Collection);
                    return {
                      Model: Quad,
                      View: QuadView,
                      Collection: new Quads()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=quad.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/quadratic',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var Quadratic, QuadraticView, Quadratics, _ref, _ref1, _ref2;
                    QuadraticView = (function(_super) {
                      __extends(QuadraticView, _super);
                
                      function QuadraticView() {
                        _ref = QuadraticView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      QuadraticView.prototype._fields = ['x0', 'y0', 'x1', 'y1', 'cx', 'cy'];
                
                      QuadraticView.prototype._properties = ['line'];
                
                      QuadraticView.prototype._map_data = function() {
                        var _ref1, _ref2, _ref3;
                        _ref1 = this.renderer.map_to_screen(this.x0, this.glyph.x0.units, this.y0, this.glyph.y0.units), this.sx0 = _ref1[0], this.sy0 = _ref1[1];
                        _ref2 = this.renderer.map_to_screen(this.x1, this.glyph.x1.units, this.y1, this.glyph.y1.units), this.sx1 = _ref2[0], this.sy1 = _ref2[1];
                        return _ref3 = this.renderer.map_to_screen(this.cx, this.glyph.cx.units, this.cy, this.glyph.cy.units), this.scx = _ref3[0], this.scy = _ref3[1], _ref3;
                      };
                
                      QuadraticView.prototype._render = function(ctx, indices) {
                        var i, _i, _len, _results;
                        if (this.props.line.do_stroke) {
                          _results = [];
                          for (_i = 0, _len = indices.length; _i < _len; _i++) {
                            i = indices[_i];
                            if (isNaN(this.sx0[i] + this.sy0[i] + this.sx1[i] + this.sy1[i] + this.scx[i] + this.scy[i])) {
                              continue;
                            }
                            ctx.beginPath();
                            ctx.moveTo(this.sx0[i], this.sy0[i]);
                            ctx.quadraticCurveTo(this.scx[i], this.scy[i], this.sx1[i], this.sy1[i]);
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          }
                          return _results;
                        }
                      };
                
                      QuadraticView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_line_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return QuadraticView;
                
                    })(Glyph.View);
                    Quadratic = (function(_super) {
                      __extends(Quadratic, _super);
                
                      function Quadratic() {
                        _ref1 = Quadratic.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Quadratic.prototype.default_view = QuadraticView;
                
                      Quadratic.prototype.type = 'Quadratic';
                
                      Quadratic.prototype.display_defaults = function() {
                        return _.extend({}, Quadratic.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return Quadratic;
                
                    })(Glyph.Model);
                    Quadratics = (function(_super) {
                      __extends(Quadratics, _super);
                
                      function Quadratics() {
                        _ref2 = Quadratics.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Quadratics.prototype.model = Quadratic;
                
                      return Quadratics;
                
                    })(Glyph.Collection);
                    return {
                      Model: Quadratic,
                      View: QuadraticView,
                      Collection: new Quadratics()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=quadratic.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/ray',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var Ray, RayView, Rays, _ref, _ref1, _ref2;
                    RayView = (function(_super) {
                      __extends(RayView, _super);
                
                      function RayView() {
                        _ref = RayView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      RayView.prototype._fields = ['x', 'y', 'angle', 'length'];
                
                      RayView.prototype._properties = ['line'];
                
                      RayView.prototype._map_data = function() {
                        var height, i, inf_len, width, _i, _ref1, _ref2, _results;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        this.length = this.distance_vector('x', 'length', 'edge');
                        width = this.renderer.plot_view.frame.get('width');
                        height = this.renderer.plot_view.frame.get('height');
                        inf_len = 2 * (width + height);
                        _results = [];
                        for (i = _i = 0, _ref2 = this.length.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                          if (this.length[i] === 0) {
                            _results.push(this.length[i] = inf_len);
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      RayView.prototype._render = function(ctx, indices) {
                        var i, _i, _len, _results;
                        if (this.props.line.do_stroke) {
                          _results = [];
                          for (_i = 0, _len = indices.length; _i < _len; _i++) {
                            i = indices[_i];
                            if (isNaN(this.sx[i] + this.sy[i] + this.angle[i] + this.length[i])) {
                              continue;
                            }
                            ctx.translate(this.sx[i], this.sy[i]);
                            ctx.rotate(this.angle[i]);
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(this.length[i], 0);
                            this.props.line.set_vectorize(ctx, i);
                            ctx.stroke();
                            ctx.rotate(-this.angle[i]);
                            _results.push(ctx.translate(-this.sx[i], -this.sy[i]));
                          }
                          return _results;
                        }
                      };
                
                      RayView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_line_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return RayView;
                
                    })(Glyph.View);
                    Ray = (function(_super) {
                      __extends(Ray, _super);
                
                      function Ray() {
                        _ref1 = Ray.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Ray.prototype.default_view = RayView;
                
                      Ray.prototype.type = 'Ray';
                
                      Ray.prototype.display_defaults = function() {
                        return _.extend({}, Ray.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return Ray;
                
                    })(Glyph.Model);
                    Rays = (function(_super) {
                      __extends(Rays, _super);
                
                      function Rays() {
                        _ref2 = Rays.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Rays.prototype.model = Ray;
                
                      return Rays;
                
                    })(Glyph.Collection);
                    return {
                      Model: Ray,
                      View: RayView,
                      Collection: new Rays()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=ray.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/rect',["underscore", "rbush", "renderer/properties", "./glyph"], function(_, rbush, Properties, Glyph) {
                    var Rect, RectView, Rects, _ref, _ref1, _ref2;
                    RectView = (function(_super) {
                      __extends(RectView, _super);
                
                      function RectView() {
                        _ref = RectView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      RectView.prototype._fields = ['x', 'y', 'width', 'height', 'angle'];
                
                      RectView.prototype._properties = ['line', 'fill'];
                
                      RectView.prototype._map_data = function() {
                        var i, sxi, syi, _i, _ref1, _ref2;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), sxi = _ref1[0], syi = _ref1[1];
                        this.sw = this.distance_vector('x', 'width', 'center', this.mget('dilate'));
                        this.sh = this.distance_vector('y', 'height', 'center', this.mget('dilate'));
                        this.sx = new Array(sxi.length);
                        this.sy = new Array(sxi.length);
                        for (i = _i = 0, _ref2 = sxi.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                          if (Math.abs(sxi[i] - this.sw[i]) < 2) {
                            this.sx[i] = Math.round(sxi[i]);
                          } else {
                            this.sx[i] = sxi[i];
                          }
                          if (Math.abs(syi[i] - this.sh[i]) < 2) {
                            this.sy[i] = Math.round(syi[i]);
                          } else {
                            this.sy[i] = syi[i];
                          }
                        }
                        this.max_width = _.max(this.width);
                        return this.max_height = _.max(this.height);
                      };
                
                      RectView.prototype._set_data = function() {
                        var i, pts, _i, _ref1;
                        this.index = rbush();
                        pts = [];
                        for (i = _i = 0, _ref1 = this.x.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (!isNaN(this.x[i] + this.y[i])) {
                            pts.push([
                              this.x[i], this.y[i], this.x[i], this.y[i], {
                                'i': i
                              }
                            ]);
                          }
                        }
                        return this.index.load(pts);
                      };
                
                      RectView.prototype._render = function(ctx, indices, sx, sy, sw, sh) {
                        var i, _i, _j, _len, _len1;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (sw == null) {
                          sw = this.sw;
                        }
                        if (sh == null) {
                          sh = this.sh;
                        }
                        if (this.props.fill.do_fill) {
                          for (_i = 0, _len = indices.length; _i < _len; _i++) {
                            i = indices[_i];
                            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this.angle[i])) {
                              continue;
                            }
                            this.props.fill.set_vectorize(ctx, i);
                            if (this.angle[i]) {
                              ctx.translate(sx[i], sy[i]);
                              ctx.rotate(this.angle[i]);
                              ctx.fillRect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);
                              ctx.rotate(-this.angle[i]);
                              ctx.translate(-sx[i], -sy[i]);
                            } else {
                              ctx.fillRect(sx[i] - sw[i] / 2, sy[i] - sh[i] / 2, sw[i], sh[i]);
                            }
                          }
                        }
                        if (this.props.line.do_stroke) {
                          ctx.beginPath();
                          for (_j = 0, _len1 = indices.length; _j < _len1; _j++) {
                            i = indices[_j];
                            if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + this.angle[i])) {
                              continue;
                            }
                            if (sw[i] === 0 || sh[i] === 0) {
                              continue;
                            }
                            if (this.angle[i]) {
                              ctx.translate(sx[i], sy[i]);
                              ctx.rotate(this.angle[i]);
                              ctx.rect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);
                              ctx.rotate(-this.angle[i]);
                              ctx.translate(-sx[i], -sy[i]);
                            } else {
                              ctx.rect(sx[i] - sw[i] / 2, sy[i] - sh[i] / 2, sw[i], sh[i]);
                            }
                            this.props.line.set_vectorize(ctx, i);
                            ctx.stroke();
                            ctx.beginPath();
                          }
                          return ctx.stroke();
                        }
                      };
                
                      RectView.prototype._hit_rect = function(geometry) {
                        var x, x0, x1, y0, y1, _ref1, _ref2;
                        _ref1 = this.renderer.xmapper.v_map_from_target([geometry.vx0, geometry.vx1]), x0 = _ref1[0], x1 = _ref1[1];
                        _ref2 = this.renderer.ymapper.v_map_from_target([geometry.vy0, geometry.vy1]), y0 = _ref2[0], y1 = _ref2[1];
                        return (function() {
                          var _i, _len, _ref3, _results;
                          _ref3 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                            x = _ref3[_i];
                            _results.push(x[4].i);
                          }
                          return _results;
                        }).call(this);
                      };
                
                      RectView.prototype._hit_point = function(geometry) {
                        var c, candidates, d, height_in, hits, i, max_height, max_width, pt, px, py, s, sx, sy, vx, vx0, vx1, vy, vy0, vy1, width_in, x, x0, x1, xcat, y, y0, y1, ycat, _i, _len, _ref1, _ref2, _ref3;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        x = this.renderer.xmapper.map_from_target(vx);
                        y = this.renderer.ymapper.map_from_target(vy);
                        xcat = typeof x === "string";
                        ycat = typeof y === "string";
                        if (xcat || ycat) {
                          candidates = (function() {
                            var _i, _ref2, _results;
                            _results = [];
                            for (i = _i = 0, _ref2 = this.x.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                              _results.push(i);
                            }
                            return _results;
                          }).call(this);
                        } else {
                          if (this.width_units === "screen" || xcat) {
                            max_width = this.max_width;
                            if (xcat) {
                              max_width = this.renderer.xmapper.map_to_target(max_width);
                            }
                            vx0 = vx - 2 * max_width;
                            vx1 = vx + 2 * max_width;
                            _ref2 = this.renderer.xmapper.v_map_from_target([vx0, vx1]), x0 = _ref2[0], x1 = _ref2[1];
                          } else {
                            x0 = x - 2 * this.max_width;
                            x1 = x + 2 * this.max_width;
                          }
                          if (this.height_units === "screen" || ycat) {
                            max_height = this.max_height;
                            if (ycat) {
                              max_height = this.renderer.ymapper.map_to_target(max_height);
                            }
                            vy0 = vy - 2 * max_height;
                            vy1 = vy + 2 * max_height;
                            _ref3 = this.renderer.ymapper.v_map_from_target([vy0, vy1]), y0 = _ref3[0], y1 = _ref3[1];
                          } else {
                            y0 = y - 2 * this.max_height;
                            y1 = y + 2 * this.max_height;
                          }
                          candidates = (function() {
                            var _i, _len, _ref4, _results;
                            _ref4 = this.index.search([x0, y0, x1, y1]);
                            _results = [];
                            for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                              pt = _ref4[_i];
                              _results.push(pt[4].i);
                            }
                            return _results;
                          }).call(this);
                        }
                        hits = [];
                        for (_i = 0, _len = candidates.length; _i < _len; _i++) {
                          i = candidates[_i];
                          if (this.width_units === "screen" || xcat) {
                            sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          } else {
                            sx = this.renderer.plot_view.canvas.vx_to_sx(this.renderer.xmapper.map_to_target(x));
                          }
                          if (this.height_units === "screen" || ycat) {
                            sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          } else {
                            sy = this.renderer.plot_view.canvas.vy_to_sy(this.renderer.ymapper.map_to_target(y));
                          }
                          if (this.angle[i]) {
                            d = Math.sqrt(Math.pow(sx - this.sx[i], 2) + Math.pow(sy - this.sy[i], 2));
                            s = Math.sin(-this.angle[i]);
                            c = Math.cos(-this.angle[i]);
                            px = c * (sx - this.sx[i]) - s * (sy - this.sy[i]) + this.sx[i];
                            py = s * (sx - this.sx[i]) + c * (sy - this.sy[i]) + this.sy[i];
                            sx = px;
                            sy = py;
                          }
                          width_in = Math.abs(this.sx[i] - sx) <= this.sw[i] / 2;
                          height_in = Math.abs(this.sy[i] - sy) <= this.sh[i] / 2;
                          if (height_in && width_in) {
                            hits.push(i);
                          }
                        }
                        return hits;
                      };
                
                      RectView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_area_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return RectView;
                
                    })(Glyph.View);
                    Rect = (function(_super) {
                      __extends(Rect, _super);
                
                      function Rect() {
                        _ref1 = Rect.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Rect.prototype.default_view = RectView;
                
                      Rect.prototype.type = 'Rect';
                
                      Rect.prototype.display_defaults = function() {
                        return _.extend({}, Rect.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults, {
                          angle: 0.0,
                          dilate: false
                        });
                      };
                
                      return Rect;
                
                    })(Glyph.Model);
                    Rects = (function(_super) {
                      __extends(Rects, _super);
                
                      function Rects() {
                        _ref2 = Rects.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Rects.prototype.model = Rect;
                
                      return Rects;
                
                    })(Glyph.Collection);
                    return {
                      Model: Rect,
                      View: RectView,
                      Collection: new Rects()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=rect.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/segment',["underscore", "renderer/properties", "./glyph"], function(_, Properties, Glyph) {
                    var Segment, SegmentView, Segments, _ref, _ref1, _ref2;
                    SegmentView = (function(_super) {
                      __extends(SegmentView, _super);
                
                      function SegmentView() {
                        _ref = SegmentView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SegmentView.prototype._fields = ['x0', 'y0', 'x1', 'y1'];
                
                      SegmentView.prototype._properties = ['line'];
                
                      SegmentView.prototype._map_data = function() {
                        var _ref1, _ref2;
                        _ref1 = this.renderer.map_to_screen(this.x0, this.glyph.x0.units, this.y0, this.glyph.y0.units), this.sx0 = _ref1[0], this.sy0 = _ref1[1];
                        return _ref2 = this.renderer.map_to_screen(this.x1, this.glyph.x1.units, this.y1, this.glyph.y1.units), this.sx1 = _ref2[0], this.sy1 = _ref2[1], _ref2;
                      };
                
                      SegmentView.prototype._render = function(ctx, indices) {
                        var i, _i, _len, _results;
                        if (this.props.line.do_stroke) {
                          _results = [];
                          for (_i = 0, _len = indices.length; _i < _len; _i++) {
                            i = indices[_i];
                            if (isNaN(this.sx0[i] + this.sy0[i] + this.sx1[i] + this.sy1[i])) {
                              continue;
                            }
                            ctx.beginPath();
                            ctx.moveTo(this.sx0[i], this.sy0[i]);
                            ctx.lineTo(this.sx1[i], this.sy1[i]);
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          }
                          return _results;
                        }
                      };
                
                      SegmentView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        return this._generic_line_legend(ctx, x0, x1, y0, y1);
                      };
                
                      return SegmentView;
                
                    })(Glyph.View);
                    Segment = (function(_super) {
                      __extends(Segment, _super);
                
                      function Segment() {
                        _ref1 = Segment.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Segment.prototype.default_view = SegmentView;
                
                      Segment.prototype.type = 'Segment';
                
                      Segment.prototype.display_defaults = function() {
                        return _.extend({}, Segment.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return Segment;
                
                    })(Glyph.Model);
                    Segments = (function(_super) {
                      __extends(Segments, _super);
                
                      function Segments() {
                        _ref2 = Segments.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Segments.prototype.model = Segment;
                
                      return Segments;
                
                    })(Glyph.Collection);
                    return {
                      Model: Segment,
                      View: SegmentView,
                      Collection: new Segments()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=segment.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/text',["underscore", "./glyph"], function(_, Glyph) {
                    var Text, TextView, Texts, _ref, _ref1, _ref2;
                    TextView = (function(_super) {
                      __extends(TextView, _super);
                
                      function TextView() {
                        _ref = TextView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      TextView.prototype._fields = ['x', 'y', 'angle', 'text:string'];
                
                      TextView.prototype._properties = ['text'];
                
                      TextView.prototype._map_data = function() {
                        var _ref1;
                        return _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1], _ref1;
                      };
                
                      TextView.prototype._render = function(ctx, indices) {
                        var i, _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(this.sx[i] + this.sy[i] + this.angle[i])) {
                            continue;
                          }
                          ctx.translate(this.sx[i], this.sy[i]);
                          ctx.rotate(this.angle[i]);
                          this.props.text.set_vectorize(ctx, i);
                          ctx.fillText(this.text[i], 0, 0);
                          ctx.rotate(-this.angle[i]);
                          _results.push(ctx.translate(-this.sx[i], -this.sy[i]));
                        }
                        return _results;
                      };
                
                      TextView.prototype.draw_legend = function(ctx, x1, x2, y1, y2) {
                        var glyph_settings, reference_point, text_props;
                        ctx.save();
                        reference_point = this.get_reference_point();
                        if (reference_point != null) {
                          glyph_settings = reference_point;
                        } else {
                          glyph_settings = this.props;
                        }
                        text_props = this.props.text;
                        text_props.set(ctx, glyph_settings);
                        ctx.font = text_props.font(12);
                        ctx.textAlign = "right";
                        ctx.textBaseline = "middle";
                        ctx.fillText("txt", x2, (y1 + y2) / 2);
                        return ctx.restore();
                      };
                
                      return TextView;
                
                    })(Glyph.View);
                    Text = (function(_super) {
                      __extends(Text, _super);
                
                      function Text() {
                        _ref1 = Text.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Text.prototype.default_view = TextView;
                
                      Text.prototype.type = 'Text';
                
                      Text.prototype.display_defaults = function() {
                        return _.extend({}, Text.__super__.display_defaults.call(this), {
                          text_font: "helvetica",
                          text_font_size: "12pt",
                          text_font_style: "normal",
                          text_color: "#444444",
                          text_alpha: 1.0,
                          text_align: "left",
                          text_baseline: "bottom"
                        });
                      };
                
                      return Text;
                
                    })(Glyph.Model);
                    Texts = (function(_super) {
                      __extends(Texts, _super);
                
                      function Texts() {
                        _ref2 = Texts.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Texts.prototype.model = Text;
                
                      return Texts;
                
                    })(Glyph.Collection);
                    return {
                      Model: Text,
                      View: TextView,
                      Collection: new Texts()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=text.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/wedge',["underscore", "rbush", "common/mathutils", "renderer/properties", "./glyph"], function(_, rbush, mathutils, Properties, Glyph) {
                    var Wedge, WedgeView, Wedges, _ref, _ref1, _ref2;
                    WedgeView = (function(_super) {
                      __extends(WedgeView, _super);
                
                      function WedgeView() {
                        _ref = WedgeView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      WedgeView.prototype._fields = ['x', 'y', 'radius', 'start_angle', 'end_angle', 'direction:string'];
                
                      WedgeView.prototype._properties = ['line', 'fill'];
                
                      WedgeView.prototype._set_data = function() {
                        var i, pts, _i, _ref1;
                        this.max_radius = _.max(this.radius);
                        this.index = rbush();
                        pts = [];
                        for (i = _i = 0, _ref1 = this.x.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (!isNaN(this.x[i] + this.y[i])) {
                            pts.push([
                              this.x[i], this.y[i], this.x[i], this.y[i], {
                                'i': i
                              }
                            ]);
                          }
                        }
                        return this.index.load(pts);
                      };
                
                      WedgeView.prototype._map_data = function() {
                        var _ref1;
                        _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1];
                        return this.radius = this.distance_vector('x', 'radius', 'edge');
                      };
                
                      WedgeView.prototype._render = function(ctx, indices, sx, sy, radius) {
                        var i, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (radius == null) {
                          radius = this.radius;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + radius[i] + this.start_angle[i] + this.end_angle[i] + this.direction[i])) {
                            continue;
                          }
                          ctx.beginPath();
                          ctx.arc(sx[i], sy[i], radius[i], this.start_angle[i], this.end_angle[i], this.direction[i]);
                          ctx.lineTo(sx[i], sy[i]);
                          ctx.closePath();
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      WedgeView.prototype._hit_point = function(geometry) {
                        var angle, candidates, candidates2, dist, hits, i, pt, r2, sx, sx0, sx1, sy, sy0, sy1, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y, y0, y1, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        x = this.renderer.xmapper.map_from_target(vx);
                        y = this.renderer.ymapper.map_from_target(vy);
                        if (this.radius_units === "screen") {
                          vx0 = vx - this.max_radius;
                          vx1 = vx + this.max_radius;
                          _ref2 = this.renderer.xmapper.v_map_from_target([vx0, vx1]), x0 = _ref2[0], x1 = _ref2[1];
                          vy0 = vy - this.max_radius;
                          vy1 = vy + this.max_radius;
                          _ref3 = this.renderer.ymapper.v_map_from_target([vy0, vy1]), y0 = _ref3[0], y1 = _ref3[1];
                        } else {
                          x0 = x - this.max_radius;
                          x1 = x + this.max_radius;
                          y0 = y - this.max_radius;
                          y1 = y + this.max_radius;
                        }
                        candidates = (function() {
                          var _i, _len, _ref4, _results;
                          _ref4 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                            pt = _ref4[_i];
                            _results.push(pt[4].i);
                          }
                          return _results;
                        }).call(this);
                        candidates2 = [];
                        if (this.radius_units === "screen") {
                          sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          for (_i = 0, _len = candidates.length; _i < _len; _i++) {
                            i = candidates[_i];
                            r2 = Math.pow(this.radius[i], 2);
                            dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);
                            if (dist <= r2) {
                              candidates2.push([i, dist]);
                            }
                          }
                        } else {
                          for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
                            i = candidates[_j];
                            r2 = Math.pow(this.radius[i], 2);
                            sx0 = this.renderer.xmapper.map_to_target(x);
                            sx1 = this.renderer.xmapper.map_to_target(this.x[i]);
                            sy0 = this.renderer.ymapper.map_to_target(y);
                            sy1 = this.renderer.ymapper.map_to_target(this.y[i]);
                            dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);
                            if (dist <= r2) {
                              candidates2.push([i, dist]);
                            }
                          }
                        }
                        hits = [];
                        for (_k = 0, _len2 = candidates2.length; _k < _len2; _k++) {
                          _ref4 = candidates2[_k], i = _ref4[0], dist = _ref4[1];
                          sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                          sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                          angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);
                          if (mathutils.angle_between(-angle, -this.start_angle[i], -this.end_angle[i], this.direction[i])) {
                            hits.push([i, dist]);
                          }
                        }
                        hits = _.chain(hits).sortBy(function(elt) {
                          return elt[1];
                        }).map(function(elt) {
                          return elt[0];
                        }).value();
                        return hits;
                      };
                
                      WedgeView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        var indices, radius, reference_point, sx, sy, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        indices = [reference_point];
                        sx = {};
                        sx[reference_point] = (x0 + x1) / 2;
                        sy = {};
                        sy[reference_point] = (y0 + y1) / 2;
                        radius = {};
                        radius[reference_point] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;
                        return this._render(ctx, indices, sx, sy, radius);
                      };
                
                      return WedgeView;
                
                    })(Glyph.View);
                    Wedge = (function(_super) {
                      __extends(Wedge, _super);
                
                      function Wedge() {
                        _ref1 = Wedge.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Wedge.prototype.default_view = WedgeView;
                
                      Wedge.prototype.type = 'Wedge';
                
                      Wedge.prototype.display_defaults = function() {
                        return _.extend({}, Wedge.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults, {
                          direction: 'anticlock'
                        });
                      };
                
                      return Wedge;
                
                    })(Glyph.Model);
                    Wedges = (function(_super) {
                      __extends(Wedges, _super);
                
                      function Wedges() {
                        _ref2 = Wedges.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Wedges.prototype.model = Wedge;
                
                      return Wedges;
                
                    })(Glyph.Collection);
                    return {
                      Model: Wedge,
                      View: WedgeView,
                      Collection: new Wedges()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=wedge.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/marker',["underscore", "rbush", "../glyph"], function(_, rbush, Glyph) {
                    var Marker, MarkerView, Markers, point_in_poly, _ref, _ref1, _ref2;
                    point_in_poly = function(x, y, px, py) {
                      var i, inside, x1, x2, y1, y2, _i, _ref;
                      inside = false;
                      x1 = px[px.length - 1];
                      y1 = py[py.length - 1];
                      for (i = _i = 0, _ref = px.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                        x2 = px[i];
                        y2 = py[i];
                        if ((y1 < y) !== (y2 < y)) {
                          if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x) {
                            inside = !inside;
                          }
                        }
                        x1 = x2;
                        y1 = y2;
                      }
                      return inside;
                    };
                    MarkerView = (function(_super) {
                      __extends(MarkerView, _super);
                
                      function MarkerView() {
                        _ref = MarkerView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      MarkerView.prototype._fields = ['x', 'y', 'size'];
                
                      MarkerView.prototype.draw_legend = function(ctx, x0, x1, y0, y1) {
                        var indices, reference_point, size, sx, sy, _ref1;
                        reference_point = (_ref1 = this.get_reference_point()) != null ? _ref1 : 0;
                        indices = [reference_point];
                        sx = {};
                        sx[reference_point] = (x0 + x1) / 2;
                        sy = {};
                        sy[reference_point] = (y0 + y1) / 2;
                        size = {};
                        size[reference_point] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;
                        return this._render(ctx, indices, this.props, sx, sy, size);
                      };
                
                      MarkerView.prototype._set_data = function() {
                        var i, pts, _i, _ref1;
                        this.max_size = _.max(this.size);
                        this.index = rbush();
                        pts = [];
                        for (i = _i = 0, _ref1 = this.x.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          if (!isNaN(this.x[i] + this.y[i])) {
                            pts.push([
                              this.x[i], this.y[i], this.x[i], this.y[i], {
                                'i': i
                              }
                            ]);
                          }
                        }
                        return this.index.load(pts);
                      };
                
                      MarkerView.prototype._map_data = function() {
                        var _ref1;
                        return _ref1 = this.renderer.map_to_screen(this.x, this.glyph.x.units, this.y, this.glyph.y.units), this.sx = _ref1[0], this.sy = _ref1[1], _ref1;
                      };
                
                      MarkerView.prototype._mask_data = function() {
                        var hr, vr, vx0, vx1, vy0, vy1, x, x0, x1, y0, y1, _ref1, _ref2;
                        hr = this.renderer.plot_view.frame.get('h_range');
                        vx0 = hr.get('start') - this.max_size;
                        vx1 = hr.get('end') + this.max_size;
                        _ref1 = this.renderer.xmapper.v_map_from_target([vx0, vx1]), x0 = _ref1[0], x1 = _ref1[1];
                        vr = this.renderer.plot_view.frame.get('v_range');
                        vy0 = vr.get('start') - this.max_size;
                        vy1 = vr.get('end') + this.max_size;
                        _ref2 = this.renderer.ymapper.v_map_from_target([vy0, vy1]), y0 = _ref2[0], y1 = _ref2[1];
                        return (function() {
                          var _i, _len, _ref3, _results;
                          _ref3 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                            x = _ref3[_i];
                            _results.push(x[4].i);
                          }
                          return _results;
                        }).call(this);
                      };
                
                      MarkerView.prototype._hit_point = function(geometry) {
                        var candidates, dist, hits, i, s2, sx, sy, vx, vx0, vx1, vy, vy0, vy1, x, x0, x1, y0, y1, _i, _len, _ref1, _ref2, _ref3;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        sx = this.renderer.plot_view.canvas.vx_to_sx(vx);
                        sy = this.renderer.plot_view.canvas.vy_to_sy(vy);
                        vx0 = vx - this.max_size;
                        vx1 = vx + this.max_size;
                        _ref2 = this.renderer.xmapper.v_map_from_target([vx0, vx1]), x0 = _ref2[0], x1 = _ref2[1];
                        vy0 = vy - this.max_size;
                        vy1 = vy + this.max_size;
                        _ref3 = this.renderer.ymapper.v_map_from_target([vy0, vy1]), y0 = _ref3[0], y1 = _ref3[1];
                        candidates = (function() {
                          var _i, _len, _ref4, _results;
                          _ref4 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
                            x = _ref4[_i];
                            _results.push(x[4].i);
                          }
                          return _results;
                        }).call(this);
                        hits = [];
                        for (_i = 0, _len = candidates.length; _i < _len; _i++) {
                          i = candidates[_i];
                          s2 = this.size[i] / 2;
                          dist = Math.abs(this.sx[i] - sx) + Math.abs(this.sy[i] - sy);
                          if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {
                            hits.push([i, dist]);
                          }
                        }
                        hits = _.chain(hits).sortBy(function(elt) {
                          return elt[1];
                        }).map(function(elt) {
                          return elt[0];
                        }).value();
                        return hits;
                      };
                
                      MarkerView.prototype._hit_rect = function(geometry) {
                        var x, x0, x1, y0, y1, _ref1, _ref2;
                        _ref1 = this.renderer.xmapper.v_map_from_target([geometry.vx0, geometry.vx1]), x0 = _ref1[0], x1 = _ref1[1];
                        _ref2 = this.renderer.ymapper.v_map_from_target([geometry.vy0, geometry.vy1]), y0 = _ref2[0], y1 = _ref2[1];
                        return (function() {
                          var _i, _len, _ref3, _results;
                          _ref3 = this.index.search([x0, y0, x1, y1]);
                          _results = [];
                          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                            x = _ref3[_i];
                            _results.push(x[4].i);
                          }
                          return _results;
                        }).call(this);
                      };
                
                      MarkerView.prototype._hit_poly = function(geometry) {
                        var candidates, hits, i, idx, sx, sy, vx, vy, _i, _j, _ref1, _ref2, _ref3, _results;
                        _ref1 = [geometry.vx, geometry.vy], vx = _ref1[0], vy = _ref1[1];
                        sx = this.renderer.plot_view.canvas.v_vx_to_sx(vx);
                        sy = this.renderer.plot_view.canvas.v_vy_to_sy(vy);
                        candidates = (function() {
                          _results = [];
                          for (var _i = 0, _ref2 = this.sx.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
                          return _results;
                        }).apply(this);
                        hits = [];
                        for (i = _j = 0, _ref3 = candidates.length; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
                          idx = candidates[i];
                          if (point_in_poly(this.sx[i], this.sy[i], sx, sy)) {
                            hits.push(idx);
                          }
                        }
                        return hits;
                      };
                
                      return MarkerView;
                
                    })(Glyph.View);
                    Marker = (function(_super) {
                      __extends(Marker, _super);
                
                      function Marker() {
                        _ref1 = Marker.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Marker.prototype.display_defaults = function() {
                        return _.extend({}, Marker.__super__.display_defaults.call(this), {
                          size: 4
                        });
                      };
                
                      return Marker;
                
                    })(Glyph.Model);
                    Markers = (function(_super) {
                      __extends(Markers, _super);
                
                      function Markers() {
                        _ref2 = Markers.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      return Markers;
                
                    })(Glyph.Collection);
                    return {
                      Model: Marker,
                      View: MarkerView,
                      Collection: Markers
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=marker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/asterisk',["underscore", "./marker"], function(_, Marker) {
                    var Asterisk, AsteriskView, Asterisks, _ref, _ref1, _ref2;
                    AsteriskView = (function(_super) {
                      __extends(AsteriskView, _super);
                
                      function AsteriskView() {
                        _ref = AsteriskView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      AsteriskView.prototype._properties = ['line'];
                
                      AsteriskView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, r2, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          r = size[i] / 2;
                          r2 = r * 0.65;
                          ctx.beginPath();
                          ctx.moveTo(sx[i], sy[i] + r);
                          ctx.lineTo(sx[i], sy[i] - r);
                          ctx.moveTo(sx[i] - r, sy[i]);
                          ctx.lineTo(sx[i] + r, sy[i]);
                          ctx.moveTo(sx[i] - r2, sy[i] + r2);
                          ctx.lineTo(sx[i] + r2, sy[i] - r2);
                          ctx.moveTo(sx[i] - r2, sy[i] - r2);
                          ctx.lineTo(sx[i] + r2, sy[i] + r2);
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return AsteriskView;
                
                    })(Marker.View);
                    Asterisk = (function(_super) {
                      __extends(Asterisk, _super);
                
                      function Asterisk() {
                        _ref1 = Asterisk.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Asterisk.prototype.default_view = AsteriskView;
                
                      Asterisk.prototype.type = 'Asterisk';
                
                      Asterisk.prototype.display_defaults = function() {
                        return _.extend({}, Asterisk.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return Asterisk;
                
                    })(Marker.Model);
                    Asterisks = (function(_super) {
                      __extends(Asterisks, _super);
                
                      function Asterisks() {
                        _ref2 = Asterisks.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Asterisks.prototype.model = Asterisk;
                
                      return Asterisks;
                
                    })(Marker.Collection);
                    return {
                      Model: Asterisk,
                      View: AsteriskView,
                      Collection: new Asterisks()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=asterisk.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/circle_cross',["underscore", "./marker"], function(_, Marker) {
                    var CircleCross, CircleCrossView, CircleCrosses, _ref, _ref1, _ref2;
                    CircleCrossView = (function(_super) {
                      __extends(CircleCrossView, _super);
                
                      function CircleCrossView() {
                        _ref = CircleCrossView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CircleCrossView.prototype._properties = ['line', 'fill'];
                
                      CircleCrossView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          ctx.beginPath();
                          r = size[i] / 2;
                          ctx.arc(sx[i], sy[i], r, 0, 2 * Math.PI, false);
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            ctx.moveTo(sx[i], sy[i] + r);
                            ctx.lineTo(sx[i], sy[i] - r);
                            ctx.moveTo(sx[i] - r, sy[i]);
                            ctx.lineTo(sx[i] + r, sy[i]);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return CircleCrossView;
                
                    })(Marker.View);
                    CircleCross = (function(_super) {
                      __extends(CircleCross, _super);
                
                      function CircleCross() {
                        _ref1 = CircleCross.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CircleCross.prototype.default_view = CircleCrossView;
                
                      CircleCross.prototype.type = 'CircleCross';
                
                      CircleCross.prototype.display_defaults = function() {
                        return _.extend({}, CircleCross.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return CircleCross;
                
                    })(Marker.Model);
                    CircleCrosses = (function(_super) {
                      __extends(CircleCrosses, _super);
                
                      function CircleCrosses() {
                        _ref2 = CircleCrosses.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      CircleCrosses.prototype.model = CircleCross;
                
                      return CircleCrosses;
                
                    })(Marker.Collection);
                    return {
                      Model: CircleCross,
                      View: CircleCrossView,
                      Collection: new CircleCrosses()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=circle_cross.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/circle_x',["underscore", "./marker"], function(_, Marker) {
                    var CircleX, CircleXView, CircleXs, _ref, _ref1, _ref2;
                    CircleXView = (function(_super) {
                      __extends(CircleXView, _super);
                
                      function CircleXView() {
                        _ref = CircleXView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CircleXView.prototype._properties = ['line', 'fill'];
                
                      CircleXView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          ctx.beginPath();
                          r = size[i] / 2;
                          ctx.arc(sx[i], sy[i], r, 0, 2 * Math.PI, false);
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            ctx.moveTo(sx[i] - r, sy[i] + r);
                            ctx.lineTo(sx[i] + r, sy[i] - r);
                            ctx.moveTo(sx[i] - r, sy[i] - r);
                            ctx.lineTo(sx[i] + r, sy[i] + r);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return CircleXView;
                
                    })(Marker.View);
                    CircleX = (function(_super) {
                      __extends(CircleX, _super);
                
                      function CircleX() {
                        _ref1 = CircleX.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CircleX.prototype.default_view = CircleXView;
                
                      CircleX.prototype.type = 'CircleX';
                
                      CircleX.prototype.display_defaults = function() {
                        return _.extend({}, CircleX.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return CircleX;
                
                    })(Marker.Model);
                    CircleXs = (function(_super) {
                      __extends(CircleXs, _super);
                
                      function CircleXs() {
                        _ref2 = CircleXs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      CircleXs.prototype.model = CircleX;
                
                      return CircleXs;
                
                    })(Marker.Collection);
                    return {
                      Model: CircleX,
                      View: CircleXView,
                      Collection: new CircleXs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=circle_x.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/cross',["underscore", "./marker"], function(_, Marker) {
                    var Cross, CrossView, Crosses, _ref, _ref1, _ref2;
                    CrossView = (function(_super) {
                      __extends(CrossView, _super);
                
                      function CrossView() {
                        _ref = CrossView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CrossView.prototype._properties = ['line'];
                
                      CrossView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          r = size[i] / 2;
                          ctx.beginPath();
                          ctx.moveTo(sx[i], sy[i] + r);
                          ctx.lineTo(sx[i], sy[i] - r);
                          ctx.moveTo(sx[i] - r, sy[i]);
                          ctx.lineTo(sx[i] + r, sy[i]);
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return CrossView;
                
                    })(Marker.View);
                    Cross = (function(_super) {
                      __extends(Cross, _super);
                
                      function Cross() {
                        _ref1 = Cross.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Cross.prototype.default_view = CrossView;
                
                      Cross.prototype.type = 'Cross';
                
                      Cross.prototype.display_defaults = function() {
                        return _.extend({}, Cross.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return Cross;
                
                    })(Marker.Model);
                    Crosses = (function(_super) {
                      __extends(Crosses, _super);
                
                      function Crosses() {
                        _ref2 = Crosses.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Crosses.prototype.model = Cross;
                
                      return Crosses;
                
                    })(Marker.Collection);
                    return {
                      Model: Cross,
                      View: CrossView,
                      Collection: new Crosses()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=cross.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/diamond',["underscore", "./marker"], function(_, Marker) {
                    var Diamond, DiamondView, Diamonds, _ref, _ref1, _ref2;
                    DiamondView = (function(_super) {
                      __extends(DiamondView, _super);
                
                      function DiamondView() {
                        _ref = DiamondView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DiamondView.prototype._properties = ['line', 'fill'];
                
                      DiamondView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          r = size[i] / 2;
                          ctx.beginPath();
                          ctx.moveTo(sx[i], sy[i] + r);
                          ctx.lineTo(sx[i] + r, sy[i]);
                          ctx.lineTo(sx[i], sy[i] - r);
                          ctx.lineTo(sx[i] - r, sy[i]);
                          ctx.closePath();
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return DiamondView;
                
                    })(Marker.View);
                    Diamond = (function(_super) {
                      __extends(Diamond, _super);
                
                      function Diamond() {
                        _ref1 = Diamond.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Diamond.prototype.default_view = DiamondView;
                
                      Diamond.prototype.type = 'Diamond';
                
                      Diamond.prototype.display_defaults = function() {
                        return _.extend({}, Diamond.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return Diamond;
                
                    })(Marker.Model);
                    Diamonds = (function(_super) {
                      __extends(Diamonds, _super);
                
                      function Diamonds() {
                        _ref2 = Diamonds.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Diamonds.prototype.model = Diamond;
                
                      return Diamonds;
                
                    })(Marker.Collection);
                    return {
                      Model: Diamond,
                      View: DiamondView,
                      Collection: new Diamonds()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=diamond.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/diamond_cross',["underscore", "./marker"], function(_, Marker) {
                    var DiamondCross, DiamondCrossView, DiamondCrosses, _ref, _ref1, _ref2;
                    DiamondCrossView = (function(_super) {
                      __extends(DiamondCrossView, _super);
                
                      function DiamondCrossView() {
                        _ref = DiamondCrossView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DiamondCrossView.prototype._properties = ['line', 'fill'];
                
                      DiamondCrossView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          r = size[i] / 2;
                          ctx.beginPath();
                          ctx.moveTo(sx[i], sy[i] + r);
                          ctx.lineTo(sx[i] + r, sy[i]);
                          ctx.lineTo(sx[i], sy[i] - r);
                          ctx.lineTo(sx[i] - r, sy[i]);
                          ctx.closePath();
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            ctx.moveTo(sx[i], sy[i] + r);
                            ctx.lineTo(sx[i], sy[i] - r);
                            ctx.moveTo(sx[i] - r, sy[i]);
                            ctx.lineTo(sx[i] + r, sy[i]);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return DiamondCrossView;
                
                    })(Marker.View);
                    DiamondCross = (function(_super) {
                      __extends(DiamondCross, _super);
                
                      function DiamondCross() {
                        _ref1 = DiamondCross.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DiamondCross.prototype.default_view = DiamondCrossView;
                
                      DiamondCross.prototype.type = 'DiamondCross';
                
                      DiamondCross.prototype.display_defaults = function() {
                        return _.extend({}, DiamondCross.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return DiamondCross;
                
                    })(Marker.Model);
                    DiamondCrosses = (function(_super) {
                      __extends(DiamondCrosses, _super);
                
                      function DiamondCrosses() {
                        _ref2 = DiamondCrosses.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      DiamondCrosses.prototype.model = DiamondCross;
                
                      return DiamondCrosses;
                
                    })(Marker.Collection);
                    return {
                      Model: DiamondCross,
                      View: DiamondCrossView,
                      Collection: new DiamondCrosses()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=diamond_cross.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/inverted_triangle',["underscore", "./marker"], function(_, Marker) {
                    var InvertedTriangle, InvertedTriangleView, InvertedTriangles, _ref, _ref1, _ref2;
                    InvertedTriangleView = (function(_super) {
                      __extends(InvertedTriangleView, _super);
                
                      function InvertedTriangleView() {
                        _ref = InvertedTriangleView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      InvertedTriangleView.prototype._properties = ['line', 'fill'];
                
                      InvertedTriangleView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var a, h, i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          a = size[i] * Math.sqrt(3) / 6;
                          r = size[i] / 2;
                          h = size[i] * Math.sqrt(3) / 2;
                          ctx.beginPath();
                          ctx.moveTo(sx[i] - r, sy[i] - a);
                          ctx.lineTo(sx[i] + r, sy[i] - a);
                          ctx.lineTo(sx[i], sy[i] - a + h);
                          ctx.closePath();
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return InvertedTriangleView;
                
                    })(Marker.View);
                    InvertedTriangle = (function(_super) {
                      __extends(InvertedTriangle, _super);
                
                      function InvertedTriangle() {
                        _ref1 = InvertedTriangle.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      InvertedTriangle.prototype.default_view = InvertedTriangleView;
                
                      InvertedTriangle.prototype.type = 'InvertedTriangle';
                
                      InvertedTriangle.prototype.display_defaults = function() {
                        return _.extend({}, InvertedTriangle.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return InvertedTriangle;
                
                    })(Marker.Model);
                    InvertedTriangles = (function(_super) {
                      __extends(InvertedTriangles, _super);
                
                      function InvertedTriangles() {
                        _ref2 = InvertedTriangles.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      InvertedTriangles.prototype.model = InvertedTriangle;
                
                      return InvertedTriangles;
                
                    })(Marker.Collection);
                    return {
                      Model: InvertedTriangle,
                      View: InvertedTriangleView,
                      Collection: new InvertedTriangles()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=inverted_triangle.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/square',["underscore", "./marker"], function(_, Marker) {
                    var Square, SquareView, Squares, _ref, _ref1, _ref2;
                    SquareView = (function(_super) {
                      __extends(SquareView, _super);
                
                      function SquareView() {
                        _ref = SquareView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SquareView.prototype._properties = ['line', 'fill'];
                
                      SquareView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          ctx.translate(sx[i], sy[i]);
                          ctx.beginPath();
                          ctx.rect(-size[i] / 2, -size[i] / 2, size[i], size[i]);
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            ctx.stroke();
                          }
                          _results.push(ctx.translate(-sx[i], -sy[i]));
                        }
                        return _results;
                      };
                
                      return SquareView;
                
                    })(Marker.View);
                    Square = (function(_super) {
                      __extends(Square, _super);
                
                      function Square() {
                        _ref1 = Square.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Square.prototype.default_view = SquareView;
                
                      Square.prototype.type = 'Square';
                
                      Square.prototype.display_defaults = function() {
                        return _.extend({}, Square.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return Square;
                
                    })(Marker.Model);
                    Squares = (function(_super) {
                      __extends(Squares, _super);
                
                      function Squares() {
                        _ref2 = Squares.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Squares.prototype.model = Square;
                
                      return Squares;
                
                    })(Marker.Collection);
                    return {
                      Model: Square,
                      View: SquareView,
                      Collection: new Squares()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=square.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/square_cross',["underscore", "./marker"], function(_, Marker) {
                    var SquareCross, SquareCrossView, SquareCrosses, _ref, _ref1, _ref2;
                    SquareCrossView = (function(_super) {
                      __extends(SquareCrossView, _super);
                
                      function SquareCrossView() {
                        _ref = SquareCrossView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SquareCrossView.prototype._properties = ['line', 'fill'];
                
                      SquareCrossView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          ctx.translate(sx[i], sy[i]);
                          ctx.beginPath();
                          ctx.rect(-size[i] / 2, -size[i] / 2, size[i], size[i]);
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            r = size[i] / 2;
                            ctx.moveTo(0, +r);
                            ctx.lineTo(0, -r);
                            ctx.moveTo(-r, 0);
                            ctx.lineTo(+r, 0);
                            ctx.stroke();
                          }
                          _results.push(ctx.translate(-sx[i], -sy[i]));
                        }
                        return _results;
                      };
                
                      return SquareCrossView;
                
                    })(Marker.View);
                    SquareCross = (function(_super) {
                      __extends(SquareCross, _super);
                
                      function SquareCross() {
                        _ref1 = SquareCross.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      SquareCross.prototype.default_view = SquareCrossView;
                
                      SquareCross.prototype.type = 'SquareCross';
                
                      SquareCross.prototype.display_defaults = function() {
                        return _.extend({}, SquareCross.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return SquareCross;
                
                    })(Marker.Model);
                    SquareCrosses = (function(_super) {
                      __extends(SquareCrosses, _super);
                
                      function SquareCrosses() {
                        _ref2 = SquareCrosses.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      SquareCrosses.prototype.model = SquareCross;
                
                      return SquareCrosses;
                
                    })(Marker.Collection);
                    return {
                      Model: SquareCross,
                      View: SquareCrossView,
                      Collection: new SquareCrosses()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=square_cross.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/square_x',["underscore", "./marker"], function(_, Marker) {
                    var SquareX, SquareXView, SquareXs, _ref, _ref1, _ref2;
                    SquareXView = (function(_super) {
                      __extends(SquareXView, _super);
                
                      function SquareXView() {
                        _ref = SquareXView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SquareXView.prototype._properties = ['line', 'fill'];
                
                      SquareXView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          ctx.translate(sx[i], sy[i]);
                          ctx.beginPath();
                          ctx.rect(-size[i] / 2, -size[i] / 2, size[i], size[i]);
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            ctx.stroke();
                            r = size[i] / 2;
                            ctx.moveTo(-r, +r);
                            ctx.lineTo(+r, -r);
                            ctx.moveTo(-r, -r);
                            ctx.lineTo(+r, +r);
                            ctx.stroke();
                          }
                          _results.push(ctx.translate(-sx[i], -sy[i]));
                        }
                        return _results;
                      };
                
                      return SquareXView;
                
                    })(Marker.View);
                    SquareX = (function(_super) {
                      __extends(SquareX, _super);
                
                      function SquareX() {
                        _ref1 = SquareX.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      SquareX.prototype.default_view = SquareXView;
                
                      SquareX.prototype.type = 'SquareX';
                
                      SquareX.prototype.display_defaults = function() {
                        return _.extend({}, SquareX.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return SquareX;
                
                    })(Marker.Model);
                    SquareXs = (function(_super) {
                      __extends(SquareXs, _super);
                
                      function SquareXs() {
                        _ref2 = SquareXs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      SquareXs.prototype.model = SquareX;
                
                      return SquareXs;
                
                    })(Marker.Collection);
                    return {
                      Model: SquareX,
                      View: SquareXView,
                      Collection: new SquareXs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=square_x.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/triangle',["underscore", "./marker"], function(_, Marker) {
                    var Triangle, TriangleView, Triangles, _ref, _ref1, _ref2;
                    TriangleView = (function(_super) {
                      __extends(TriangleView, _super);
                
                      function TriangleView() {
                        _ref = TriangleView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      TriangleView.prototype._properties = ['line', 'fill'];
                
                      TriangleView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var a, h, i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          a = size[i] * Math.sqrt(3) / 6;
                          r = size[i] / 2;
                          h = size[i] * Math.sqrt(3) / 2;
                          ctx.beginPath();
                          ctx.moveTo(sx[i] - r, sy[i] + a);
                          ctx.lineTo(sx[i] + r, sy[i] + a);
                          ctx.lineTo(sx[i], sy[i] + a - h);
                          ctx.closePath();
                          if (this.props.fill.do_fill) {
                            this.props.fill.set_vectorize(ctx, i);
                            ctx.fill();
                          }
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return TriangleView;
                
                    })(Marker.View);
                    Triangle = (function(_super) {
                      __extends(Triangle, _super);
                
                      function Triangle() {
                        _ref1 = Triangle.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Triangle.prototype.default_view = TriangleView;
                
                      Triangle.prototype.type = 'Triangle';
                
                      Triangle.prototype.display_defaults = function() {
                        return _.extend({}, Triangle.__super__.display_defaults.call(this), this.line_defaults, this.fill_defaults);
                      };
                
                      return Triangle;
                
                    })(Marker.Model);
                    Triangles = (function(_super) {
                      __extends(Triangles, _super);
                
                      function Triangles() {
                        _ref2 = Triangles.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Triangles.prototype.model = Triangle;
                
                      return Triangles;
                
                    })(Marker.Collection);
                    return {
                      Model: Triangle,
                      View: TriangleView,
                      Collection: new Triangles()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=triangle.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/glyph/marker/x',["underscore", "./marker"], function(_, Marker) {
                    var X, XView, Xs, _ref, _ref1, _ref2;
                    XView = (function(_super) {
                      __extends(XView, _super);
                
                      function XView() {
                        _ref = XView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      XView.prototype._properties = ['line'];
                
                      XView.prototype._render = function(ctx, indices, sx, sy, size) {
                        var i, r, _i, _len, _results;
                        if (sx == null) {
                          sx = this.sx;
                        }
                        if (sy == null) {
                          sy = this.sy;
                        }
                        if (size == null) {
                          size = this.size;
                        }
                        _results = [];
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (isNaN(sx[i] + sy[i] + size[i])) {
                            continue;
                          }
                          r = size[i] / 2;
                          ctx.beginPath();
                          ctx.moveTo(sx[i] - r, sy[i] + r);
                          ctx.lineTo(sx[i] + r, sy[i] - r);
                          ctx.moveTo(sx[i] - r, sy[i] - r);
                          ctx.lineTo(sx[i] + r, sy[i] + r);
                          if (this.props.line.do_stroke) {
                            this.props.line.set_vectorize(ctx, i);
                            _results.push(ctx.stroke());
                          } else {
                            _results.push(void 0);
                          }
                        }
                        return _results;
                      };
                
                      return XView;
                
                    })(Marker.View);
                    X = (function(_super) {
                      __extends(X, _super);
                
                      function X() {
                        _ref1 = X.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      X.prototype.default_view = XView;
                
                      X.prototype.type = 'X';
                
                      X.prototype.display_defaults = function() {
                        return _.extend({}, X.__super__.display_defaults.call(this), this.line_defaults);
                      };
                
                      return X;
                
                    })(Marker.Model);
                    Xs = (function(_super) {
                      __extends(Xs, _super);
                
                      function Xs() {
                        _ref2 = Xs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Xs.prototype.model = X;
                
                      return Xs;
                
                    })(Marker.Collection);
                    return {
                      Model: X,
                      View: XView,
                      Collection: new Xs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=x.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/guide/axis',["underscore", "kiwi", "common/has_parent", "common/layout_box", "common/logging", "common/plot_widget", "renderer/properties"], function(_, kiwi, HasParent, LayoutBox, Logging, PlotWidget, properties) {
                    var ALPHABETIC, Axis, AxisView, CENTER, HANGING, LEFT, MIDDLE, RIGHT, logger, pi2, _align_lookup, _align_lookup_negative, _align_lookup_positive, _angle_lookup, _apply_location_heuristics, _baseline_lookup, _ref, _ref1;
                    logger = Logging.logger;
                    pi2 = Math.PI / 2;
                    ALPHABETIC = 'alphabetic';
                    MIDDLE = 'middle';
                    HANGING = 'hanging';
                    LEFT = 'left';
                    RIGHT = 'right';
                    CENTER = 'center';
                    _angle_lookup = {
                      above: {
                        parallel: 0,
                        normal: -pi2,
                        horizontal: 0,
                        vertical: -pi2
                      },
                      below: {
                        parallel: 0,
                        normal: pi2,
                        horizontal: 0,
                        vertical: pi2
                      },
                      left: {
                        parallel: -pi2,
                        normal: 0,
                        horizontal: 0,
                        vertical: -pi2
                      },
                      right: {
                        parallel: pi2,
                        normal: 0,
                        horizontal: 0,
                        vertical: pi2
                      }
                    };
                    _baseline_lookup = {
                      above: {
                        parallel: ALPHABETIC,
                        normal: MIDDLE,
                        horizontal: ALPHABETIC,
                        vertical: MIDDLE
                      },
                      below: {
                        parallel: HANGING,
                        normal: MIDDLE,
                        horizontal: HANGING,
                        vertical: MIDDLE
                      },
                      left: {
                        parallel: ALPHABETIC,
                        normal: MIDDLE,
                        horizontal: MIDDLE,
                        vertical: ALPHABETIC
                      },
                      right: {
                        parallel: ALPHABETIC,
                        normal: MIDDLE,
                        horizontal: MIDDLE,
                        vertical: ALPHABETIC
                      }
                    };
                    _align_lookup = {
                      above: {
                        parallel: CENTER,
                        normal: LEFT,
                        horizontal: CENTER,
                        vertical: LEFT
                      },
                      below: {
                        parallel: CENTER,
                        normal: LEFT,
                        horizontal: CENTER,
                        vertical: RIGHT
                      },
                      left: {
                        parallel: CENTER,
                        normal: RIGHT,
                        horizontal: RIGHT,
                        vertical: CENTER
                      },
                      right: {
                        parallel: CENTER,
                        normal: LEFT,
                        horizontal: LEFT,
                        vertical: CENTER
                      }
                    };
                    _align_lookup_negative = {
                      above: RIGHT,
                      below: LEFT,
                      left: RIGHT,
                      right: LEFT
                    };
                    _align_lookup_positive = {
                      above: LEFT,
                      below: RIGHT,
                      left: RIGHT,
                      right: LEFT
                    };
                    _apply_location_heuristics = function(ctx, side, orient) {
                      var align, baseline;
                      if (_.isString(orient)) {
                        baseline = _baseline_lookup[side][orient];
                        align = _align_lookup[side][orient];
                      } else if (orient === 0) {
                        baseline = _baseline_lookup[side][orient];
                        align = _align_lookup[side][orient];
                      } else if (orient < 0) {
                        baseline = 'middle';
                        align = _align_lookup_negative[side];
                      } else if (orient > 0) {
                        baseline = 'middle';
                        align = _align_lookup_positive[side];
                      }
                      ctx.textBaseline = baseline;
                      return ctx.textAlign = align;
                    };
                    AxisView = (function(_super) {
                      __extends(AxisView, _super);
                
                      function AxisView() {
                        _ref = AxisView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      AxisView.prototype.initialize = function(options) {
                        AxisView.__super__.initialize.call(this, options);
                        this.rule_props = new properties.Line(this, 'axis_');
                        this.major_tick_props = new properties.Line(this, 'major_tick_');
                        this.minor_tick_props = new properties.Line(this, 'minor_tick_');
                        this.major_label_props = new properties.Text(this, 'major_label_');
                        this.axis_label_props = new properties.Text(this, 'axis_label_');
                        this.x_range_name = this.mget('x_range_name');
                        return this.y_range_name = this.mget('y_range_name');
                      };
                
                      AxisView.prototype.render = function() {
                        var ctx;
                        ctx = this.plot_view.canvas_view.ctx;
                        ctx.save();
                        this._draw_rule(ctx);
                        this._draw_major_ticks(ctx);
                        this._draw_minor_ticks(ctx);
                        this._draw_major_labels(ctx);
                        this._draw_axis_label(ctx);
                        return ctx.restore();
                      };
                
                      AxisView.prototype.bind_bokeh_events = function() {
                        return this.listenTo(this.model, 'change', this.plot_view.request_render);
                      };
                
                      AxisView.prototype._draw_rule = function(ctx) {
                        var coords, i, nx, ny, sx, sy, x, xoff, y, yoff, _i, _ref1, _ref2, _ref3, _ref4, _ref5;
                        if (!this.rule_props.do_stroke) {
                          return;
                        }
                        _ref1 = coords = this.mget('rule_coords'), x = _ref1[0], y = _ref1[1];
                        _ref2 = this.plot_view.map_to_screen(x, "data", y, "data", this.x_range_name, this.y_range_name), sx = _ref2[0], sy = _ref2[1];
                        _ref3 = this.mget('normals'), nx = _ref3[0], ny = _ref3[1];
                        _ref4 = this.mget('offsets'), xoff = _ref4[0], yoff = _ref4[1];
                        this.rule_props.set(ctx, this);
                        ctx.beginPath();
                        ctx.moveTo(Math.round(sx[0] + nx * xoff), Math.round(sy[0] + ny * yoff));
                        for (i = _i = 1, _ref5 = sx.length; 1 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 1 <= _ref5 ? ++_i : --_i) {
                          ctx.lineTo(Math.round(sx[i] + nx * xoff), Math.round(sy[i] + ny * yoff));
                        }
                        return ctx.stroke();
                      };
                
                      AxisView.prototype._draw_major_ticks = function(ctx) {
                        var coords, i, nx, ny, sx, sy, tin, tout, x, xoff, y, yoff, _i, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
                        if (!this.major_tick_props.do_stroke) {
                          return;
                        }
                        coords = this.mget('tick_coords');
                        _ref1 = coords.major, x = _ref1[0], y = _ref1[1];
                        _ref2 = this.plot_view.map_to_screen(x, "data", y, "data", this.x_range_name, this.y_range_name), sx = _ref2[0], sy = _ref2[1];
                        _ref3 = this.mget('normals'), nx = _ref3[0], ny = _ref3[1];
                        _ref4 = this.mget('offsets'), xoff = _ref4[0], yoff = _ref4[1];
                        tin = this.mget('major_tick_in');
                        tout = this.mget('major_tick_out');
                        this.major_tick_props.set(ctx, this);
                        _results = [];
                        for (i = _i = 0, _ref5 = sx.length; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 0 <= _ref5 ? ++_i : --_i) {
                          ctx.beginPath();
                          ctx.moveTo(Math.round(sx[i] + nx * tout + nx * xoff), Math.round(sy[i] + ny * tout + ny * yoff));
                          ctx.lineTo(Math.round(sx[i] - nx * tin + nx * xoff), Math.round(sy[i] - ny * tin + ny * yoff));
                          _results.push(ctx.stroke());
                        }
                        return _results;
                      };
                
                      AxisView.prototype._draw_minor_ticks = function(ctx) {
                        var coords, i, nx, ny, sx, sy, tin, tout, x, xoff, y, yoff, _i, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
                        if (!this.minor_tick_props.do_stroke) {
                          return;
                        }
                        coords = this.mget('tick_coords');
                        _ref1 = coords.minor, x = _ref1[0], y = _ref1[1];
                        _ref2 = this.plot_view.map_to_screen(x, "data", y, "data", this.x_range_name, this.y_range_name), sx = _ref2[0], sy = _ref2[1];
                        _ref3 = this.mget('normals'), nx = _ref3[0], ny = _ref3[1];
                        _ref4 = this.mget('offsets'), xoff = _ref4[0], yoff = _ref4[1];
                        tin = this.mget('minor_tick_in');
                        tout = this.mget('minor_tick_out');
                        this.minor_tick_props.set(ctx, this);
                        _results = [];
                        for (i = _i = 0, _ref5 = sx.length; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 0 <= _ref5 ? ++_i : --_i) {
                          ctx.beginPath();
                          ctx.moveTo(Math.round(sx[i] + nx * tout + nx * xoff), Math.round(sy[i] + ny * tout + ny * yoff));
                          ctx.lineTo(Math.round(sx[i] - nx * tin + nx * xoff), Math.round(sy[i] - ny * tin + ny * yoff));
                          _results.push(ctx.stroke());
                        }
                        return _results;
                      };
                
                      AxisView.prototype._draw_major_labels = function(ctx) {
                        var angle, coords, dim, i, labels, nx, ny, orient, side, standoff, sx, sy, x, xoff, y, yoff, _i, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
                        coords = this.mget('tick_coords');
                        _ref1 = coords.major, x = _ref1[0], y = _ref1[1];
                        _ref2 = this.plot_view.map_to_screen(x, "data", y, "data", this.x_range_name, this.y_range_name), sx = _ref2[0], sy = _ref2[1];
                        _ref3 = this.mget('normals'), nx = _ref3[0], ny = _ref3[1];
                        _ref4 = this.mget('offsets'), xoff = _ref4[0], yoff = _ref4[1];
                        dim = this.mget('dimension');
                        side = this.mget('location');
                        orient = this.mget('major_label_orientation');
                        if (_.isString(orient)) {
                          angle = _angle_lookup[side][orient];
                        } else {
                          angle = -orient;
                        }
                        standoff = this.model._tick_extent(this) + this.mget('major_label_standoff');
                        labels = this.mget('formatter').format(coords.major[dim]);
                        this.major_label_props.set(ctx, this);
                        _apply_location_heuristics(ctx, side, orient);
                        _results = [];
                        for (i = _i = 0, _ref5 = sx.length; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 0 <= _ref5 ? ++_i : --_i) {
                          if (angle) {
                            ctx.translate(sx[i] + nx * standoff + nx * xoff, sy[i] + ny * standoff + ny * yoff);
                            ctx.rotate(angle);
                            ctx.fillText(labels[i], 0, 0);
                            ctx.rotate(-angle);
                            _results.push(ctx.translate(-sx[i] - nx * standoff + nx * xoff, -sy[i] - ny * standoff + ny * yoff));
                          } else {
                            _results.push(ctx.fillText(labels[i], Math.round(sx[i] + nx * standoff + nx * xoff), Math.round(sy[i] + ny * standoff + ny * yoff)));
                          }
                        }
                        return _results;
                      };
                
                      AxisView.prototype._draw_axis_label = function(ctx) {
                        var angle, label, nx, ny, orient, side, standoff, sx, sy, x, xoff, y, yoff, _ref1, _ref2, _ref3, _ref4;
                        label = this.mget('axis_label');
                        if (label == null) {
                          return;
                        }
                        _ref1 = this.mget('rule_coords'), x = _ref1[0], y = _ref1[1];
                        _ref2 = this.plot_view.map_to_screen(x, "data", y, "data", this.x_range_name, this.y_range_name), sx = _ref2[0], sy = _ref2[1];
                        _ref3 = this.mget('normals'), nx = _ref3[0], ny = _ref3[1];
                        _ref4 = this.mget('offsets'), xoff = _ref4[0], yoff = _ref4[1];
                        side = this.mget('location');
                        orient = 'parallel';
                        angle = _angle_lookup[side][orient];
                        standoff = this.model._tick_extent(this) + this.model._tick_label_extent(this) + this.mget('axis_label_standoff');
                        sx = (sx[0] + sx[sx.length - 1]) / 2;
                        sy = (sy[0] + sy[sy.length - 1]) / 2;
                        this.axis_label_props.set(ctx, this);
                        _apply_location_heuristics(ctx, side, orient);
                        if (angle) {
                          ctx.translate(sx + nx * standoff + nx * xoff, sy + ny * standoff + ny * yoff);
                          ctx.rotate(angle);
                          ctx.fillText(label, 0, 0);
                          ctx.rotate(-angle);
                          return ctx.translate(-sx - nx * standoff + nx * xoff, -sy - ny * standoff + ny * yoff);
                        } else {
                          return ctx.fillText(label, sx + nx * standoff + nx * xoff, sy + ny * standoff + ny * yoff);
                        }
                      };
                
                      return AxisView;
                
                    })(PlotWidget);
                    Axis = (function(_super) {
                      __extends(Axis, _super);
                
                      function Axis() {
                        _ref1 = Axis.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Axis.prototype.default_view = AxisView;
                
                      Axis.prototype.type = 'Axis';
                
                      Axis.prototype.initialize = function(attrs, options) {
                        Axis.__super__.initialize.call(this, attrs, options);
                        this.register_property('computed_bounds', this._computed_bounds, false);
                        this.add_dependencies('computed_bounds', this, ['bounds']);
                        this.add_dependencies('computed_bounds', this.get('plot'), ['x_range', 'y_range']);
                        this.register_property('rule_coords', this._rule_coords, false);
                        this.add_dependencies('rule_coords', this, ['computed_bounds', 'side']);
                        this.register_property('tick_coords', this._tick_coords, false);
                        this.add_dependencies('tick_coords', this, ['computed_bounds', 'location']);
                        this.register_property('ranges', this._ranges, true);
                        this.register_property('normals', (function() {
                          return this._normals;
                        }), true);
                        this.register_property('dimension', (function() {
                          return this._dim;
                        }), true);
                        return this.register_property('offsets', this._offsets, true);
                      };
                
                      Axis.prototype.initialize_layout = function(solver) {
                        var panel, side;
                        panel = new LayoutBox.Model({
                          solver: solver
                        });
                        this.panel = panel;
                        this._top = panel._top;
                        this._bottom = panel._bottom;
                        this._left = panel._left;
                        this._right = panel._right;
                        this._width = panel._width;
                        this._height = panel._height;
                        side = this.get('location');
                        if (side === "above") {
                          this._dim = 0;
                          this._normals = [0, -1];
                          this._size = panel._height;
                          return this._anchor = panel._bottom;
                        } else if (side === "below") {
                          this._dim = 0;
                          this._normals = [0, 1];
                          this._size = panel._height;
                          return this._anchor = panel._top;
                        } else if (side === "left") {
                          this._dim = 1;
                          this._normals = [-1, 0];
                          this._size = panel._width;
                          return this._anchor = panel._right;
                        } else if (side === "right") {
                          this._dim = 1;
                          this._normals = [1, 0];
                          this._size = panel._width;
                          return this._anchor = panel._left;
                        } else {
                          return logger.error("unrecognized side: '" + side + "'");
                        }
                      };
                
                      Axis.prototype.update_layout = function(view, solver) {
                        var size;
                        size = this._tick_extent(view) + this._tick_label_extent(view) + this._axis_label_extent(view);
                        if (this._last_size == null) {
                          this._last_size = -1;
                        }
                        if (size === this._last_size) {
                          return;
                        }
                        this._last_size = size;
                        if (this._size_constraint != null) {
                          solver.remove_constraint(this._size_constraint);
                        }
                        this._size_constraint = new kiwi.Constraint(new kiwi.Expression(this._size, -size), kiwi.Operator.Eq);
                        return solver.add_constraint(this._size_constraint);
                      };
                
                      Axis.prototype._offsets = function() {
                        var frame, side, xoff, yoff, _ref2;
                        side = this.get('location');
                        _ref2 = [0, 0], xoff = _ref2[0], yoff = _ref2[1];
                        frame = this.get('plot').get('frame');
                        if (side === "below") {
                          yoff = Math.abs(this.panel.get("top") - frame.get("bottom"));
                        } else if (side === "above") {
                          yoff = Math.abs(this.panel.get("bottom") - frame.get("top"));
                        } else if (side === "right") {
                          xoff = Math.abs(this.panel.get("left") - frame.get("right"));
                        } else if (side === "left") {
                          xoff = Math.abs(this.panel.get("right") - frame.get("left"));
                        }
                        return [xoff, yoff];
                      };
                
                      Axis.prototype._ranges = function() {
                        var frame, i, j, ranges;
                        i = this.get('dimension');
                        j = (i + 1) % 2;
                        frame = this.get('plot').get('frame');
                        ranges = [frame.get('x_ranges')[this.get('x_range_name')], frame.get('y_ranges')[this.get('y_range_name')]];
                        return [ranges[i], ranges[j]];
                      };
                
                      Axis.prototype._computed_bounds = function() {
                        var cross_range, end, range, range_bounds, start, user_bounds, _ref2, _ref3;
                        _ref2 = this.get('ranges'), range = _ref2[0], cross_range = _ref2[1];
                        user_bounds = (_ref3 = this.get('bounds')) != null ? _ref3 : 'auto';
                        range_bounds = [range.get('min'), range.get('max')];
                        if (user_bounds === 'auto') {
                          return range_bounds;
                        }
                        if (_.isArray(user_bounds)) {
                          if (Math.abs(user_bounds[0] - user_bounds[1]) > Math.abs(range_bounds[0] - range_bounds[1])) {
                            start = Math.max(Math.min(user_bounds[0], user_bounds[1]), range_bounds[0]);
                            end = Math.min(Math.max(user_bounds[0], user_bounds[1]), range_bounds[1]);
                          } else {
                            start = Math.min(user_bounds[0], user_bounds[1]);
                            end = Math.max(user_bounds[0], user_bounds[1]);
                          }
                          return [start, end];
                        }
                        logger.error("user bounds '" + user_bounds + "' not understood");
                        return null;
                      };
                
                      Axis.prototype._rule_coords = function() {
                        var coords, cross_range, end, i, j, loc, range, start, xs, ys, _ref2, _ref3;
                        i = this.get('dimension');
                        j = (i + 1) % 2;
                        _ref2 = this.get('ranges'), range = _ref2[0], cross_range = _ref2[1];
                        _ref3 = this.get('computed_bounds'), start = _ref3[0], end = _ref3[1];
                        xs = new Array(2);
                        ys = new Array(2);
                        coords = [xs, ys];
                        loc = this._get_loc(cross_range);
                        coords[i][0] = Math.max(start, range.get('min'));
                        coords[i][1] = Math.min(end, range.get('max'));
                        if (coords[i][0] > coords[i][1]) {
                          coords[i][0] = coords[i][1] = NaN;
                        }
                        coords[j][0] = loc;
                        coords[j][1] = loc;
                        return coords;
                      };
                
                      Axis.prototype._tick_coords = function() {
                        var coords, cross_range, end, i, ii, j, loc, majors, minor_coords, minor_xs, minor_ys, minors, range, range_max, range_min, start, ticks, xs, ys, _i, _j, _k, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
                        i = this.get('dimension');
                        j = (i + 1) % 2;
                        _ref2 = this.get('ranges'), range = _ref2[0], cross_range = _ref2[1];
                        _ref3 = this.get('computed_bounds'), start = _ref3[0], end = _ref3[1];
                        ticks = this.get('ticker').get_ticks(start, end, range, {});
                        majors = ticks.major;
                        minors = ticks.minor;
                        loc = this._get_loc(cross_range);
                        xs = [];
                        ys = [];
                        coords = [xs, ys];
                        minor_xs = [];
                        minor_ys = [];
                        minor_coords = [minor_xs, minor_ys];
                        if (range.type === "FactorRange") {
                          for (ii = _i = 0, _ref4 = majors.length; 0 <= _ref4 ? _i < _ref4 : _i > _ref4; ii = 0 <= _ref4 ? ++_i : --_i) {
                            coords[i].push(majors[ii]);
                            coords[j].push(loc);
                          }
                        } else {
                          _ref5 = [range.get('min'), range.get('max')], range_min = _ref5[0], range_max = _ref5[1];
                          for (ii = _j = 0, _ref6 = majors.length; 0 <= _ref6 ? _j < _ref6 : _j > _ref6; ii = 0 <= _ref6 ? ++_j : --_j) {
                            if (majors[ii] < range_min || majors[ii] > range_max) {
                              continue;
                            }
                            coords[i].push(majors[ii]);
                            coords[j].push(loc);
                          }
                          for (ii = _k = 0, _ref7 = minors.length; 0 <= _ref7 ? _k < _ref7 : _k > _ref7; ii = 0 <= _ref7 ? ++_k : --_k) {
                            if (minors[ii] < range_min || minors[ii] > range_max) {
                              continue;
                            }
                            minor_coords[i].push(minors[ii]);
                            minor_coords[j].push(loc);
                          }
                        }
                        return {
                          "major": coords,
                          "minor": minor_coords
                        };
                      };
                
                      Axis.prototype._get_loc = function(cross_range) {
                        var cend, cstart, loc, side;
                        cstart = cross_range.get('start');
                        cend = cross_range.get('end');
                        side = this.get('location');
                        if (side === 'left' || side === 'below') {
                          loc = 'start';
                        } else if (side === 'right' || side === 'above') {
                          loc = 'end';
                        }
                        return cross_range.get(loc);
                      };
                
                      Axis.prototype._tick_extent = function(view) {
                        return this.get('major_tick_out');
                      };
                
                      Axis.prototype._tick_label_extent = function(view) {
                        var angle, c, coords, ctx, dim, extent, h, hfactor, hscale, i, labels, orient, s, side, val, w, wfactor, _i, _ref2;
                        extent = 0;
                        dim = this.get('dimension');
                        ctx = view.plot_view.canvas_view.ctx;
                        coords = this.get('tick_coords').major;
                        side = this.get('location');
                        orient = this.get('major_label_orientation');
                        labels = this.get('formatter').format(coords[dim]);
                        view.major_label_props.set(ctx, view);
                        if (_.isString(orient)) {
                          hscale = 1;
                          angle = _angle_lookup[side][orient];
                        } else {
                          hscale = 2;
                          angle = -orient;
                        }
                        angle = Math.abs(angle);
                        c = Math.cos(angle);
                        s = Math.sin(angle);
                        if (side === "above" || side === "below") {
                          wfactor = s;
                          hfactor = c;
                        } else {
                          wfactor = c;
                          hfactor = s;
                        }
                        for (i = _i = 0, _ref2 = labels.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                          if (labels[i] == null) {
                            continue;
                          }
                          w = ctx.measureText(labels[i]).width * 1.1;
                          h = ctx.measureText(labels[i]).ascent * 0.9;
                          val = w * wfactor + (h / hscale) * hfactor;
                          if (val > extent) {
                            extent = val;
                          }
                        }
                        if (extent > 0) {
                          extent += this.get('major_label_standoff');
                        }
                        return extent;
                      };
                
                      Axis.prototype._axis_label_extent = function(view) {
                        var angle, c, ctx, extent, h, orient, s, side, w;
                        extent = 0;
                        side = this.get('location');
                        orient = 'parallel';
                        ctx = view.plot_view.canvas_view.ctx;
                        view.axis_label_props.set(ctx, view);
                        angle = Math.abs(_angle_lookup[side][orient]);
                        c = Math.cos(angle);
                        s = Math.sin(angle);
                        if (this.get('axis_label')) {
                          extent += this.get('axis_label_standoff');
                          view.axis_label_props.set(ctx, view);
                          w = ctx.measureText(this.get('axis_label')).width * 1.1;
                          h = ctx.measureText(this.get('axis_label')).ascent * 0.9;
                          if (side === "above" || side === "below") {
                            extent += w * s + h * c;
                          } else {
                            extent += w * c + h * s;
                          }
                        }
                        return extent;
                      };
                
                      Axis.prototype.defaults = function() {
                        return _.extend({}, Axis.__super__.defaults.call(this), {
                          x_range_name: "default",
                          y_range_name: "default"
                        });
                      };
                
                      Axis.prototype.display_defaults = function() {
                        return _.extend({}, Axis.__super__.display_defaults.call(this), {
                          level: 'overlay',
                          axis_line_color: 'black',
                          axis_line_width: 1,
                          axis_line_alpha: 1.0,
                          axis_line_join: 'miter',
                          axis_line_cap: 'butt',
                          axis_line_dash: [],
                          axis_line_dash_offset: 0,
                          major_tick_in: 2,
                          major_tick_out: 6,
                          major_tick_line_color: 'black',
                          major_tick_line_width: 1,
                          major_tick_line_alpha: 1.0,
                          major_tick_line_join: 'miter',
                          major_tick_line_cap: 'butt',
                          major_tick_line_dash: [],
                          major_tick_line_dash_offset: 0,
                          minor_tick_in: 0,
                          minor_tick_out: 4,
                          minor_tick_line_color: 'black',
                          minor_tick_line_width: 1,
                          minor_tick_line_alpha: 1.0,
                          minor_tick_line_join: 'miter',
                          minor_tick_line_cap: 'butt',
                          minor_tick_line_dash: [],
                          minor_tick_line_dash_offset: 0,
                          major_label_standoff: 5,
                          major_label_orientation: "horizontal",
                          major_label_text_font: "helvetica",
                          major_label_text_font_size: "10pt",
                          major_label_text_font_style: "normal",
                          major_label_text_color: "#444444",
                          major_label_text_alpha: 1.0,
                          major_label_text_align: "center",
                          major_label_text_baseline: "alphabetic",
                          axis_label: "",
                          axis_label_standoff: 5,
                          axis_label_text_font: "helvetica",
                          axis_label_text_font_size: "16pt",
                          axis_label_text_font_style: "normal",
                          axis_label_text_color: "#444444",
                          axis_label_text_alpha: 1.0,
                          axis_label_text_align: "center",
                          axis_label_text_baseline: "alphabetic"
                        });
                      };
                
                      return Axis;
                
                    })(HasParent);
                    return {
                      "Model": Axis,
                      "View": AxisView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=axis.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/categorical_ticker',["common/collection", "common/has_properties"], function(Collection, HasProperties) {
                    var CategoricalTicker, CategoricalTickers, _ref, _ref1;
                    CategoricalTicker = (function(_super) {
                      __extends(CategoricalTicker, _super);
                
                      function CategoricalTicker() {
                        _ref = CategoricalTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CategoricalTicker.prototype.type = 'CategoricalTicker';
                
                      CategoricalTicker.prototype.get_ticks = function(start, end, range, _arg) {
                        var desired_n_ticks;
                        desired_n_ticks = _arg.desired_n_ticks;
                        return {
                          "major": range.get("factors"),
                          "minor": []
                        };
                      };
                
                      return CategoricalTicker;
                
                    })(HasProperties);
                    CategoricalTickers = (function(_super) {
                      __extends(CategoricalTickers, _super);
                
                      function CategoricalTickers() {
                        _ref1 = CategoricalTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CategoricalTickers.prototype.model = CategoricalTicker;
                
                      return CategoricalTickers;
                
                    })(Collection);
                    return {
                      "Model": CategoricalTicker,
                      "Collection": new CategoricalTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=categorical_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/categorical_tick_formatter',["common/collection", "common/has_properties"], function(Collection, HasProperties) {
                    var CategoricalTickFormatter, CategoricalTickFormatters, _ref, _ref1;
                    CategoricalTickFormatter = (function(_super) {
                      __extends(CategoricalTickFormatter, _super);
                
                      function CategoricalTickFormatter() {
                        _ref = CategoricalTickFormatter.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CategoricalTickFormatter.prototype.type = 'CategoricalTickFormatter';
                
                      CategoricalTickFormatter.prototype.initialize = function(attrs, options) {
                        return CategoricalTickFormatter.__super__.initialize.call(this, attrs, options);
                      };
                
                      CategoricalTickFormatter.prototype.format = function(ticks) {
                        return ticks;
                      };
                
                      return CategoricalTickFormatter;
                
                    })(HasProperties);
                    CategoricalTickFormatters = (function(_super) {
                      __extends(CategoricalTickFormatters, _super);
                
                      function CategoricalTickFormatters() {
                        _ref1 = CategoricalTickFormatters.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CategoricalTickFormatters.prototype.model = CategoricalTickFormatter;
                
                      return CategoricalTickFormatters;
                
                    })(Collection);
                    return {
                      "Model": CategoricalTickFormatter,
                      "Collection": new CategoricalTickFormatters()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=categorical_tick_formatter.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/guide/categorical_axis',["common/collection", "./axis", "common/logging", "range/factor_range", "ticking/categorical_ticker", "ticking/categorical_tick_formatter"], function(Collection, Axis, Logging, FactorRange, CategoricalTicker, CategoricalTickFormatter) {
                    var CategoricalAxes, CategoricalAxis, CategoricalAxisView, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    CategoricalAxisView = (function(_super) {
                      __extends(CategoricalAxisView, _super);
                
                      function CategoricalAxisView() {
                        _ref = CategoricalAxisView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      return CategoricalAxisView;
                
                    })(Axis.View);
                    CategoricalAxis = (function(_super) {
                      __extends(CategoricalAxis, _super);
                
                      function CategoricalAxis() {
                        _ref1 = CategoricalAxis.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CategoricalAxis.prototype.default_view = CategoricalAxisView;
                
                      CategoricalAxis.prototype.type = 'CategoricalAxis';
                
                      CategoricalAxis.prototype.initialize = function(attrs, objects) {
                        CategoricalAxis.__super__.initialize.call(this, attrs, objects);
                        if (this.get('ticker') == null) {
                          this.set_obj('ticker', CategoricalTicker.Collection.create());
                        }
                        if (this.get('formatter') == null) {
                          return this.set_obj('formatter', CategoricalTickFormatter.Collection.create());
                        }
                      };
                
                      CategoricalAxis.prototype._bounds = function() {
                        var i, range_bounds, ranges, user_bounds, _ref2;
                        i = this.get('dimension');
                        ranges = [this.get('plot').get('x_range'), this.get('plot').get('y_range')];
                        user_bounds = (_ref2 = this.get('bounds')) != null ? _ref2 : 'auto';
                        if (user_bounds !== 'auto') {
                          logger.warn("Categorical Axes only support user_bounds='auto', ignoring");
                        }
                        range_bounds = [ranges[i].get('min'), ranges[i].get('max')];
                        return range_bounds;
                      };
                
                      return CategoricalAxis;
                
                    })(Axis.Model);
                    CategoricalAxes = (function(_super) {
                      __extends(CategoricalAxes, _super);
                
                      function CategoricalAxes() {
                        _ref2 = CategoricalAxes.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      CategoricalAxes.prototype.model = CategoricalAxis;
                
                      return CategoricalAxes;
                
                    })(Collection);
                    return {
                      "Model": CategoricalAxis,
                      "Collection": new CategoricalAxes(),
                      "View": CategoricalAxisView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=categorical_axis.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/abstract_ticker',["underscore", "common/collection", "common/has_properties"], function(_, Collection, HasProperties) {
                    var AbstractTicker, AbstractTickers, DEFAULT_DESIRED_N_TICKS, repr, _ref, _ref1;
                    repr = function(obj) {
                      var elem, elems_str, key, obj_as_string, props_str;
                      if (obj === null) {
                        return "null";
                      }
                      if (obj == null) {
                        return "undefined";
                      } else if (obj.constructor === Array) {
                        elems_str = ((function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = obj.length; _i < _len; _i++) {
                            elem = obj[_i];
                            _results.push(repr(elem));
                          }
                          return _results;
                        })()).join(", ");
                        return "[" + elems_str + "]";
                      } else if (obj.constructor === Object) {
                        props_str = ((function() {
                          var _results;
                          _results = [];
                          for (key in obj) {
                            _results.push("" + key + ": " + (repr(obj[key])));
                          }
                          return _results;
                        })()).join(", ");
                        return "{" + props_str + "}";
                      } else if (obj.constructor === String) {
                        return "\"" + obj + "\"";
                      } else if (obj.constructor === Function) {
                        return "<Function: " + obj.name + ">";
                      } else {
                        obj_as_string = obj.toString();
                        if (obj_as_string === "[object Object]") {
                          return "<" + obj.constructor.name + ">";
                        } else {
                          return obj_as_string;
                        }
                      }
                    };
                    DEFAULT_DESIRED_N_TICKS = 6;
                    AbstractTicker = (function(_super) {
                      __extends(AbstractTicker, _super);
                
                      function AbstractTicker() {
                        _ref = AbstractTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      AbstractTicker.prototype.type = 'AbstractTicker';
                
                      AbstractTicker.prototype.initialize = function(attrs, options) {
                        return AbstractTicker.__super__.initialize.call(this, attrs, options);
                      };
                
                      AbstractTicker.prototype.get_ticks = function(data_low, data_high, range, _arg) {
                        var desired_n_ticks;
                        desired_n_ticks = _arg.desired_n_ticks;
                        if (desired_n_ticks == null) {
                          desired_n_ticks = DEFAULT_DESIRED_N_TICKS;
                        }
                        return this.get_ticks_no_defaults(data_low, data_high, desired_n_ticks);
                      };
                
                      AbstractTicker.prototype.get_ticks_no_defaults = function(data_low, data_high, desired_n_ticks) {
                        var end_factor, factor, factors, i, interval, minor_interval, minor_offsets, minor_ticks, num_minor_ticks, start_factor, tick, ticks, x, _i, _j, _k, _len, _len1, _len2;
                        interval = this.get_interval(data_low, data_high, desired_n_ticks);
                        start_factor = Math.floor(data_low / interval);
                        end_factor = Math.ceil(data_high / interval);
                        if (_.isNaN(start_factor) || _.isNaN(end_factor)) {
                          factors = [];
                        } else {
                          factors = _.range(start_factor, end_factor + 1);
                        }
                        ticks = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = factors.length; _i < _len; _i++) {
                            factor = factors[_i];
                            _results.push(factor * interval);
                          }
                          return _results;
                        })();
                        num_minor_ticks = this.get("num_minor_ticks");
                        minor_ticks = [];
                        if (num_minor_ticks > 1) {
                          minor_interval = interval / num_minor_ticks;
                          minor_offsets = (function() {
                            var _i, _results;
                            _results = [];
                            for (i = _i = 1; 1 <= num_minor_ticks ? _i <= num_minor_ticks : _i >= num_minor_ticks; i = 1 <= num_minor_ticks ? ++_i : --_i) {
                              _results.push(i * minor_interval);
                            }
                            return _results;
                          })();
                          for (_i = 0, _len = minor_offsets.length; _i < _len; _i++) {
                            x = minor_offsets[_i];
                            minor_ticks.push(ticks[0] - x);
                          }
                          for (_j = 0, _len1 = ticks.length; _j < _len1; _j++) {
                            tick = ticks[_j];
                            for (_k = 0, _len2 = minor_offsets.length; _k < _len2; _k++) {
                              x = minor_offsets[_k];
                              minor_ticks.push(tick + x);
                            }
                          }
                        }
                        return {
                          "major": ticks,
                          "minor": minor_ticks
                        };
                      };
                
                      AbstractTicker.prototype.get_interval = void 0;
                
                      AbstractTicker.prototype.get_min_interval = function() {
                        return this.get('min_interval');
                      };
                
                      AbstractTicker.prototype.get_max_interval = function() {
                        return this.get('max_interval');
                      };
                
                      AbstractTicker.prototype.toString = function() {
                        var class_name, key, params_str, props;
                        class_name = typeof this;
                        props = this.get('toString_properties');
                        params_str = ((function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = props.length; _i < _len; _i++) {
                            key = props[_i];
                            _results.push("" + key + "=" + (repr(this[key])));
                          }
                          return _results;
                        }).call(this)).join(", ");
                        return "" + class_name + "(" + params_str + ")";
                      };
                
                      AbstractTicker.prototype.get_ideal_interval = function(data_low, data_high, desired_n_ticks) {
                        var data_range;
                        data_range = data_high - data_low;
                        return data_range / desired_n_ticks;
                      };
                
                      AbstractTicker.prototype.defaults = function() {
                        return _.extend({}, AbstractTicker.__super__.defaults.call(this), {
                          toString_properties: [],
                          num_minor_ticks: 5
                        });
                      };
                
                      return AbstractTicker;
                
                    })(HasProperties);
                    AbstractTickers = (function(_super) {
                      __extends(AbstractTickers, _super);
                
                      function AbstractTickers() {
                        _ref1 = AbstractTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      AbstractTickers.prototype.model = AbstractTicker;
                
                      return AbstractTickers;
                
                    })(Collection);
                    return {
                      "Model": AbstractTicker,
                      "Collection": new AbstractTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=abstract_ticker.js.map
                */;
                (function() {
                  define('ticking/util',["underscore"], function(_) {
                    var ONE_DAY, ONE_HOUR, ONE_MILLI, ONE_MINUTE, ONE_MONTH, ONE_SECOND, ONE_YEAR, argmin, copy_date, last_month_no_later_than, last_year_no_later_than;
                    ONE_MILLI = 1.0;
                    ONE_SECOND = 1000.0;
                    ONE_MINUTE = 60.0 * ONE_SECOND;
                    ONE_HOUR = 60 * ONE_MINUTE;
                    ONE_DAY = 24 * ONE_HOUR;
                    ONE_MONTH = 30 * ONE_DAY;
                    ONE_YEAR = 365 * ONE_DAY;
                    argmin = function(arr) {
                      var ret;
                      ret = _.min(_.range(arr.length), (function(i) {
                        return arr[i];
                      }));
                      return ret;
                    };
                    copy_date = function(date) {
                      return new Date(date.getTime());
                    };
                    last_month_no_later_than = function(date) {
                      date = copy_date(date);
                      date.setUTCDate(1);
                      date.setUTCHours(0);
                      date.setUTCMinutes(0);
                      date.setUTCSeconds(0);
                      date.setUTCMilliseconds(0);
                      return date;
                    };
                    last_year_no_later_than = function(date) {
                      date = last_month_no_later_than(date);
                      date.setUTCMonth(0);
                      return date;
                    };
                    return {
                      "argmin": argmin,
                      "copy_date": copy_date,
                      "last_month_no_later_than": last_month_no_later_than,
                      "last_year_no_later_than": last_year_no_later_than,
                      "ONE_MILLI": ONE_MILLI,
                      "ONE_SECOND": ONE_SECOND,
                      "ONE_MINUTE": ONE_MINUTE,
                      "ONE_HOUR": ONE_HOUR,
                      "ONE_DAY": ONE_DAY,
                      "ONE_MONTH": ONE_MONTH,
                      "ONE_YEAR": ONE_YEAR
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=util.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/adaptive_ticker',["underscore", "common/collection", "ticking/abstract_ticker", "ticking/util"], function(_, Collection, AbstractTicker, util) {
                    var AdaptiveTicker, AdaptiveTickers, argmin, clamp, log, _ref, _ref1;
                    argmin = util.argmin;
                    clamp = function(x, min_val, max_val) {
                      return Math.max(min_val, Math.min(max_val, x));
                    };
                    log = function(x, base) {
                      if (base == null) {
                        base = Math.E;
                      }
                      return Math.log(x) / Math.log(base);
                    };
                    AdaptiveTicker = (function(_super) {
                      __extends(AdaptiveTicker, _super);
                
                      function AdaptiveTicker() {
                        _ref = AdaptiveTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      AdaptiveTicker.prototype.type = 'AdaptiveTicker';
                
                      AdaptiveTicker.prototype.initialize = function(attrs, options) {
                        var prefix_mantissa, suffix_mantissa;
                        AdaptiveTicker.__super__.initialize.call(this, attrs, options);
                        prefix_mantissa = _.last(this.get('mantissas')) / this.get('base');
                        suffix_mantissa = _.first(this.get('mantissas')) * this.get('base');
                        this.extended_mantissas = _.flatten([prefix_mantissa, this.get('mantissas'), suffix_mantissa]);
                        return this.base_factor = this.get('min_interval') === 0.0 ? 1.0 : this.get('min_interval');
                      };
                
                      AdaptiveTicker.prototype.get_interval = function(data_low, data_high, desired_n_ticks) {
                        var best_mantissa, candidate_mantissas, data_range, errors, ideal_interval, ideal_magnitude, ideal_mantissa, interval, interval_exponent;
                        data_range = data_high - data_low;
                        ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);
                        interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.get('base')));
                        ideal_magnitude = Math.pow(this.get('base'), interval_exponent) * this.base_factor;
                        ideal_mantissa = ideal_interval / ideal_magnitude;
                        candidate_mantissas = this.extended_mantissas;
                        errors = candidate_mantissas.map(function(mantissa) {
                          return Math.abs(desired_n_ticks - (data_range / (mantissa * ideal_magnitude)));
                        });
                        best_mantissa = candidate_mantissas[argmin(errors)];
                        interval = best_mantissa * ideal_magnitude;
                        return clamp(interval, this.get('min_interval'), this.get('max_interval'));
                      };
                
                      AdaptiveTicker.prototype.defaults = function() {
                        return _.extend({}, AdaptiveTicker.__super__.defaults.call(this), {
                          toString_properties: ['mantissas', 'base', 'min_magnitude', 'max_magnitude'],
                          base: 10.0,
                          mantissas: [2, 5, 10],
                          min_interval: 0.0,
                          max_interval: Infinity
                        });
                      };
                
                      return AdaptiveTicker;
                
                    })(AbstractTicker.Model);
                    AdaptiveTickers = (function(_super) {
                      __extends(AdaptiveTickers, _super);
                
                      function AdaptiveTickers() {
                        _ref1 = AdaptiveTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      AdaptiveTickers.prototype.model = AdaptiveTicker;
                
                      return AdaptiveTickers;
                
                    })(Collection);
                    return {
                      "Model": AdaptiveTicker,
                      "Collection": new AdaptiveTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=adaptive_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/composite_ticker',["underscore", "common/collection", "ticking/abstract_ticker", "ticking/util"], function(_, Collection, AbstractTicker, util) {
                    var CompositeTicker, CompositeTickers, argmin, _ref, _ref1;
                    argmin = util.argmin;
                    CompositeTicker = (function(_super) {
                      __extends(CompositeTicker, _super);
                
                      function CompositeTicker() {
                        _ref = CompositeTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CompositeTicker.prototype.type = 'CompositeTicker';
                
                      CompositeTicker.prototype.initialize = function(attrs, options) {
                        var tickers;
                        CompositeTicker.__super__.initialize.call(this, attrs, options);
                        tickers = this.get('tickers');
                        this.register_property('min_intervals', function() {
                          return _.invoke(tickers, 'get_min_interval');
                        }, true);
                        this.add_dependencies('min_intervals', this, ['tickers']);
                        this.register_property('max_intervals', function() {
                          return _.invoke(tickers, 'get_max_interval');
                        }, true);
                        this.add_dependencies('max_intervals', this, ['tickers']);
                        this.register_property('min_interval', function() {
                          return _.first(this.get('min_intervals'));
                        }, true);
                        this.add_dependencies('min_interval', this, ['min_intervals']);
                        this.register_property('max_interval', function() {
                          return _.first(this.get('max_intervals'));
                        }, true);
                        return this.add_dependencies('max_interval', this, ['max_interval']);
                      };
                
                      CompositeTicker.prototype.get_best_ticker = function(data_low, data_high, desired_n_ticks) {
                        var best_index, best_ticker, best_ticker_ndx, data_range, errors, ideal_interval, intervals, ticker_ndxs;
                        data_range = data_high - data_low;
                        ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);
                        ticker_ndxs = [_.sortedIndex(this.get('min_intervals'), ideal_interval) - 1, _.sortedIndex(this.get('max_intervals'), ideal_interval)];
                        intervals = [this.get('min_intervals')[ticker_ndxs[0]], this.get('max_intervals')[ticker_ndxs[1]]];
                        errors = intervals.map(function(interval) {
                          return Math.abs(desired_n_ticks - (data_range / interval));
                        });
                        best_index = argmin(errors);
                        if (best_index === Infinity) {
                          return this.get('tickers')[0];
                        }
                        best_ticker_ndx = ticker_ndxs[best_index];
                        best_ticker = this.get('tickers')[best_ticker_ndx];
                        return best_ticker;
                      };
                
                      CompositeTicker.prototype.get_interval = function(data_low, data_high, desired_n_ticks) {
                        var best_ticker;
                        best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);
                        return best_ticker.get_interval(data_low, data_high, desired_n_ticks);
                      };
                
                      CompositeTicker.prototype.get_ticks_no_defaults = function(data_low, data_high, desired_n_ticks) {
                        var best_ticker, ticks;
                        best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);
                        ticks = best_ticker.get_ticks_no_defaults(data_low, data_high, desired_n_ticks);
                        return ticks;
                      };
                
                      return CompositeTicker;
                
                    })(AbstractTicker.Model);
                    CompositeTickers = (function(_super) {
                      __extends(CompositeTickers, _super);
                
                      function CompositeTickers() {
                        _ref1 = CompositeTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CompositeTickers.prototype.model = CompositeTicker;
                
                      return CompositeTickers;
                
                    })(Collection);
                    return {
                      "Model": CompositeTicker,
                      "Collection": new CompositeTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=composite_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/single_interval_ticker',["underscore", "common/collection", "ticking/abstract_ticker"], function(_, Collection, AbstractTicker) {
                    var SingleIntervalTicker, SingleIntervalTickers, _ref, _ref1;
                    SingleIntervalTicker = (function(_super) {
                      __extends(SingleIntervalTicker, _super);
                
                      function SingleIntervalTicker() {
                        _ref = SingleIntervalTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SingleIntervalTicker.prototype.type = 'SingleIntervalTicker';
                
                      SingleIntervalTicker.prototype.initialize = function(attrs, options) {
                        SingleIntervalTicker.__super__.initialize.call(this, attrs, options);
                        this.register_property('min_interval', function() {
                          return this.get('interval');
                        }, true);
                        this.add_dependencies('min_interval', this, ['interval']);
                        this.register_property('max_interval', function() {
                          return this.get('interval');
                        }, true);
                        return this.add_dependencies('max_interval', this, ['interval']);
                      };
                
                      SingleIntervalTicker.prototype.get_interval = function(data_low, data_high, n_desired_ticks) {
                        return this.get('interval');
                      };
                
                      SingleIntervalTicker.prototype.defaults = function() {
                        return _.extend({}, SingleIntervalTicker.__super__.defaults.call(this), {
                          toString_properties: ['interval']
                        });
                      };
                
                      return SingleIntervalTicker;
                
                    })(AbstractTicker.Model);
                    SingleIntervalTickers = (function(_super) {
                      __extends(SingleIntervalTickers, _super);
                
                      function SingleIntervalTickers() {
                        _ref1 = SingleIntervalTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      SingleIntervalTickers.prototype.model = SingleIntervalTicker;
                
                      return SingleIntervalTickers;
                
                    })(Collection);
                    return {
                      "Model": SingleIntervalTicker,
                      "Collection": new SingleIntervalTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=single_interval_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/days_ticker',["underscore", "common/collection", "ticking/single_interval_ticker", "ticking/util"], function(_, Collection, SingleIntervalTicker, util) {
                    var DaysTicker, DaysTickers, ONE_DAY, copy_date, date_range_by_month, last_month_no_later_than, _ref, _ref1;
                    copy_date = util.copy_date;
                    last_month_no_later_than = util.last_month_no_later_than;
                    ONE_DAY = util.ONE_DAY;
                    date_range_by_month = function(start_time, end_time) {
                      var date, dates, end_date, prev_end_date, start_date;
                      start_date = last_month_no_later_than(new Date(start_time));
                      end_date = last_month_no_later_than(new Date(end_time));
                      prev_end_date = copy_date(end_date);
                      end_date.setUTCMonth(end_date.getUTCMonth() + 1);
                      dates = [];
                      date = start_date;
                      while (true) {
                        dates.push(copy_date(date));
                        date.setUTCMonth(date.getUTCMonth() + 1);
                        if (date > end_date) {
                          break;
                        }
                      }
                      return dates;
                    };
                    DaysTicker = (function(_super) {
                      __extends(DaysTicker, _super);
                
                      function DaysTicker() {
                        _ref = DaysTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DaysTicker.prototype.type = 'DaysTicker';
                
                      DaysTicker.prototype.initialize = function(attrs, options) {
                        var days, interval;
                        attrs.num_minor_ticks = 0;
                        DaysTicker.__super__.initialize.call(this, attrs, options);
                        days = this.get('days');
                        interval = days.length > 1 ? (days[1] - days[0]) * ONE_DAY : 31 * ONE_DAY;
                        return this.set('interval', interval);
                      };
                
                      DaysTicker.prototype.get_ticks_no_defaults = function(data_low, data_high, desired_n_ticks) {
                        var all_ticks, date, day_dates, days, days_of_month, interval, month_dates, ticks_in_range,
                          _this = this;
                        month_dates = date_range_by_month(data_low, data_high);
                        days = this.get('days');
                        days_of_month = function(month_date, interval) {
                          var dates, day, day_date, future_date, _i, _len;
                          dates = [];
                          for (_i = 0, _len = days.length; _i < _len; _i++) {
                            day = days[_i];
                            day_date = copy_date(month_date);
                            day_date.setUTCDate(day);
                            future_date = new Date(day_date.getTime() + (interval / 2));
                            if (future_date.getUTCMonth() === month_date.getUTCMonth()) {
                              dates.push(day_date);
                            }
                          }
                          return dates;
                        };
                        interval = this.get('interval');
                        day_dates = _.flatten((function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = month_dates.length; _i < _len; _i++) {
                            date = month_dates[_i];
                            _results.push(days_of_month(date, interval));
                          }
                          return _results;
                        })());
                        all_ticks = _.invoke(day_dates, 'getTime');
                        ticks_in_range = _.filter(all_ticks, (function(tick) {
                          return (data_low <= tick && tick <= data_high);
                        }));
                        return {
                          "major": ticks_in_range,
                          "minor": []
                        };
                      };
                
                      DaysTicker.prototype.defaults = function() {
                        return _.extend({}, DaysTicker.__super__.defaults.call(this), {
                          toString_properties: ['days']
                        });
                      };
                
                      return DaysTicker;
                
                    })(SingleIntervalTicker.Model);
                    DaysTickers = (function(_super) {
                      __extends(DaysTickers, _super);
                
                      function DaysTickers() {
                        _ref1 = DaysTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DaysTickers.prototype.model = DaysTicker;
                
                      return DaysTickers;
                
                    })(Collection);
                    return {
                      "Model": DaysTicker,
                      "Collection": new DaysTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=days_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/months_ticker',["underscore", "common/collection", "ticking/single_interval_ticker", "ticking/util"], function(_, Collection, SingleIntervalTicker, util) {
                    var MonthsTicker, MonthsTickers, ONE_MONTH, copy_date, date_range_by_year, last_year_no_later_than, _ref, _ref1;
                    copy_date = util.copy_date;
                    last_year_no_later_than = util.last_year_no_later_than;
                    ONE_MONTH = util.ONE_MONTH;
                    date_range_by_year = function(start_time, end_time) {
                      var date, dates, end_date, start_date;
                      start_date = last_year_no_later_than(new Date(start_time));
                      end_date = last_year_no_later_than(new Date(end_time));
                      end_date.setUTCFullYear(end_date.getUTCFullYear() + 1);
                      dates = [];
                      date = start_date;
                      while (true) {
                        dates.push(copy_date(date));
                        date.setUTCFullYear(date.getUTCFullYear() + 1);
                        if (date > end_date) {
                          break;
                        }
                      }
                      return dates;
                    };
                    MonthsTicker = (function(_super) {
                      __extends(MonthsTicker, _super);
                
                      function MonthsTicker() {
                        _ref = MonthsTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      MonthsTicker.prototype.type = 'MonthsTicker';
                
                      MonthsTicker.prototype.initialize = function(attrs, options) {
                        var interval, months;
                        MonthsTicker.__super__.initialize.call(this, attrs, options);
                        months = this.get('months');
                        interval = months.length > 1 ? (months[1] - months[0]) * ONE_MONTH : 12 * ONE_MONTH;
                        return this.set('interval', interval);
                      };
                
                      MonthsTicker.prototype.get_ticks_no_defaults = function(data_low, data_high, desired_n_ticks) {
                        var all_ticks, date, month_dates, months, months_of_year, ticks_in_range, year_dates;
                        year_dates = date_range_by_year(data_low, data_high);
                        months = this.get('months');
                        months_of_year = function(year_date) {
                          return months.map(function(month) {
                            var month_date;
                            month_date = copy_date(year_date);
                            month_date.setUTCMonth(month);
                            return month_date;
                          });
                        };
                        month_dates = _.flatten((function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = year_dates.length; _i < _len; _i++) {
                            date = year_dates[_i];
                            _results.push(months_of_year(date));
                          }
                          return _results;
                        })());
                        all_ticks = _.invoke(month_dates, 'getTime');
                        ticks_in_range = _.filter(all_ticks, (function(tick) {
                          return (data_low <= tick && tick <= data_high);
                        }));
                        return {
                          "major": ticks_in_range,
                          "minor": []
                        };
                      };
                
                      MonthsTicker.prototype.defaults = function() {
                        return _.extend({}, MonthsTicker.__super__.defaults.call(this), {
                          toString_properties: ['months']
                        });
                      };
                
                      return MonthsTicker;
                
                    })(SingleIntervalTicker.Model);
                    MonthsTickers = (function(_super) {
                      __extends(MonthsTickers, _super);
                
                      function MonthsTickers() {
                        _ref1 = MonthsTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      MonthsTickers.prototype.model = MonthsTicker;
                
                      return MonthsTickers;
                
                    })(Collection);
                    return {
                      "Model": MonthsTicker,
                      "Collection": new MonthsTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=months_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/basic_ticker',["common/collection", "ticking/adaptive_ticker"], function(Collection, AdaptiveTicker) {
                    var BasicTicker, BasicTickers, _ref, _ref1;
                    BasicTicker = (function(_super) {
                      __extends(BasicTicker, _super);
                
                      function BasicTicker() {
                        _ref = BasicTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      BasicTicker.prototype.type = 'BasicTicker';
                
                      BasicTicker.prototype.initialize = function(attrs, options) {
                        return BasicTicker.__super__.initialize.call(this, attrs, options);
                      };
                
                      BasicTicker.prototype.defaults = function() {
                        return _.extend({}, BasicTicker.__super__.defaults.call(this), {
                          mantissas: [1, 2, 5]
                        });
                      };
                
                      return BasicTicker;
                
                    })(AdaptiveTicker.Model);
                    BasicTickers = (function(_super) {
                      __extends(BasicTickers, _super);
                
                      function BasicTickers() {
                        _ref1 = BasicTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      BasicTickers.prototype.model = BasicTicker;
                
                      return BasicTickers;
                
                    })(Collection);
                    return {
                      "Model": BasicTicker,
                      "Collection": new BasicTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=basic_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/years_ticker',["underscore", "common/collection", "ticking/basic_ticker", "ticking/single_interval_ticker", "ticking/util"], function(_, Collection, BasicTicker, SingleIntervalTicker, util) {
                    var ONE_YEAR, YearsTicker, YearsTickers, last_year_no_later_than, _ref, _ref1;
                    last_year_no_later_than = util.last_year_no_later_than;
                    ONE_YEAR = util.ONE_YEAR;
                    YearsTicker = (function(_super) {
                      __extends(YearsTicker, _super);
                
                      function YearsTicker() {
                        _ref = YearsTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      YearsTicker.prototype.type = 'YearsTicker';
                
                      YearsTicker.prototype.initialize = function(attrs, options) {
                        YearsTicker.__super__.initialize.call(this, attrs, options);
                        this.set('interval', ONE_YEAR);
                        return this.basic_ticker = new BasicTicker.Model({
                          num_minor_ticks: 0
                        });
                      };
                
                      YearsTicker.prototype.get_ticks_no_defaults = function(data_low, data_high, desired_n_ticks) {
                        var all_ticks, end_year, start_year, ticks_in_range, year, years;
                        start_year = last_year_no_later_than(new Date(data_low)).getUTCFullYear();
                        end_year = last_year_no_later_than(new Date(data_high)).getUTCFullYear();
                        years = this.basic_ticker.get_ticks_no_defaults(start_year, end_year, desired_n_ticks).major;
                        all_ticks = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = years.length; _i < _len; _i++) {
                            year = years[_i];
                            _results.push(Date.UTC(year, 0, 1));
                          }
                          return _results;
                        })();
                        ticks_in_range = _.filter(all_ticks, (function(tick) {
                          return (data_low <= tick && tick <= data_high);
                        }));
                        return {
                          "major": ticks_in_range,
                          "minor": []
                        };
                      };
                
                      YearsTicker.prototype.defaults = function() {
                        return _.extend({}, YearsTicker.__super__.defaults.call(this), {
                          toString_properties: ['years']
                        });
                      };
                
                      return YearsTicker;
                
                    })(SingleIntervalTicker.Model);
                    YearsTickers = (function(_super) {
                      __extends(YearsTickers, _super);
                
                      function YearsTickers() {
                        _ref1 = YearsTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      YearsTickers.prototype.model = YearsTicker;
                
                      return YearsTickers;
                
                    })(Collection);
                    return {
                      "Model": YearsTicker,
                      "Collection": new YearsTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=years_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/datetime_ticker',["underscore", "common/collection", "ticking/adaptive_ticker", "ticking/composite_ticker", "ticking/days_ticker", "ticking/months_ticker", "ticking/years_ticker", "ticking/util"], function(_, Collection, AdaptiveTicker, CompositeTicker, DaysTicker, MonthsTicker, YearsTicker, util) {
                    var DatetimeTicker, DatetimeTickers, ONE_HOUR, ONE_MILLI, ONE_MINUTE, ONE_MONTH, ONE_SECOND, _ref, _ref1;
                    ONE_MILLI = util.ONE_MILLI;
                    ONE_SECOND = util.ONE_SECOND;
                    ONE_MINUTE = util.ONE_MINUTE;
                    ONE_HOUR = util.ONE_HOUR;
                    ONE_MONTH = util.ONE_MONTH;
                    DatetimeTicker = (function(_super) {
                      __extends(DatetimeTicker, _super);
                
                      function DatetimeTicker() {
                        _ref = DatetimeTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DatetimeTicker.prototype.type = 'DatetimeTicker';
                
                      DatetimeTicker.prototype.defaults = function() {
                        return _.extend({}, DatetimeTicker.__super__.defaults.call(this), {
                          num_minor_ticks: 0,
                          tickers: [
                            new AdaptiveTicker.Model({
                              mantissas: [1, 2, 5],
                              base: 10,
                              min_interval: 0,
                              max_interval: 500 * ONE_MILLI,
                              num_minor_ticks: 0
                            }), new AdaptiveTicker.Model({
                              mantissas: [1, 2, 5, 10, 15, 20, 30],
                              base: 60,
                              min_interval: ONE_SECOND,
                              max_interval: 30 * ONE_MINUTE,
                              num_minor_ticks: 0
                            }), new AdaptiveTicker.Model({
                              mantissas: [1, 2, 4, 6, 8, 12],
                              base: 24.0,
                              min_interval: ONE_HOUR,
                              max_interval: 12 * ONE_HOUR,
                              num_minor_ticks: 0
                            }), new DaysTicker.Model({
                              days: _.range(1, 32)
                            }), new DaysTicker.Model({
                              days: _.range(1, 31, 3)
                            }), new DaysTicker.Model({
                              days: [1, 8, 15, 22]
                            }), new DaysTicker.Model({
                              days: [1, 15]
                            }), new MonthsTicker.Model({
                              months: _.range(0, 12, 1)
                            }), new MonthsTicker.Model({
                              months: _.range(0, 12, 2)
                            }), new MonthsTicker.Model({
                              months: _.range(0, 12, 4)
                            }), new MonthsTicker.Model({
                              months: _.range(0, 12, 6)
                            }), new YearsTicker.Model({})
                          ]
                        });
                      };
                
                      return DatetimeTicker;
                
                    })(CompositeTicker.Model);
                    DatetimeTickers = (function(_super) {
                      __extends(DatetimeTickers, _super);
                
                      function DatetimeTickers() {
                        _ref1 = DatetimeTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DatetimeTickers.prototype.model = DatetimeTicker;
                
                      return DatetimeTickers;
                
                    })(Collection);
                    return {
                      "Model": DatetimeTicker,
                      "Collection": new DatetimeTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=datetime_ticker.js.map
                */;
                (function(root) {
                define("sprintf", [], function() {
                  return (function() {
                /*! sprintf.js | Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro> | 3 clause BSD license */
                
                (function(ctx) {
                	var sprintf = function() {
                		if (!sprintf.cache.hasOwnProperty(arguments[0])) {
                			sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);
                		}
                		return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);
                	};
                
                	sprintf.format = function(parse_tree, argv) {
                		var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
                		for (i = 0; i < tree_length; i++) {
                			node_type = get_type(parse_tree[i]);
                			if (node_type === 'string') {
                				output.push(parse_tree[i]);
                			}
                			else if (node_type === 'array') {
                				match = parse_tree[i]; // convenience purposes only
                				if (match[2]) { // keyword argument
                					arg = argv[cursor];
                					for (k = 0; k < match[2].length; k++) {
                						if (!arg.hasOwnProperty(match[2][k])) {
                							throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                						}
                						arg = arg[match[2][k]];
                					}
                				}
                				else if (match[1]) { // positional argument (explicit)
                					arg = argv[match[1]];
                				}
                				else { // positional argument (implicit)
                					arg = argv[cursor++];
                				}
                
                				if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                					throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                				}
                				switch (match[8]) {
                					case 'b': arg = arg.toString(2); break;
                					case 'c': arg = String.fromCharCode(arg); break;
                					case 'd': arg = parseInt(arg, 10); break;
                					case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                					case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                					case 'o': arg = arg.toString(8); break;
                					case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                					case 'u': arg = arg >>> 0; break;
                					case 'x': arg = arg.toString(16); break;
                					case 'X': arg = arg.toString(16).toUpperCase(); break;
                				}
                				arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                				pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                				pad_length = match[6] - String(arg).length;
                				pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                				output.push(match[5] ? arg + pad : pad + arg);
                			}
                		}
                		return output.join('');
                	};
                
                	sprintf.cache = {};
                
                	sprintf.parse = function(fmt) {
                		var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
                		while (_fmt) {
                			if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                				parse_tree.push(match[0]);
                			}
                			else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                				parse_tree.push('%');
                			}
                			else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                				if (match[2]) {
                					arg_names |= 1;
                					var field_list = [], replacement_field = match[2], field_match = [];
                					if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                						field_list.push(field_match[1]);
                						while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                							if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                								field_list.push(field_match[1]);
                							}
                							else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                								field_list.push(field_match[1]);
                							}
                							else {
                								throw('[sprintf] huh?');
                							}
                						}
                					}
                					else {
                						throw('[sprintf] huh?');
                					}
                					match[2] = field_list;
                				}
                				else {
                					arg_names |= 2;
                				}
                				if (arg_names === 3) {
                					throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                				}
                				parse_tree.push(match);
                			}
                			else {
                				throw('[sprintf] huh?');
                			}
                			_fmt = _fmt.substring(match[0].length);
                		}
                		return parse_tree;
                	};
                
                	var vsprintf = function(fmt, argv, _argv) {
                		_argv = argv.slice(0);
                		_argv.splice(0, 0, fmt);
                		return sprintf.apply(null, _argv);
                	};
                
                	/**
                	 * helpers
                	 */
                	function get_type(variable) {
                		return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
                	}
                
                	function str_repeat(input, multiplier) {
                		for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
                		return output.join('');
                	}
                
                	/**
                	 * export to either browser or node.js
                	 */
                	ctx.sprintf = sprintf;
                	ctx.vsprintf = vsprintf;
                })(typeof exports != "undefined" ? exports : window);
                
                return root.sprintf = sprintf;
                  }).apply(root, arguments);
                });
                }(this));
                
                !function (definition) {
                  if (typeof module == "object" && module.exports) module.exports = definition();
                  else if (typeof define == "function") define('timezone',definition);
                  else this.tz = definition();
                } (function () {
                /*
                  function die () {
                    console.log.apply(console, __slice.call(arguments, 0));
                    return process.exit(1);
                  }
                
                  function say () { return console.log.apply(console, __slice.call(arguments, 0)) }
                */
                  function actualize (entry, rule, year) {
                    var actualized, date = rule.day[1];
                
                    do {
                      actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));
                    } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0])
                
                    actualized = {
                      clock: rule.clock,
                      sort: actualized.getTime(),
                      rule: rule,
                      save: rule.save * 6e4,
                      offset: entry.offset
                    };
                
                    actualized[actualized.clock] = actualized.sort + rule.time * 6e4;
                
                    if (actualized.posix) {
                      actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);
                    } else {
                      actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);
                    }
                
                    return actualized;
                  }
                
                  function find (request, clock, time) {
                    var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules
                      , j, year = new Date(time).getUTCFullYear(), off = 1;
                    for (i = 1, I = zone.length; i < I; i++) if (zone[i][clock] <= time) break;
                    entry = zone[i];
                    if (entry.rules) {
                      rules = request[entry.rules];
                      for (j = year + 1; j >= year - off; --j)
                        for (i = 0, I = rules.length; i < I; i++)
                          if (rules[i].from <= j && j <= rules[i].to) actualized.push(actualize(entry, rules[i], j));
                          else if (rules[i].to < j && off == 1) off = j - rules[i].to;
                      actualized.sort(function (a, b) { return a.sort - b.sort });
                      for (i = 0, I = actualized.length; i < I; i++) {
                        if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock]) found = actualized[i];
                      }
                    }
                    if (found) {
                      if (abbrev = /^(.*)\/(.*)$/.exec(entry.format)) {
                        found.abbrev = abbrev[found.save ? 2 : 1];
                      } else {
                        found.abbrev = entry.format.replace(/%s/, found.rule.letter);
                      }
                    }
                    return found || entry;
                  }
                
                  function convertToWallclock (request, posix) {
                    if (request.zone == "UTC") return posix;
                    request.entry = find(request, "posix", posix);
                    return posix + request.entry.offset + request.entry.save;
                  }
                
                  function convertToPOSIX (request, wallclock) {
                    if (request.zone == "UTC") return wallclock;
                
                    var entry, diff;
                    request.entry = entry = find(request, "wallclock", wallclock);
                    diff = wallclock - entry.wallclock;
                
                    return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;
                  }
                
                  function adjust (request, posix, match) {
                    var increment = +(match[1] + 1) // conversion necessary for week day addition
                      , offset = match[2] * increment
                      , index = UNITS.indexOf(match[3].toLowerCase())
                      , date
                      ;
                    if (index > 9) {
                      posix += offset * TIME[index - 10];
                    } else {
                      date = new Date(convertToWallclock(request, posix));
                      if (index < 7) {
                        while (offset) {
                          date.setUTCDate(date.getUTCDate() + increment);
                          if (date.getUTCDay() == index) offset -= increment;
                        }
                      } else if (index == 7) {
                        date.setUTCFullYear(date.getUTCFullYear() + offset);
                      } else if (index == 8) {
                        date.setUTCMonth(date.getUTCMonth() + offset);
                      } else {
                        date.setUTCDate(date.getUTCDate() + offset);
                      }
                      if ((posix = convertToPOSIX(request, date.getTime())) == null) {
                        posix = convertToPOSIX(request, date.getTime() + 864e5 * increment) - 864e5 * increment;
                      }
                    }
                    return posix;
                  }
                
                  function convert (vargs) {
                    if (!vargs.length) return "0.0.23";
                
                    var request = Object.create(this)
                      , adjustments = []
                      , i, I, $, argument, date
                      ;
                
                    for (i = 0; i < vargs.length; i++) { // leave the for loop alone, it works.
                      argument = vargs[i];
                      // https://twitter.com/bigeasy/status/215112186572439552
                      if (Array.isArray(argument)) {
                        if (!i && !isNaN(argument[1])) {
                          date = argument;
                        } else {
                          argument.splice.apply(vargs, [ i--, 1 ].concat(argument));
                        }
                      } else if (isNaN(argument)) {
                        $ = typeof argument;
                        if ($ == "string") {
                          if (~argument.indexOf("%")) {
                            request.format = argument;
                          } else if (!i && argument == "*") {
                            date = argument;
                          } else if (!i && ($ = /^(\d{4})-(\d{2})-(\d{2})(?:[T\s](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d+))?)?(Z|(([+-])(\d{2}(:\d{2}){0,2})))?)?$/.exec(argument))) {
                            date = [];
                            date.push.apply(date, $.slice(1, 8));
                            if ($[9]) {
                              date.push($[10] + 1);
                              date.push.apply(date, $[11].split(/:/));
                            } else if ($[8]) {
                              date.push(1);
                            }
                          } else if (/^\w{2,3}_\w{2}$/.test(argument)) {
                            request.locale = argument;
                          } else if ($ = UNIT_RE.exec(argument)) {
                            adjustments.push($);
                          } else {
                            request.zone = argument;
                          }
                        } else if ($ == "function") {
                          if ($ = argument.call(request)) return $;
                        } else if (/^\w{2,3}_\w{2}$/.test(argument.name)) {
                          request[argument.name] = argument;
                        } else if (argument.zones) {
                          for ($ in argument.zones) request[$] = argument.zones[$];
                          for ($ in argument.rules) request[$] = argument.rules[$];
                        }
                      } else if (!i) {
                        date = argument;
                      }
                    }
                
                    if (!request[request.locale]) delete request.locale;
                    if (!request[request.zone]) delete request.zone;
                
                    if (date != null) {
                      if (date == "*") {
                        date = request.clock();
                      } else if (Array.isArray(date)) {
                        I = !date[7];
                        for (i = 0; i < 11; i++) date[i] = +(date[i] || 0); // conversion necessary for decrement
                        --date[1]; // Grr..
                        date = Date.UTC.apply(Date.UTC, date.slice(0, 8)) +
                          -date[7] * (date[8] * 36e5 + date[9] * 6e4 + date[10] * 1e3);
                      } else {
                        date = Math.floor(date);
                      }
                      if (!isNaN(date)) {
                        if (I) date = convertToPOSIX(request, date);
                
                        if (date == null) return date;
                
                        for (i = 0, I = adjustments.length; i < I; i++) {
                          date = adjust(request, date, adjustments[i]);
                        }
                
                        if (!request.format) return date;
                
                        $ = new Date(convertToWallclock(request, date));
                        return request.format.replace(/%([-0_^]?)(:{0,3})(\d*)(.)/g,
                        function (value, flag, colons, padding, specifier) {
                          var f, fill = "0", pad;
                          if (f = request[specifier]) {
                            value = String(f.call(request, $, date, flag, colons.length));
                            if ((flag || f.style) == "_") fill = " ";
                            pad = flag == "-" ? 0 : f.pad || 0;
                            while (value.length < pad) value = fill + value;
                            pad = flag == "-" ? 0 : padding || f.pad;
                            while (value.length < pad) value = fill + value;
                            if (specifier == "N" && pad < value.length) value = value.slice(0, pad);
                            if (flag == "^") value = value.toUpperCase();
                          }
                          return value;
                        });
                      }
                    }
                
                    return function () { return request.convert(arguments) };
                  }
                
                  var context =
                    { clock: function () { return +(new Date()) }
                    , zone: "UTC"
                    , entry: { abbrev: "UTC", offset: 0, save: 0 }
                    , UTC: 1
                    , z: function(date, posix, flag, delimiters) {
                        var offset = this.entry.offset + this.entry.save
                          , seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;
                        for (i = 0; i < 3; i++) {
                          parts.push(("0" + Math.floor(seconds / part)).slice(-2));
                          seconds %= part;
                          part /= 60;
                        }
                        if (flag == "^" && !offset) return "Z";
                        if (flag == "^") delimiters = 3;
                        if (delimiters == 3) {
                          z = parts.join(":");
                          z = z.replace(/:00$/, "");
                          if (flag != "^") z = z.replace(/:00$/, "");
                        } else if (delimiters) {
                          z = parts.slice(0, delimiters + 1).join(":");
                          if (flag == "^") z = z.replace(/:00$/, "");
                        } else {
                          z = parts.slice(0, 2).join("");
                        }
                        z = (offset < 0 ? "-" : "+") + z;
                        z = z.replace(/([-+])(0)/, { "_": " $1", "-": "$1" }[flag] || "$1$2");
                        return z;
                      }
                    , "%": function(date) { return "%" }
                    , n: function (date) { return "\n" }
                    , t: function (date) { return "\t" }
                    , U: function (date) { return weekOfYear(date, 0) }
                    , W: function (date) { return weekOfYear(date, 1) }
                    , V: function (date) { return isoWeek(date)[0] }
                    , G: function (date) { return isoWeek(date)[1] }
                    , g: function (date) { return isoWeek(date)[1] % 100 }
                    , j: function (date) { return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 864e5) + 1 }
                    , s: function (date) { return Math.floor(date.getTime() / 1000) }
                    , C: function (date) { return Math.floor(date.getUTCFullYear() / 100) }
                    , N: function (date) { return date.getTime() % 1000 * 1000000 }
                    , m: function (date) { return date.getUTCMonth() + 1 }
                    , Y: function (date) { return date.getUTCFullYear() }
                    , y: function (date) { return date.getUTCFullYear() % 100 }
                    , H: function (date) { return date.getUTCHours() }
                    , M: function (date) { return date.getUTCMinutes() }
                    , S: function (date) { return date.getUTCSeconds() }
                    , e: function (date) { return date.getUTCDate() }
                    , d: function (date) { return date.getUTCDate() }
                    , u: function (date) { return date.getUTCDay() || 7 }
                    , w: function (date) { return date.getUTCDay() }
                    , l: function (date) { return date.getUTCHours() % 12 || 12 }
                    , I: function (date) { return date.getUTCHours() % 12 || 12 }
                    , k: function (date) { return date.getUTCHours() }
                    , Z: function (date) { return this.entry.abbrev }
                    , a: function (date) { return this[this.locale].day.abbrev[date.getUTCDay()] }
                    , A: function (date) { return this[this.locale].day.full[date.getUTCDay()] }
                    , h: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }
                    , b: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }
                    , B: function (date) { return this[this.locale].month.full[date.getUTCMonth()] }
                    , P: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase() }
                    , p: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)] }
                    , R: function (date, posix) { return this.convert([ posix, "%H:%M" ]) }
                    , T: function (date, posix) { return this.convert([ posix, "%H:%M:%S" ]) }
                    , D: function (date, posix) { return this.convert([ posix, "%m/%d/%y" ]) }
                    , F: function (date, posix) { return this.convert([ posix, "%Y-%m-%d" ]) }
                    , x: function (date, posix) { return this.convert([ posix, this[this.locale].date ]) }
                    , r: function (date, posix) { return this.convert([ posix, this[this.locale].time12 || '%I:%M:%S' ]) }
                    , X: function (date, posix) { return this.convert([ posix, this[this.locale].time24 ]) }
                    , c: function (date, posix) { return this.convert([ posix, this[this.locale].dateTime ]) }
                    , convert: convert
                    , locale: "en_US"
                    , en_US: {
                        date: "%m/%d/%Y",
                        time24: "%I:%M:%S %p",
                        time12: "%I:%M:%S %p",
                        dateTime: "%a %d %b %Y %I:%M:%S %p %Z",
                        meridiem: [ "AM", "PM" ],
                        month: {
                          abbrev: "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec".split("|"),
                          full: "January|February|March|April|May|June|July|August|September|October|November|December".split("|")
                        },
                        day: {
                          abbrev: "Sun|Mon|Tue|Wed|Thu|Fri|Sat".split("|"),
                          full: "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday".split("|")
                        }
                      }
                    };
                  var UNITS = "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond"
                    , UNIT_RE = new RegExp("^\\s*([+-])(\\d+)\\s+(" + UNITS + ")s?\\s*$", "i")
                    , TIME = [ 36e5, 6e4, 1e3, 1 ]
                    ;
                  UNITS = UNITS.toLowerCase().split("|");
                
                  "delmHMSUWVgCIky".replace(/./g, function (e) { context[e].pad = 2 });
                
                  context.N.pad = 9;
                  context.j.pad = 3;
                
                  context.k.style = "_";
                  context.l.style = "_";
                  context.e.style = "_";
                
                  function weekOfYear (date, startOfWeek) {
                    var diff, nyd, weekStart;
                    nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));
                    diff = Math.floor((date.getTime() - nyd.getTime()) / 864e5);
                    if (nyd.getUTCDay() == startOfWeek) {
                      weekStart = 0;
                    } else {
                      weekStart = 7 - nyd.getUTCDay() + startOfWeek;
                      if (weekStart == 8) {
                        weekStart = 1;
                      }
                    }
                    return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;
                  }
                
                  function isoWeek (date) {
                    var nyd, nyy, week;
                    nyy = date.getUTCFullYear();
                    nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
                    week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);
                    if (!week) {
                      nyy = date.getUTCFullYear() - 1;
                      nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
                      week = nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29) ? 53 : 52;
                      return [week, date.getUTCFullYear() - 1];
                    } else if (week == 53 && !(nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29))) {
                      return [1, date.getUTCFullYear() + 1];
                    } else {
                      return [week, date.getUTCFullYear()];
                    }
                  }
                
                  return function () { return context.convert(arguments) };
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/datetime_tick_formatter',["underscore", "common/collection", "sprintf", "timezone", "common/has_properties", "common/logging"], function(_, Collection, sprintf, tz, HasProperties, Logging) {
                    var DatetimeTickFormatter, DatetimeTickFormatters, logger, _array, _four_digit_year, _ms_dot_us, _ref, _ref1, _strftime, _two_digit_year, _us;
                    logger = Logging.logger;
                    _us = function(t) {
                      return sprintf("%3dus", Math.floor((t % 1) * 1000));
                    };
                    _ms_dot_us = function(t) {
                      var ms, us;
                      ms = Math.floor(((t / 1000) % 1) * 1000);
                      us = Math.floor((t % 1) * 1000);
                      return sprintf("%3d.%3dms", ms, us);
                    };
                    _two_digit_year = function(t) {
                      var dt, year;
                      dt = new Date(t);
                      year = dt.getFullYear();
                      if (dt.getMonth() >= 7) {
                        year += 1;
                      }
                      return sprintf("'%02d", year % 100);
                    };
                    _four_digit_year = function(t) {
                      var dt, year;
                      dt = new Date(t);
                      year = dt.getFullYear();
                      if (dt.getMonth() >= 7) {
                        year += 1;
                      }
                      return sprintf("%d", year);
                    };
                    _array = function(t) {
                      return tz(t, "%Y %m %d %H %M %S").split(/\s+/).map(function(e) {
                        return parseInt(e, 10);
                      });
                    };
                    _strftime = function(t, format) {
                      if (_.isFunction(format)) {
                        return format(t);
                      } else {
                        return tz(t, format);
                      }
                    };
                    DatetimeTickFormatter = (function(_super) {
                      __extends(DatetimeTickFormatter, _super);
                
                      function DatetimeTickFormatter() {
                        _ref = DatetimeTickFormatter.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DatetimeTickFormatter.prototype.type = 'DatetimeTickFormatter';
                
                      DatetimeTickFormatter.prototype.format_order = ['microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes', 'hourmin', 'hours', 'days', 'months', 'years'];
                
                      DatetimeTickFormatter.prototype._formats = {
                        'microseconds': [_us, _ms_dot_us],
                        'milliseconds': ['%3Nms', '%S.%3Ns'],
                        'seconds': ['%Ss'],
                        'minsec': [':%M:%S'],
                        'minutes': [':%M', '%Mm'],
                        'hourmin': ['%H:%M'],
                        'hours': ['%Hh', '%H:%M'],
                        'days': ['%m/%d', '%a%d'],
                        'months': ['%m/%Y', '%b%y'],
                        'years': ['%Y', _two_digit_year, _four_digit_year]
                      };
                
                      DatetimeTickFormatter.prototype.strip_leading_zeros = true;
                
                      DatetimeTickFormatter.prototype.initialize = function(attrs, options) {
                        var fmt, fmt_name, fmt_string, fmt_strings, now, sizes, sorted, _results;
                        DatetimeTickFormatter.__super__.initialize.call(this, attrs, options);
                        fmt = _.extend({}, this._formats, this.get("formats"));
                        now = tz(new Date());
                        this.formats = {};
                        _results = [];
                        for (fmt_name in fmt) {
                          fmt_strings = fmt[fmt_name];
                          sizes = (function() {
                            var _i, _len, _results1;
                            _results1 = [];
                            for (_i = 0, _len = fmt_strings.length; _i < _len; _i++) {
                              fmt_string = fmt_strings[_i];
                              _results1.push(_strftime(now, fmt_string).length);
                            }
                            return _results1;
                          })();
                          sorted = _.sortBy(_.zip(sizes, fmt_strings), function(_arg) {
                            var fmt, size;
                            size = _arg[0], fmt = _arg[1];
                            return size;
                          });
                          _results.push(this.formats[fmt_name] = _.zip.apply(_, sorted));
                        }
                        return _results;
                      };
                
                      DatetimeTickFormatter.prototype._get_resolution_str = function(resolution_secs, span_secs) {
                        var adjusted_resolution_secs, str;
                        adjusted_resolution_secs = resolution_secs * 1.1;
                        if (adjusted_resolution_secs < 1e-3) {
                          str = "microseconds";
                        } else if (adjusted_resolution_secs < 1.0) {
                          str = "milliseconds";
                        } else if (adjusted_resolution_secs < 60) {
                          if (span_secs >= 60) {
                            str = "minsec";
                          } else {
                            str = "seconds";
                          }
                        } else if (adjusted_resolution_secs < 3600) {
                          if (span_secs >= 3600) {
                            str = "hourmin";
                          } else {
                            str = "minutes";
                          }
                        } else if (adjusted_resolution_secs < 24 * 3600) {
                          str = "hours";
                        } else if (adjusted_resolution_secs < 31 * 24 * 3600) {
                          str = "days";
                        } else if (adjusted_resolution_secs < 365 * 24 * 3600) {
                          str = "months";
                        } else {
                          str = "years";
                        }
                        return str;
                      };
                
                      DatetimeTickFormatter.prototype.format = function(ticks, num_labels, char_width, fill_ratio, ticker) {
                        var error, fmt, format, formats, good_formats, hybrid_handled, i, labels, next_format, next_ndx, r, resol, resol_ndx, s, span, ss, t, time_tuple_ndx_for_resol, tm, widths, _i, _j, _k, _len, _len1, _ref1, _ref2, _ref3;
                        if (num_labels == null) {
                          num_labels = null;
                        }
                        if (char_width == null) {
                          char_width = null;
                        }
                        if (fill_ratio == null) {
                          fill_ratio = 0.3;
                        }
                        if (ticker == null) {
                          ticker = null;
                        }
                        if (ticks.length === 0) {
                          return [];
                        }
                        span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000.0;
                        if (ticker) {
                          r = ticker.resolution;
                        } else {
                          r = span / (ticks.length - 1);
                        }
                        resol = this._get_resolution_str(r, span);
                        _ref1 = this.formats[resol], widths = _ref1[0], formats = _ref1[1];
                        format = formats[0];
                        if (char_width) {
                          good_formats = [];
                          for (i = _i = 0, _ref2 = widths.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                            if (widths[i] * ticks.length < fill_ratio * char_width) {
                              good_formats.push(this.formats[i]);
                            }
                          }
                          if (good_formats.length > 0) {
                            format = _.last(good_formats);
                          }
                        }
                        labels = [];
                        resol_ndx = this.format_order.indexOf(resol);
                        time_tuple_ndx_for_resol = {};
                        _ref3 = this.format_order;
                        for (_j = 0, _len = _ref3.length; _j < _len; _j++) {
                          fmt = _ref3[_j];
                          time_tuple_ndx_for_resol[fmt] = 0;
                        }
                        time_tuple_ndx_for_resol["seconds"] = 5;
                        time_tuple_ndx_for_resol["minsec"] = 4;
                        time_tuple_ndx_for_resol["minutes"] = 4;
                        time_tuple_ndx_for_resol["hourmin"] = 3;
                        time_tuple_ndx_for_resol["hours"] = 3;
                        for (_k = 0, _len1 = ticks.length; _k < _len1; _k++) {
                          t = ticks[_k];
                          try {
                            tm = _array(t);
                            s = _strftime(t, format);
                          } catch (_error) {
                            error = _error;
                            logger.warn("unable to format tick for timestamp value " + t);
                            logger.warn(" - " + error);
                            labels.push("ERR");
                            continue;
                          }
                          hybrid_handled = false;
                          next_ndx = resol_ndx;
                          while (tm[time_tuple_ndx_for_resol[this.format_order[next_ndx]]] === 0) {
                            next_ndx += 1;
                            if (next_ndx === this.format_order.length) {
                              break;
                            }
                            if ((resol === "minsec" || resol === "hourmin") && !hybrid_handled) {
                              if ((resol === "minsec" && tm[4] === 0 && tm[5] !== 0) || (resol === "hourmin" && tm[3] === 0 && tm[4] !== 0)) {
                                next_format = this.formats[this.format_order[resol_ndx - 1]][1][0];
                                s = _strftime(t, next_format);
                                break;
                              } else {
                                hybrid_handled = true;
                              }
                            }
                            next_format = this.formats[this.format_order[next_ndx]][1][0];
                            s = _strftime(t, next_format);
                          }
                          if (this.strip_leading_zeros) {
                            ss = s.replace(/^0+/g, "");
                            if (ss !== s && (ss === '' || !isFinite(ss[0]))) {
                              ss = '0' + ss;
                            }
                            labels.push(ss);
                          } else {
                            labels.push(s);
                          }
                        }
                        return labels;
                      };
                
                      DatetimeTickFormatter.prototype.defaults = function() {
                        return _.extend({}, DatetimeTickFormatter.__super__.defaults.call(this), {
                          formats: {}
                        });
                      };
                
                      return DatetimeTickFormatter;
                
                    })(HasProperties);
                    DatetimeTickFormatters = (function(_super) {
                      __extends(DatetimeTickFormatters, _super);
                
                      function DatetimeTickFormatters() {
                        _ref1 = DatetimeTickFormatters.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DatetimeTickFormatters.prototype.model = DatetimeTickFormatter;
                
                      return DatetimeTickFormatters;
                
                    })(Collection);
                    return {
                      "Model": DatetimeTickFormatter,
                      "Collection": new DatetimeTickFormatters()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=datetime_tick_formatter.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/guide/datetime_axis',["common/collection", "./axis", "ticking/datetime_ticker", "ticking/datetime_tick_formatter"], function(Collection, Axis, DatetimeTicker, DatetimeTickFormatter) {
                    var DatetimeAxes, DatetimeAxis, DatetimeAxisView, _ref, _ref1, _ref2;
                    DatetimeAxisView = (function(_super) {
                      __extends(DatetimeAxisView, _super);
                
                      function DatetimeAxisView() {
                        _ref = DatetimeAxisView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      return DatetimeAxisView;
                
                    })(Axis.View);
                    DatetimeAxis = (function(_super) {
                      __extends(DatetimeAxis, _super);
                
                      function DatetimeAxis() {
                        _ref1 = DatetimeAxis.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DatetimeAxis.prototype.default_view = DatetimeAxisView;
                
                      DatetimeAxis.prototype.type = 'DatetimeAxis';
                
                      DatetimeAxis.prototype.initialize = function(attrs, objects) {
                        DatetimeAxis.__super__.initialize.call(this, attrs, objects);
                        if (this.get('ticker') == null) {
                          this.set_obj('ticker', DatetimeTicker.Collection.create());
                        }
                        if (this.get('formatter') == null) {
                          return this.set_obj('formatter', DatetimeTickFormatter.Collection.create());
                        }
                      };
                
                      return DatetimeAxis;
                
                    })(Axis.Model);
                    DatetimeAxes = (function(_super) {
                      __extends(DatetimeAxes, _super);
                
                      function DatetimeAxes() {
                        _ref2 = DatetimeAxes.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      DatetimeAxes.prototype.model = DatetimeAxis;
                
                      return DatetimeAxes;
                
                    })(Collection);
                    return {
                      "Model": DatetimeAxis,
                      "Collection": new DatetimeAxes(),
                      "View": DatetimeAxisView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=datetime_axis.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/guide/grid',["underscore", "common/has_parent", "common/collection", "renderer/properties", "common/plot_widget"], function(_, HasParent, Collection, properties, PlotWidget) {
                    var Grid, GridView, Grids, _ref, _ref1, _ref2;
                    GridView = (function(_super) {
                      __extends(GridView, _super);
                
                      function GridView() {
                        _ref = GridView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      GridView.prototype.initialize = function(attrs, options) {
                        GridView.__super__.initialize.call(this, attrs, options);
                        this.grid_props = new properties.Line(this, 'grid_');
                        this.x_range_name = this.mget('x_range_name');
                        return this.y_range_name = this.mget('y_range_name');
                      };
                
                      GridView.prototype.render = function() {
                        var ctx;
                        ctx = this.plot_view.canvas_view.ctx;
                        ctx.save();
                        this._draw_grids(ctx);
                        return ctx.restore();
                      };
                
                      GridView.prototype.bind_bokeh_events = function() {
                        return this.listenTo(this.model, 'change', this.request_render);
                      };
                
                      GridView.prototype._draw_grids = function(ctx) {
                        var i, sx, sy, xs, ys, _i, _j, _ref1, _ref2, _ref3, _ref4;
                        if (!this.grid_props.do_stroke) {
                          return;
                        }
                        _ref1 = this.mget('grid_coords'), xs = _ref1[0], ys = _ref1[1];
                        this.grid_props.set(ctx, this);
                        for (i = _i = 0, _ref2 = xs.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
                          _ref3 = this.plot_view.map_to_screen(xs[i], "data", ys[i], "data", this.x_range_name, this.y_range_name), sx = _ref3[0], sy = _ref3[1];
                          ctx.beginPath();
                          ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));
                          for (i = _j = 1, _ref4 = sx.length; 1 <= _ref4 ? _j < _ref4 : _j > _ref4; i = 1 <= _ref4 ? ++_j : --_j) {
                            ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));
                          }
                          ctx.stroke();
                        }
                      };
                
                      return GridView;
                
                    })(PlotWidget);
                    Grid = (function(_super) {
                      __extends(Grid, _super);
                
                      function Grid() {
                        _ref1 = Grid.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Grid.prototype.default_view = GridView;
                
                      Grid.prototype.type = 'Grid';
                
                      Grid.prototype.initialize = function(attrs, options) {
                        Grid.__super__.initialize.call(this, attrs, options);
                        this.register_property('computed_bounds', this._bounds, false);
                        this.add_dependencies('computed_bounds', this, ['bounds']);
                        this.register_property('grid_coords', this._grid_coords, false);
                        this.add_dependencies('grid_coords', this, ['computed_bounds', 'dimension', 'ticker']);
                        return this.register_property('ranges', this._ranges, true);
                      };
                
                      Grid.prototype._ranges = function() {
                        var frame, i, j, ranges;
                        i = this.get('dimension');
                        j = (i + 1) % 2;
                        frame = this.get('plot').get('frame');
                        ranges = [frame.get('x_ranges')[this.get('x_range_name')], frame.get('y_ranges')[this.get('y_range_name')]];
                        return [ranges[i], ranges[j]];
                      };
                
                      Grid.prototype._bounds = function() {
                        var cross_range, end, range, range_bounds, start, user_bounds, _ref2, _ref3;
                        _ref2 = this.get('ranges'), range = _ref2[0], cross_range = _ref2[1];
                        user_bounds = (_ref3 = this.get('bounds')) != null ? _ref3 : 'auto';
                        range_bounds = [range.get('min'), range.get('max')];
                        if (_.isArray(user_bounds)) {
                          start = Math.min(user_bounds[0], user_bounds[1]);
                          end = Math.max(user_bounds[0], user_bounds[1]);
                          if (start < range_bounds[0]) {
                            start = range_bounds[0];
                          } else if (start > range_bounds[1]) {
                            start = null;
                          }
                          if (end > range_bounds[1]) {
                            end = range_bounds[1];
                          } else if (end < range_bounds[0]) {
                            end = null;
                          }
                        } else {
                          start = range_bounds[0], end = range_bounds[1];
                        }
                        return [start, end];
                      };
                
                      Grid.prototype._grid_coords = function() {
                        var N, cmax, cmin, coords, cross_range, dim_i, dim_j, end, i, ii, j, loc, max, min, n, range, start, ticks, tmp, _i, _j, _ref2, _ref3, _ref4;
                        i = this.get('dimension');
                        j = (i + 1) % 2;
                        _ref2 = this.get('ranges'), range = _ref2[0], cross_range = _ref2[1];
                        _ref3 = this.get('computed_bounds'), start = _ref3[0], end = _ref3[1];
                        tmp = Math.min(start, end);
                        end = Math.max(start, end);
                        start = tmp;
                        ticks = this.get('ticker').get_ticks(start, end, range, {}).major;
                        min = range.get('min');
                        max = range.get('max');
                        cmin = cross_range.get('min');
                        cmax = cross_range.get('max');
                        coords = [[], []];
                        for (ii = _i = 0, _ref4 = ticks.length; 0 <= _ref4 ? _i < _ref4 : _i > _ref4; ii = 0 <= _ref4 ? ++_i : --_i) {
                          if (ticks[ii] === min || ticks[ii] === max) {
                            continue;
                          }
                          dim_i = [];
                          dim_j = [];
                          N = 2;
                          for (n = _j = 0; 0 <= N ? _j < N : _j > N; n = 0 <= N ? ++_j : --_j) {
                            loc = cmin + (cmax - cmin) / (N - 1) * n;
                            dim_i.push(ticks[ii]);
                            dim_j.push(loc);
                          }
                          coords[i].push(dim_i);
                          coords[j].push(dim_j);
                        }
                        return coords;
                      };
                
                      Grid.prototype.defaults = function() {
                        return _.extend({}, Grid.__super__.defaults.call(this), {
                          x_range_name: "default",
                          y_range_name: "default"
                        });
                      };
                
                      Grid.prototype.display_defaults = function() {
                        return _.extend({}, Grid.__super__.display_defaults.call(this), {
                          level: 'underlay',
                          grid_line_color: '#cccccc',
                          grid_line_width: 1,
                          grid_line_alpha: 1.0,
                          grid_line_join: 'miter',
                          grid_line_cap: 'butt',
                          grid_line_dash: [],
                          grid_line_dash_offset: 0
                        });
                      };
                
                      return Grid;
                
                    })(HasParent);
                    Grids = (function(_super) {
                      __extends(Grids, _super);
                
                      function Grids() {
                        _ref2 = Grids.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Grids.prototype.model = Grid;
                
                      return Grids;
                
                    })(Collection);
                    return {
                      "Model": Grid,
                      "Collection": new Grids(),
                      "View": GridView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=grid.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/basic_tick_formatter',["underscore", "common/collection", "common/has_properties"], function(_, Collection, HasProperties) {
                    var BasicTickFormatter, BasicTickFormatters, _ref, _ref1;
                    BasicTickFormatter = (function(_super) {
                      __extends(BasicTickFormatter, _super);
                
                      function BasicTickFormatter() {
                        _ref = BasicTickFormatter.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      BasicTickFormatter.prototype.type = 'BasicTickFormatter';
                
                      BasicTickFormatter.prototype.initialize = function(attrs, options) {
                        BasicTickFormatter.__super__.initialize.call(this, attrs, options);
                        this.register_property('scientific_limit_low', function() {
                          return Math.pow(10.0, this.get('power_limit_low'));
                        }, true);
                        this.add_dependencies('scientific_limit_low', this, ['power_limit_low']);
                        this.register_property('scientific_limit_high', function() {
                          return Math.pow(10.0, this.get('power_limit_high'));
                        }, true);
                        this.add_dependencies('scientific_limit_high', this, ['power_limit_high']);
                        return this.last_precision = 3;
                      };
                
                      BasicTickFormatter.prototype.format = function(ticks) {
                        var i, is_ok, labels, need_sci, precision, tick, tick_abs, x, zero_eps, _i, _j, _k, _l, _len, _m, _n, _ref1, _ref2, _ref3, _ref4, _ref5;
                        if (ticks.length === 0) {
                          return [];
                        }
                        zero_eps = 0;
                        if (ticks.length >= 2) {
                          zero_eps = Math.abs(ticks[1] - ticks[0]) / 10000;
                        }
                        need_sci = false;
                        if (this.get('use_scientific')) {
                          for (_i = 0, _len = ticks.length; _i < _len; _i++) {
                            tick = ticks[_i];
                            tick_abs = Math.abs(tick);
                            if (tick_abs > zero_eps && (tick_abs >= this.get('scientific_limit_high') || tick_abs <= this.get('scientific_limit_low'))) {
                              need_sci = true;
                              break;
                            }
                          }
                        }
                        precision = this.get('precision');
                        if ((precision == null) || _.isNumber(precision)) {
                          labels = new Array(ticks.length);
                          if (need_sci) {
                            for (i = _j = 0, _ref1 = ticks.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                              labels[i] = ticks[i].toExponential(precision || void 0);
                            }
                          } else {
                            for (i = _k = 0, _ref2 = ticks.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
                              labels[i] = ticks[i].toFixed(precision || void 0).replace(/(\.[0-9]*?)0+$/, "$1").replace(/\.$/, "");
                            }
                          }
                          return labels;
                        } else if (precision === 'auto') {
                          labels = new Array(ticks.length);
                          for (x = _l = _ref3 = this.last_precision; _ref3 <= 15 ? _l <= 15 : _l >= 15; x = _ref3 <= 15 ? ++_l : --_l) {
                            is_ok = true;
                            if (need_sci) {
                              for (i = _m = 0, _ref4 = ticks.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
                                labels[i] = ticks[i].toExponential(x);
                                if (i > 0) {
                                  if (labels[i] === labels[i - 1]) {
                                    is_ok = false;
                                    break;
                                  }
                                }
                              }
                              if (is_ok) {
                                break;
                              }
                            } else {
                              for (i = _n = 0, _ref5 = ticks.length; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; i = 0 <= _ref5 ? ++_n : --_n) {
                                labels[i] = ticks[i].toFixed(x).replace(/(\.[0-9]*?)0+$/, "$1").replace(/\.$/, "");
                                if (i > 0) {
                                  if (labels[i] === labels[i - 1]) {
                                    is_ok = false;
                                    break;
                                  }
                                }
                              }
                              if (is_ok) {
                                break;
                              }
                            }
                            if (is_ok) {
                              this.last_precision = x;
                              return labels;
                            }
                          }
                        }
                        return labels;
                      };
                
                      BasicTickFormatter.prototype.defaults = function() {
                        return _.extend({}, BasicTickFormatter.__super__.defaults.call(this), {
                          precision: 'auto',
                          use_scientific: true,
                          power_limit_high: 5,
                          power_limit_low: -3
                        });
                      };
                
                      return BasicTickFormatter;
                
                    })(HasProperties);
                    BasicTickFormatters = (function(_super) {
                      __extends(BasicTickFormatters, _super);
                
                      function BasicTickFormatters() {
                        _ref1 = BasicTickFormatters.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      BasicTickFormatters.prototype.model = BasicTickFormatter;
                
                      return BasicTickFormatters;
                
                    })(Collection);
                    return {
                      "Model": BasicTickFormatter,
                      "Collection": new BasicTickFormatters()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=basic_tick_formatter.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/guide/linear_axis',["underscore", "common/collection", "./axis", "ticking/basic_ticker", "ticking/basic_tick_formatter"], function(_, Collection, Axis, BasicTicker, BasicTickFormatter) {
                    var LinearAxes, LinearAxis, LinearAxisView, _ref, _ref1, _ref2;
                    LinearAxisView = (function(_super) {
                      __extends(LinearAxisView, _super);
                
                      function LinearAxisView() {
                        _ref = LinearAxisView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      return LinearAxisView;
                
                    })(Axis.View);
                    LinearAxis = (function(_super) {
                      __extends(LinearAxis, _super);
                
                      function LinearAxis() {
                        _ref1 = LinearAxis.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LinearAxis.prototype.default_view = LinearAxisView;
                
                      LinearAxis.prototype.type = 'LinearAxis';
                
                      LinearAxis.prototype.initialize = function(attrs, objects) {
                        LinearAxis.__super__.initialize.call(this, attrs, objects);
                        if (this.get('ticker') == null) {
                          this.set_obj('ticker', BasicTicker.Collection.create());
                        }
                        if (this.get('formatter') == null) {
                          return this.set_obj('formatter', BasicTickFormatter.Collection.create());
                        }
                      };
                
                      return LinearAxis;
                
                    })(Axis.Model);
                    LinearAxes = (function(_super) {
                      __extends(LinearAxes, _super);
                
                      function LinearAxes() {
                        _ref2 = LinearAxes.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      LinearAxes.prototype.model = LinearAxis;
                
                      return LinearAxes;
                
                    })(Collection);
                    return {
                      "Model": LinearAxis,
                      "Collection": new LinearAxes(),
                      "View": LinearAxisView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=linear_axis.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/log_ticker',["common/collection", "ticking/adaptive_ticker"], function(Collection, AdaptiveTicker) {
                    var LogTicker, LogTickers, range, _ref, _ref1;
                    range = function(start, stop, step) {
                      var i, result;
                      if (typeof stop === "undefined") {
                        stop = start;
                        start = 0;
                      }
                      if (typeof step === "undefined") {
                        step = 1;
                      }
                      if ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {
                        return [];
                      }
                      result = [];
                      i = start;
                      while ((step > 0 ? i < stop : i > stop)) {
                        result.push(i);
                        i += step;
                      }
                      return result;
                    };
                    LogTicker = (function(_super) {
                      __extends(LogTicker, _super);
                
                      function LogTicker() {
                        _ref = LogTicker.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LogTicker.prototype.type = 'LogTicker';
                
                      LogTicker.prototype.initialize = function(attrs, options) {
                        return LogTicker.__super__.initialize.call(this, attrs, options);
                      };
                
                      LogTicker.prototype.get_ticks_no_defaults = function(data_low, data_high, desired_n_ticks) {
                        var end_factor, endlog, factor, factors, i, interval, log_high, log_interval, log_low, minor_interval, minor_offsets, minor_ticks, num_minor_ticks, start_factor, startlog, tick, ticks, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref1;
                        num_minor_ticks = this.get('num_minor_ticks');
                        minor_ticks = [];
                        if (data_low <= 0) {
                          data_low = 1;
                        }
                        if (data_low > data_high) {
                          _ref1 = [data_high, data_low], data_low = _ref1[0], data_high = _ref1[1];
                        }
                        log_low = Math.log(data_low) / Math.log(10);
                        log_high = Math.log(data_high) / Math.log(10);
                        log_interval = log_high - log_low;
                        if (log_interval < 2) {
                          interval = this.get_interval(data_low, data_high, desired_n_ticks);
                          start_factor = Math.floor(data_low / interval);
                          end_factor = Math.ceil(data_high / interval);
                          if (_.isNaN(start_factor) || _.isNaN(end_factor)) {
                            factors = [];
                          } else {
                            factors = _.range(start_factor, end_factor + 1);
                          }
                          ticks = (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = factors.length; _i < _len; _i++) {
                              factor = factors[_i];
                              if (factor !== 0) {
                                _results.push(factor * interval);
                              }
                            }
                            return _results;
                          })();
                          if (num_minor_ticks > 1) {
                            minor_interval = interval / num_minor_ticks;
                            minor_offsets = (function() {
                              var _i, _results;
                              _results = [];
                              for (i = _i = 1; 1 <= num_minor_ticks ? _i <= num_minor_ticks : _i >= num_minor_ticks; i = 1 <= num_minor_ticks ? ++_i : --_i) {
                                _results.push(i * minor_interval);
                              }
                              return _results;
                            })();
                            for (_i = 0, _len = minor_offsets.length; _i < _len; _i++) {
                              x = minor_offsets[_i];
                              minor_ticks.push(ticks[0] - x);
                            }
                            for (_j = 0, _len1 = ticks.length; _j < _len1; _j++) {
                              tick = ticks[_j];
                              for (_k = 0, _len2 = minor_offsets.length; _k < _len2; _k++) {
                                x = minor_offsets[_k];
                                minor_ticks.push(tick + x);
                              }
                            }
                          }
                        } else {
                          startlog = Math.ceil(log_low);
                          endlog = Math.floor(log_high);
                          interval = Math.ceil((endlog - startlog) / 9.0);
                          ticks = range(startlog, endlog, interval);
                          if ((endlog - startlog) % interval === 0) {
                            ticks = ticks.concat([endlog]);
                          }
                          ticks = ticks.map(function(i) {
                            return Math.pow(10, i);
                          });
                          if (num_minor_ticks > 1) {
                            minor_interval = Math.pow(10, interval) / num_minor_ticks;
                            minor_offsets = (function() {
                              var _l, _results;
                              _results = [];
                              for (i = _l = 1; 1 <= num_minor_ticks ? _l <= num_minor_ticks : _l >= num_minor_ticks; i = 1 <= num_minor_ticks ? ++_l : --_l) {
                                _results.push(i * minor_interval);
                              }
                              return _results;
                            })();
                            for (_l = 0, _len3 = minor_offsets.length; _l < _len3; _l++) {
                              x = minor_offsets[_l];
                              minor_ticks.push(ticks[0] / x);
                            }
                            for (_m = 0, _len4 = ticks.length; _m < _len4; _m++) {
                              tick = ticks[_m];
                              for (_n = 0, _len5 = minor_offsets.length; _n < _len5; _n++) {
                                x = minor_offsets[_n];
                                minor_ticks.push(tick * x);
                              }
                            }
                          }
                        }
                        return {
                          "major": ticks,
                          "minor": minor_ticks
                        };
                      };
                
                      LogTicker.prototype.defaults = function() {
                        return _.extend({}, LogTicker.__super__.defaults.call(this), {
                          mantissas: [1, 5]
                        });
                      };
                
                      return LogTicker;
                
                    })(AdaptiveTicker.Model);
                    LogTickers = (function(_super) {
                      __extends(LogTickers, _super);
                
                      function LogTickers() {
                        _ref1 = LogTickers.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LogTickers.prototype.model = LogTicker;
                
                      return LogTickers;
                
                    })(Collection);
                    return {
                      "Model": LogTicker,
                      "Collection": new LogTickers()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=log_ticker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('ticking/log_tick_formatter',["underscore", "common/collection", "common/has_properties", "ticking/basic_tick_formatter"], function(_, Collection, HasProperties, BasicTickFormatter) {
                    var LogTickFormatter, LogTickFormatters, _ref, _ref1;
                    LogTickFormatter = (function(_super) {
                      __extends(LogTickFormatter, _super);
                
                      function LogTickFormatter() {
                        _ref = LogTickFormatter.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LogTickFormatter.prototype.type = 'LogTickFormatter';
                
                      LogTickFormatter.prototype.initialize = function(attrs, options) {
                        LogTickFormatter.__super__.initialize.call(this, attrs, options);
                        return this.basic_formatter = new BasicTickFormatter.Model();
                      };
                
                      LogTickFormatter.prototype.format = function(ticks) {
                        var i, labels, small_interval, _i, _ref1;
                        if (ticks.length === 0) {
                          return [];
                        }
                        small_interval = false;
                        labels = new Array(ticks.length);
                        for (i = _i = 0, _ref1 = ticks.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          labels[i] = "10^" + (Math.round(Math.log(ticks[i]) / Math.log(10)));
                          if ((i > 0) && (labels[i] === labels[i - 1])) {
                            small_interval = true;
                            break;
                          }
                        }
                        if (small_interval) {
                          labels = this.basic_formatter.format(ticks);
                        }
                        return labels;
                      };
                
                      return LogTickFormatter;
                
                    })(HasProperties);
                    LogTickFormatters = (function(_super) {
                      __extends(LogTickFormatters, _super);
                
                      function LogTickFormatters() {
                        _ref1 = LogTickFormatters.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LogTickFormatters.prototype.model = LogTickFormatter;
                
                      return LogTickFormatters;
                
                    })(Collection);
                    return {
                      "Model": LogTickFormatter,
                      "Collection": new LogTickFormatters()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=log_tick_formatter.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/guide/log_axis',["underscore", "common/collection", "./axis", "ticking/log_ticker", "ticking/log_tick_formatter"], function(_, Collection, Axis, LogTicker, LogTickFormatter) {
                    var LogAxes, LogAxis, LogAxisView, _ref, _ref1, _ref2;
                    LogAxisView = (function(_super) {
                      __extends(LogAxisView, _super);
                
                      function LogAxisView() {
                        _ref = LogAxisView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      return LogAxisView;
                
                    })(Axis.View);
                    LogAxis = (function(_super) {
                      __extends(LogAxis, _super);
                
                      function LogAxis() {
                        _ref1 = LogAxis.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LogAxis.prototype.default_view = LogAxisView;
                
                      LogAxis.prototype.type = 'LogAxis';
                
                      LogAxis.prototype.initialize = function(attrs, objects) {
                        LogAxis.__super__.initialize.call(this, attrs, objects);
                        if (this.get('ticker') == null) {
                          this.set_obj('ticker', LogTicker.Collection.create());
                        }
                        if (this.get('formatter') == null) {
                          return this.set_obj('formatter', LogTickFormatter.Collection.create());
                        }
                      };
                
                      return LogAxis;
                
                    })(Axis.Model);
                    LogAxes = (function(_super) {
                      __extends(LogAxes, _super);
                
                      function LogAxes() {
                        _ref2 = LogAxes.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      LogAxes.prototype.model = LogAxis;
                
                      return LogAxes;
                
                    })(Collection);
                    return {
                      "Model": LogAxis,
                      "Collection": new LogAxes(),
                      "View": LogAxisView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=log_axis.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/overlay/box_selection',["underscore", "common/has_parent", "common/collection", "common/plot_widget"], function(_, HasParent, Collection, PlotWidget) {
                    var BoxSelection, BoxSelectionView, BoxSelections, _ref, _ref1, _ref2;
                    BoxSelectionView = (function(_super) {
                      __extends(BoxSelectionView, _super);
                
                      function BoxSelectionView() {
                        _ref = BoxSelectionView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      BoxSelectionView.prototype.initialize = function(options) {
                        BoxSelectionView.__super__.initialize.call(this, options);
                        this.$el.appendTo(this.plot_view.$el.find('div.bk-canvas-overlays'));
                        this.$el.addClass('shading');
                        return this.$el.hide();
                      };
                
                      BoxSelectionView.prototype.bind_bokeh_events = function() {
                        return this.listenTo(this.model, 'change:data', this._draw_box);
                      };
                
                      BoxSelectionView.prototype.render = function() {
                        this._draw_box();
                        return this;
                      };
                
                      BoxSelectionView.prototype._draw_box = function() {
                        var canvas, data, sh, style, sw, sx, sy, vxlim, vylim;
                        data = this.mget('data');
                        if (_.isEmpty(data)) {
                          this.$el.hide();
                          return;
                        }
                        vxlim = data.vxlim;
                        vylim = data.vylim;
                        canvas = this.plot_view.canvas;
                        sx = Math.min(canvas.vx_to_sx(vxlim[0]), canvas.vx_to_sx(vxlim[1]));
                        sy = Math.min(canvas.vy_to_sy(vylim[0]), canvas.vy_to_sy(vylim[1]));
                        sw = Math.abs(vxlim[1] - vxlim[0]);
                        sh = Math.abs(vylim[1] - vylim[0]);
                        style = "left:" + sx + "px; width:" + sw + "px; top:" + sy + "px; height:" + sh + "px";
                        this.$el.attr('style', style);
                        return this.$el.show();
                      };
                
                      return BoxSelectionView;
                
                    })(PlotWidget);
                    BoxSelection = (function(_super) {
                      __extends(BoxSelection, _super);
                
                      function BoxSelection() {
                        _ref1 = BoxSelection.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      BoxSelection.prototype.default_view = BoxSelectionView;
                
                      BoxSelection.prototype.type = "BoxSelection";
                
                      BoxSelection.prototype.defaults = function() {
                        return _.extend({}, BoxSelection.__super__.defaults.call(this), {
                          level: 'overlay',
                          data: {}
                        });
                      };
                
                      return BoxSelection;
                
                    })(HasParent);
                    BoxSelections = (function(_super) {
                      __extends(BoxSelections, _super);
                
                      function BoxSelections() {
                        _ref2 = BoxSelections.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      BoxSelections.prototype.model = BoxSelection;
                
                      return BoxSelections;
                
                    })(Collection);
                    return {
                      "Model": BoxSelection,
                      "Collection": new BoxSelections(),
                      "View": BoxSelectionView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=box_selection.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('renderer/overlay/poly_selection',["underscore", "common/has_parent", "common/collection", "common/plot_widget", "renderer/properties"], function(_, HasParent, Collection, PlotWidget, properties) {
                    var PolySelection, PolySelectionView, PolySelections, _ref, _ref1, _ref2;
                    PolySelectionView = (function(_super) {
                      __extends(PolySelectionView, _super);
                
                      function PolySelectionView() {
                        _ref = PolySelectionView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PolySelectionView.prototype.initialize = function(options) {
                        PolySelectionView.__super__.initialize.call(this, options);
                        return this.props = {
                          line: new properties.Line(this),
                          fill: new properties.Fill(this)
                        };
                      };
                
                      PolySelectionView.prototype.bind_bokeh_events = function() {
                        return this.listenTo(this.model, 'change:data', this.plot_view.request_render);
                      };
                
                      PolySelectionView.prototype.render = function(ctx) {
                        var canvas, data, i, sx, sy, _i, _ref1;
                        data = _.clone(this.mget('data'));
                        if (_.isEmpty(data) || (data == null)) {
                          return null;
                        }
                        canvas = this.plot_view.canvas;
                        ctx = this.plot_view.canvas_view.ctx;
                        for (i = _i = 0, _ref1 = data.vx.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          sx = canvas.vx_to_sx(data.vx[i]);
                          sy = canvas.vy_to_sy(data.vy[i]);
                          if (i === 0) {
                            ctx.beginPath();
                            ctx.moveTo(sx, sy);
                          } else {
                            ctx.lineTo(sx, sy);
                          }
                        }
                        if (this.mget('auto_close')) {
                          ctx.closePath();
                        }
                        if (this.props.line.do_stroke) {
                          this.props.line.set(ctx);
                          ctx.stroke();
                        }
                        if (this.props.fill.do_fill && this.mget('auto_close')) {
                          this.props.fill.set(ctx);
                          return ctx.fill();
                        }
                      };
                
                      return PolySelectionView;
                
                    })(PlotWidget);
                    PolySelection = (function(_super) {
                      __extends(PolySelection, _super);
                
                      function PolySelection() {
                        _ref1 = PolySelection.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      PolySelection.prototype.default_view = PolySelectionView;
                
                      PolySelection.prototype.type = "PolySelection";
                
                      PolySelection.prototype.display_defaults = function() {
                        return _.extend({}, PolySelection.__super__.display_defaults.call(this), {
                          fill_color: null,
                          fill_alpha: 0.2,
                          line_color: 'grey',
                          line_width: 2,
                          line_alpha: 0.8,
                          line_join: 'miter',
                          line_cap: 'butt',
                          line_dash: [4],
                          line_dash_offset: 0
                        });
                      };
                
                      PolySelection.prototype.defaults = function() {
                        return _.extend({}, PolySelection.__super__.defaults.call(this), {
                          level: 'overlay',
                          auto_close: true,
                          data: {}
                        });
                      };
                
                      return PolySelection;
                
                    })(HasParent);
                    PolySelections = (function(_super) {
                      __extends(PolySelections, _super);
                
                      function PolySelections() {
                        _ref2 = PolySelections.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      PolySelections.prototype.model = PolySelection;
                
                      return PolySelections;
                
                    })(Collection);
                    return {
                      "Model": PolySelection,
                      "Collection": new PolySelections(),
                      "View": PolySelectionView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=poly_selection.js.map
                */;
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('source/column_data_source',["underscore", "common/collection", "common/has_properties", "common/selection_manager"], function(_, Collection, HasProperties, SelectionManager) {
                    var ColumnDataSource, ColumnDataSources, _ref, _ref1;
                    ColumnDataSource = (function(_super) {
                      __extends(ColumnDataSource, _super);
                
                      function ColumnDataSource() {
                        this.defaults = __bind(this.defaults, this);
                        _ref = ColumnDataSource.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ColumnDataSource.prototype.type = 'ColumnDataSource';
                
                      ColumnDataSource.prototype.get_column = function(colname) {
                        var _ref1;
                        return (_ref1 = this.get('data')[colname]) != null ? _ref1 : null;
                      };
                
                      ColumnDataSource.prototype.get_length = function() {
                        var data;
                        data = this.get('data');
                        if (_.keys(data).length === 0) {
                          return 0;
                        }
                        return data[_.keys(data)[0]].length;
                      };
                
                      ColumnDataSource.prototype.columns = function() {
                        return _.keys(this.get('data'));
                      };
                
                      ColumnDataSource.prototype.datapoints = function() {
                        var data, field, fields, i, point, points, _i, _j, _len, _ref1;
                        data = this.get('data');
                        fields = _.keys(data);
                        if (fields.length === 0) {
                          return [];
                        }
                        points = [];
                        for (i = _i = 0, _ref1 = data[fields[0]].length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                          point = {};
                          for (_j = 0, _len = fields.length; _j < _len; _j++) {
                            field = fields[_j];
                            point[field] = data[field][i];
                          }
                          points.push(point);
                        }
                        return points;
                      };
                
                      ColumnDataSource.prototype.defaults = function() {
                        return _.extend({}, ColumnDataSource.__super__.defaults.call(this), {
                          data: {},
                          selection_manager: new SelectionManager({
                            'source': this
                          })
                        });
                      };
                
                      return ColumnDataSource;
                
                    })(HasProperties);
                    ColumnDataSources = (function(_super) {
                      __extends(ColumnDataSources, _super);
                
                      function ColumnDataSources() {
                        _ref1 = ColumnDataSources.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ColumnDataSources.prototype.model = ColumnDataSource;
                
                      return ColumnDataSources;
                
                    })(Collection);
                    return {
                      "Model": ColumnDataSource,
                      "Collection": new ColumnDataSources()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=column_data_source.js.map
                */;
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('source/server_data_source',["underscore", "common/collection", "common/has_properties", "common/logging", "range/range1d", "range/data_range1d"], function(_, Collection, HasProperties, Logging, Range1d, DataRange1d) {
                    var ServerDataSource, ServerDataSources, ajax_throttle, logger, _ref, _ref1;
                    logger = Logging.logger;
                    ajax_throttle = function(func) {
                      var busy, callback, has_callback, resp;
                      busy = false;
                      resp = null;
                      has_callback = false;
                      callback = function() {
                        if (busy) {
                          if (has_callback) {
                            return logger.debug('already bound, ignoring');
                          } else {
                            logger.debug('busy, so doing it later');
                            has_callback = true;
                            return resp.done(function() {
                              has_callback = false;
                              return callback();
                            });
                          }
                        } else {
                          logger.debug('executing');
                          busy = true;
                          resp = func();
                          return resp.done(function() {
                            logger.debug('done, setting to false');
                            busy = false;
                            return resp = null;
                          });
                        }
                      };
                      return callback;
                    };
                    ServerDataSource = (function(_super) {
                      __extends(ServerDataSource, _super);
                
                      function ServerDataSource() {
                        this.heatmap_update = __bind(this.heatmap_update, this);
                        this.line1d_update = __bind(this.line1d_update, this);
                        this.initialize = __bind(this.initialize, this);
                        _ref = ServerDataSource.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ServerDataSource.prototype.type = 'ServerDataSource';
                
                      ServerDataSource.prototype.initialize = function(attrs, options) {
                        ServerDataSource.__super__.initialize.call(this, attrs, options);
                        return this.callbacks = {};
                      };
                
                      ServerDataSource.prototype.stoplistening_for_updates = function(column_data_source) {
                        var entry, _i, _len, _ref1, _results;
                        if (this.callbacks[column_data_source.get('id')]) {
                          _ref1 = this.callbacks[column_data_source.get('id')];
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            entry = _ref1[_i];
                            _results.push(this.stopListening.apply(this, entry));
                          }
                          return _results;
                        }
                      };
                
                      ServerDataSource.prototype.update_url = function() {
                        var owner_username, prefix, url;
                        owner_username = this.get('owner_username');
                        prefix = this.get_base().Config.prefix;
                        return url = "" + prefix + "bokeh/data/" + owner_username + "/" + (this.get('doc')) + "/" + (this.get('id'));
                      };
                
                      ServerDataSource.prototype.listen_for_line1d_updates = function(column_data_source, plot_x_span, plot_y_span, domain_span, range_span, screen_span, primary_column, domain_name, columns, input_params) {
                        var callback, plot_state, throttle,
                          _this = this;
                        plot_state = {
                          screen_x: plot_x_span,
                          screen_y: plot_y_span
                        };
                        this.stoplistening_for_updates(column_data_source);
                        this.line1d_update(column_data_source, plot_state, domain_span, range_span, screen_span, primary_column, domain_name, columns, input_params);
                        throttle = _.throttle(this.line1d_update, 300);
                        callback = function() {
                          return throttle(column_data_source, plot_state, domain_span, range_span, screen_span, primary_column, domain_name, columns, input_params);
                        };
                        this.listenTo(screen_span, 'change', callback);
                        this.listenTo(domain_span, 'change', callback);
                        return this.callbacks[column_data_source.get('id')] = [[screen_span, 'change', callback], [domain_span, 'change', callback]];
                      };
                
                      ServerDataSource.prototype.line1d_update = function(column_data_source, plot_state, domain_span, range_span, screen_span, primary_column, domain_name, columns, input_params) {
                        var domain_limit, domain_resolution, params, range_limit;
                        domain_resolution = (screen_span.get('end') - screen_span.get('start')) / 2;
                        domain_resolution = Math.floor(domain_resolution);
                        domain_limit = [domain_span.get('start'), domain_span.get('end')];
                        range_limit = [range_span.get('start'), range_span.get('end')];
                        if (plot_state['screen_x'].get('start') === plot_state['screen_x'].get('end') || plot_state['screen_y'].get('start') === plot_state['screen_y'].get('end') || domain_limit[0] > domain_limit[1] || range_limit[0] > range_limit[1]) {
                          return $.ajax();
                        }
                        if (_.any(_.map(domain_limit, function(x) {
                          return _.isNaN(x);
                        })) || _.every(_.map(domain_limit, function(x) {
                          return _.isEqual(0, x);
                        }))) {
                          domain_limit = 'auto';
                        }
                        if (_.any(_.map(range_limit, function(x) {
                          return _.isNaN(x);
                        })) || _.every(_.map(range_limit, function(x) {
                          return _.isEqual(0, x);
                        }))) {
                          range_limit = 'auto';
                        }
                        params = [primary_column, domain_name, columns, domain_limit, range_limit, domain_resolution, input_params];
                        return $.ajax({
                          dataType: 'json',
                          url: this.update_url(),
                          xhrField: {
                            withCredentials: true
                          },
                          success: function(data) {
                            if (domain_limit === 'auto') {
                              domain_span.set({
                                start: data.domain_limit[0],
                                end: data.domain_limit[1]
                              });
                            }
                            if (range_limit === 'auto') {
                              range_span.set({
                                start: data.range_limit[0],
                                end: data.range_limit[1]
                              });
                            }
                            return column_data_source.set('data', data.data);
                          },
                          data: {
                            resample_parameters: JSON.stringify(params),
                            plot_state: JSON.stringify(plot_state)
                          }
                        });
                      };
                
                      ServerDataSource.prototype.listen_for_ar_updates = function(plot_view, column_data_source, plot_x_range, plot_y_range, x_data_range, y_data_range, input_params) {
                        var callback, param, plot_state, _i, _len, _ref1,
                          _this = this;
                        plot_state = {
                          data_x: x_data_range,
                          data_y: y_data_range,
                          screen_x: plot_x_range,
                          screen_y: plot_y_range
                        };
                        this.stoplistening_for_updates(column_data_source);
                        callback = ajax_throttle(function() {
                          return _this.ar_update(plot_view, column_data_source, plot_state, input_params);
                        });
                        callback();
                        this.callbacks[column_data_source.get('id')] = [];
                        _ref1 = [x_data_range, y_data_range, plot_x_range, plot_y_range];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          param = _ref1[_i];
                          this.listenTo(param, 'change', callback);
                          this.callbacks[column_data_source.get('id')].push([param, 'change', callback]);
                        }
                        this.listenTo(this, 'change:index_slice', callback);
                        this.callbacks[column_data_source.get('id')].push([this, 'change:index_slice', callback]);
                        this.listenTo(this, 'change:data_slice', callback);
                        this.callbacks[column_data_source.get('id')].push([this, 'change:data_slice', callback]);
                        return null;
                      };
                
                      ServerDataSource.prototype.ar_update = function(plot_view, column_data_source, plot_state, input_params) {
                        var domain_limit, item, key, proxy, render_state, resp, sendable_plot_state;
                        domain_limit = 'not auto';
                        render_state = column_data_source.get('data')['render_state'];
                        if (!render_state) {
                          render_state = {};
                        }
                        if (plot_state['screen_x'].get('start') === plot_state['screen_x'].get('end') || plot_state['screen_y'].get('start') === plot_state['screen_y'].get('end')) {
                          logger.debug("skipping due to under-defined view state");
                          return $.ajax();
                        }
                        if (plot_view.x_range.get('start') === plot_view.x_range.get('end') || _.isNaN(plot_view.x_range.get('start')) || _.isNaN(plot_view.x_range.get('end')) || plot_view.y_range.get('start') === plot_view.y_range.get('end') || _.isNaN(plot_view.y_range.get('start')) || _.isNaN(plot_view.y_range.get('end'))) {
                          domain_limit = 'auto';
                        }
                        sendable_plot_state = {};
                        for (key in plot_state) {
                          item = plot_state[key];
                          proxy = new Range1d.Model();
                          proxy.set('start', item.get('start'));
                          proxy.set('end', item.get('end'));
                          sendable_plot_state[key] = proxy;
                        }
                        logger.debug("Sent render State", render_state);
                        resp = $.ajax({
                          dataType: 'json',
                          url: this.update_url(),
                          xhrField: {
                            withCredentials: true
                          },
                          success: function(data) {
                            var new_data;
                            if (data.render_state === "NO UPDATE") {
                              logger.info("No update");
                              return;
                            }
                            if (domain_limit === 'auto') {
                              plot_state['data_x'].set({
                                start: data.x_range.start,
                                end: data.x_range.end
                              });
                              plot_state['data_y'].set({
                                start: data.y_range.start,
                                end: data.y_range.end
                              });
                            }
                            logger.debug("New render State:", data.render_state);
                            new_data = _.clone(column_data_source.get('data'));
                            _.extend(new_data, data);
                            column_data_source.set('data', new_data);
                            return plot_view.request_render();
                          },
                          data: {
                            resample_parameters: JSON.stringify([input_params]),
                            plot_state: JSON.stringify(sendable_plot_state),
                            render_state: JSON.stringify(render_state)
                          }
                        });
                        return resp;
                      };
                
                      ServerDataSource.prototype.listen_for_heatmap_updates = function(column_data_source, plot_x_range, plot_y_range, x_data_range, y_data_range, input_params) {
                        var callback, param, plot_state, _i, _len, _ref1,
                          _this = this;
                        plot_state = {
                          data_x: x_data_range,
                          data_y: y_data_range,
                          screen_x: plot_x_range,
                          screen_y: plot_y_range
                        };
                        this.stoplistening_for_updates(column_data_source);
                        callback = ajax_throttle(function() {
                          return _this.heatmap_update(column_data_source, plot_state, input_params);
                        });
                        callback();
                        this.callbacks[column_data_source.get('id')] = [];
                        _ref1 = [x_data_range, y_data_range, plot_x_range, plot_y_range];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          param = _ref1[_i];
                          this.listenTo(param, 'change', callback);
                          this.callbacks[column_data_source.get('id')].push([param, 'change', callback]);
                        }
                        this.listenTo(this, 'change:index_slice', callback);
                        this.callbacks[column_data_source.get('id')].push([this, 'change:index_slice', callback]);
                        this.listenTo(this, 'change:data_slice', callback);
                        this.callbacks[column_data_source.get('id')].push([this, 'change:data_slice', callback]);
                        return null;
                      };
                
                      ServerDataSource.prototype.heatmap_update = function(column_data_source, plot_state, input_params) {
                        var data_slice, global_offset_x, global_offset_y, global_x_range, global_y_range, index_slice, params;
                        global_x_range = this.get('data').global_x_range;
                        global_y_range = this.get('data').global_y_range;
                        global_offset_x = this.get('data').global_offset_x[0];
                        global_offset_y = this.get('data').global_offset_y[0];
                        index_slice = this.get('index_slice');
                        data_slice = this.get('data_slice');
                        if (plot_state['screen_x'].get('start') === plot_state['screen_x'].get('end') || plot_state['screen_y'].get('start') === plot_state['screen_y'].get('end')) {
                          logger.debug("skipping due to under-defined view state");
                          return $.ajax();
                        }
                        params = [global_x_range, global_y_range, global_offset_x, global_offset_y, index_slice, data_slice, this.get('transpose'), input_params];
                        return $.ajax({
                          dataType: 'json',
                          url: this.update_url(),
                          xhrField: {
                            withCredentials: true
                          },
                          success: function(data) {
                            var new_data;
                            new_data = _.clone(column_data_source.get('data'));
                            _.extend(new_data, data);
                            return column_data_source.set('data', new_data);
                          },
                          data: {
                            resample_parameters: JSON.stringify(params),
                            plot_state: JSON.stringify(plot_state)
                          }
                        });
                      };
                
                      return ServerDataSource;
                
                    })(HasProperties);
                    ServerDataSources = (function(_super) {
                      __extends(ServerDataSources, _super);
                
                      function ServerDataSources() {
                        _ref1 = ServerDataSources.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ServerDataSources.prototype.model = ServerDataSource;
                
                      return ServerDataSources;
                
                    })(Collection);
                    return {
                      "Model": ServerDataSource,
                      "Collection": new ServerDataSources()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=server_data_source.js.map
                */;
                define('bootstrap/modal',["jquery"], function(jQuery) {
                
                /* ========================================================================
                 * Bootstrap: modal.js v3.1.1
                 * http://getbootstrap.com/javascript/#modals
                 * ========================================================================
                 * Copyright 2011-2014 Twitter, Inc.
                 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
                 * ======================================================================== */
                
                
                +function ($) {
                  
                
                  // MODAL CLASS DEFINITION
                  // ======================
                
                  var Modal = function (element, options) {
                    this.options   = options
                    this.$element  = $(element)
                    this.$backdrop =
                    this.isShown   = null
                
                    if (this.options.remote) {
                      this.$element
                        .find('.bk-bs-modal-content')
                        .load(this.options.remote, $.proxy(function () {
                          this.$element.trigger('loaded.bk-bs.modal')
                        }, this))
                    }
                  }
                
                  Modal.DEFAULTS = {
                    backdrop: true,
                    keyboard: true,
                    show: true
                  }
                
                  Modal.prototype.toggle = function (_relatedTarget) {
                    return this[!this.isShown ? 'show' : 'hide'](_relatedTarget)
                  }
                
                  Modal.prototype.show = function (_relatedTarget) {
                    var that = this
                    var e    = $.Event('show.bk-bs.modal', { relatedTarget: _relatedTarget })
                
                    this.$element.trigger(e)
                
                    if (this.isShown || e.isDefaultPrevented()) return
                
                    this.isShown = true
                
                    this.escape()
                
                    this.$element.on('click.dismiss.bk-bs.modal', '[data-bk-bs-dismiss="modal"]', $.proxy(this.hide, this))
                
                    this.backdrop(function () {
                      var transition = $.support.transition && that.$element.hasClass('bk-bs-fade')
                
                      if (!that.$element.parent().length) {
                        that.$element.appendTo(document.body) // don't move modals dom position
                      }
                
                      that.$element
                        .show()
                        .scrollTop(0)
                
                      if (transition) {
                        that.$element[0].offsetWidth // force reflow
                      }
                
                      that.$element
                        .addClass('bk-bs-in')
                        .attr('aria-hidden', false)
                
                      that.enforceFocus()
                
                      var e = $.Event('shown.bk-bs.modal', { relatedTarget: _relatedTarget })
                
                      transition ?
                        that.$element.find('.bk-bs-modal-dialog') // wait for modal to slide in
                          .one($.support.transition.end, function () {
                            that.$element.focus().trigger(e)
                          })
                          .emulateTransitionEnd(300) :
                        that.$element.focus().trigger(e)
                    })
                  }
                
                  Modal.prototype.hide = function (e) {
                    if (e) e.preventDefault()
                
                    e = $.Event('hide.bk-bs.modal')
                
                    this.$element.trigger(e)
                
                    if (!this.isShown || e.isDefaultPrevented()) return
                
                    this.isShown = false
                
                    this.escape()
                
                    $(document).off('focusin.bk-bs.modal')
                
                    this.$element
                      .removeClass('bk-bs-in')
                      .attr('aria-hidden', true)
                      .off('click.dismiss.bk-bs.modal')
                
                    $.support.transition && this.$element.hasClass('bk-bs-fade') ?
                      this.$element
                        .one($.support.transition.end, $.proxy(this.hideModal, this))
                        .emulateTransitionEnd(300) :
                      this.hideModal()
                  }
                
                  Modal.prototype.enforceFocus = function () {
                    $(document)
                      .off('focusin.bk-bs.modal') // guard against infinite focus loop
                      .on('focusin.bk-bs.modal', $.proxy(function (e) {
                        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                          this.$element.focus()
                        }
                      }, this))
                  }
                
                  Modal.prototype.escape = function () {
                    if (this.isShown && this.options.keyboard) {
                      this.$element.on('keyup.dismiss.bk-bs.modal', $.proxy(function (e) {
                        e.which == 27 && this.hide()
                      }, this))
                    } else if (!this.isShown) {
                      this.$element.off('keyup.dismiss.bk-bs.modal')
                    }
                  }
                
                  Modal.prototype.hideModal = function () {
                    var that = this
                    this.$element.hide()
                    this.backdrop(function () {
                      that.removeBackdrop()
                      that.$element.trigger('hidden.bk-bs.modal')
                    })
                  }
                
                  Modal.prototype.removeBackdrop = function () {
                    this.$backdrop && this.$backdrop.remove()
                    this.$backdrop = null
                  }
                
                  Modal.prototype.backdrop = function (callback) {
                    var animate = this.$element.hasClass('bk-bs-fade') ? 'bk-bs-fade' : ''
                
                    if (this.isShown && this.options.backdrop) {
                      var doAnimate = $.support.transition && animate
                
                      this.$backdrop = $('<div class="bk-bs-modal-backdrop ' + animate + '" />')
                        .appendTo(document.body)
                
                      this.$element.on('click.dismiss.bk-bs.modal', $.proxy(function (e) {
                        if (e.target !== e.currentTarget) return
                        this.options.backdrop == 'static'
                          ? this.$element[0].focus.call(this.$element[0])
                          : this.hide.call(this)
                      }, this))
                
                      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow
                
                      this.$backdrop.addClass('bk-bs-in')
                
                      if (!callback) return
                
                      doAnimate ?
                        this.$backdrop
                          .one($.support.transition.end, callback)
                          .emulateTransitionEnd(150) :
                        callback()
                
                    } else if (!this.isShown && this.$backdrop) {
                      this.$backdrop.removeClass('bk-bs-in')
                
                      $.support.transition && this.$element.hasClass('bk-bs-fade') ?
                        this.$backdrop
                          .one($.support.transition.end, callback)
                          .emulateTransitionEnd(150) :
                        callback()
                
                    } else if (callback) {
                      callback()
                    }
                  }
                
                
                  // MODAL PLUGIN DEFINITION
                  // =======================
                
                  var old = $.fn.modal
                
                  $.fn.modal = function (option, _relatedTarget) {
                    return this.each(function () {
                      var $this   = $(this)
                      var data    = $this.data('bk-bs.modal')
                      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)
                
                      if (!data) $this.data('bk-bs.modal', (data = new Modal(this, options)))
                      if (typeof option == 'string') data[option](_relatedTarget)
                      else if (options.show) data.show(_relatedTarget)
                    })
                  }
                
                  $.fn.modal.Constructor = Modal
                
                
                  // MODAL NO CONFLICT
                  // =================
                
                  $.fn.modal.noConflict = function () {
                    $.fn.modal = old
                    return this
                  }
                
                
                  // MODAL DATA-API
                  // ==============
                
                  $(document).on('click.bk-bs.modal.data-api', '[data-bk-bs-toggle="modal"]', function (e) {
                    var $this   = $(this)
                    var href    = $this.attr('href')
                    var $target = $($this.attr('data-bk-bs-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
                    var option  = $target.data('bk-bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())
                
                    if ($this.is('a')) e.preventDefault()
                
                    $target
                      .modal(option, this)
                      .one('hide', function () {
                        $this.is(':visible') && $this.focus()
                      })
                  })
                
                  $(document)
                    .on('show.bk-bs.modal', '.bk-bs-modal', function () { $(document.body).addClass('bk-bs-modal-open') })
                    .on('hidden.bk-bs.modal', '.bk-bs-modal', function () { $(document.body).removeClass('bk-bs-modal-open') })
                
                }(jQuery);
                
                });
                
                define('tool/actions/preview_save_tool_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<div class="bk-bs-modal-dialog">\n  <div class="bk-bs-modal-content">\n    <div class="bk-bs-modal-header">\n      <button type="button" class="bk-bs-close" data-bk-bs-dismiss="modal">&times;</button>\n      <h4 class="bk-bs-modal-title">Image Preview (right click -> \'Save As\' to save PNG)</h4>\n    </div>\n    <div class="bk-bs-modal-body">\n      <img style="max-height: 300px; max-width: 400px">\n    </div>\n    <div class="bk-bs-modal-footer">\n      <button type="button" class="bk-bs-btn bk-bs-btn-primary" data-bk-bs-dismiss="modal">Close</button>\n    </div>\n  </div>\n</div>'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/actions/preview_save_tool',["underscore", "jquery", "bootstrap/modal", "common/collection", "./action_tool", "./preview_save_tool_template"], function(_, $, $$1, Collection, ActionTool, preview_save_tool_template) {
                    var PreviewSaveTool, PreviewSaveToolView, PreviewSaveTools, _ref, _ref1, _ref2;
                    PreviewSaveToolView = (function(_super) {
                      __extends(PreviewSaveToolView, _super);
                
                      function PreviewSaveToolView() {
                        _ref = PreviewSaveToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PreviewSaveToolView.prototype.className = "bk-bs-modal";
                
                      PreviewSaveToolView.prototype.template = preview_save_tool_template;
                
                      PreviewSaveToolView.prototype.initialize = function(options) {
                        var _this = this;
                        PreviewSaveToolView.__super__.initialize.call(this, options);
                        this.$el.html(this.template());
                        this.$el.attr("tabindex", "-1");
                        $('body').append(this.$el);
                        this.$el.on('hidden', function() {
                          return _this.$el.modal('hide');
                        });
                        return this.$el.modal({
                          show: false
                        });
                      };
                
                      PreviewSaveToolView.prototype["do"] = function() {
                        var canvas;
                        canvas = this.plot_view.canvas_view.canvas[0];
                        this.$('.bk-bs-modal-body img').attr("src", canvas.toDataURL());
                        return this.$el.modal('show');
                      };
                
                      return PreviewSaveToolView;
                
                    })(ActionTool.View);
                    PreviewSaveTool = (function(_super) {
                      __extends(PreviewSaveTool, _super);
                
                      function PreviewSaveTool() {
                        _ref1 = PreviewSaveTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      PreviewSaveTool.prototype.default_view = PreviewSaveToolView;
                
                      PreviewSaveTool.prototype.type = "PreviewSaveTool";
                
                      PreviewSaveTool.prototype.tool_name = "Preview/Save";
                
                      PreviewSaveTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNS4xIE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozMjFERDhENjIwQjIxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozMjFERDhENzIwQjIxMUU0ODREQUYzNzM5QTM2MjBCRSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMyMUREOEQ0MjBCMjExRTQ4NERBRjM3MzlBMzYyMEJFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMyMUREOEQ1MjBCMjExRTQ4NERBRjM3MzlBMzYyMEJFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+h5hT8AAAAKBJREFUeNpiWbhs5QcGBgZ+hgECTAwDDGAO+AjEjGj4Lw5xUrAAkl3ocr8IhQAzjT3PRu0o+I+EHw65NDDqgJHrABYC8t9JMIuRmiHACS2IKC0LOKH0X1JDAOTzs0BsBs3XlIKz5KSBRCA+RQXLjwNxNDlp4BoQm9Mo7fGPZsNRB4w6YNQBI94BfwfaAV9G08CoA9DbA/xUavkMvRAACDAAaPgYViexODkAAAAASUVORK5CYII=";
                
                      return PreviewSaveTool;
                
                    })(ActionTool.Model);
                    PreviewSaveTools = (function(_super) {
                      __extends(PreviewSaveTools, _super);
                
                      function PreviewSaveTools() {
                        _ref2 = PreviewSaveTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      PreviewSaveTools.prototype.model = PreviewSaveTool;
                
                      return PreviewSaveTools;
                
                    })(Collection);
                    return {
                      Model: PreviewSaveTool,
                      Collection: new PreviewSaveTools(),
                      View: PreviewSaveToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=preview_save_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/actions/reset_tool',["underscore", "common/collection", "./action_tool"], function(_, Collection, ActionTool) {
                    var ResetTool, ResetToolView, ResetTools, _ref, _ref1, _ref2;
                    ResetToolView = (function(_super) {
                      __extends(ResetToolView, _super);
                
                      function ResetToolView() {
                        _ref = ResetToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ResetToolView.prototype["do"] = function() {
                        return this.plot_view.update_range();
                      };
                
                      return ResetToolView;
                
                    })(ActionTool.View);
                    ResetTool = (function(_super) {
                      __extends(ResetTool, _super);
                
                      function ResetTool() {
                        _ref1 = ResetTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ResetTool.prototype.default_view = ResetToolView;
                
                      ResetTool.prototype.type = "ResetTool";
                
                      ResetTool.prototype.tool_name = "Reset";
                
                      ResetTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNS4xIE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCRTI5MDhFMDIwQjUxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyOUMzNDE3NDIwQkIxMUU0ODREQUYzNzM5QTM2MjBCRSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJFMjkwOERFMjBCNTExRTQ4NERBRjM3MzlBMzYyMEJFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkJFMjkwOERGMjBCNTExRTQ4NERBRjM3MzlBMzYyMEJFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+kFHGtQAAAm1JREFUeNrMmE9ExFEQx3+7ZYmlLrEsUUTHaEV0iESJVqduXaJr1xKlFB1bdYqoQ9GlFBFdikgpIhLd0rLqUsQqrW2G7+YZr+2993vaHT6H3583M795897M+0U2t3cCR6kh+kA3rtvx7IYoEGfEMSi4GIk4OJgg5ogRot5wzBvBhmaJnI2xqMW7dcQC8UCMWzgX4N1xjF2ALq8OctROiGkiHrhLHDpOoNOLg5xXF0Sn5lmWWCUGiBRRC1K4t4p3pLCuKyVnnXMwAUVJcT+HfFo3SH5ePGPI24TmA1Pl8rJcBGPEvsa5I6KVWDNcmQW824qxqiRhI+bi4IxmWjOYuneH/HvH2Ixmumd8bjNhhad8lxgSzrfp8jUa/L/wlI8KZ3h1T4bdB30Kb9zz4t6YbgurlIMBdoBHUQiGTBx8JYoKPqVe0ftFNInnW8J20SSCjRWM8k8E1S+TNfbZYyQ59yJEg0kjw1QyB42k1iI6ReXLfEWSK8iHJnJVsYqN8jtammuFc/FOr3juU7Ia+39uM7fiuq8aVrEqp+J6BPWzahw8IPLKdTPKUNU4yJ3Fhqb1inu0y7qeRNVYsWkWFkXPl0QZ8iVbohFmW0s2DmY1jSUX8mUPzi1rmoLML2eXsvsgR/FO3JtAix53nNZ96FDlDrasW35eKGniRRPJeywck9VdOjTdayL3Ahv5MC1/xy+Hp1Iq7BGHMHatjOEqMUgMlxmbVsaEOpMk4GSnp0VyCedyLtuMTlhRD1ZaPoRjeejoMf1HE7VUPkW04Jz7Ztm9rGHslM1Hhjl2xlCn+4muQP/77RyHdf799uli5FuAAQC+l5Sj5nEBdwAAAABJRU5ErkJggg==";
                
                      return ResetTool;
                
                    })(ActionTool.Model);
                    ResetTools = (function(_super) {
                      __extends(ResetTools, _super);
                
                      function ResetTools() {
                        _ref2 = ResetTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      ResetTools.prototype.model = ResetTool;
                
                      return ResetTools;
                
                    })(Collection);
                    return {
                      "Model": ResetTool,
                      "Collection": new ResetTools(),
                      "View": ResetToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=reset_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/select_tool',["common/logging", "./gesture_tool"], function(Logging, GestureTool) {
                    var SelectTool, SelectToolView, logger, _ref, _ref1;
                    logger = Logging.logger;
                    SelectToolView = (function(_super) {
                      __extends(SelectToolView, _super);
                
                      function SelectToolView() {
                        _ref = SelectToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SelectToolView.prototype._keyup = function(e) {
                        var ds, r, sm, _i, _len, _ref1, _results;
                        if (e.keyCode === 27) {
                          _ref1 = this.mget('renderers');
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            r = _ref1[_i];
                            ds = r.get('data_source');
                            sm = ds.get('selection_manager');
                            _results.push(sm.clear());
                          }
                          return _results;
                        }
                      };
                
                      SelectToolView.prototype._save_geometry = function(geometry, final, append) {
                        var g, geoms, i, tool_events, xm, ym, _i, _ref1;
                        g = _.clone(geometry);
                        xm = this.plot_view.frame.get('x_mappers')['default'];
                        ym = this.plot_view.frame.get('y_mappers')['default'];
                        if (g.type === 'point') {
                          g.x = xm.map_from_target(g.vx);
                          g.y = ym.map_from_target(g.vy);
                        } else if (g.type === 'rect') {
                          g.x0 = xm.map_from_target(g.vx0);
                          g.y0 = ym.map_from_target(g.vy0);
                          g.x1 = xm.map_from_target(g.vx1);
                          g.y1 = ym.map_from_target(g.vy1);
                        } else if (g.type === 'poly') {
                          g.x = new Array(g.vx.length);
                          g.y = new Array(g.vy.length);
                          for (i = _i = 0, _ref1 = g.vx.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
                            g.x[i] = xm.map_from_target(g.vx[i]);
                            g.y[i] = ym.map_from_target(g.vy[i]);
                          }
                        } else {
                          logger.debug("Unrecognized selection geometry type: '" + g.type + "'");
                        }
                        if (final) {
                          tool_events = this.plot_model.get('tool_events');
                          if (append) {
                            geoms = tool_events.get('geometries');
                            geoms.push(g);
                          } else {
                            geoms = [g];
                          }
                          tool_events.set("geometries", geoms);
                          tool_events.save();
                        }
                        return null;
                      };
                
                      return SelectToolView;
                
                    })(GestureTool.View);
                    SelectTool = (function(_super) {
                      __extends(SelectTool, _super);
                
                      function SelectTool() {
                        _ref1 = SelectTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      SelectTool.prototype.initialize = function(attrs, options) {
                        var all_renderers, names, r, renderers, _i, _len;
                        SelectTool.__super__.initialize.call(this, attrs, options);
                        names = this.get('names');
                        renderers = this.get('renderers');
                        if (renderers.length === 0) {
                          all_renderers = this.get('plot').get('renderers');
                          renderers = (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = all_renderers.length; _i < _len; _i++) {
                              r = all_renderers[_i];
                              if (r.type === "GlyphRenderer") {
                                _results.push(r);
                              }
                            }
                            return _results;
                          })();
                        }
                        if (names.length > 0) {
                          renderers = (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = renderers.length; _i < _len; _i++) {
                              r = renderers[_i];
                              if (names.indexOf(r.get('name')) >= 0) {
                                _results.push(r);
                              }
                            }
                            return _results;
                          })();
                        }
                        this.set('renderers', renderers);
                        logger.debug("setting " + renderers.length + " renderers for " + this.type + " " + this.id);
                        for (_i = 0, _len = renderers.length; _i < _len; _i++) {
                          r = renderers[_i];
                          logger.debug("- " + r.type + " " + r.id);
                        }
                        return null;
                      };
                
                      SelectTool.prototype.defaults = function() {
                        return _.extend({}, SelectTool.__super__.defaults.call(this), {
                          renderers: [],
                          names: [],
                          multi_select_modifier: "shift"
                        });
                      };
                
                      return SelectTool;
                
                    })(GestureTool.Model);
                    return {
                      "Model": SelectTool,
                      "View": SelectToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=select_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/box_select_tool',["underscore", "common/collection", "renderer/overlay/box_selection", "tool/gestures/select_tool"], function(_, Collection, BoxSelection, SelectTool) {
                    var BoxSelectTool, BoxSelectToolView, BoxSelectTools, _ref, _ref1, _ref2;
                    BoxSelectToolView = (function(_super) {
                      __extends(BoxSelectToolView, _super);
                
                      function BoxSelectToolView() {
                        _ref = BoxSelectToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      BoxSelectToolView.prototype._pan_start = function(e) {
                        var canvas;
                        canvas = this.plot_view.canvas;
                        this._baseboint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];
                        return null;
                      };
                
                      BoxSelectToolView.prototype._pan = function(e) {
                        var append, canvas, curpoint, dims, frame, vxlim, vylim, _ref1, _ref2;
                        canvas = this.plot_view.canvas;
                        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];
                        frame = this.plot_model.get('frame');
                        dims = this.mget('dimensions');
                        _ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = _ref1[0], vylim = _ref1[1];
                        this.mget('overlay').set('data', {
                          vxlim: vxlim,
                          vylim: vylim
                        });
                        if (this.mget('select_every_mousemove')) {
                          append = (_ref2 = e.srcEvent.shiftKey) != null ? _ref2 : false;
                          this._select(vxlim, vylim, false, append);
                        }
                        return null;
                      };
                
                      BoxSelectToolView.prototype._pan_end = function(e) {
                        var append, canvas, curpoint, dims, frame, vxlim, vylim, _ref1, _ref2;
                        canvas = this.plot_view.canvas;
                        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];
                        frame = this.plot_model.get('frame');
                        dims = this.mget('dimensions');
                        _ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = _ref1[0], vylim = _ref1[1];
                        append = (_ref2 = e.srcEvent.shiftKey) != null ? _ref2 : false;
                        this._select(vxlim, vylim, true, append);
                        this.mget('overlay').set('data', {});
                        this._baseboint = null;
                        return null;
                      };
                
                      BoxSelectToolView.prototype._select = function(_arg, _arg1, final, append) {
                        var ds, geometry, r, sm, vx0, vx1, vy0, vy1, _i, _len, _ref1;
                        vx0 = _arg[0], vx1 = _arg[1];
                        vy0 = _arg1[0], vy1 = _arg1[1];
                        if (append == null) {
                          append = false;
                        }
                        geometry = {
                          type: 'rect',
                          vx0: vx0,
                          vx1: vx1,
                          vy0: vy0,
                          vy1: vy1
                        };
                        _ref1 = this.mget('renderers');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          r = _ref1[_i];
                          ds = r.get('data_source');
                          sm = ds.get('selection_manager');
                          sm.select(this, this.plot_view.renderers[r.id], geometry, final, append);
                        }
                        this._save_geometry(geometry, final, append);
                        return null;
                      };
                
                      return BoxSelectToolView;
                
                    })(SelectTool.View);
                    BoxSelectTool = (function(_super) {
                      __extends(BoxSelectTool, _super);
                
                      function BoxSelectTool() {
                        _ref1 = BoxSelectTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      BoxSelectTool.prototype.default_view = BoxSelectToolView;
                
                      BoxSelectTool.prototype.type = "BoxSelectTool";
                
                      BoxSelectTool.prototype.tool_name = "Box Select";
                
                      BoxSelectTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAgCAYAAAB6kdqOAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNS4xIE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODVDNDBCRjIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODVDNDBDMDIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkE4NUM0MEJEMjBCMzExRTQ4NERBRjM3MzlBMzYyMEJFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4NUM0MEJFMjBCMzExRTQ4NERBRjM3MzlBMzYyMEJFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+hdQ7dQAAAJdJREFUeNpiXLhs5X8GBPgIxAJQNjZxfiD+wIAKGCkUZ0SWZGIYZIAF3YVoPkEHH6kojhUMyhD6jydEaAlgaWnwh9BAgf9DKpfxDxYHjeay0Vw2bHMZw2guG81lwyXKRnMZWlt98JdDTFAX/x9NQwPkIH6kGMAVEyjyo7lstC4jouc69Moh9L42rlyBTZyYXDS00xBAgAEAqsguPe03+cYAAAAASUVORK5CYII=";
                
                      BoxSelectTool.prototype.event_type = "pan";
                
                      BoxSelectTool.prototype.default_order = 30;
                
                      BoxSelectTool.prototype.initialize = function(attrs, options) {
                        var plot_renderers;
                        BoxSelectTool.__super__.initialize.call(this, attrs, options);
                        this.register_property('tooltip', function() {
                          return this._get_dim_tooltip(this.get("tool_name"), this._check_dims(this.get('dimensions'), "box select tool"));
                        }, false);
                        this.add_dependencies('tooltip', this, ['dimensions']);
                        this.set('overlay', new BoxSelection.Model);
                        plot_renderers = this.get('plot').get('renderers');
                        plot_renderers.push(this.get('overlay'));
                        return this.get('plot').set('renderers', plot_renderers);
                      };
                
                      BoxSelectTool.prototype.defaults = function() {
                        return _.extend({}, BoxSelectTool.__super__.defaults.call(this), {
                          dimensions: ["width", "height"],
                          select_every_mousemove: false
                        });
                      };
                
                      return BoxSelectTool;
                
                    })(SelectTool.Model);
                    BoxSelectTools = (function(_super) {
                      __extends(BoxSelectTools, _super);
                
                      function BoxSelectTools() {
                        _ref2 = BoxSelectTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      BoxSelectTools.prototype.model = BoxSelectTool;
                
                      return BoxSelectTools;
                
                    })(Collection);
                    return {
                      "Model": BoxSelectTool,
                      "Collection": new BoxSelectTools(),
                      "View": BoxSelectToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=box_select_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/box_zoom_tool',["underscore", "common/collection", "renderer/overlay/box_selection", "tool/gestures/gesture_tool"], function(_, Collection, BoxSelection, GestureTool) {
                    var BoxZoomTool, BoxZoomToolView, BoxZoomTools, _ref, _ref1, _ref2;
                    BoxZoomToolView = (function(_super) {
                      __extends(BoxZoomToolView, _super);
                
                      function BoxZoomToolView() {
                        _ref = BoxZoomToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      BoxZoomToolView.prototype._pan_start = function(e) {
                        var canvas;
                        canvas = this.plot_view.canvas;
                        this._baseboint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];
                        return null;
                      };
                
                      BoxZoomToolView.prototype._pan = function(e) {
                        var canvas, curpoint, dims, frame, vxlim, vylim, _ref1;
                        canvas = this.plot_view.canvas;
                        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];
                        frame = this.plot_model.get('frame');
                        dims = this.mget('dimensions');
                        _ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = _ref1[0], vylim = _ref1[1];
                        this.mget('overlay').set('data', {
                          vxlim: vxlim,
                          vylim: vylim
                        });
                        return null;
                      };
                
                      BoxZoomToolView.prototype._pan_end = function(e) {
                        var canvas, curpoint, dims, frame, vxlim, vylim, _ref1;
                        canvas = this.plot_view.canvas;
                        curpoint = [canvas.sx_to_vx(e.bokeh.sx), canvas.sy_to_vy(e.bokeh.sy)];
                        frame = this.plot_model.get('frame');
                        dims = this.mget('dimensions');
                        _ref1 = this.model._get_dim_limits(this._baseboint, curpoint, frame, dims), vxlim = _ref1[0], vylim = _ref1[1];
                        this._update(vxlim, vylim);
                        this.mget('overlay').set('data', {});
                        this._baseboint = null;
                        return null;
                      };
                
                      BoxZoomToolView.prototype._update = function(vxlim, vylim) {
                        var end, mapper, name, start, xrs, yrs, zoom_info, _ref1, _ref2, _ref3, _ref4;
                        xrs = {};
                        _ref1 = this.plot_view.frame.get('x_mappers');
                        for (name in _ref1) {
                          mapper = _ref1[name];
                          _ref2 = mapper.v_map_from_target(vxlim), start = _ref2[0], end = _ref2[1];
                          xrs[name] = {
                            start: start,
                            end: end
                          };
                        }
                        yrs = {};
                        _ref3 = this.plot_view.frame.get('y_mappers');
                        for (name in _ref3) {
                          mapper = _ref3[name];
                          _ref4 = mapper.v_map_from_target(vylim), start = _ref4[0], end = _ref4[1];
                          yrs[name] = {
                            start: start,
                            end: end
                          };
                        }
                        zoom_info = {
                          xrs: xrs,
                          yrs: yrs
                        };
                        return this.plot_view.update_range(zoom_info);
                      };
                
                      return BoxZoomToolView;
                
                    })(GestureTool.View);
                    BoxZoomTool = (function(_super) {
                      __extends(BoxZoomTool, _super);
                
                      function BoxZoomTool() {
                        _ref1 = BoxZoomTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      BoxZoomTool.prototype.default_view = BoxZoomToolView;
                
                      BoxZoomTool.prototype.type = "BoxZoomTool";
                
                      BoxZoomTool.prototype.tool_name = "Box Zoom";
                
                      BoxZoomTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAgCAYAAAB3j6rJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNS4xIE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozMjFERDhEMjIwQjIxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozMjFERDhEMzIwQjIxMUU0ODREQUYzNzM5QTM2MjBCRSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMyMUREOEQwMjBCMjExRTQ4NERBRjM3MzlBMzYyMEJFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMyMUREOEQxMjBCMjExRTQ4NERBRjM3MzlBMzYyMEJFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+a2Q0KAAAAmVJREFUeNq8V19EpFEUvzOtmKfpJSJKDL2WiLJExKaUEq0eeikiaolZLT2lVUpPydqHqIlIo1ilFOmphxj1miKWWHppnobIt7+zeyZ3jjvz/bnf9OPHd8/9d77z3XN+94ts7ew6SqksWKX+w1GFiLjYdVSAfeAQ2Ag2sf0GvAXT4C/wle1x3lt9UOGBNk6BrYa+FuYIeAWOsmNviGqe6W+q081OmAGvizgh0cpjZ3RjGBFZBpMG+xn4wM8NYJfWFwNXwXrwS96RiIUTwwYn6AxMgb+FvQ5c4zOUxzR4Ce5GLZyo5LfSsQP2G5xQbKO+bWFfoLWinA1OAEcoM2rFRpMe5sloJWgtm4j0iPZcPhVdkOWxBWvZONIi2uc+5sqxbTaO1Ij2o4+5T6JdGy1SF4Kg2mLsi01E/oh2l4+5HTKaNlmTEe0ka40XyNqTsYnIkWiTwC16rMRNci0bR0hJ7w1veizqy9uB5D4ZDZKBtI3WvLCCJoT9E3jHny4j1DdmWOcbrWWjNYuGoqaL2kdmKayTztio7yzTJprz4A/9PuI3a8YMh5IKVC9fetxAY5rB79pNzXdESMJ/GrSjm8/DCTjAgpjQZCDDh5I+w4HuQBBHOsE9USty4KB2KF85m9J+v5XX9KXr3T7fQZS26WefYlcU+ayJlxhDIT40jBnn21hQOPrfgFtEqAhdGETqK7gZ4h/Av4g4Jf5TUoYquQSuqJDhFpEJca3b4EoYOtyyhrSkHTzlcj4R4t4FZ9NL+j6yMzlT/ocZES9aky3D3r6y5t2gaw3xWXgs7XFhdyzsgSpr2fFXgAEAmp2J9DuX/WgAAAAASUVORK5CYII=";
                
                      BoxZoomTool.prototype.event_type = "pan";
                
                      BoxZoomTool.prototype.default_order = 20;
                
                      BoxZoomTool.prototype.initialize = function(attrs, options) {
                        var plot_renderers;
                        BoxZoomTool.__super__.initialize.call(this, attrs, options);
                        this.register_property('tooltip', function() {
                          return this._get_dim_tooltip(this.get("tool_name"), this._check_dims(this.get('dimensions'), "box zoom tool"));
                        }, false);
                        this.add_dependencies('tooltip', this, ['dimensions']);
                        this.set('overlay', new BoxSelection.Model);
                        plot_renderers = this.get('plot').get('renderers');
                        plot_renderers.push(this.get('overlay'));
                        return this.get('plot').set('renderers', plot_renderers);
                      };
                
                      BoxZoomTool.prototype.defaults = function() {
                        return _.extend({}, BoxZoomTool.__super__.defaults.call(this), {
                          dimensions: ["width", "height"]
                        });
                      };
                
                      return BoxZoomTool;
                
                    })(GestureTool.Model);
                    BoxZoomTools = (function(_super) {
                      __extends(BoxZoomTools, _super);
                
                      function BoxZoomTools() {
                        _ref2 = BoxZoomTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      BoxZoomTools.prototype.model = BoxZoomTool;
                
                      return BoxZoomTools;
                
                    })(Collection);
                    return {
                      "Model": BoxZoomTool,
                      "Collection": new BoxZoomTools(),
                      "View": BoxZoomToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=box_zoom_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/lasso_select_tool',["underscore", "common/collection", "renderer/overlay/poly_selection", "tool/gestures/select_tool"], function(_, Collection, PolySelection, SelectTool) {
                    var LassoSelectTool, LassoSelectToolView, LassoSelectTools, _ref, _ref1, _ref2;
                    LassoSelectToolView = (function(_super) {
                      __extends(LassoSelectToolView, _super);
                
                      function LassoSelectToolView() {
                        _ref = LassoSelectToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LassoSelectToolView.prototype.initialize = function(options) {
                        LassoSelectToolView.__super__.initialize.call(this, options);
                        this.listenTo(this.model, 'change:active', this._active_change);
                        return this.data = null;
                      };
                
                      LassoSelectToolView.prototype._active_change = function() {
                        if (!this.mget('active')) {
                          return this._clear_overlay();
                        }
                      };
                
                      LassoSelectToolView.prototype._keyup = function(e) {
                        if (e.keyCode === 13) {
                          return this._clear_overlay();
                        }
                      };
                
                      LassoSelectToolView.prototype._pan_start = function(e) {
                        var canvas, vx, vy;
                        canvas = this.plot_view.canvas;
                        vx = canvas.sx_to_vx(e.bokeh.sx);
                        vy = canvas.sy_to_vy(e.bokeh.sy);
                        this.data = {
                          vx: [vx],
                          vy: [vy]
                        };
                        return null;
                      };
                
                      LassoSelectToolView.prototype._pan = function(e) {
                        var append, canvas, new_data, overlay, vx, vy, _ref1;
                        canvas = this.plot_view.canvas;
                        vx = canvas.sx_to_vx(e.bokeh.sx);
                        vy = canvas.sy_to_vy(e.bokeh.sy);
                        this.data.vx.push(vx);
                        this.data.vy.push(vy);
                        overlay = this.mget('overlay');
                        new_data = {};
                        new_data.vx = _.clone(this.data.vx);
                        new_data.vy = _.clone(this.data.vy);
                        overlay.set('data', new_data);
                        append = (_ref1 = e.srcEvent.shiftKey) != null ? _ref1 : false;
                        return this._select(this.data.vx, this.data.vy, append);
                      };
                
                      LassoSelectToolView.prototype._pan_end = function(e) {
                        return this._clear_overlay();
                      };
                
                      LassoSelectToolView.prototype._clear_overlay = function() {
                        return this.mget('overlay').set('data', null);
                      };
                
                      LassoSelectToolView.prototype._select = function(vx, vy, append) {
                        var ds, geometry, r, sm, _i, _len, _ref1;
                        geometry = {
                          type: 'poly',
                          vx: vx,
                          vy: vy
                        };
                        _ref1 = this.mget('renderers');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          r = _ref1[_i];
                          ds = r.get('data_source');
                          sm = ds.get('selection_manager');
                          sm.select(this, this.plot_view.renderers[r.id], geometry, true, append);
                        }
                        this._save_geometry(geometry, true, append);
                        return null;
                      };
                
                      return LassoSelectToolView;
                
                    })(SelectTool.View);
                    LassoSelectTool = (function(_super) {
                      __extends(LassoSelectTool, _super);
                
                      function LassoSelectTool() {
                        _ref1 = LassoSelectTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      LassoSelectTool.prototype.default_view = LassoSelectToolView;
                
                      LassoSelectTool.prototype.type = "LassoSelectTool";
                
                      LassoSelectTool.prototype.tool_name = "Lasso Select";
                
                      LassoSelectTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAGlSURBVDiNldNNiM1hFMfxz/3PHQqxoCgWYmNDk0jyUqwsuP/719xnPVkQStl4mYWpsVXKQkYpL1m4qWmyYElZkDLKyiSbkdKYNBovo8m1uM+d/nPd/2TO6nn5nW+/c57zlCwQ9eGRBPuwF7uxAUswjme4V6tWxqFUAFiLXlSxDaswiz9RkqAL79Ffq1YeldoAXTiNs9iIn3iN0Zj0OULWYycORU1fKQdZh5s4ggncxX28DVk6W+D8MG5hrJQr5Ql68AADIUvfFTZvPuw5VpZjOVcjZCBk6eD/ACJkF7ZgMMEJVHB7kZDNeIhXGEpwEg3cWASkFy9i3vFatTJTxvJ4sAcvo3ANpkOW/sold+MgTsUKRlGbm6P68Mh59GvOSR2/cVTzqYfifisOYDtm4vmlkKVTjUZDC5TgIi5gBX7gG7qxVHNuluEjHuN6yNI3LadzoJz1HejDMXzP3X2Njp+GLJ1o79c/oBzwGgK+YHV0cyVk6eV27YKgCNuEKZzBubjeH7J0rAiUdAKFLP0QsnQSdzCp+Wl7Omlb0RGUi0+YRlmz+YXxF2YZkqkolYwKAAAAAElFTkSuQmCC";
                
                      LassoSelectTool.prototype.event_type = "pan";
                
                      LassoSelectTool.prototype.default_order = 12;
                
                      LassoSelectTool.prototype.initialize = function(attrs, options) {
                        var plot_renderers;
                        LassoSelectTool.__super__.initialize.call(this, attrs, options);
                        this.set('overlay', new PolySelection.Model);
                        plot_renderers = this.get('plot').get('renderers');
                        plot_renderers.push(this.get('overlay'));
                        return this.get('plot').set('renderers', plot_renderers);
                      };
                
                      return LassoSelectTool;
                
                    })(SelectTool.Model);
                    LassoSelectTools = (function(_super) {
                      __extends(LassoSelectTools, _super);
                
                      function LassoSelectTools() {
                        _ref2 = LassoSelectTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      LassoSelectTools.prototype.model = LassoSelectTool;
                
                      return LassoSelectTools;
                
                    })(Collection);
                    return {
                      "Model": LassoSelectTool,
                      "Collection": new LassoSelectTools(),
                      "View": LassoSelectToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=lasso_select_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/pan_tool',["underscore", "common/collection", "common/logging", "tool/gestures/gesture_tool"], function(_, Collection, Logging, GestureTool) {
                    var PanTool, PanToolView, PanTools, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    PanToolView = (function(_super) {
                      __extends(PanToolView, _super);
                
                      function PanToolView() {
                        _ref = PanToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PanToolView.prototype._pan_start = function(e) {
                        var canvas, frame, hr, vr, vx, vy;
                        this.last_dx = 0;
                        this.last_dy = 0;
                        canvas = this.plot_view.canvas;
                        frame = this.plot_view.frame;
                        vx = canvas.sx_to_vx(e.bokeh.sx);
                        vy = canvas.sy_to_vy(e.bokeh.sy);
                        if (!frame.contains(vx, vy)) {
                          hr = frame.get('h_range');
                          vr = frame.get('v_range');
                          if (vx < hr.get('start') || vx > hr.get('end')) {
                            this.v_axis_only = true;
                          }
                          if (vy < vr.get('start') || vy > vr.get('end')) {
                            return this.h_axis_only = true;
                          }
                        }
                      };
                
                      PanToolView.prototype._pan = function(e) {
                        return this._update(e.deltaX, -e.deltaY);
                      };
                
                      PanToolView.prototype._pan_end = function(e) {
                        this.h_axis_only = false;
                        return this.v_axis_only = false;
                      };
                
                      PanToolView.prototype._update = function(dx, dy) {
                        var dims, end, frame, hr, mapper, name, new_dx, new_dy, pan_info, sdx, sdy, start, sx0, sx1, sx_high, sx_low, sy0, sy1, sy_high, sy_low, vr, xrs, yrs, _ref1, _ref2, _ref3, _ref4;
                        frame = this.plot_view.frame;
                        new_dx = dx - this.last_dx;
                        new_dy = dy - this.last_dy;
                        hr = _.clone(frame.get('h_range'));
                        sx_low = hr.get('start') - new_dx;
                        sx_high = hr.get('end') - new_dx;
                        vr = _.clone(frame.get('v_range'));
                        sy_low = vr.get('start') - new_dy;
                        sy_high = vr.get('end') - new_dy;
                        dims = this.mget('dimensions');
                        if (dims.indexOf('width') > -1 && !this.v_axis_only) {
                          sx0 = sx_low;
                          sx1 = sx_high;
                          sdx = -new_dx;
                        } else {
                          sx0 = hr.get('start');
                          sx1 = hr.get('end');
                          sdx = 0;
                        }
                        if (dims.indexOf('height') > -1 && !this.h_axis_only) {
                          sy0 = sy_low;
                          sy1 = sy_high;
                          sdy = new_dy;
                        } else {
                          sy0 = vr.get('start');
                          sy1 = vr.get('end');
                          sdy = 0;
                        }
                        this.last_dx = dx;
                        this.last_dy = dy;
                        xrs = {};
                        _ref1 = frame.get('x_mappers');
                        for (name in _ref1) {
                          mapper = _ref1[name];
                          _ref2 = mapper.v_map_from_target([sx0, sx1]), start = _ref2[0], end = _ref2[1];
                          xrs[name] = {
                            start: start,
                            end: end
                          };
                        }
                        yrs = {};
                        _ref3 = frame.get('y_mappers');
                        for (name in _ref3) {
                          mapper = _ref3[name];
                          _ref4 = mapper.v_map_from_target([sy0, sy1]), start = _ref4[0], end = _ref4[1];
                          yrs[name] = {
                            start: start,
                            end: end
                          };
                        }
                        pan_info = {
                          xrs: xrs,
                          yrs: yrs,
                          sdx: sdx,
                          sdy: sdy
                        };
                        this.plot_view.update_range(pan_info);
                        return null;
                      };
                
                      return PanToolView;
                
                    })(GestureTool.View);
                    PanTool = (function(_super) {
                      __extends(PanTool, _super);
                
                      function PanTool() {
                        _ref1 = PanTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      PanTool.prototype.default_view = PanToolView;
                
                      PanTool.prototype.type = "PanTool";
                
                      PanTool.prototype.tool_name = "Pan";
                
                      PanTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNS4xIE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCRTI5MDhEODIwQjUxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCRTI5MDhEOTIwQjUxMUU0ODREQUYzNzM5QTM2MjBCRSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJFMjkwOEQ2MjBCNTExRTQ4NERBRjM3MzlBMzYyMEJFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkJFMjkwOEQ3MjBCNTExRTQ4NERBRjM3MzlBMzYyMEJFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+OXzPwwAAAKNJREFUeNrsVsEKgCAM3cyj0f8fuwT9XdEHrLyVIOKYY4kPPDim0+fenF+3HZi4nhFec+Rs4oCPAALwjDVUsKMWA6DNAFX6YXcMYIERdRWIYBzAZbKYGsSKex6mVUAK8Za0TphgoFTbpSvlx3/I0EQOILO2i/ibegLk/mgVONM4JvuBVizgkGH3XTGrR/xlV0ycbO8qCeMN54wdtVQwSTFwCzAATqEZUn8W8W4AAAAASUVORK5CYII=";
                
                      PanTool.prototype.event_type = "pan";
                
                      PanTool.prototype.default_order = 10;
                
                      PanTool.prototype.initialize = function(attrs, options) {
                        PanTool.__super__.initialize.call(this, attrs, options);
                        this.register_property('tooltip', function() {
                          return this._get_dim_tooltip("Pan", this._check_dims(this.get('dimensions'), "pan tool"));
                        }, false);
                        return this.add_dependencies('tooltip', this, ['dimensions']);
                      };
                
                      PanTool.prototype.defaults = function() {
                        return _.extend({}, PanTool.__super__.defaults.call(this), {
                          dimensions: ["width", "height"]
                        });
                      };
                
                      return PanTool;
                
                    })(GestureTool.Model);
                    PanTools = (function(_super) {
                      __extends(PanTools, _super);
                
                      function PanTools() {
                        _ref2 = PanTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      PanTools.prototype.model = PanTool;
                
                      return PanTools;
                
                    })(Collection);
                    return {
                      "Model": PanTool,
                      "Collection": new PanTools(),
                      "View": PanToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=pan_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/resize_tool',["underscore", "common/collection", "tool/gestures/gesture_tool"], function(_, Collection, GestureTool) {
                    var ResizeTool, ResizeToolView, ResizeTools, _ref, _ref1, _ref2;
                    ResizeToolView = (function(_super) {
                      __extends(ResizeToolView, _super);
                
                      function ResizeToolView() {
                        _ref = ResizeToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ResizeToolView.prototype.className = "bk-resize-popup pull-right";
                
                      ResizeToolView.prototype.initialize = function(options) {
                        var wrapper;
                        ResizeToolView.__super__.initialize.call(this, options);
                        wrapper = this.plot_view.$el.find('div.bk-canvas-wrapper');
                        this.$el.appendTo(wrapper);
                        this.$el.hide();
                        return null;
                      };
                
                      ResizeToolView.prototype.activate = function() {
                        this.$el.show();
                        return null;
                      };
                
                      ResizeToolView.prototype.deactivate = function() {
                        this.$el.hide();
                        return null;
                      };
                
                      ResizeToolView.prototype._pan_start = function(e) {
                        var canvas;
                        canvas = this.plot_view.canvas;
                        this.ch = canvas.get('height');
                        this.cw = canvas.get('width');
                        return null;
                      };
                
                      ResizeToolView.prototype._pan = function(e) {
                        this._update(e.deltaX, e.deltaY);
                        return null;
                      };
                
                      ResizeToolView.prototype._update = function(dx, dy) {
                        var canvas;
                        this.plot_view.pause();
                        canvas = this.plot_view.canvas;
                        canvas._set_dims([this.cw + dx, this.ch + dy]);
                        this.plot_view.request_render();
                        this.plot_view.unpause();
                        return null;
                      };
                
                      return ResizeToolView;
                
                    })(GestureTool.View);
                    ResizeTool = (function(_super) {
                      __extends(ResizeTool, _super);
                
                      function ResizeTool() {
                        _ref1 = ResizeTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ResizeTool.prototype.default_view = ResizeToolView;
                
                      ResizeTool.prototype.type = "ResizeTool";
                
                      ResizeTool.prototype.tool_name = "Resize";
                
                      ResizeTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAgCAYAAAB3j6rJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNS4xIE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpBODVDNDBCQjIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpBODVDNDBCQzIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMyMUREOEQ4MjBCMjExRTQ4NERBRjM3MzlBMzYyMEJFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4NUM0MEJBMjBCMzExRTQ4NERBRjM3MzlBMzYyMEJFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+nIbQ0AAAAIJJREFUeNpiXLhs5X8G7ICRgTYAq31MDIMEwBzyERoCyJhWAN2ej4MqRFiIjUMahczgSyMsNE4PxACBQZlrcAFsuYkcLECpQwZNiIw6ZNQhow4ZdcioQ0YdMuoQerRZkQE/vdqwgypqQD7+MIBuANn9f1CnEcbRXIMjd4zM0QCAAAMAbdAPQaze1JcAAAAASUVORK5CYII=";
                
                      ResizeTool.prototype.event_type = "pan";
                
                      ResizeTool.prototype.default_order = 40;
                
                      return ResizeTool;
                
                    })(GestureTool.Model);
                    ResizeTools = (function(_super) {
                      __extends(ResizeTools, _super);
                
                      function ResizeTools() {
                        _ref2 = ResizeTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      ResizeTools.prototype.model = ResizeTool;
                
                      return ResizeTools;
                
                    })(Collection);
                    return {
                      "Model": ResizeTool,
                      "Collection": new ResizeTools(),
                      "View": ResizeToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=resize_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/tap_tool',["underscore", "common/collection", "tool/gestures/select_tool"], function(_, Collection, SelectTool) {
                    var TapTool, TapToolView, TapTools, _ref, _ref1, _ref2;
                    TapToolView = (function(_super) {
                      __extends(TapToolView, _super);
                
                      function TapToolView() {
                        _ref = TapToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      TapToolView.prototype._tap = function(e) {
                        var append, canvas, vx, vy, _ref1;
                        canvas = this.plot_view.canvas;
                        vx = canvas.sx_to_vx(e.bokeh.sx);
                        vy = canvas.sy_to_vy(e.bokeh.sy);
                        append = (_ref1 = e.srcEvent.shiftKey) != null ? _ref1 : false;
                        return this._select(vx, vy, append);
                      };
                
                      TapToolView.prototype._select = function(vx, vy, append) {
                        var ds, geometry, r, sm, _i, _len, _ref1;
                        geometry = {
                          type: 'point',
                          vx: vx,
                          vy: vy
                        };
                        _ref1 = this.mget('renderers');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          r = _ref1[_i];
                          ds = r.get('data_source');
                          sm = ds.get('selection_manager');
                          sm.select(this, this.plot_view.renderers[r.id], geometry, true, append);
                        }
                        this._save_geometry(geometry, true, append);
                        return null;
                      };
                
                      return TapToolView;
                
                    })(SelectTool.View);
                    TapTool = (function(_super) {
                      __extends(TapTool, _super);
                
                      function TapTool() {
                        _ref1 = TapTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      TapTool.prototype.default_view = TapToolView;
                
                      TapTool.prototype.type = "TapTool";
                
                      TapTool.prototype.tool_name = "Tap";
                
                      TapTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAHWSURBVDiNbdJfaI9RGAfwz/7JNlLGjdxLyDU2u0EIx6uc7UIpF5pIU1OSGzfkUhvSiuSCvZbXGxeT0IxcSYlIiVxSJmqZzbj4nbafcer0nM75Ps/5Pt/vU2PWyouyAbsRsTJdv0SOGzELE9X4mlnJ7TiOtentV3qqS/EJTsUsDP9TIC/KvTiHZgyhwHP8Tkx2Ygd+4EDMwpXpAnlRtuJu+vFozMLF2a0lXAfOowkbYxYe1+RF2Yhb2IT9MQv9eVHOxTGsSwxGcCZm4WdelLuSHg8QatGZeh5KyQtxB/NwCIfRgtt5US6IWbiJgZTTWZ/UrsG1xLQHL2IWeqrYd+dF2YdunMRVBMRaLMckXiVwK3r/I0E/tqXzW0xgdX0VYCrFOjO2Va+PuJTO4/iE8Xq8RhuWqdj2FAdxpDo7ZmEUF/KiXIwxrMJUvYqibSrTdx2nUeZFeRaX8SFm4Suk5PcYiVnYAtU2bkBHzMJgXpTNOIHtqfdeLMUS3Mcz7GFmkNbjHr6jK2ZhsJp+XpQt6ec6jKIB86cLJNA+9GFOamsAb1Qc+qJic2PSagzv/iqQirQn6mvS1SQ+Y0WawkXJjUcxC5uhdpbSw9iKLjzEt7QnE6QpxWmb/wA4250STmTc7QAAAABJRU5ErkJggg==";
                
                      TapTool.prototype.event_type = "tap";
                
                      TapTool.prototype.default_order = 10;
                
                      return TapTool;
                
                    })(SelectTool.Model);
                    TapTools = (function(_super) {
                      __extends(TapTools, _super);
                
                      function TapTools() {
                        _ref2 = TapTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      TapTools.prototype.model = TapTool;
                
                      return TapTools;
                
                    })(Collection);
                    return {
                      "Model": TapTool,
                      "Collection": new TapTools(),
                      "View": TapToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=tap_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/wheel_zoom_tool',["underscore", "common/collection", "common/logging", "tool/gestures/gesture_tool"], function(_, Collection, Logging, GestureTool) {
                    var WheelZoomTool, WheelZoomToolView, WheelZoomTools, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    WheelZoomToolView = (function(_super) {
                      __extends(WheelZoomToolView, _super);
                
                      function WheelZoomToolView() {
                        _ref = WheelZoomToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      WheelZoomToolView.prototype._pinch = function(e) {
                        var delta;
                        if (e.scale >= 1) {
                          delta = (e.scale - 1) * 20.0;
                        } else {
                          delta = -20.0 / e.scale;
                        }
                        e.bokeh.delta = delta;
                        return this._scroll(e);
                      };
                
                      WheelZoomToolView.prototype._scroll = function(e) {
                        var delta, dims, end, factor, frame, h_axis_only, hr, mapper, multiplier, name, start, sx0, sx1, sy0, sy1, v_axis_only, vr, vx, vx_high, vx_low, vy, vy_high, vy_low, xrs, yrs, zoom_info, _ref1, _ref2, _ref3, _ref4, _ref5;
                        frame = this.plot_model.get('frame');
                        hr = frame.get('h_range');
                        vr = frame.get('v_range');
                        vx = this.plot_view.canvas.sx_to_vx(e.bokeh.sx);
                        vy = this.plot_view.canvas.sy_to_vy(e.bokeh.sy);
                        if (vx < hr.get('start') || vx > hr.get('end')) {
                          v_axis_only = true;
                        }
                        if (vy < vr.get('start') || vy > vr.get('end')) {
                          h_axis_only = true;
                        }
                        if (navigator.userAgent.toLowerCase().indexOf("firefox") > -1) {
                          multiplier = 20;
                        } else {
                          multiplier = 1;
                        }
                        if (((_ref1 = e.originalEvent) != null ? _ref1.deltaY : void 0) != null) {
                          delta = -e.originalEvent.deltaY * multiplier;
                        } else {
                          delta = e.bokeh.delta;
                        }
                        factor = this.mget('speed') * delta;
                        if (factor > 0.9) {
                          factor = 0.9;
                        } else if (factor < -0.9) {
                          factor = -0.9;
                        }
                        vx_low = hr.get('start');
                        vx_high = hr.get('end');
                        vy_low = vr.get('start');
                        vy_high = vr.get('end');
                        dims = this.mget('dimensions');
                        if (dims.indexOf('width') > -1 && !v_axis_only) {
                          sx0 = vx_low - (vx_low - vx) * factor;
                          sx1 = vx_high - (vx_high - vx) * factor;
                        } else {
                          sx0 = vx_low;
                          sx1 = vx_high;
                        }
                        if (dims.indexOf('height') > -1 && !h_axis_only) {
                          sy0 = vy_low - (vy_low - vy) * factor;
                          sy1 = vy_high - (vy_high - vy) * factor;
                        } else {
                          sy0 = vy_low;
                          sy1 = vy_high;
                        }
                        xrs = {};
                        _ref2 = frame.get('x_mappers');
                        for (name in _ref2) {
                          mapper = _ref2[name];
                          _ref3 = mapper.v_map_from_target([sx0, sx1]), start = _ref3[0], end = _ref3[1];
                          xrs[name] = {
                            start: start,
                            end: end
                          };
                        }
                        yrs = {};
                        _ref4 = frame.get('y_mappers');
                        for (name in _ref4) {
                          mapper = _ref4[name];
                          _ref5 = mapper.v_map_from_target([sy0, sy1]), start = _ref5[0], end = _ref5[1];
                          yrs[name] = {
                            start: start,
                            end: end
                          };
                        }
                        zoom_info = {
                          xrs: xrs,
                          yrs: yrs,
                          factor: factor
                        };
                        this.plot_view.update_range(zoom_info);
                        return null;
                      };
                
                      return WheelZoomToolView;
                
                    })(GestureTool.View);
                    WheelZoomTool = (function(_super) {
                      __extends(WheelZoomTool, _super);
                
                      function WheelZoomTool() {
                        _ref1 = WheelZoomTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      WheelZoomTool.prototype.default_view = WheelZoomToolView;
                
                      WheelZoomTool.prototype.type = "WheelZoomTool";
                
                      WheelZoomTool.prototype.tool_name = "Wheel Zoom";
                
                      WheelZoomTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAgCAYAAABpRpp6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNS4xIE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCRTI5MDhEQzIwQjUxMUU0ODREQUYzNzM5QTM2MjBCRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCRTI5MDhERDIwQjUxMUU0ODREQUYzNzM5QTM2MjBCRSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJFMjkwOERBMjBCNTExRTQ4NERBRjM3MzlBMzYyMEJFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkJFMjkwOERCMjBCNTExRTQ4NERBRjM3MzlBMzYyMEJFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+sFLapAAAA8xJREFUeNq8WH9k1VEU/+67ecTYxKM8xlJiifKIMUqUKMvy1CqbEmUxJZbSlGXTLBuJpYi18dpqStOzacT+WcTXpkiRUjziETEeY9bnzHm5O53vj/te7fDx3r3fc+/9fM/3nHPPvWWP0mOOIlVAC3AQqOc2SRZ4A9Cg58CSNrj1+FEnSIYfPynHTyOQArYCO/jRPPAJGAcmMM9f87vKfG3AF+AucMAgS5LgRZ4CH/mFrARkieAs8Aw4ASSBckaS++jZLOv6El4HjAKDwPoIa28GXgLdFmQv4WcO2BVBnXTmeIxK+D5wzLGXa8D1CGT78NPPhjFlGnjAmBbPSLefx65IBf+eZZ81hfznIfsr+W0eaACa2G3MhbuAt8CUD1kyRIfongDa4affhW4Nu2Oj0d2Bfg+6Y2UIukr2x4ShkAMOMQlNyLcmgVqj7z2wk17UDDosFOOYMOdPQ+dkyBcZFkb8DGxz2ckTwrKHA8g6HMn7gQWjbzsHqZSUmJ8sej6Cq7WzrhkzKVeYnmSEXSBM6I17RZ+WNWRfJ6z7K2xy1umUc7lGDizIkDL+AsNRXs6U3YpOUrRfWwS01K2noIuLzg+iTcFSiFLKlQPi8+aNAIwri24QlstaEM6JdoIsHBOdiyJl9RntfiXazUljEdJb3IKw1F10Q/Krtin0KaSD5Ido77MYK10sG0S4ByjzwW2LRT3pYlxLRBFpGM91/r9kRJuC/FbEnVEmhEwQYRqw7IMuC8LjnAKllSeBhEI0Qc8U636luWinWxYPqoFCnuxmX16VR9ldCvINqOH/NK5alpe8NY8qL5Nnl/GMFJhU6g2SZtqaw1xCkrss2pGEFhLp0CxuGow83+BDdoDn+FP8hJFeYusNlODL9LI/ubKLRRxDKfamuaNWRBx4o9TI49NDD9yjSdn9NKFa5jTGrdrIKpw1FJCtU8h6Rp/HwbVyBNOOSGtKGHJKtGdAao/NBO4aWrecS9mwQiuU8KLoi1nOEfepQ6TsFXVxnnO0NWFZEdVZjK8RaSgXoHtGbihwh4ViCM+LvhaL8VJ3xscdqnwOCk4xhDNKYNRHPOZfCakbzGOS+SWyloX8KsIj4lNScLwIuTsgsq+ASnFkmor4JdJayopKeEHZGOJ8OzMoatIkF0XvxIm5cGhcUtyhVqlrh4rNNoU8fI+jOCUs3cYIk14L63py9yo2D7fyBZ+t3AGuWgTmiFOCuCIvHuHFo6QbCpxm4GLIxZ+880j/K8Lm593EVZqnXF9N8UXIFt7zgwoeunDZCJzju44M+nKlEP4twAAD1RclkNDukAAAAABJRU5ErkJggg==";
                
                      WheelZoomTool.prototype.event_type = 'ontouchstart' in document ? 'pinch' : 'scroll';
                
                      WheelZoomTool.prototype.default_order = 10;
                
                      WheelZoomTool.prototype.initialize = function(attrs, options) {
                        WheelZoomTool.__super__.initialize.call(this, attrs, options);
                        this.register_property('tooltip', function() {
                          return this._get_dim_tooltip(this.get("tool_name"), this._check_dims(this.get('dimensions'), "wheel zoom tool"));
                        }, false);
                        return this.add_dependencies('tooltip', this, ['dimensions']);
                      };
                
                      WheelZoomTool.prototype.defaults = function() {
                        return _.extend({}, WheelZoomTool.__super__.defaults.call(this), {
                          dimensions: ["width", "height"],
                          speed: 1 / 600
                        });
                      };
                
                      return WheelZoomTool;
                
                    })(GestureTool.Model);
                    WheelZoomTools = (function(_super) {
                      __extends(WheelZoomTools, _super);
                
                      function WheelZoomTools() {
                        _ref2 = WheelZoomTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      WheelZoomTools.prototype.model = WheelZoomTool;
                
                      return WheelZoomTools;
                
                    })(Collection);
                    return {
                      "Model": WheelZoomTool,
                      "Collection": new WheelZoomTools(),
                      "View": WheelZoomToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=wheel_zoom_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/inspectors/crosshair_tool',["underscore", "common/collection", "renderer/annotation/span", "./inspect_tool"], function(_, Collection, Span, InspectTool) {
                    var CrosshairTool, CrosshairToolView, CrosshairTools, _ref, _ref1, _ref2;
                    CrosshairToolView = (function(_super) {
                      __extends(CrosshairToolView, _super);
                
                      function CrosshairToolView() {
                        _ref = CrosshairToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CrosshairToolView.prototype._move = function(e) {
                        var canvas, dim, frame, span, vx, vy, _i, _len, _ref1, _results;
                        if (!this.mget('active')) {
                          return;
                        }
                        frame = this.plot_model.get('frame');
                        canvas = this.plot_model.get('canvas');
                        vx = canvas.sx_to_vx(e.bokeh.sx);
                        vy = canvas.sy_to_vy(e.bokeh.sy);
                        _ref1 = this.mget('dimensions');
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          dim = _ref1[_i];
                          span = this.mget('spans')[dim];
                          if (!frame.contains(vx, vy)) {
                            _results.push(span.unset('location'));
                          } else {
                            if (dim === "width") {
                              _results.push(span.set('location', vy));
                            } else {
                              _results.push(span.set('location', vx));
                            }
                          }
                        }
                        return _results;
                      };
                
                      CrosshairToolView.prototype._move_exit = function(e) {
                        var dim, span, _i, _len, _ref1, _results;
                        _ref1 = this.mget('dimensions');
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          dim = _ref1[_i];
                          span = this.mget('spans')[dim];
                          _results.push(span.unset('location'));
                        }
                        return _results;
                      };
                
                      return CrosshairToolView;
                
                    })(InspectTool.View);
                    CrosshairTool = (function(_super) {
                      __extends(CrosshairTool, _super);
                
                      function CrosshairTool() {
                        _ref1 = CrosshairTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CrosshairTool.prototype.default_view = CrosshairToolView;
                
                      CrosshairTool.prototype.type = "CrosshairTool";
                
                      CrosshairTool.prototype.tool_name = "Crosshair";
                
                      CrosshairTool.prototype.initialize = function(attrs, options) {
                        var renderers;
                        CrosshairTool.__super__.initialize.call(this, attrs, options);
                        this.register_property('tooltip', function() {
                          return this._get_dim_tooltip("Crosshair", this._check_dims(this.get('dimensions'), "crosshair tool"));
                        }, false);
                        this.add_dependencies('tooltip', this, ['dimensions']);
                        this.set('spans', {
                          width: new Span.Model({
                            dimension: "width"
                          }),
                          height: new Span.Model({
                            dimension: "height"
                          })
                        });
                        renderers = this.get('plot').get('renderers');
                        renderers.push(this.get('spans').width);
                        renderers.push(this.get('spans').height);
                        return this.get('plot').set('renderers', renderers);
                      };
                
                      CrosshairTool.prototype.defaults = function() {
                        return _.extend({}, CrosshairTool.__super__.defaults.call(this), {
                          dimensions: ["width", "height"]
                        });
                      };
                
                      return CrosshairTool;
                
                    })(InspectTool.Model);
                    CrosshairTools = (function(_super) {
                      __extends(CrosshairTools, _super);
                
                      function CrosshairTools() {
                        _ref2 = CrosshairTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      CrosshairTools.prototype.model = CrosshairTool;
                
                      return CrosshairTools;
                
                    })(Collection);
                    return {
                      "Model": CrosshairTool,
                      "Collection": new CrosshairTools(),
                      "View": CrosshairToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=crosshair_tool.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/inspectors/hover_tool',["underscore", "sprintf", "common/collection", "renderer/annotation/tooltip", "./inspect_tool"], function(_, sprintf, Collection, Tooltip, InspectTool) {
                    var HoverTool, HoverToolView, HoverTools, _color_to_hex, _format_number, _ref, _ref1, _ref2;
                    _color_to_hex = function(color) {
                      var blue, digits, green, red, rgb;
                      if (color.substr(0, 1) === '#') {
                        return color;
                      }
                      digits = /(.*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color);
                      red = parseInt(digits[2]);
                      green = parseInt(digits[3]);
                      blue = parseInt(digits[4]);
                      rgb = blue | (green << 8) | (red << 16);
                      return digits[1] + '#' + rgb.toString(16);
                    };
                    _format_number = function(number) {
                      if (typeof number === "string") {
                        return number;
                      }
                      if (Math.floor(number) === number) {
                        return sprintf("%d", number);
                      }
                      if (Math.abs(number) > 0.1 && Math.abs(number) < 1000) {
                        return sprintf("%0.3f", number);
                      }
                      return sprintf("%0.3e", number);
                    };
                    HoverToolView = (function(_super) {
                      __extends(HoverToolView, _super);
                
                      function HoverToolView() {
                        _ref = HoverToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      HoverToolView.prototype.bind_bokeh_events = function() {
                        var r, _i, _len, _ref1;
                        _ref1 = this.mget('renderers');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          r = _ref1[_i];
                          this.listenTo(r.get('data_source'), 'inspect', this._update);
                        }
                        return this.plot_view.canvas_view.canvas_wrapper.css('cursor', 'crosshair');
                      };
                
                      HoverToolView.prototype._move = function(e) {
                        var canvas, vx, vy;
                        if (!this.mget('active')) {
                          return;
                        }
                        canvas = this.plot_view.canvas;
                        vx = canvas.sx_to_vx(e.bokeh.sx);
                        vy = canvas.sy_to_vy(e.bokeh.sy);
                        if (!this.plot_view.frame.contains(vx, vy)) {
                          this.mget('tooltip').clear();
                          return;
                        }
                        return this._inspect(vx, vy);
                      };
                
                      HoverToolView.prototype._move_exit = function() {
                        return this.mget('tooltip').clear();
                      };
                
                      HoverToolView.prototype._inspect = function(vx, vy, e) {
                        var geometry, r, sm, _i, _len, _ref1, _results;
                        geometry = {
                          type: 'point',
                          vx: vx,
                          vy: vy
                        };
                        _ref1 = this.mget('renderers');
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          r = _ref1[_i];
                          sm = r.get('data_source').get('selection_manager');
                          _results.push(sm.inspect(this, this.plot_view.renderers[r.id], geometry, {
                            "geometry": geometry
                          }));
                        }
                        return _results;
                      };
                
                      HoverToolView.prototype._update = function(indices, tool, renderer, ds, _arg) {
                        var canvas, colname, color, column, column_name, dsvalue, frame, geometry, hex, i, label, match, opts, row, rx, ry, span, swatch, sx, sy, table, td, unused, value, vx, vy, x, xmapper, y, ymapper, _i, _len, _ref1, _ref2, _ref3, _ref4;
                        geometry = _arg.geometry;
                        this.mget('tooltip').clear();
                        if (indices.length === 0) {
                          return;
                        }
                        vx = geometry.vx;
                        vy = geometry.vy;
                        canvas = this.plot_model.get('canvas');
                        frame = this.plot_model.get('frame');
                        sx = canvas.vx_to_sx(vx);
                        sy = canvas.vy_to_sy(vy);
                        xmapper = frame.get('x_mappers')[renderer.mget('x_range_name')];
                        ymapper = frame.get('y_mappers')[renderer.mget('y_range_name')];
                        x = xmapper.map_from_target(vx);
                        y = ymapper.map_from_target(vy);
                        for (_i = 0, _len = indices.length; _i < _len; _i++) {
                          i = indices[_i];
                          if (this.mget('snap_to_data')) {
                            rx = canvas.sx_to_vx(renderer.glyph.sx[i]);
                            ry = canvas.sy_to_vy(renderer.glyph.sy[i]);
                          } else {
                            _ref1 = [vx, vy], rx = _ref1[0], ry = _ref1[1];
                          }
                          table = $('<table></table>');
                          _ref2 = this.mget("tooltips");
                          for (label in _ref2) {
                            value = _ref2[label];
                            row = $("<tr></tr>");
                            row.append($("<td class='bk-tooltip-row-label'>" + label + ": </td>"));
                            td = $("<td class='bk-tooltip-row-value'></td>");
                            if (value.indexOf("$color") >= 0) {
                              _ref3 = value.match(/\$color(\[.*\])?:(\w*)/), match = _ref3[0], opts = _ref3[1], colname = _ref3[2];
                              column = ds.get_column(colname);
                              if (column == null) {
                                span = $("<span>" + colname + " unknown</span>");
                                td.append(span);
                                continue;
                              }
                              hex = (opts != null ? opts.indexOf("hex") : void 0) >= 0;
                              swatch = (opts != null ? opts.indexOf("swatch") : void 0) >= 0;
                              color = column[i];
                              if (color == null) {
                                span = $("<span>(null)</span>");
                                td.append(span);
                                continue;
                              }
                              if (hex) {
                                color = _color_to_hex(color);
                              }
                              span = $("<span>" + color + "</span>");
                              td.append(span);
                              if (swatch) {
                                span = $("<span class='bk-tooltip-color-block'> </span>");
                                span.css({
                                  backgroundColor: color
                                });
                              }
                              td.append(span);
                            } else {
                              value = value.replace("$index", "" + i);
                              value = value.replace("$x", "" + (_format_number(x)));
                              value = value.replace("$y", "" + (_format_number(y)));
                              value = value.replace("$vx", "" + vx);
                              value = value.replace("$vy", "" + vy);
                              value = value.replace("$sx", "" + sx);
                              value = value.replace("$sy", "" + sy);
                              while (value.indexOf("@") >= 0) {
                                _ref4 = value.match(/(@)(\w*)/), match = _ref4[0], unused = _ref4[1], column_name = _ref4[2];
                                column = ds.get_column(column_name);
                                if (column == null) {
                                  value = value.replace(column_name, "" + column_name + " unknown");
                                  break;
                                }
                                column = ds.get_column(column_name);
                                dsvalue = column[i];
                                if (typeof dsvalue === "number") {
                                  value = value.replace(match, "" + (_format_number(dsvalue)));
                                } else {
                                  value = value.replace(match, "" + dsvalue);
                                }
                              }
                              span = $("<span>" + value + "</span>");
                              td.append(span);
                            }
                            row.append(td);
                            table.append(row);
                          }
                          this.mget('tooltip').add(rx, ry, table);
                        }
                        return null;
                      };
                
                      return HoverToolView;
                
                    })(InspectTool.View);
                    HoverTool = (function(_super) {
                      var icon;
                
                      __extends(HoverTool, _super);
                
                      function HoverTool() {
                        _ref1 = HoverTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      HoverTool.prototype.default_view = HoverToolView;
                
                      HoverTool.prototype.type = "HoverTool";
                
                      HoverTool.prototype.tool_name = "Hover Tool";
                
                      icon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA8ElEQVQ4T42T0Q2CMBCGaQjPxgmMG/jelIQN3ECZQEfADRwBJzBuQCC81wlkBHxvqP8lmhTsUfpSWvp/vfvvKiJn1HVdpml6dPdC38I90DSNxVobYzKMPiSm/z5AZK3t4zjOpJQ6BPECfiKAcqRUzkFmASQEhHzJOUgQ8BWyviwFsL4sBnC+LAE84YMWQnSAVCixdkvMAiB6Q7TCfJtrLq4PHkmSnHHbi0LHvOYa6w/g3kitjSgOYFyUUoWvlCPA9C1gvQfgDmiHNLZBgO8A3geZt+G6chQBA7hi/0QVQBrZ9EwQ0LbtbhgGghQAVFPAB25HmRH8b2/nAAAAAElFTkSuQmCC';
                
                      HoverTool.prototype.initialize = function(attrs, options) {
                        var renderers;
                        HoverTool.__super__.initialize.call(this, attrs, options);
                        this.set('tooltip', new Tooltip.Model());
                        renderers = this.get('plot').get('renderers');
                        renderers.push(this.get('tooltip'));
                        return this.get('plot').set('renderers', renderers);
                      };
                
                      HoverTool.prototype.defaults = function() {
                        return _.extend({}, HoverTool.__super__.defaults.call(this), {
                          snap_to_data: true,
                          tooltips: {
                            "index": "$index",
                            "data (x, y)": "($x, $y)",
                            "canvas (x, y)": "($sx, $sy)"
                          }
                        });
                      };
                
                      return HoverTool;
                
                    })(InspectTool.Model);
                    HoverTools = (function(_super) {
                      __extends(HoverTools, _super);
                
                      function HoverTools() {
                        _ref2 = HoverTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      HoverTools.prototype.model = HoverTool;
                
                      return HoverTools;
                
                    })(Collection);
                    return {
                      "Model": HoverTool,
                      "Collection": new HoverTools(),
                      "View": HoverToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=hover_tool.js.map
                */;
                define('widget/data_table_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      var column, idx, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
                    
                      _print(_safe('<table class="bk-bs-table bk-bs-table-bordered">\n  <thead>\n    '));
                    
                      if (this.counts) {
                        _print(_safe('\n      <th>counts</th>\n    '));
                      }
                    
                      _print(_safe('\n    <th>index</th>\n    '));
                    
                      _ref = this.columns;
                      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        column = _ref[_i];
                        _print(_safe('\n      '));
                        if (!this.skip[column]) {
                          _print(_safe('\n        <th style="white-space: nowrap;" data-cdx-column="'));
                          _print(column);
                          _print(_safe('">\n          <a class="pandascolumn">'));
                          _print(column);
                          _print(_safe('</a>\n          '));
                          if (this.sort_ascendings[column] === true) {
                            _print(_safe('\n            <i class="cdx-column-sort fa fa-sort-up"></i>\n          '));
                          } else if (this.sort_ascendings[column] === false) {
                            _print(_safe('\n            <i class="cdx-column-sort fa fa-sort-down"></i>\n          '));
                          } else {
                            _print(_safe('\n            <i class="cdx-column-sort fa fa-sort"></i>\n          '));
                          }
                          _print(_safe('\n        </th>\n      '));
                        }
                        _print(_safe('\n    '));
                      }
                    
                      _print(_safe('\n  </thead>\n  '));
                    
                      _ref1 = _.range(this.length);
                      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                        idx = _ref1[_j];
                        _print(_safe('\n  <tr class="pandasrow" rownum="'));
                        _print(idx);
                        _print(_safe('">\n    '));
                        if (this.selected && this.selected[idx]) {
                          _print(_safe('\n      <td style="background-color:'));
                          _print(this.colors[idx]);
                          _print(_safe('">\n        '));
                          _print(this.selected[idx]);
                          _print(_safe('/'));
                          _print(this.counts[idx]);
                          _print(_safe('\n      </td>\n    '));
                        } else {
                          _print(_safe('\n      <td> '));
                          _print(this.counts[idx]);
                          _print(_safe(' </td>\n    '));
                        }
                        _print(_safe('\n    <td> '));
                        _print(this.index[idx]);
                        _print(_safe(' </td>\n    '));
                        _ref2 = this.columns;
                        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                          column = _ref2[_k];
                          _print(_safe('\n      '));
                          if (!this.skip[column]) {
                            _print(_safe('\n      <td> '));
                            _print(this.data[column][idx]);
                            _print(_safe(' </td>\n      '));
                          }
                          _print(_safe('\n    '));
                        }
                        _print(_safe('\n  </tr>\n  '));
                      }
                    
                      _print(_safe('\n</table>\n<form>\n  <center>\n    <ul class="pagination">\n      <li><a href="javascript://" class="cdx-go-first">First</a></li>\n      <li><a href="javascript://" class="cdx-go-prev">Previous</a></li>\n      <li><a href="javascript://" class="cdx-go-next">Next</a></li>\n      <li><a href="javascript://" class="cdx-go-last">Last</a></li>\n    </ul>\n    <div class="paginatedisplay">\n      Show <input type="text" class="pandassize" value="'));
                    
                      _print(this.length);
                    
                      _print(_safe('"> records\n      From <input type="text" class="pandasoffset" value="'));
                    
                      _print(this.offset);
                    
                      _print(_safe('">\n      to '));
                    
                      _print(this.length + this.offset);
                    
                      _print(_safe(' -\n      Total: '));
                    
                      _print(this.totallength);
                    
                      _print(_safe('\n    </div>\n  </center>\n</form>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/data_table',["underscore", "common/collection", "common/has_parent", "common/continuum_view", "./data_table_template"], function(_, Collection, HasParent, ContinuumView, data_table_template) {
                    var DataTable, DataTableView, DataTables, ENTER, _ref, _ref1, _ref2;
                    ENTER = 13;
                    DataTableView = (function(_super) {
                      __extends(DataTableView, _super);
                
                      function DataTableView() {
                        this.colors = __bind(this.colors, this);
                        this.go_last = __bind(this.go_last, this);
                        this.go_next = __bind(this.go_next, this);
                        this.go_prev = __bind(this.go_prev, this);
                        this.go_first = __bind(this.go_first, this);
                        this.toggle_more_controls = __bind(this.toggle_more_controls, this);
                        this.sort = __bind(this.sort, this);
                        this.rowclick = __bind(this.rowclick, this);
                        this.toggle_filterselected = __bind(this.toggle_filterselected, this);
                        this.clearselected = __bind(this.clearselected, this);
                        this.computedtxtbox = __bind(this.computedtxtbox, this);
                        this.column_del = __bind(this.column_del, this);
                        this.search = __bind(this.search, this);
                        _ref = DataTableView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DataTableView.prototype.template = data_table_template;
                
                      DataTableView.prototype.initialize = function(options) {
                        DataTableView.__super__.initialize.call(this, options);
                        this.listenTo(this.model, 'destroy', this.remove);
                        this.listenTo(this.model, 'change', this.render);
                        return this.render();
                      };
                
                      DataTableView.prototype.events = {
                        "keyup .pandasgroup": 'pandasgroup',
                        "keyup .pandasoffset": 'pandasoffset',
                        "keyup .pandassize": 'pandassize',
                        "change .pandasagg": 'pandasagg',
                        "click .cdx-go-first": 'go_first',
                        "click .cdx-go-prev": 'go_prev',
                        "click .cdx-go-next": 'go_next',
                        "click .cdx-go-last": 'go_last',
                        "click .controlsmore": 'toggle_more_controls',
                        "click .cdx-column-sort": 'sort',
                        "click .pandasrow": 'rowclick',
                        "click .filterselected": 'toggle_filterselected',
                        "click .clearselected": 'clearselected',
                        "keyup .computedtxtbox": 'computedtxtbox',
                        "click .column_del": "column_del",
                        "keyup .search": 'search'
                      };
                
                      DataTableView.prototype.search = function(e) {
                        var code, source;
                        if (e.keyCode === ENTER) {
                          code = $(e.currentTarget).val();
                          source = this.model.get('source');
                          source.rpc('search', [code]);
                          return e.preventDefault();
                        }
                      };
                
                      DataTableView.prototype.column_del = function(e) {
                        var computed_columns, name, old, source;
                        source = this.model.get('source');
                        old = source.get('computed_columns');
                        name = $(e.currentTarget).attr('name');
                        computed_columns = _.filter(old, function(x) {
                          return x.name !== name;
                        });
                        return source.rpc('set_computed_columns', [computed_columns]);
                      };
                
                      DataTableView.prototype.computedtxtbox = function(e) {
                        var code, name, old, source;
                        if (e.keyCode === ENTER) {
                          name = this.$('.computedname').val();
                          code = this.$('.computedtxtbox').val();
                          source = this.model.get('source');
                          old = source.get('computed_columns');
                          old.push({
                            name: name,
                            code: code
                          });
                          source.rpc('set_computed_columns', [old]);
                          return e.preventDefault();
                        }
                      };
                
                      DataTableView.prototype.clearselected = function(e) {
                        return this.model.rpc('setselect', [[]]);
                      };
                
                      DataTableView.prototype.toggle_filterselected = function(e) {
                        var checked;
                        checked = this.$('.filterselected').is(":checked");
                        this.mset('filterselected', checked);
                        return this.model.save();
                      };
                
                      DataTableView.prototype.rowclick = function(e) {
                        var count, counts, idx, index, ratio, ratios, resp, rownum, select, selected;
                        counts = this.counts();
                        selected = this.selected();
                        ratios = (function() {
                          var _i, _len, _ref1, _ref2, _results;
                          _ref1 = _.zip(selected, counts);
                          _results = [];
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            _ref2 = _ref1[_i], select = _ref2[0], count = _ref2[1];
                            _results.push(select / count);
                          }
                          return _results;
                        })();
                        selected = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (idx = _i = 0, _len = ratios.length; _i < _len; idx = ++_i) {
                            ratio = ratios[idx];
                            if (ratio > 0.5) {
                              _results.push(idx);
                            }
                          }
                          return _results;
                        })();
                        rownum = Number($(e.currentTarget).attr('rownum'));
                        index = selected.indexOf(rownum);
                        if (index === -1) {
                          resp = this.model.rpc('select', [[rownum]]);
                        } else {
                          resp = this.model.rpc('deselect', [[rownum]]);
                        }
                        return null;
                      };
                
                      DataTableView.prototype.sort = function(event) {
                        var column;
                        column = $(event.currentTarget).parent().data("cdx-column");
                        return this.model.toggle_column_sort(column);
                      };
                
                      DataTableView.prototype.toggle_more_controls = function() {
                        if (this.controls_hide) {
                          this.controls_hide = false;
                        } else {
                          this.controls_hide = true;
                        }
                        return this.render();
                      };
                
                      DataTableView.prototype.go_first = function() {
                        return this.model.go_first();
                      };
                
                      DataTableView.prototype.go_prev = function() {
                        return this.model.go_prev();
                      };
                
                      DataTableView.prototype.go_next = function() {
                        return this.model.go_next();
                      };
                
                      DataTableView.prototype.go_last = function() {
                        return this.model.go_last();
                      };
                
                      DataTableView.prototype.pandasoffset = function(e) {
                        var offset;
                        if (e.keyCode === ENTER) {
                          offset = this.$el.find('.pandasoffset').val();
                          offset = Number(offset);
                          if (_.isNaN(offset)) {
                            offset = this.model.defaults.offset;
                          }
                          this.model.save('offset', offset, {
                            wait: true
                          });
                          return e.preventDefault();
                        }
                      };
                
                      DataTableView.prototype.pandassize = function(e) {
                        var size, sizetxt;
                        if (e.keyCode === ENTER) {
                          sizetxt = this.$el.find('.pandassize').val();
                          size = Number(sizetxt);
                          if (_.isNaN(size) || sizetxt === "") {
                            size = this.model.defaults.length;
                          }
                          if (size + this.mget('offset') > this.mget('maxlength')) {
                            size = this.mget('maxlength') - this.mget('offset');
                          }
                          this.model.save('length', size, {
                            wait: true
                          });
                          return e.preventDefault();
                        }
                      };
                
                      DataTableView.prototype.pandasagg = function() {
                        return this.model.save('agg', this.$el.find('.pandasagg').val(), {
                          'wait': true
                        });
                      };
                
                      DataTableView.prototype.fromcsv = function(str) {
                        if (!str) {
                          return [];
                        }
                        return _.map(str.split(","), function(x) {
                          return x.trim();
                        });
                      };
                
                      DataTableView.prototype.pandasgroup = function(e) {
                        if (e.keyCode === ENTER) {
                          this.model.set({
                            group: this.fromcsv(this.$el.find(".pandasgroup").val()),
                            offset: 0
                          });
                          this.model.save();
                          e.preventDefault();
                          return false;
                        }
                      };
                
                      DataTableView.prototype.counts = function() {
                        return this.mget('tabledata').data._counts;
                      };
                
                      DataTableView.prototype.selected = function() {
                        return this.mget('tabledata').data._selected;
                      };
                
                      DataTableView.prototype.colors = function() {
                        var counts, selected;
                        counts = this.counts();
                        selected = this.selected();
                        if (counts && selected) {
                          return _.map(_.zip(counts, selected), function(temp) {
                            var alpha, count;
                            count = temp[0], selected = temp[1];
                            alpha = 0.3 * selected / count;
                            return "rgba(0,0,255," + alpha + ")";
                          });
                        } else {
                          return null;
                        }
                      };
                
                      DataTableView.prototype.render = function() {
                        var colors, group, html, obj, sort, sort_ascendings, source, template_data, _i, _len, _ref1;
                        group = this.mget('group');
                        if (_.isArray(group)) {
                          group = group.join(",");
                        }
                        sort = this.mget('sort');
                        if (_.isArray(sort)) {
                          sort = sort.join(",");
                        }
                        colors = this.colors();
                        sort_ascendings = {};
                        _ref1 = this.mget('sort');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          obj = _ref1[_i];
                          sort_ascendings[obj['column']] = obj['ascending'];
                        }
                        source = this.mget('source');
                        template_data = {
                          skip: {
                            _counts: true,
                            _selected: true,
                            index: true
                          },
                          computed_columns: this.mget('source').get('computed_columns'),
                          columns: this.mget('tabledata').column_names,
                          data: this.mget('tabledata').data,
                          group: group,
                          sort_ascendings: sort_ascendings,
                          offset: this.mget('offset'),
                          length: this.model.length(),
                          filterselected: this.mget('filterselected'),
                          totallength: this.mget('totallength'),
                          counts: this.mget('tabledata').data._counts,
                          selected: this.mget('tabledata').data._selected,
                          controls_hide: this.controls_hide,
                          colors: colors,
                          index: this.mget('tabledata').data.index
                        };
                        this.$el.empty();
                        html = this.template(template_data);
                        this.$el.html(html);
                        this.$(".pandasagg").find("option[value=\"" + (this.mget('agg')) + "\"]").attr('selected', 'selected');
                        return this.$el.addClass("bk-table");
                      };
                
                      return DataTableView;
                
                    })(ContinuumView);
                    DataTable = (function(_super) {
                      __extends(DataTable, _super);
                
                      function DataTable() {
                        this.toggle_column_sort = __bind(this.toggle_column_sort, this);
                        _ref1 = DataTable.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DataTable.prototype.type = 'DataTable';
                
                      DataTable.prototype.initialize = function(attrs, options) {
                        var _this = this;
                        DataTable.__super__.initialize.call(this, attrs, options);
                        return this.throttled_fetch = _.throttle((function() {
                          return _this.fetch();
                        }), 500);
                      };
                
                      DataTable.prototype.fetch = function(options) {
                        return DataTable.__super__.fetch.call(this, options);
                      };
                
                      DataTable.prototype.length = function() {
                        return _.values(this.get('tabledata').data)[0].length;
                      };
                
                      DataTable.prototype.toggle_column_sort = function(colname) {
                        var sort, sorting;
                        sorting = this.get('sort');
                        this.unset('sort', {
                          'silent': true
                        });
                        sort = _.filter(sorting, function(x) {
                          return x['column'] === colname;
                        });
                        if (sort.length > 0) {
                          sort = sort[0];
                        } else {
                          sorting = _.clone(sorting);
                          sorting.push({
                            column: colname,
                            ascending: true
                          });
                          this.save('sort', sorting, {
                            'wait': true
                          });
                          return;
                        }
                        if (sort['ascending']) {
                          sort['ascending'] = false;
                          this.save('sort', sorting, {
                            'wait': true
                          });
                        } else {
                          sorting = _.filter(sorting, function(x) {
                            return x['column'] !== colname;
                          });
                          this.save('sort', sorting, {
                            'wait': true
                          });
                        }
                      };
                
                      DataTable.prototype.go_first = function() {
                        this.set('offset', 0);
                        return this.save();
                      };
                
                      DataTable.prototype.go_prev = function() {
                        var offset;
                        offset = this.get('offset');
                        offset = offset - this.length();
                        if (offset < 0) {
                          offset = 0;
                        }
                        this.set('offset', offset);
                        return this.save();
                      };
                
                      DataTable.prototype.go_next = function() {
                        var maxoffset, offset;
                        offset = this.get('offset');
                        offset = offset + this.length();
                        maxoffset = this.get('maxlength') - this.length();
                        if (offset > maxoffset) {
                          offset = maxoffset;
                        }
                        this.set('offset', offset);
                        return this.save();
                      };
                
                      DataTable.prototype.go_last = function() {
                        var maxoffset;
                        maxoffset = this.get('maxlength') - this.length();
                        this.set('offset', maxoffset);
                        return this.save();
                      };
                
                      DataTable.prototype.default_view = DataTableView;
                
                      DataTable.prototype.defaults = function() {
                        return _.extend({}, DataTable.__super__.defaults.call(this), {
                          sort: [],
                          group: [],
                          agg: 'sum',
                          offset: 0,
                          length: 100,
                          maxlength: 1000,
                          tabledata: null,
                          columns_names: []
                        });
                      };
                
                      return DataTable;
                
                    })(HasParent);
                    DataTables = (function(_super) {
                      __extends(DataTables, _super);
                
                      function DataTables() {
                        _ref2 = DataTables.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      DataTables.prototype.model = DataTable;
                
                      return DataTables;
                
                    })(Collection);
                    return {
                      "Model": DataTable,
                      "Collection": new DataTables(),
                      "View": DataTableView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=data_table.js.map
                */;
                /*!
                 * Handsontable 0.11.1
                 * Handsontable is a simple jQuery plugin for editable tables with basic copy-paste compatibility with Excel and Google Docs
                 *
                 * Copyright 2012-2014 Marcin Warpechowski
                 * Licensed under the MIT license.
                 * http://handsontable.com/
                 *
                 * Date: Fri Sep 05 2014 12:54:36 GMT+0200 (CEST)
                 */
                /*jslint white: true, browser: true, plusplus: true, indent: 4, maxerr: 50 */
                
                var Handsontable = { //class namespace
                  plugins: {}, //plugin namespace
                  helper: {} //helper namespace
                };
                
                (function ($, window, Handsontable) {
                  
                //http://stackoverflow.com/questions/3629183/why-doesnt-indexof-work-on-an-array-ie8
                if (!Array.prototype.indexOf) {
                  Array.prototype.indexOf = function (elt /*, from*/) {
                    var len = this.length >>> 0;
                
                    var from = Number(arguments[1]) || 0;
                    from = (from < 0)
                      ? Math.ceil(from)
                      : Math.floor(from);
                    if (from < 0)
                      from += len;
                
                    for (; from < len; from++) {
                      if (from in this &&
                        this[from] === elt)
                        return from;
                    }
                    return -1;
                  };
                }
                /**
                 * Array.filter() shim by Trevor Menagh (https://github.com/trevmex) with some modifications
                 */
                
                if (!Array.prototype.filter) {
                  Array.prototype.filter = function (fun, thisp) {
                    
                
                    if (typeof this === "undefined" || this === null) {
                      throw new TypeError();
                    }
                    if (typeof fun !== "function") {
                      throw new TypeError();
                    }
                
                    thisp = thisp || this;
                
                    if (isNodeList(thisp)) {
                      thisp = convertNodeListToArray(thisp);
                    }
                
                    var len = thisp.length,
                      res = [],
                      i,
                      val;
                
                    for (i = 0; i < len; i += 1) {
                      if (thisp.hasOwnProperty(i)) {
                        val = thisp[i]; // in case fun mutates this
                        if (fun.call(thisp, val, i, thisp)) {
                          res.push(val);
                        }
                      }
                    }
                
                    return res;
                
                    function isNodeList(object) {
                      return /NodeList/i.test(object.item);
                    }
                
                    function convertNodeListToArray(nodeList) {
                      var array = [];
                
                      for (var i = 0, len = nodeList.length; i < len; i++){
                        array[i] = nodeList[i]
                      }
                
                      return array;
                    }
                  };
                }
                
                /*
                 * Copyright 2012 The Polymer Authors. All rights reserved.
                 * Use of this source code is governed by a BSD-style
                 * license that can be found in the LICENSE file.
                 */
                
                if (typeof WeakMap === 'undefined') {
                  (function() {
                    var defineProperty = Object.defineProperty;
                
                    try {
                      var properDefineProperty = true;
                      defineProperty(function(){}, 'foo', {});
                    } catch (e) {
                      properDefineProperty = false;
                    }
                
                    /*
                      IE8 does not support Date.now() but IE8 compatibility mode in IE9 and IE10 does.
                      M$ deserves a high five for this one :)
                     */
                    var counter = +(new Date) % 1e9;
                
                    var WeakMap = function() {
                      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');
                      if(!properDefineProperty){
                        this._wmCache = [];
                      }
                    };
                
                    if(properDefineProperty){
                      WeakMap.prototype = {
                        set: function(key, value) {
                          var entry = key[this.name];
                          if (entry && entry[0] === key)
                            entry[1] = value;
                          else
                            defineProperty(key, this.name, {value: [key, value], writable: true});
                
                        },
                        get: function(key) {
                          var entry;
                          return (entry = key[this.name]) && entry[0] === key ?
                            entry[1] : undefined;
                        },
                        'delete': function(key) {
                          this.set(key, undefined);
                        }
                      };
                    } else {
                      WeakMap.prototype = {
                        set: function(key, value) {
                
                          if(typeof key == 'undefined' || typeof value == 'undefined') return;
                
                          for(var i = 0, len = this._wmCache.length; i < len; i++){
                            if(this._wmCache[i].key == key){
                              this._wmCache[i].value = value;
                              return;
                            }
                          }
                
                          this._wmCache.push({key: key, value: value});
                
                        },
                        get: function(key) {
                
                          if(typeof key == 'undefined') return;
                
                          for(var i = 0, len = this._wmCache.length; i < len; i++){
                            if(this._wmCache[i].key == key){
                              return  this._wmCache[i].value;
                            }
                          }
                
                          return;
                
                        },
                        'delete': function(key) {
                
                          if(typeof key == 'undefined') return;
                
                          for(var i = 0, len = this._wmCache.length; i < len; i++){
                            if(this._wmCache[i].key == key){
                              Array.prototype.slice.call(this._wmCache, i, 1);
                            }
                          }
                        }
                      };
                    }
                
                    window.WeakMap = WeakMap;
                  })();
                }
                
                Handsontable.activeGuid = null;
                
                /**
                 * Handsontable constructor
                 * @param rootElement The jQuery element in which Handsontable DOM will be inserted
                 * @param userSettings
                 * @constructor
                 */
                Handsontable.Core = function (rootElement, userSettings) {
                  var priv
                    , datamap
                    , grid
                    , selection
                    , editorManager
                    , instance = this
                    , GridSettings = function () {}
                    , $document = $(document.documentElement)
                    , $body = $(document.body);
                
                  Handsontable.helper.extend(GridSettings.prototype, DefaultSettings.prototype); //create grid settings as a copy of default settings
                  Handsontable.helper.extend(GridSettings.prototype, userSettings); //overwrite defaults with user settings
                  Handsontable.helper.extend(GridSettings.prototype, expandType(userSettings));
                
                  this.rootElement = rootElement;
                
                  this.container = document.createElement('DIV');
                  this.container.className = 'htContainer';
                  rootElement.prepend(this.container);
                  this.container = $(this.container);
                
                  this.guid = 'ht_' + Handsontable.helper.randomString(); //this is the namespace for global events
                
                  if (!this.rootElement[0].id) {
                    this.rootElement[0].id = this.guid; //if root element does not have an id, assign a random id
                  }
                
                  priv = {
                    cellSettings: [],
                    columnSettings: [],
                    columnsSettingConflicts: ['data', 'width'],
                    settings: new GridSettings(), // current settings instance
                    selRange: null, //exposed by public method `getSelectedRange`
                    isPopulated: null,
                    scrollable: null,
                    firstRun: true
                  };
                
                  grid = {
                    /**
                     * Inserts or removes rows and columns
                     * @param {String} action Possible values: "insert_row", "insert_col", "remove_row", "remove_col"
                     * @param {Number} index
                     * @param {Number} amount
                     * @param {String} [source] Optional. Source of hook runner.
                     * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
                     */
                    alter: function (action, index, amount, source, keepEmptyRows) {
                      var delta;
                
                      amount = amount || 1;
                
                      switch (action) {
                        case "insert_row":
                          delta = datamap.createRow(index, amount);
                
                          if (delta) {
                            if (selection.isSelected() && priv.selRange.from.row >= index) {
                              priv.selRange.from.row = priv.selRange.from.row + delta;
                              selection.transformEnd(delta, 0); //will call render() internally
                            }
                            else {
                              selection.refreshBorders(); //it will call render and prepare methods
                            }
                          }
                          break;
                
                        case "insert_col":
                          delta = datamap.createCol(index, amount);
                
                          if (delta) {
                
                            if(Handsontable.helper.isArray(instance.getSettings().colHeaders)){
                              var spliceArray = [index, 0];
                              spliceArray.length += delta; //inserts empty (undefined) elements at the end of an array
                              Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArray); //inserts empty (undefined) elements into the colHeader array
                            }
                
                            if (selection.isSelected() && priv.selRange.from.col >= index) {
                              priv.selRange.from.col = priv.selRange.from.col + delta;
                              selection.transformEnd(0, delta); //will call render() internally
                            }
                            else {
                              selection.refreshBorders(); //it will call render and prepare methods
                            }
                          }
                          break;
                
                        case "remove_row":
                          datamap.removeRow(index, amount);
                          priv.cellSettings.splice(index, amount);
                          grid.adjustRowsAndCols();
                          selection.refreshBorders(); //it will call render and prepare methods
                          break;
                
                        case "remove_col":
                          datamap.removeCol(index, amount);
                
                          for(var row = 0, len = datamap.getAll().length; row < len; row++){
                            if(row in priv.cellSettings){  //if row hasn't been rendered it wouldn't have cellSettings
                              priv.cellSettings[row].splice(index, amount);
                            }
                          }
                
                          if(Handsontable.helper.isArray(instance.getSettings().colHeaders)){
                            if(typeof index == 'undefined'){
                              index = -1;
                            }
                            instance.getSettings().colHeaders.splice(index, amount);
                          }
                
                          priv.columnSettings.splice(index, amount);
                
                          grid.adjustRowsAndCols();
                          selection.refreshBorders(); //it will call render and prepare methods
                          break;
                
                        default:
                          throw new Error('There is no such action "' + action + '"');
                          break;
                      }
                
                      if (!keepEmptyRows) {
                        grid.adjustRowsAndCols(); //makes sure that we did not add rows that will be removed in next refresh
                      }
                    },
                
                    /**
                     * Makes sure there are empty rows at the bottom of the table
                     */
                    adjustRowsAndCols: function () {
                      var r, rlen, emptyRows, emptyCols;
                
                      //should I add empty rows to data source to meet minRows?
                      rlen = instance.countRows();
                      if (rlen < priv.settings.minRows) {
                        for (r = 0; r < priv.settings.minRows - rlen; r++) {
                          datamap.createRow(instance.countRows(), 1, true);
                        }
                      }
                
                      emptyRows = instance.countEmptyRows(true);
                
                      //should I add empty rows to meet minSpareRows?
                      if (emptyRows < priv.settings.minSpareRows) {
                        for (; emptyRows < priv.settings.minSpareRows && instance.countRows() < priv.settings.maxRows; emptyRows++) {
                          datamap.createRow(instance.countRows(), 1, true);
                        }
                      }
                
                      //count currently empty cols
                      emptyCols = instance.countEmptyCols(true);
                
                      //should I add empty cols to meet minCols?
                      if (!priv.settings.columns && instance.countCols() < priv.settings.minCols) {
                        for (; instance.countCols() < priv.settings.minCols; emptyCols++) {
                          datamap.createCol(instance.countCols(), 1, true);
                        }
                      }
                
                      //should I add empty cols to meet minSpareCols?
                      if (!priv.settings.columns && instance.dataType === 'array' && emptyCols < priv.settings.minSpareCols) {
                        for (; emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols; emptyCols++) {
                          datamap.createCol(instance.countCols(), 1, true);
                        }
                      }
                
                      // if (priv.settings.enterBeginsEditing) {
                      //   for (; (((priv.settings.minRows || priv.settings.minSpareRows) && instance.countRows() > priv.settings.minRows) && (priv.settings.minSpareRows && emptyRows > priv.settings.minSpareRows)); emptyRows--) {
                      //     datamap.removeRow();
                      //   }
                      // }
                
                      // if (priv.settings.enterBeginsEditing && !priv.settings.columns) {
                      //   for (; (((priv.settings.minCols || priv.settings.minSpareCols) && instance.countCols() > priv.settings.minCols) && (priv.settings.minSpareCols && emptyCols > priv.settings.minSpareCols)); emptyCols--) {
                      //     datamap.removeCol();
                      //   }
                      // }
                
                      var rowCount = instance.countRows();
                      var colCount = instance.countCols();
                
                      if (rowCount === 0 || colCount === 0) {
                        selection.deselect();
                      }
                
                      if (selection.isSelected()) {
                        var selectionChanged;
                        var fromRow = priv.selRange.from.row;
                        var fromCol = priv.selRange.from.col;
                        var toRow = priv.selRange.to.row;
                        var toCol = priv.selRange.to.col;
                
                        //if selection is outside, move selection to last row
                        if (fromRow > rowCount - 1) {
                          fromRow = rowCount - 1;
                          selectionChanged = true;
                          if (toRow > fromRow) {
                            toRow = fromRow;
                          }
                        } else if (toRow > rowCount - 1) {
                          toRow = rowCount - 1;
                          selectionChanged = true;
                          if (fromRow > toRow) {
                            fromRow = toRow;
                          }
                        }
                
                        //if selection is outside, move selection to last row
                        if (fromCol > colCount - 1) {
                          fromCol = colCount - 1;
                          selectionChanged = true;
                          if (toCol > fromCol) {
                            toCol = fromCol;
                          }
                        } else if (toCol > colCount - 1) {
                          toCol = colCount - 1;
                          selectionChanged = true;
                          if (fromCol > toCol) {
                            fromCol = toCol;
                          }
                        }
                
                        if (selectionChanged) {
                          instance.selectCell(fromRow, fromCol, toRow, toCol);
                        }
                      }
                    },
                
                    /**
                     * Populate cells at position with 2d array
                     * @param {Object} start Start selection position
                     * @param {Array} input 2d array
                     * @param {Object} [end] End selection position (only for drag-down mode)
                     * @param {String} [source="populateFromArray"]
                     * @param {String} [method="overwrite"]
                     * @return {Object|undefined} ending td in pasted area (only if any cell was changed)
                     */
                    populateFromArray: function (start, input, end, source, method) {
                      var r, rlen, c, clen, setData = [], current = {};
                      rlen = input.length;
                      if (rlen === 0) {
                        return false;
                      }
                
                      var repeatCol
                        , repeatRow
                        , cmax
                        , rmax;
                
                      // insert data with specified pasteMode method
                      switch (method) {
                        case 'shift_down' :
                          repeatCol = end ? end.col - start.col + 1 : 0;
                          repeatRow = end ? end.row - start.row + 1 : 0;
                          input = Handsontable.helper.translateRowsToColumns(input);
                          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {
                            if (c < clen) {
                              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {
                                input[c].push(input[c][r % rlen]);
                              }
                              input[c].unshift(start.col + c, start.row, 0);
                              instance.spliceCol.apply(instance, input[c]);
                            }
                            else {
                              input[c % clen][0] = start.col + c;
                              instance.spliceCol.apply(instance, input[c % clen]);
                            }
                          }
                          break;
                
                        case 'shift_right' :
                          repeatCol = end ? end.col - start.col + 1 : 0;
                          repeatRow = end ? end.row - start.row + 1 : 0;
                          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {
                            if (r < rlen) {
                              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {
                                input[r].push(input[r][c % clen]);
                              }
                              input[r].unshift(start.row + r, start.col, 0);
                              instance.spliceRow.apply(instance, input[r]);
                            }
                            else {
                              input[r % rlen][0] = start.row + r;
                              instance.spliceRow.apply(instance, input[r % rlen]);
                            }
                          }
                          break;
                
                        case 'overwrite' :
                        default:
                          // overwrite and other not specified options
                          current.row = start.row;
                          current.col = start.col;
                          for (r = 0; r < rlen; r++) {
                            if ((end && current.row > end.row) || (!priv.settings.minSpareRows && current.row > instance.countRows() - 1) || (current.row >= priv.settings.maxRows)) {
                              break;
                            }
                            current.col = start.col;
                            clen = input[r] ? input[r].length : 0;
                            for (c = 0; c < clen; c++) {
                              if ((end && current.col > end.col) || (!priv.settings.minSpareCols && current.col > instance.countCols() - 1) || (current.col >= priv.settings.maxCols)) {
                                break;
                              }
                              if (!instance.getCellMeta(current.row, current.col).readOnly) {
                                setData.push([current.row, current.col, input[r][c]]);
                              }
                              current.col++;
                              if (end && c === clen - 1) {
                                c = -1;
                              }
                            }
                            current.row++;
                            if (end && r === rlen - 1) {
                              r = -1;
                            }
                          }
                          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');
                          break;
                      }
                    }
                  };
                
                  this.selection = selection = { //this public assignment is only temporary
                    inProgress: false,
                
                    /**
                     * Sets inProgress to true. This enables onSelectionEnd and onSelectionEndByProp to function as desired
                     */
                    begin: function () {
                      instance.selection.inProgress = true;
                    },
                
                    /**
                     * Sets inProgress to false. Triggers onSelectionEnd and onSelectionEndByProp
                     */
                    finish: function () {
                      var sel = instance.getSelected();
                      Handsontable.hooks.run(instance, "afterSelectionEnd", sel[0], sel[1], sel[2], sel[3]);
                      Handsontable.hooks.run(instance, "afterSelectionEndByProp", sel[0], instance.colToProp(sel[1]), sel[2], instance.colToProp(sel[3]));
                      instance.selection.inProgress = false;
                    },
                
                    isInProgress: function () {
                      return instance.selection.inProgress;
                    },
                
                    /**
                     * Starts selection range on given td object
                     * @param {WalkontableCellCoords} coords
                     */
                    setRangeStart: function (coords) {
                      Handsontable.hooks.run(instance, "beforeSetRangeStart", coords);
                      priv.selRange = new WalkontableCellRange(coords, coords, coords);
                      selection.setRangeEnd(coords);
                    },
                
                    /**
                     * Ends selection range on given td object
                     * @param {WalkontableCellCoords} coords
                     * @param {Boolean} [scrollToCell=true] If true, viewport will be scrolled to range end
                     */
                    setRangeEnd: function (coords, scrollToCell) {
                      //trigger handlers
                      Handsontable.hooks.run(instance, "beforeSetRangeEnd", coords);
                
                      instance.selection.begin();
                
                      priv.selRange.to = coords;
                      if (!priv.settings.multiSelect) {
                        priv.selRange.from = coords;
                      }
                
                      //set up current selection
                      instance.view.wt.selections.current.clear();
                      instance.view.wt.selections.current.add(priv.selRange.highlight);
                
                      //set up area selection
                      instance.view.wt.selections.area.clear();
                      if (selection.isMultiple()) {
                        instance.view.wt.selections.area.add(priv.selRange.from);
                        instance.view.wt.selections.area.add(priv.selRange.to);
                      }
                
                      //set up highlight
                      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {
                        instance.view.wt.selections.highlight.clear();
                        instance.view.wt.selections.highlight.add(priv.selRange.from);
                        instance.view.wt.selections.highlight.add(priv.selRange.to);
                      }
                
                      //trigger handlers
                      Handsontable.hooks.run(instance, "afterSelection", priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col);
                      Handsontable.hooks.run(instance, "afterSelectionByProp", priv.selRange.from.row, datamap.colToProp(priv.selRange.from.col), priv.selRange.to.row, datamap.colToProp(priv.selRange.to.col));
                
                      if (scrollToCell !== false && instance.view.mainViewIsActive()) {
                        instance.view.scrollViewport(coords);
                      }
                      selection.refreshBorders();
                    },
                
                    /**
                     * Destroys editor, redraws borders around cells, prepares editor
                     * @param {Boolean} revertOriginal
                     * @param {Boolean} keepEditor
                     */
                    refreshBorders: function (revertOriginal, keepEditor) {
                      if (!keepEditor) {
                        editorManager.destroyEditor(revertOriginal);
                      }
                      instance.view.render();
                      if (selection.isSelected() && !keepEditor) {
                        editorManager.prepareEditor();
                      }
                    },
                
                    /**
                     * Returns information if we have a multiselection
                     * @return {Boolean}
                     */
                    isMultiple: function () {
                      return !(priv.selRange.to.col === priv.selRange.from.col && priv.selRange.to.row === priv.selRange.from.row);
                    },
                
                    /**
                     * Selects cell relative to current cell (if possible)
                     */
                    transformStart: function (rowDelta, colDelta, force) {
                      var delta = new WalkontableCellCoords(rowDelta, colDelta);
                      instance.runHooks('modifyTransformStart', delta);
                
                      if (priv.selRange.highlight.row + rowDelta > instance.countRows() - 1) {
                        if (force && priv.settings.minSpareRows > 0) {
                          instance.alter("insert_row", instance.countRows());
                        }
                        else if (priv.settings.autoWrapCol) {
                          delta.row = 1 - instance.countRows();
                          delta.col = priv.selRange.highlight.col + delta.col == instance.countCols() - 1 ? 1 - instance.countCols() : 1;
                        }
                      }
                      else if (priv.settings.autoWrapCol && priv.selRange.highlight.row + delta.row < 0 && priv.selRange.highlight.col + delta.col >= 0) {
                        delta.row = instance.countRows() - 1;
                        delta.col = priv.selRange.highlight.col + delta.col == 0 ? instance.countCols() - 1 : -1;
                      }
                
                      if (priv.selRange.highlight.col + delta.col > instance.countCols() - 1) {
                        if (force && priv.settings.minSpareCols > 0) {
                          instance.alter("insert_col", instance.countCols());
                        }
                        else if (priv.settings.autoWrapRow) {
                          delta.row = priv.selRange.highlight.row + delta.row == instance.countRows() - 1 ? 1 - instance.countRows() : 1;
                          delta.col = 1 - instance.countCols();
                        }
                      }
                      else if (priv.settings.autoWrapRow && priv.selRange.highlight.col + delta.col < 0 && priv.selRange.highlight.row + delta.row >= 0) {
                        delta.row = priv.selRange.highlight.row + delta.row == 0 ? instance.countRows() - 1 : -1;
                        delta.col = instance.countCols() - 1;
                      }
                
                      var totalRows = instance.countRows();
                      var totalCols = instance.countCols();
                      var coords = new WalkontableCellCoords(priv.selRange.highlight.row + delta.row, priv.selRange.highlight.col + delta.col);
                
                      if (coords.row < 0) {
                        coords.row = 0;
                      }
                      else if (coords.row > 0 && coords.row >= totalRows) {
                        coords.row = totalRows - 1;
                      }
                
                      if (coords.col < 0) {
                        coords.col = 0;
                      }
                      else if (coords.col > 0 && coords.col >= totalCols) {
                        coords.col = totalCols - 1;
                      }
                
                      selection.setRangeStart(coords);
                    },
                
                    /**
                     * Sets selection end cell relative to current selection end cell (if possible)
                     */
                    transformEnd: function (rowDelta, colDelta) {
                      var delta = new WalkontableCellCoords(rowDelta, colDelta);
                      instance.runHooks('modifyTransformEnd', delta);
                
                        var totalRows = instance.countRows();
                        var totalCols = instance.countCols();
                        var coords = new WalkontableCellCoords(priv.selRange.to.row + delta.row, priv.selRange.to.col + delta.col);
                
                        if (coords.row < 0) {
                          coords.row = 0;
                        }
                        else if (coords.row > 0 && coords.row >= totalRows) {
                          coords.row = totalRows - 1;
                        }
                
                        if (coords.col < 0) {
                          coords.col = 0;
                        }
                        else if (coords.col > 0 && coords.col >= totalCols) {
                          coords.col = totalCols - 1;
                        }
                
                        selection.setRangeEnd(coords);
                    },
                
                    /**
                     * Returns true if currently there is a selection on screen, false otherwise
                     * @return {Boolean}
                     */
                    isSelected: function () {
                      return (priv.selRange !== null);
                    },
                
                    /**
                     * Returns true if coords is within current selection coords
                     * @param {WalkontableCellCoords} coords
                     * @return {Boolean}
                     */
                    inInSelection: function (coords) {
                      if (!selection.isSelected()) {
                        return false;
                      }
                      return priv.selRange.includes(coords);
                    },
                
                    /**
                     * Deselects all selected cells
                     */
                    deselect: function () {
                      if (!selection.isSelected()) {
                        return;
                      }
                      instance.selection.inProgress = false; //needed by HT inception
                      priv.selRange = null;
                      instance.view.wt.selections.current.clear();
                      instance.view.wt.selections.area.clear();
                      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {
                        instance.view.wt.selections.highlight.clear();
                      }
                      editorManager.destroyEditor();
                      selection.refreshBorders();
                      Handsontable.hooks.run(instance, 'afterDeselect');
                    },
                
                    /**
                     * Select all cells
                     */
                    selectAll: function () {
                      if (!priv.settings.multiSelect) {
                        return;
                      }
                      selection.setRangeStart(new WalkontableCellCoords(0, 0));
                      selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, instance.countCols() - 1), false);
                    },
                
                    /**
                     * Deletes data from selected cells
                     */
                    empty: function () {
                      if (!selection.isSelected()) {
                        return;
                      }
                      var topLeft = priv.selRange.getTopLeftCorner();
                      var bottomRight = priv.selRange.getBottomRightCorner();
                      var r, c, changes = [];
                      for (r = topLeft.row; r <= bottomRight.row; r++) {
                        for (c = topLeft.col; c <= bottomRight.col; c++) {
                          if (!instance.getCellMeta(r, c).readOnly) {
                            changes.push([r, c, '']);
                          }
                        }
                      }
                      instance.setDataAtCell(changes);
                    }
                  };
                
                  this.init = function () {
                    Handsontable.hooks.run(instance, 'beforeInit');
                
                    this.updateSettings(priv.settings, true);
                
                    this.view = new Handsontable.TableView(this);
                    editorManager = new Handsontable.EditorManager(instance, priv, selection, datamap);
                
                    this.forceFullRender = true; //used when data was changed
                    this.view.render();
                
                    if (typeof priv.firstRun === 'object') {
                      Handsontable.hooks.run(instance, 'afterChange', priv.firstRun[0], priv.firstRun[1]);
                      priv.firstRun = false;
                    }
                    Handsontable.hooks.run(instance, 'afterInit');
                  };
                
                  function ValidatorsQueue() { //moved this one level up so it can be used in any function here. Probably this should be moved to a separate file
                    var resolved = false;
                
                    return {
                      validatorsInQueue: 0,
                      addValidatorToQueue: function () {
                        this.validatorsInQueue++;
                        resolved = false;
                      },
                      removeValidatorFormQueue: function () {
                        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
                        this.checkIfQueueIsEmpty();
                      },
                      onQueueEmpty: function () {
                      },
                      checkIfQueueIsEmpty: function () {
                        if (this.validatorsInQueue == 0 && resolved == false) {
                          resolved = true;
                          this.onQueueEmpty();
                        }
                      }
                    };
                  }
                
                  function validateChanges(changes, source, callback) {
                    var waitingForValidator = new ValidatorsQueue();
                    waitingForValidator.onQueueEmpty = resolve;
                
                    for (var i = changes.length - 1; i >= 0; i--) {
                      if (changes[i] === null) {
                        changes.splice(i, 1);
                      }
                      else {
                        var row = changes[i][0];
                        var col = datamap.propToCol(changes[i][1]);
                        var logicalCol = instance.runHooksAndReturn('modifyCol', col); //column order may have changes, so we need to translate physical col index (stored in datasource) to logical (displayed to user)
                        var cellProperties = instance.getCellMeta(row, logicalCol);
                
                        if (cellProperties.type === 'numeric' && typeof changes[i][3] === 'string') {
                          if (changes[i][3].length > 0 && /^-?[\d\s]*(\.|\,)?\d*$/.test(changes[i][3])) {
                            var len = changes[i][3].length
                            if (typeof cellProperties.language == 'undefined') {
                              numeral.language('en');
                            }
                            else if (changes[i][3].indexOf(".") === len - 3 && changes[i][3].indexOf(",") === -1) { //this input in format XXXX.XX is likely to come from paste. Let's parse it using international rules
                              numeral.language('en');
                            }
                            else {
                              numeral.language(cellProperties.language);
                            }
                
                            changes[i][3] = numeral().unformat(changes[i][3] || '0'); //numeral cannot unformat empty string
                          }
                        }
                
                        if (instance.getCellValidator(cellProperties)) {
                          waitingForValidator.addValidatorToQueue();
                          instance.validateCell(changes[i][3], cellProperties, (function (i, cellProperties) {
                            return function (result) {
                              if (typeof result !== 'boolean') {
                                throw new Error("Validation error: result is not boolean");
                              }
                              if (result === false && cellProperties.allowInvalid === false) {
                                changes.splice(i, 1);         // cancel the change
                                cellProperties.valid = true;  // we cancelled the change, so cell value is still valid
                                --i;
                              }
                              waitingForValidator.removeValidatorFormQueue();
                            }
                          })(i, cellProperties)
                            , source);
                        }
                      }
                    }
                    waitingForValidator.checkIfQueueIsEmpty();
                
                    function resolve() {
                      var beforeChangeResult;
                
                      if (changes.length) {
                        beforeChangeResult = Handsontable.hooks.execute(instance, "beforeChange", changes, source);
                        if (typeof beforeChangeResult === 'function') {
                          $.when(result).then(function () {
                            callback(); //called when async validators and async beforeChange are resolved
                          });
                        }
                        else if (beforeChangeResult === false) {
                          changes.splice(0, changes.length); //invalidate all changes (remove everything from array)
                        }
                      }
                      if (typeof beforeChangeResult !== 'function') {
                        callback(); //called when async validators are resolved and beforeChange was not async
                      }
                    }
                  }
                
                  /**
                   * Internal function to apply changes. Called after validateChanges
                   * @param {Array} changes Array in form of [row, prop, oldValue, newValue]
                   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)
                   */
                  function applyChanges(changes, source) {
                    var i = changes.length - 1;
                
                    if (i < 0) {
                      return;
                    }
                
                    for (; 0 <= i; i--) {
                      if (changes[i] === null) {
                        changes.splice(i, 1);
                        continue;
                      }
                
                      if(changes[i][2] == null && changes[i][3] == null) {
                        continue;
                      }
                
                      if (priv.settings.minSpareRows) {
                        while (changes[i][0] > instance.countRows() - 1) {
                          datamap.createRow();
                        }
                      }
                
                      if (instance.dataType === 'array' && priv.settings.minSpareCols) {
                        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
                          datamap.createCol();
                        }
                      }
                
                      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
                    }
                
                    instance.forceFullRender = true; //used when data was changed
                    grid.adjustRowsAndCols();
                    Handsontable.hooks.run(instance, 'beforeChangeRender', changes, source);
                    selection.refreshBorders(null, true);
                    Handsontable.hooks.run(instance, 'afterChange', changes, source || 'edit');
                  }
                
                  this.validateCell = function (value, cellProperties, callback, source) {
                    var validator = instance.getCellValidator(cellProperties);
                
                    if (Object.prototype.toString.call(validator) === '[object RegExp]') {
                      validator = (function (validator) {
                        return function (value, callback) {
                          callback(validator.test(value));
                        }
                      })(validator);
                    }
                
                    if (typeof validator == 'function') {
                
                      value = Handsontable.hooks.execute(instance, "beforeValidate", value, cellProperties.row, cellProperties.prop, source);
                
                      // To provide consistent behaviour, validation should be always asynchronous
                      instance._registerTimeout(setTimeout(function () {
                        validator.call(cellProperties, value, function (valid) {
                          cellProperties.valid = valid;
                
                          valid = Handsontable.hooks.execute(instance, "afterValidate", valid, value, cellProperties.row, cellProperties.prop, source);
                
                          callback(valid);
                        });
                
                        return value;
                      }, 0));
                    } else { //resolve callback even if validator function was not found
                      cellProperties.valid = true;
                      callback(true);
                    }
                
                
                
                  };
                
                  function setDataInputToArray(row, prop_or_col, value) {
                    if (typeof row === "object") { //is it an array of changes
                      return row;
                    }
                    else if ($.isPlainObject(value)) { //backwards compatibility
                      return value;
                    }
                    else {
                      return [
                        [row, prop_or_col, value]
                      ];
                    }
                  }
                
                  /**
                   * Set data at given cell
                   * @public
                   * @param {Number|Array} row or array of changes in format [[row, col, value], ...]
                   * @param {Number|String} col or source String
                   * @param {String} value
                   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)
                   */
                  this.setDataAtCell = function (row, col, value, source) {
                    var input = setDataInputToArray(row, col, value)
                      , i
                      , ilen
                      , changes = []
                      , prop;
                
                    for (i = 0, ilen = input.length; i < ilen; i++) {
                      if (typeof input[i] !== 'object') {
                        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');
                      }
                      if (typeof input[i][1] !== 'number') {
                        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`');
                      }
                      prop = datamap.colToProp(input[i][1]);
                      changes.push([
                        input[i][0],
                        prop,
                        datamap.get(input[i][0], prop),
                        input[i][2]
                      ]);
                    }
                
                    if (!source && typeof row === "object") {
                      source = col;
                    }
                
                    validateChanges(changes, source, function () {
                      applyChanges(changes, source);
                    });
                  };
                
                
                  /**
                   * Set data at given row property
                   * @public
                   * @param {Number|Array} row or array of changes in format [[row, prop, value], ...]
                   * @param {String} prop or source String
                   * @param {String} value
                   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)
                   */
                  this.setDataAtRowProp = function (row, prop, value, source) {
                    var input = setDataInputToArray(row, prop, value)
                      , i
                      , ilen
                      , changes = [];
                
                    for (i = 0, ilen = input.length; i < ilen; i++) {
                      changes.push([
                        input[i][0],
                        input[i][1],
                        datamap.get(input[i][0], input[i][1]),
                        input[i][2]
                      ]);
                    }
                
                    if (!source && typeof row === "object") {
                      source = prop;
                    }
                
                    validateChanges(changes, source, function () {
                      applyChanges(changes, source);
                    });
                  };
                
                  /**
                   * Listen to document body keyboard input
                   */
                  this.listen = function () {
                    Handsontable.activeGuid = instance.guid;
                
                    if (document.activeElement && document.activeElement !== document.body) {
                      document.activeElement.blur();
                    }
                    else if (!document.activeElement) { //IE
                      document.body.focus();
                    }
                  };
                
                  /**
                   * Stop listening to document body keyboard input
                   */
                  this.unlisten = function () {
                    Handsontable.activeGuid = null;
                  };
                
                  /**
                   * Returns true if current Handsontable instance is listening on document body keyboard input
                   */
                  this.isListening = function () {
                    return Handsontable.activeGuid === instance.guid;
                  };
                
                  /**
                   * Destroys current editor, renders and selects current cell. If revertOriginal != true, edited data is saved
                   * @param {Boolean} revertOriginal
                   */
                  this.destroyEditor = function (revertOriginal) {
                    selection.refreshBorders(revertOriginal);
                  };
                
                  /**
                   * Populate cells at position with 2d array
                   * @param {Number} row Start row
                   * @param {Number} col Start column
                   * @param {Array} input 2d array
                   * @param {Number=} endRow End row (use when you want to cut input when certain row is reached)
                   * @param {Number=} endCol End column (use when you want to cut input when certain column is reached)
                   * @param {String=} [source="populateFromArray"]
                   * @param {String=} [method="overwrite"]
                   * @return {Object|undefined} ending td in pasted area (only if any cell was changed)
                   */
                  this.populateFromArray = function (row, col, input, endRow, endCol, source, method) {
                    if (!(typeof input === 'object' && typeof input[0] === 'object')) {
                      throw new Error("populateFromArray parameter `input` must be an array of arrays"); //API changed in 0.9-beta2, let's check if you use it correctly
                    }
                    return grid.populateFromArray(new WalkontableCellCoords(row, col), input, typeof endRow === 'number' ? new WalkontableCellCoords(endRow, endCol) : null, source, method);
                  };
                
                  /**
                   * Adds/removes data from the column
                   * @param {Number} col Index of column in which do you want to do splice.
                   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
                   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
                   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
                   */
                  this.spliceCol = function (col, index, amount/*, elements... */) {
                    return datamap.spliceCol.apply(datamap, arguments);
                  };
                
                  /**
                   * Adds/removes data from the row
                   * @param {Number} row Index of column in which do you want to do splice.
                   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
                   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
                   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
                   */
                  this.spliceRow = function (row, index, amount/*, elements... */) {
                    return datamap.spliceRow.apply(datamap, arguments);
                  };
                
                  /**
                   * Returns current selection. Returns undefined if there is no selection.
                   * @public
                   * @return {Array} [`startRow`, `startCol`, `endRow`, `endCol`]
                   */
                  this.getSelected = function () { //https://github.com/handsontable/jquery-handsontable/issues/44  //cjl
                    if (selection.isSelected()) {
                      return [priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col];
                    }
                  };
                
                  /**
                   * Returns current selection as a WalkontableCellRange object. Returns undefined if there is no selection.
                   * @public
                   * @return {WalkontableCellRange}
                   */
                  this.getSelectedRange = function () { //https://github.com/handsontable/jquery-handsontable/issues/44  //cjl
                    if (selection.isSelected()) {
                      return priv.selRange;
                    }
                  };
                
                
                  /**
                   * Render visible data
                   * @public
                   */
                  this.render = function () {
                    if (instance.view) {
                      instance.forceFullRender = true; //used when data was changed
                      selection.refreshBorders(null, true);
                    }
                  };
                
                  /**
                   * Load data from array
                   * @public
                   * @param {Array} data
                   */
                  this.loadData = function (data) {
                    if (typeof data === 'object' && data !== null) {
                      if (!(data.push && data.splice)) { //check if data is array. Must use duck-type check so Backbone Collections also pass it
                        //when data is not an array, attempt to make a single-row array of it
                        data = [data];
                      }
                    }
                    else if(data === null) {
                      data = [];
                      var row;
                      for (var r = 0, rlen = priv.settings.startRows; r < rlen; r++) {
                        row = [];
                        for (var c = 0, clen = priv.settings.startCols; c < clen; c++) {
                          row.push(null);
                        }
                        data.push(row);
                      }
                    }
                    else {
                      throw new Error("loadData only accepts array of objects or array of arrays (" + typeof data + " given)");
                    }
                
                    priv.isPopulated = false;
                    GridSettings.prototype.data = data;
                
                    if (priv.settings.dataSchema instanceof Array || data[0]  instanceof Array) {
                      instance.dataType = 'array';
                    }
                    else if (typeof priv.settings.dataSchema === 'function') {
                      instance.dataType = 'function';
                    }
                    else {
                      instance.dataType = 'object';
                    }
                
                    datamap = new Handsontable.DataMap(instance, priv, GridSettings);
                
                    clearCellSettingCache();
                
                    grid.adjustRowsAndCols();
                    Handsontable.hooks.run(instance, 'afterLoadData');
                
                    if (priv.firstRun) {
                      priv.firstRun = [null, 'loadData'];
                    }
                    else {
                      Handsontable.hooks.run(instance, 'afterChange', null, 'loadData');
                      instance.render();
                    }
                
                    priv.isPopulated = true;
                
                
                
                    function clearCellSettingCache() {
                      priv.cellSettings.length = 0;
                    }
                  };
                
                  /**
                   * Return the current data object (the same that was passed by `data` configuration option or `loadData` method). Optionally you can provide cell range `r`, `c`, `r2`, `c2` to get only a fragment of grid data
                   * @public
                   * @param {Number} r (Optional) From row
                   * @param {Number} c (Optional) From col
                   * @param {Number} r2 (Optional) To row
                   * @param {Number} c2 (Optional) To col
                   * @return {Array|Object}
                   */
                  this.getData = function (r, c, r2, c2) {
                    if (typeof r === 'undefined') {
                      return datamap.getAll();
                    } else {
                      return datamap.getRange(new WalkontableCellCoords(r, c), new WalkontableCellCoords(r2, c2), datamap.DESTINATION_RENDERER);
                    }
                  };
                
                  this.getCopyableData = function (startRow, startCol, endRow, endCol) {
                    return datamap.getCopyableText(new WalkontableCellCoords(startRow, startCol), new WalkontableCellCoords(endRow, endCol));
                  };
                
                  /**
                   * Update settings
                   * @public
                   */
                  this.updateSettings = function (settings, init) {
                    var i, clen;
                
                    if (typeof settings.rows !== "undefined") {
                      throw new Error("'rows' setting is no longer supported. do you mean startRows, minRows or maxRows?");
                    }
                    if (typeof settings.cols !== "undefined") {
                      throw new Error("'cols' setting is no longer supported. do you mean startCols, minCols or maxCols?");
                    }
                
                    for (i in settings) {
                      if (i === 'data') {
                        continue; //loadData will be triggered later
                      }
                      else {
                        if (Handsontable.hooks.hooks[i] !== void 0 || Handsontable.hooks.legacy[i] !== void 0) {
                          if (typeof settings[i] === 'function' || Handsontable.helper.isArray(settings[i])) {
                            instance.addHook(i, settings[i]);
                          }
                        }
                        else {
                          // Update settings
                          if (!init && settings.hasOwnProperty(i)) {
                            GridSettings.prototype[i] = settings[i];
                          }
                        }
                      }
                    }
                
                    // Load data or create data map
                    if (settings.data === void 0 && priv.settings.data === void 0) {
                      instance.loadData(null); //data source created just now
                    }
                    else if (settings.data !== void 0) {
                      instance.loadData(settings.data); //data source given as option
                    }
                    else if (settings.columns !== void 0) {
                      datamap.createMap();
                    }
                
                    // Init columns constructors configuration
                    clen = instance.countCols();
                
                    //Clear cellSettings cache
                    priv.cellSettings.length = 0;
                
                    if (clen > 0) {
                      var proto, column;
                
                      for (i = 0; i < clen; i++) {
                        priv.columnSettings[i] = Handsontable.helper.columnFactory(GridSettings, priv.columnsSettingConflicts);
                
                        // shortcut for prototype
                        proto = priv.columnSettings[i].prototype;
                
                        // Use settings provided by user
                        if (GridSettings.prototype.columns) {
                          column = GridSettings.prototype.columns[i];
                          Handsontable.helper.extend(proto, column);
                          Handsontable.helper.extend(proto, expandType(column));
                        }
                      }
                    }
                
                    if (typeof settings.cell !== 'undefined') {
                      for(i in settings.cell) {
                        var cell = settings.cell[i];
                        instance.setCellMetaObject(cell.row, cell.col, cell);
                      }
                    }
                
                    Handsontable.hooks.run(instance, 'afterCellMetaReset');
                
                    if (typeof settings.className !== "undefined") {
                      if (GridSettings.prototype.className) {
                        instance.rootElement.removeClass(GridSettings.prototype.className);
                      }
                      if (settings.className) {
                        instance.rootElement.addClass(settings.className);
                      }
                    }
                
                    if (typeof settings.height != 'undefined'){
                      var height = settings.height;
                
                      if (typeof height == 'function'){
                        height = height();
                      }
                
                      instance.rootElement[0].style.height = height + 'px';
                    }
                
                    if (typeof settings.width != 'undefined'){
                      var width = settings.width;
                
                      if (typeof width == 'function'){
                        width = width();
                      }
                
                      instance.rootElement[0].style.width = width + 'px';
                    }
                
                    if (height){
                      instance.rootElement[0].style.overflow = 'auto';
                    }
                
                    if (!init) {
                      Handsontable.hooks.run(instance, 'afterUpdateSettings');
                    }
                
                    grid.adjustRowsAndCols();
                    if (instance.view && !priv.firstRun) {
                      instance.forceFullRender = true; //used when data was changed
                      selection.refreshBorders(null, true);
                    }
                  };
                
                  this.getValue = function () {
                    var sel = instance.getSelected();
                    if (GridSettings.prototype.getValue) {
                      if (typeof GridSettings.prototype.getValue === 'function') {
                        return GridSettings.prototype.getValue.call(instance);
                      }
                      else if (sel) {
                        return instance.getData()[sel[0]][GridSettings.prototype.getValue];
                      }
                    }
                    else if (sel) {
                      return instance.getDataAtCell(sel[0], sel[1]);
                    }
                  };
                
                  function expandType(obj) {
                    if (!obj.hasOwnProperty('type')) return; //ignore obj.prototype.type
                
                
                    var type, expandedType = {};
                
                    if (typeof obj.type === 'object') {
                      type = obj.type;
                    }
                    else if (typeof obj.type === 'string') {
                      type = Handsontable.cellTypes[obj.type];
                      if (type === void 0) {
                        throw new Error('You declared cell type "' + obj.type + '" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
                      }
                    }
                
                
                    for (var i in type) {
                      if (type.hasOwnProperty(i) && !obj.hasOwnProperty(i)) {
                        expandedType[i] = type[i];
                      }
                    }
                
                    return expandedType;
                
                  };
                
                  /**
                   * Returns current settings object
                   * @return {Object}
                   */
                  this.getSettings = function () {
                    return priv.settings;
                  };
                
                  /**
                   * Clears grid
                   * @public
                   */
                  this.clear = function () {
                    selection.selectAll();
                    selection.empty();
                  };
                
                  /**
                   * Inserts or removes rows and columns
                   * @param {String} action See grid.alter for possible values
                   * @param {Number} index
                   * @param {Number} amount
                   * @param {String} [source] Optional. Source of hook runner.
                   * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
                   * @public
                   */
                  this.alter = function (action, index, amount, source, keepEmptyRows) {
                    grid.alter(action, index, amount, source, keepEmptyRows);
                  };
                
                  /**
                   * Returns <td> element corresponding to params row, col
                   * @param {Number} row
                   * @param {Number} col
                   * @public
                   * @return {Element}
                   */
                  this.getCell = function (row, col) {
                    return instance.view.getCellAtCoords(new WalkontableCellCoords(row, col));
                  };
                
                  /**
                   * Returns property name associated with column number
                   * @param {Number} col
                   * @public
                   * @return {String}
                   */
                  this.colToProp = function (col) {
                    return datamap.colToProp(col);
                  };
                
                  /**
                   * Returns column number associated with property name
                   * @param {String} prop
                   * @public
                   * @return {Number}
                   */
                  this.propToCol = function (prop) {
                    return datamap.propToCol(prop);
                  };
                
                  /**
                   * Return value at `row`, `col`
                   * @param {Number} row
                   * @param {Number} col
                   * @public
                   * @return value (mixed data type)
                   */
                  this.getDataAtCell = function (row, col) {
                    return datamap.get(row, datamap.colToProp(col));
                  };
                
                  /**
                   * Return value at `row`, `prop`
                   * @param {Number} row
                   * @param {String} prop
                   * @public
                   * @return value (mixed data type)
                   */
                  this.getDataAtRowProp = function (row, prop) {
                    return datamap.get(row, prop);
                  };
                
                  /**
                   * Return value at `col`, where `col` is the visible index of the column
                   * @param {Number} col
                   * @public
                   * @return {Array} value (mixed data type)
                   */
                  this.getDataAtCol = function (col) {
                    var out = [];
                    return out.concat.apply(out, datamap.getRange(new WalkontableCellCoords(0, col), new WalkontableCellCoords(priv.settings.data.length - 1, col), datamap.DESTINATION_RENDERER));
                  };
                
                  /**
                   * Return value at `prop`
                   * @param {String} prop
                   * @public
                   * @return {Array} value (mixed data type)
                   */
                  this.getDataAtProp = function (prop) {
                    var out = [];
                    return out.concat.apply(out, datamap.getRange(new WalkontableCellCoords(0, datamap.propToCol(prop)), new WalkontableCellCoords(priv.settings.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER));
                  };
                
                  /**
                   * Return original source values at 'col'
                   * @param {Number} col
                   * @public
                   * @returns value (mixed data type)
                   */
                  this.getSourceDataAtCol = function (col) {
                    var out = [],
                        data = priv.settings.data;
                
                    for (var i = 0; i < data.length; i++) {
                      out.push(data[i][col]);
                    }
                
                    return out;
                  };
                
                  /**
                   * Return original source values at 'row'
                   * @param {Number} row
                   * @public
                   * @returns value {mixed data type}
                   */
                  this.getSourceDataAtRow = function (row) {
                    return priv.settings.data[row];
                  };
                
                  /**
                   * Return value at `row`
                   * @param {Number} row
                   * @public
                   * @return value (mixed data type)
                   */
                  this.getDataAtRow = function (row) {
                    var data = datamap.getRange(new WalkontableCellCoords(row, 0), new WalkontableCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
                    return data[0];
                  };
                
                  /***
                   *  Remove "key" property object from cell meta data corresponding to params row,col
                   * @param {Number} row
                   * @param {Number} col
                   * @param {String} key
                   */
                  this.removeCellMeta = function(row, col, key) {
                    var cellMeta = instance.getCellMeta(row, col);
                    if(cellMeta[key] != undefined){
                      delete priv.cellSettings[row][col][key];
                    }
                  };
                
                  /**
                   * Set cell meta data object to corresponding params row, col
                   * @param {Number} row
                   * @param {Number} col
                   * @param {Object} prop
                   */
                  this.setCellMetaObject = function (row, col, prop) {
                    if (typeof prop === 'object') {
                      for (var i in prop) {
                        var key = i,
                            value = prop[i];
                
                        this.setCellMeta(row, col, key, value);
                      }
                    }
                  };
                
                  /**
                   * Sets cell meta data object "key" corresponding to params row, col
                   * @param {Number} row
                   * @param {Number} col
                   * @param {String} key
                   * @param {String} val
                   *
                   */
                  this.setCellMeta = function (row, col, key, val) {
                    if (!priv.cellSettings[row]) {
                      priv.cellSettings[row] = [];
                    }
                    if (!priv.cellSettings[row][col]) {
                      priv.cellSettings[row][col] = new priv.columnSettings[col]();
                    }
                    priv.cellSettings[row][col][key] = val;
                    Handsontable.hooks.run(instance, 'afterSetCellMeta', row, col, key, val);
                  };
                
                  /**
                   * Returns cell meta data object corresponding to params row, col
                   * @param {Number} row
                   * @param {Number} col
                   * @public
                   * @return {Object}
                   */
                  this.getCellMeta = function (row, col) {
                    var prop = datamap.colToProp(col)
                      , cellProperties;
                
                    row = translateRowIndex(row);
                    col = translateColIndex(col);
                
                    if (!priv.columnSettings[col]) {
                      priv.columnSettings[col] = Handsontable.helper.columnFactory(GridSettings, priv.columnsSettingConflicts);
                    }
                
                    if (!priv.cellSettings[row]) {
                      priv.cellSettings[row] = [];
                    }
                    if (!priv.cellSettings[row][col]) {
                      priv.cellSettings[row][col] = new priv.columnSettings[col]();
                    }
                
                    cellProperties = priv.cellSettings[row][col]; //retrieve cellProperties from cache
                
                    cellProperties.row = row;
                    cellProperties.col = col;
                    cellProperties.prop = prop;
                    cellProperties.instance = instance;
                
                    Handsontable.hooks.run(instance, 'beforeGetCellMeta', row, col, cellProperties);
                    Handsontable.helper.extend(cellProperties, expandType(cellProperties)); //for `type` added in beforeGetCellMeta
                
                    if (cellProperties.cells) {
                      var settings = cellProperties.cells.call(cellProperties, row, col, prop);
                
                      if (settings) {
                        Handsontable.helper.extend(cellProperties, settings);
                        Handsontable.helper.extend(cellProperties, expandType(settings)); //for `type` added in cells
                      }
                    }
                
                    Handsontable.hooks.run(instance, 'afterGetCellMeta', row, col, cellProperties);
                
                    return cellProperties;
                  };
                
                  /**
                   * If displayed rows order is different than the order of rows stored in memory (i.e. sorting is applied)
                   * we need to translate logical (stored) row index to physical (displayed) index.
                   * @param row - original row index
                   * @returns {int} translated row index
                   */
                  function translateRowIndex(row){
                    return Handsontable.hooks.execute(instance, 'modifyRow', row);
                  }
                
                  /**
                   * If displayed columns order is different than the order of columns stored in memory (i.e. column were moved using manualColumnMove plugin)
                   * we need to translate logical (stored) column index to physical (displayed) index.
                   * @param col - original column index
                   * @returns {int} - translated column index
                   */
                  function translateColIndex(col){
                    return Handsontable.hooks.execute(instance, 'modifyCol', col); // warning: this must be done after datamap.colToProp
                  }
                
                  var rendererLookup = Handsontable.helper.cellMethodLookupFactory('renderer');
                  this.getCellRenderer = function (row, col) {
                    var renderer = rendererLookup.call(this, row, col);
                    return Handsontable.renderers.getRenderer(renderer);
                
                  };
                
                  this.getCellEditor = Handsontable.helper.cellMethodLookupFactory('editor');
                
                  this.getCellValidator = Handsontable.helper.cellMethodLookupFactory('validator');
                
                
                  /**
                   * Validates all cells using their validator functions and calls callback when finished. Does not render the view
                   * @param callback
                   */
                  this.validateCells = function (callback) {
                    var waitingForValidator = new ValidatorsQueue();
                    waitingForValidator.onQueueEmpty = callback;
                
                    var i = instance.countRows() - 1;
                    while (i >= 0) {
                      var j = instance.countCols() - 1;
                      while (j >= 0) {
                        waitingForValidator.addValidatorToQueue();
                        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function () {
                          waitingForValidator.removeValidatorFormQueue();
                        }, 'validateCells');
                        j--;
                      }
                      i--;
                    }
                    waitingForValidator.checkIfQueueIsEmpty();
                  };
                
                  /**
                   * Return array of row headers (if they are enabled). If param `row` given, return header at given row as string
                   * @param {Number} row (Optional)
                   * @return {Array|String}
                   */
                  this.getRowHeader = function (row) {
                    if (row === void 0) {
                      var out = [];
                      for (var i = 0, ilen = instance.countRows(); i < ilen; i++) {
                        out.push(instance.getRowHeader(i));
                      }
                      return out;
                    }
                    else if (Object.prototype.toString.call(priv.settings.rowHeaders) === '[object Array]' && priv.settings.rowHeaders[row] !== void 0) {
                      return priv.settings.rowHeaders[row];
                    }
                    else if (typeof priv.settings.rowHeaders === 'function') {
                      return priv.settings.rowHeaders(row);
                    }
                    else if (priv.settings.rowHeaders && typeof priv.settings.rowHeaders !== 'string' && typeof priv.settings.rowHeaders !== 'number') {
                      return row + 1;
                    }
                    else {
                      return priv.settings.rowHeaders;
                    }
                  };
                
                  /**
                   * Returns information of this table is configured to display row headers
                   * @returns {boolean}
                   */
                  this.hasRowHeaders = function () {
                    return !!priv.settings.rowHeaders;
                  };
                
                  /**
                   * Returns information of this table is configured to display column headers
                   * @returns {boolean}
                   */
                  this.hasColHeaders = function () {
                    if (priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null) { //Polymer has empty value = null
                      return !!priv.settings.colHeaders;
                    }
                    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {
                      if (instance.getColHeader(i)) {
                        return true;
                      }
                    }
                    return false;
                  };
                
                  /**
                   * Return array of column headers (if they are enabled). If param `col` given, return header at given column as string
                   * @param {Number} col (Optional)
                   * @return {Array|String}
                   */
                  this.getColHeader = function (col) {
                    if (col === void 0) {
                      var out = [];
                      for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {
                        out.push(instance.getColHeader(i));
                      }
                      return out;
                    }
                    else {
                      var baseCol = col;
                      col = Handsontable.hooks.execute(instance, 'modifyCol', col);
                
                      if (priv.settings.columns && priv.settings.columns[col] && priv.settings.columns[col].title) {
                        return priv.settings.columns[col].title;
                      }
                      else if (Object.prototype.toString.call(priv.settings.colHeaders) === '[object Array]' && priv.settings.colHeaders[col] !== void 0) {
                        return priv.settings.colHeaders[col];
                      }
                      else if (typeof priv.settings.colHeaders === 'function') {
                        return priv.settings.colHeaders(col);
                      }
                      else if (priv.settings.colHeaders && typeof priv.settings.colHeaders !== 'string' && typeof priv.settings.colHeaders !== 'number') {
                        return Handsontable.helper.spreadsheetColumnLabel(baseCol); //see #1458
                      }
                      else {
                        return priv.settings.colHeaders;
                      }
                    }
                  };
                
                  /**
                   * Return column width from settings (no guessing). Private use intended
                   * @param {Number} col
                   * @return {Number}
                   */
                  this._getColWidthFromSettings = function (col) {
                    var cellProperties = instance.getCellMeta(0, col);
                    var width = cellProperties.width;
                    if (width === void 0 || width === priv.settings.width) {
                      width = cellProperties.colWidths;
                    }
                    if (width !== void 0 && width !== null) {
                      switch (typeof width) {
                        case 'object': //array
                          width = width[col];
                          break;
                
                        case 'function':
                          width = width(col);
                          break;
                      }
                      if (typeof width === 'string') {
                        width = parseInt(width, 10);
                      }
                    }
                    return width;
                  };
                
                  /**
                   * Return column width
                   * @param {Number} col
                   * @return {Number}
                   */
                  this.getColWidth = function (col) {
                    var width = instance._getColWidthFromSettings(col);
                    if (!width) {
                      width = 50;
                    }
                    width = Handsontable.hooks.execute(instance, 'modifyColWidth', width, col);
                    return width;
                  };
                
                  /**
                   * Return row height from settings (no guessing). Private use intended
                   * @param {Number} row
                   * @return {Number}
                   */
                  this._getRowHeightFromSettings= function (row) {
                    /* inefficient
                    var cellProperties = instance.getCellMeta(0, row);
                    var height = cellProperties.height;
                    if (height === void 0 || height === priv.settings.height) {
                      height = cellProperties.rowHeights;
                    }
                    */
                    var height = priv.settings.rowHeights; //only uses grid settings
                    if (height !== void 0 && height !== null) {
                      switch (typeof height) {
                        case 'object': //array
                          height = height[row];
                          break;
                
                        case 'function':
                          height = height(row);
                          break;
                      }
                      if (typeof height === 'string') {
                        height = parseInt(height, 10);
                      }
                    }
                    return height;
                  };
                
                  /**
                   * Return row height
                   * @param {Number} row
                   * @return {Number}
                   */
                  this.getRowHeight = function (row) {
                    var height = instance._getRowHeightFromSettings(row),
                        oversizedHeight = instance.checkIfRowIsOversized(row);
                
                    height = Handsontable.hooks.execute(instance, 'modifyRowHeight', height, row);
                
                    if(oversizedHeight) {
                      height = height ? Math.max(height,oversizedHeight) : oversizedHeight;
                    }
                
                    return height;
                  };
                
                
                
                  /**
                   * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height
                   * @param {Number} row
                   * @return {Number}
                   */
                   this.checkIfRowIsOversized = function(row) {
                      if(instance.view.wt.wtTable.oversizedRows) {
                        return instance.view.wt.wtTable.oversizedRows[row];
                      }
                   };
                
                
                  /**
                   * Return total number of rows in grid
                   * @return {Number}
                   */
                  this.countRows = function () {
                    return priv.settings.data.length;
                  };
                
                  /**
                   * Return total number of columns in grid
                   * @return {Number}
                   */
                  this.countCols = function () {
                    if (instance.dataType === 'object' || instance.dataType === 'function') {
                      if (priv.settings.columns && priv.settings.columns.length) {
                        return priv.settings.columns.length;
                      }
                      else {
                        return datamap.colToPropCache.length;
                      }
                    }
                    else if (instance.dataType === 'array') {
                      if (priv.settings.columns && priv.settings.columns.length) {
                        return priv.settings.columns.length;
                      }
                      else if (priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length) {
                        return priv.settings.data[0].length;
                      }
                      else {
                        return 0;
                      }
                    }
                  };
                
                  /**
                   * Return index of first visible row
                   * @return {Number}
                   */
                  this.rowOffset = function () {
                    return instance.view.wt.getSetting('offsetRow'); //actually offsetRow is the first rendered row, not neccessarily first visible
                  };
                
                  /**
                   * Return index of first visible column
                   * @return {Number}
                   */
                  this.colOffset = function () {
                    return 0; //all columns are always rendered
                  };
                
                  /**
                   * Return number of visible rows. Returns -1 if table is not visible
                   * @return {Number}
                   */
                  this.countVisibleRows = function () {
                    return instance.view.wt.drawn ? instance.view.wt.wtTable.rowStrategy.countVisible() : -1;
                  };
                
                  /**
                   * Return number of visible columns. Returns -1 if table is not visible
                   * @return {Number}
                   */
                  this.countVisibleCols = function () {
                    return instance.view.wt.drawn ? instance.view.wt.wtTable.columnStrategy.countVisible() : -1;
                  };
                
                  /**
                   * Return number of empty rows
                   * @return {Boolean} ending If true, will only count empty rows at the end of the data source
                   */
                  this.countEmptyRows = function (ending) {
                    var i = instance.countRows() - 1
                      , empty = 0
                      , row;
                    while (i >= 0) {
                      row = Handsontable.hooks.execute(this, 'modifyRow', i);
                      if (instance.isEmptyRow(row)) {
                        empty++;
                      }
                      else if (ending) {
                        break;
                      }
                      i--;
                    }
                    return empty;
                  };
                
                  /**
                   * Return number of empty columns
                   * @return {Boolean} ending If true, will only count empty columns at the end of the data source row
                   */
                  this.countEmptyCols = function (ending) {
                    if (instance.countRows() < 1) {
                      return 0;
                    }
                
                    var i = instance.countCols() - 1
                      , empty = 0;
                    while (i >= 0) {
                      if (instance.isEmptyCol(i)) {
                        empty++;
                      }
                      else if (ending) {
                        break;
                      }
                      i--;
                    }
                    return empty;
                  };
                
                  /**
                   * Return true if the row at the given index is empty, false otherwise
                   * @param {Number} r Row index
                   * @return {Boolean}
                   */
                  this.isEmptyRow = function (r) {
                    return priv.settings.isEmptyRow.call(instance, r);
                  };
                
                  /**
                   * Return true if the column at the given index is empty, false otherwise
                   * @param {Number} c Column index
                   * @return {Boolean}
                   */
                  this.isEmptyCol = function (c) {
                    return priv.settings.isEmptyCol.call(instance, c);
                  };
                
                  /**
                   * Selects cell on grid. Optionally selects range to another cell
                   * @param {Number} row
                   * @param {Number} col
                   * @param {Number} [endRow]
                   * @param {Number} [endCol]
                   * @param {Boolean} [scrollToCell=true] If true, viewport will be scrolled to the selection
                   * @public
                   * @return {Boolean}
                   */
                  this.selectCell = function (row, col, endRow, endCol, scrollToCell) {
                    if (typeof row !== 'number' || row < 0 || row >= instance.countRows()) {
                      return false;
                    }
                    if (typeof col !== 'number' || col < 0 || col >= instance.countCols()) {
                      return false;
                    }
                    if (typeof endRow !== "undefined") {
                      if (typeof endRow !== 'number' || endRow < 0 || endRow >= instance.countRows()) {
                        return false;
                      }
                      if (typeof endCol !== 'number' || endCol < 0 || endCol >= instance.countCols()) {
                        return false;
                      }
                    }
                    var coords = new WalkontableCellCoords(row, col);
                    priv.selRange = new WalkontableCellRange(coords, coords, coords);
                    if (document.activeElement && document.activeElement !== document.documentElement && document.activeElement !== document.body) {
                      document.activeElement.blur(); //needed or otherwise prepare won't focus the cell. selectionSpec tests this (should move focus to selected cell)
                    }
                    instance.listen();
                    if (typeof endRow === "undefined") {
                      selection.setRangeEnd(priv.selRange.from, scrollToCell);
                    }
                    else {
                      selection.setRangeEnd(new WalkontableCellCoords(endRow, endCol), scrollToCell);
                    }
                
                    instance.selection.finish();
                    return true;
                  };
                
                  this.selectCellByProp = function (row, prop, endRow, endProp, scrollToCell) {
                    arguments[1] = datamap.propToCol(arguments[1]);
                    if (typeof arguments[3] !== "undefined") {
                      arguments[3] = datamap.propToCol(arguments[3]);
                    }
                    return instance.selectCell.apply(instance, arguments);
                  };
                
                  /**
                   * Deselects current sell selection on grid
                   * @public
                   */
                  this.deselectCell = function () {
                    selection.deselect();
                  };
                
                  /**
                   * Remove grid from DOM
                   * @public
                   */
                  this.destroy = function () {
                    instance._clearTimeouts();
                    if (instance.view) { //in case HT is destroyed before initialization has finished
                      instance.view.wt.destroy();
                    }
                    instance.rootElement.empty();
                    instance.rootElement.removeData('handsontable');
                    instance.rootElement.off('.handsontable');
                    $(window).off('.' + instance.guid);
                    $document.off('.' + instance.guid);
                    $body.off('.' + instance.guid);
                    Handsontable.hooks.run(instance, 'afterDestroy');
                    Handsontable.hooks.destroy(instance);
                
                    for (var i in instance) {
                      if (instance.hasOwnProperty(i)) {
                        //replace instance methods with post mortem
                        if (typeof instance[i] === "function") {
                          if (i !== "runHooks" && i !== "runHooksAndReturn") {
                            instance[i] = postMortem;
                          }
                        }
                        //replace instance properties with null (restores memory)
                        //it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests
                        else if (i !== "guid") {
                          instance[i] = null;
                        }
                      }
                    }
                
                    //replace private properties with null (restores memory)
                    //it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests
                    priv = null;
                    datamap = null;
                    grid = null;
                    selection = null;
                    editorManager = null;
                    instance = null;
                    GridSettings = null;
                    $document = null;
                    $body = null;
                  };
                
                  /**
                   * Replacement for all methods after Handsotnable was destroyed
                   */
                  function postMortem() {
                    throw new Error("This method cannot be called because this Handsontable instance has been destroyed");
                  };
                
                  /**
                   * Returns active editor object
                   * @returns {Object}
                   */
                  this.getActiveEditor = function(){
                    return editorManager.getActiveEditor();
                  };
                
                  /**
                   * Return Handsontable instance
                   * @public
                   * @return {Object}
                   */
                  this.getInstance = function () {
                    return instance;
                  };
                
                  this.addHook = function (key, fn) {
                    Handsontable.hooks.add(key, fn, instance);
                  };
                
                  this.addHookOnce = function (key, fn) {
                    Handsontable.hooks.once(key, fn, instance);
                  };
                
                  this.removeHook = function (key, fn) {
                    Handsontable.hooks.remove(key, fn, instance);
                  };
                
                  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {
                    Handsontable.hooks.run(instance, key, p1, p2, p3, p4, p5, p6);
                  };
                
                  this.runHooksAndReturn = function (key, p1, p2, p3, p4, p5, p6) {
                    return Handsontable.hooks.execute(instance, key, p1, p2, p3, p4, p5, p6);
                  };
                
                  this.timeouts = [];
                
                  /**
                   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called
                   * @public
                   */
                  this._registerTimeout = function (handle) {
                    this.timeouts.push(handle);
                  };
                
                  /**
                   * Clears all known timeouts
                   * @public
                   */
                  this._clearTimeouts = function () {
                    for(var i = 0, ilen = this.timeouts.length; i<ilen; i++) {
                      clearTimeout(this.timeouts[i]);
                    }
                  };
                
                  /**
                   * Handsontable version
                   */
                  this.version = '0.11.1'; //inserted by grunt from package.json
                };
                
                var DefaultSettings = function () {};
                
                DefaultSettings.prototype = {
                  data: void 0,
                  dataSchema: void 0,
                  width: void 0,
                  height: void 0,
                  startRows: 5,
                  startCols: 5,
                  rowHeaders: null,
                  colHeaders: null,
                  colWidths: void 0,
                  columns: void 0,
                  cells: void 0,
                  cell: [],
                  minRows: 0,
                  minCols: 0,
                  maxRows: Infinity,
                  maxCols: Infinity,
                  minSpareRows: 0,
                  minSpareCols: 0,
                  multiSelect: true,
                  fillHandle: true,
                  fixedRowsTop: 0,
                  fixedColumnsLeft: 0,
                  outsideClickDeselects: true,
                  enterBeginsEditing: true,
                  enterMoves: {row: 1, col: 0},
                  tabMoves: {row: 0, col: 1},
                  autoWrapRow: false,
                  autoWrapCol: false,
                  copyRowsLimit: 1000,
                  copyColsLimit: 1000,
                  pasteMode: 'overwrite',
                  currentRowClassName: void 0,
                  currentColClassName: void 0,
                  stretchH: 'none',
                  isEmptyRow: function (r) {
                    var val;
                    for (var c = 0, clen = this.countCols(); c < clen; c++) {
                      val = this.getDataAtCell(r, c);
                      if (val !== '' && val !== null && typeof val !== 'undefined') {
                        return false;
                      }
                    }
                    return true;
                  },
                  isEmptyCol: function (c) {
                    var val;
                    for (var r = 0, rlen = this.countRows(); r < rlen; r++) {
                      val = this.getDataAtCell(r, c);
                      if (val !== '' && val !== null && typeof val !== 'undefined') {
                        return false;
                      }
                    }
                    return true;
                  },
                  observeDOMVisibility: true,
                  allowInvalid: true,
                  invalidCellClassName: 'htInvalid',
                  placeholder: false,
                  placeholderCellClassName: 'htPlaceholder',
                  readOnlyCellClassName: 'htDimmed',
                  commentedCellClassName: 'htCommentCell',
                  fragmentSelection: false,
                  readOnly: false,
                  type: 'text',
                  copyable: true,
                  debug: false, //shows debug overlays in Walkontable
                  wordWrap: true,
                  noWordWrapClassName: 'htNoWrap',
                  contextMenu: void 0,
                  undo: void 0,
                  columnSorting: void 0,
                  manualColumnMove: void 0,
                  manualColumnResize: void 0,
                  manualRowMove: void 0,
                  manualRowResize: void 0
                };
                Handsontable.DefaultSettings = DefaultSettings;
                
                $.fn.handsontable = function (action) {
                  var i
                    , ilen
                    , args
                    , output
                    , userSettings
                    , $this = this.first() // Use only first element from list
                    , instance = $this.data('handsontable');
                
                  // Init case
                  if (typeof action !== 'string') {
                    userSettings = action || {};
                    if (instance) {
                      instance.updateSettings(userSettings);
                    }
                    else {
                      instance = new Handsontable.Core($this, userSettings);
                      $this.data('handsontable', instance);
                      instance.init();
                    }
                
                    return $this;
                  }
                  // Action case
                  else {
                    args = [];
                    if (arguments.length > 1) {
                      for (i = 1, ilen = arguments.length; i < ilen; i++) {
                        args.push(arguments[i]);
                      }
                    }
                
                    if (instance) {
                      if (typeof instance[action] !== 'undefined') {
                        output = instance[action].apply(instance, args);
                      }
                      else {
                        throw new Error('Handsontable do not provide action: ' + action);
                      }
                    }
                
                    return output;
                  }
                };
                
                (function (window) {
                  
                
                  function MultiMap() {
                    var map = {
                      arrayMap: [],
                      weakMap: new WeakMap()
                    };
                
                    return {
                      'get': function (key) {
                        if (canBeAnArrayMapKey(key)) {
                          return map.arrayMap[key];
                        } else if (canBeAWeakMapKey(key)) {
                          return map.weakMap.get(key);
                        }
                      },
                
                      'set': function (key, value) {
                        if (canBeAnArrayMapKey(key)) {
                          map.arrayMap[key] = value;
                        } else if (canBeAWeakMapKey(key)) {
                          map.weakMap.set(key, value);
                        } else {
                          throw new Error('Invalid key type');
                        }
                
                
                      },
                
                      'delete': function (key) {
                        if (canBeAnArrayMapKey(key)) {
                          delete map.arrayMap[key];
                        } else if (canBeAWeakMapKey(key)) {
                          map.weakMap['delete'](key);  //Delete must be called using square bracket notation, because IE8 does not handle using `delete` with dot notation
                        }
                      }
                    };
                
                
                
                    function canBeAnArrayMapKey(obj){
                      return obj !== null && !isNaNSymbol(obj) && (typeof obj == 'string' || typeof obj == 'number');
                    }
                
                    function canBeAWeakMapKey(obj){
                      return obj !== null && (typeof obj == 'object' || typeof obj == 'function');
                    }
                
                    function isNaNSymbol(obj){
                      return obj !== obj; // NaN === NaN is always false
                    }
                
                  }
                
                  if (!window.MultiMap){
                    window.MultiMap = MultiMap;
                  }
                
                })(window);
                /**
                 * DOM helper optimized for maximum performance
                 * It is recommended for Handsontable plugins and renderers, because it is much faster than jQuery
                 * @type {Object}
                 */
                Handsontable.Dom = {};
                
                //goes up the DOM tree (including given element) until it finds an element that matches the nodeName
                Handsontable.Dom.closest = function (elem, nodeNames, until) {
                  while (elem != null && elem !== until) {
                    if (elem.nodeType === 1 && nodeNames.indexOf(elem.nodeName) > -1) {
                      return elem;
                    }
                    elem = elem.parentNode;
                  }
                  return null;
                };
                
                //goes up the DOM tree and checks if element is child of another element
                Handsontable.Dom.isChildOf = function (child, parent) {
                  var node = child.parentNode;
                  while (node != null) {
                    if (node == parent) {
                      return true;
                    }
                    node = node.parentNode;
                  }
                  return false;
                };
                
                /**
                 * Counts index of element within its parent
                 * WARNING: for performance reasons, assumes there are only element nodes (no text nodes). This is true for Walkotnable
                 * Otherwise would need to check for nodeType or use previousElementSibling
                 * @see http://jsperf.com/sibling-index/10
                 * @param {Element} elem
                 * @return {Number}
                 */
                Handsontable.Dom.index = function (elem) {
                  var i = 0;
                  while (elem = elem.previousSibling) {
                    ++i
                  }
                  return i;
                };
                
                if (document.documentElement.classList) {
                  // HTML5 classList API
                  Handsontable.Dom.hasClass = function (ele, cls) {
                    return ele.classList.contains(cls);
                  };
                
                  Handsontable.Dom.addClass = function (ele, cls) {
                    ele.classList.add(cls);
                  };
                
                  Handsontable.Dom.removeClass = function (ele, cls) {
                    ele.classList.remove(cls);
                  };
                }
                else {
                  //http://snipplr.com/view/3561/addclass-removeclass-hasclass/
                  Handsontable.Dom.hasClass = function (ele, cls) {
                    return ele.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
                  };
                
                  Handsontable.Dom.addClass = function (ele, cls) {
                    if(ele.className == "") ele.className = cls;
                    else if (!this.hasClass(ele, cls)) ele.className += " " + cls;
                  };
                
                  Handsontable.Dom.removeClass = function (ele, cls) {
                    if (this.hasClass(ele, cls)) { //is this really needed?
                      var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
                      ele.className = ele.className.replace(reg, ' ').trim(); //String.prototype.trim is defined in polyfill.js
                    }
                  };
                }
                
                /*//http://net.tutsplus.com/tutorials/javascript-ajax/javascript-from-null-cross-browser-event-binding/
                 Handsontable.Dom.addEvent = (function () {
                 var that = this;
                 if (document.addEventListener) {
                 return function (elem, type, cb) {
                 if ((elem && !elem.length) || elem === window) {
                 elem.addEventListener(type, cb, false);
                 }
                 else if (elem && elem.length) {
                 var len = elem.length;
                 for (var i = 0; i < len; i++) {
                 that.addEvent(elem[i], type, cb);
                 }
                 }
                 };
                 }
                 else {
                 return function (elem, type, cb) {
                 if ((elem && !elem.length) || elem === window) {
                 elem.attachEvent('on' + type, function () {
                
                 //normalize
                 //http://stackoverflow.com/questions/4643249/cross-browser-event-object-normalization
                 var e = window['event'];
                 e.target = e.srcElement;
                 //e.offsetX = e.layerX;
                 //e.offsetY = e.layerY;
                 e.relatedTarget = e.relatedTarget || e.type == 'mouseover' ? e.fromElement : e.toElement;
                 if (e.target.nodeType === 3) e.target = e.target.parentNode; //Safari bug
                
                 return cb.call(elem, e)
                 });
                 }
                 else if (elem.length) {
                 var len = elem.length;
                 for (var i = 0; i < len; i++) {
                 that.addEvent(elem[i], type, cb);
                 }
                 }
                 };
                 }
                 })();
                
                 Handsontable.Dom.triggerEvent = function (element, eventName, target) {
                 var event;
                 if (document.createEvent) {
                 event = document.createEvent("MouseEvents");
                 event.initEvent(eventName, true, true);
                 } else {
                 event = document.createEventObject();
                 event.eventType = eventName;
                 }
                
                 event.eventName = eventName;
                 event.target = target;
                
                 if (document.createEvent) {
                 target.dispatchEvent(event);
                 } else {
                 target.fireEvent("on" + event.eventType, event);
                 }
                 };*/
                
                Handsontable.Dom.removeTextNodes = function (elem, parent) {
                  if (elem.nodeType === 3) {
                    parent.removeChild(elem); //bye text nodes!
                  }
                  else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(elem.nodeName) > -1) {
                    var childs = elem.childNodes;
                    for (var i = childs.length - 1; i >= 0; i--) {
                      this.removeTextNodes(childs[i], elem);
                    }
                  }
                };
                
                /**
                 * Remove childs function
                 * WARNING - this doesn't unload events and data attached by jQuery
                 * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/9
                 * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/11 - no siginificant improvement with Chrome remove() method
                 * @param element
                 * @returns {void}
                 */
                //
                Handsontable.Dom.empty = function (element) {
                  var child;
                  while (child = element.lastChild) {
                    element.removeChild(child);
                  }
                };
                
                Handsontable.Dom.HTML_CHARACTERS = /(<(.*)>|&(.*);)/;
                
                /**
                 * Insert content into element trying avoid innerHTML method.
                 * @return {void}
                 */
                Handsontable.Dom.fastInnerHTML = function (element, content) {
                  if (this.HTML_CHARACTERS.test(content)) {
                    element.innerHTML = content;
                  }
                  else {
                    this.fastInnerText(element, content);
                  }
                };
                
                /**
                 * Insert text content into element
                 * @return {void}
                 */
                if (document.createTextNode('test').textContent) { //STANDARDS
                  Handsontable.Dom.fastInnerText = function (element, content) {
                    var child = element.firstChild;
                    if (child && child.nodeType === 3 && child.nextSibling === null) {
                      //fast lane - replace existing text node
                      //http://jsperf.com/replace-text-vs-reuse
                      child.textContent = content;
                    }
                    else {
                      //slow lane - empty element and insert a text node
                      this.empty(element);
                      element.appendChild(document.createTextNode(content));
                    }
                  };
                }
                else { //IE8
                  Handsontable.Dom.fastInnerText = function (element, content) {
                    var child = element.firstChild;
                    if (child && child.nodeType === 3 && child.nextSibling === null) {
                      //fast lane - replace existing text node
                      //http://jsperf.com/replace-text-vs-reuse
                      child.data = content;
                    }
                    else {
                      //slow lane - empty element and insert a text node
                      this.empty(element);
                      element.appendChild(document.createTextNode(content));
                    }
                  };
                }
                
                /**
                 * Returns true/false depending if element has offset parent
                 * @param elem
                 * @returns {boolean}
                 */
                /*if (document.createTextNode('test').textContent) { //STANDARDS
                  Handsontable.Dom.hasOffsetParent = function (elem) {
                    return !!elem.offsetParent;
                  }
                }
                else {
                  Handsontable.Dom.hasOffsetParent = function (elem) {
                    try {
                      if (!elem.offsetParent) {
                        return false;
                      }
                    }
                    catch (e) {
                      return false; //IE8 throws "Unspecified error" when offsetParent is not found - we catch it here
                    }
                    return true;
                  }
                }*/
                
                /**
                 * Returns true if element is attached to the DOM and visible, false otherwise
                 * @param elem
                 * @returns {boolean}
                 */
                Handsontable.Dom.isVisible = function (elem) {
                  //fast method according to benchmarks, but requires layout so slow in our case
                  /*
                  if (!Handsontable.Dom.hasOffsetParent(elem)) {
                    return false; //fixes problem with UI Bootstrap <tabs> directive
                  }
                
                //  if (elem.offsetWidth > 0 || (elem.parentNode && elem.parentNode.offsetWidth > 0)) { //IE10 was mistaken here
                  if (elem.offsetWidth > 0) {
                    return true;
                  }
                  */
                
                  //slow method
                  var next = elem;
                  while (next !== document.documentElement) { //until <html> reached
                    if (next === null) { //parent detached from DOM
                      return false;
                    }
                    else if (next.nodeType === 11) {  //nodeType == 1 -> DOCUMENT_FRAGMENT_NODE
                      if (next.host) { //this is Web Components Shadow DOM
                        //see: http://w3c.github.io/webcomponents/spec/shadow/#encapsulation
                        //according to spec, should be if (next.ownerDocument !== window.document), but that doesn't work yet
                        if (next.host.impl) { //Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features disabled
                          return Handsontable.Dom.isVisible(next.host.impl);
                        }
                        else if (next.host) { //Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features enabled
                          return Handsontable.Dom.isVisible(next.host);
                        }
                        else {
                          throw new Error("Lost in Web Components world");
                        }
                      }
                      else {
                        return false; //this is a node detached from document in IE8
                      }
                    }
                    else if (next.style.display === 'none') {
                      return false;
                    }
                    next = next.parentNode;
                  }
                  return true;
                };
                
                /**
                 * Returns elements top and left offset relative to the document. In our usage case compatible with jQuery but 2x faster
                 * @param {HTMLElement} elem
                 * @return {Object}
                 */
                Handsontable.Dom.offset = function (elem) {
                  if (this.hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
                    //fixes problem with Firefox ignoring <caption> in TABLE offset (see also Handsontable.Dom.outerHeight)
                    //http://jsperf.com/offset-vs-getboundingclientrect/8
                    var box = elem.getBoundingClientRect();
                    return {
                      top: box.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0),
                      left: box.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0)
                    };
                  }
                
                  var offsetLeft = elem.offsetLeft
                    , offsetTop = elem.offsetTop
                    , lastElem = elem;
                
                  while (elem = elem.offsetParent) {
                    if (elem === document.body) { //from my observation, document.body always has scrollLeft/scrollTop == 0
                      break;
                    }
                    offsetLeft += elem.offsetLeft;
                    offsetTop += elem.offsetTop;
                    lastElem = elem;
                  }
                
                  if (lastElem && lastElem.style.position === 'fixed') { //slow - http://jsperf.com/offset-vs-getboundingclientrect/6
                    //if(lastElem !== document.body) { //faster but does gives false positive in Firefox
                    offsetLeft += window.pageXOffset || document.documentElement.scrollLeft;
                    offsetTop += window.pageYOffset || document.documentElement.scrollTop;
                  }
                
                  return {
                    left: offsetLeft,
                    top: offsetTop
                  };
                };
                
                Handsontable.Dom.getWindowScrollTop = function () {
                  var res = window.scrollY;
                  if (res == void 0) { //IE8-11
                    res = document.documentElement.scrollTop;
                  }
                  return res;
                };
                
                Handsontable.Dom.getWindowScrollLeft = function () {
                  var res = window.scrollX;
                  if (res == void 0) { //IE8-11
                    res = document.documentElement.scrollLeft;
                  }
                  return res;
                };
                
                Handsontable.Dom.getScrollTop = function (elem) {
                  if (elem === window) {
                    return Handsontable.Dom.getWindowScrollTop(elem);
                  }
                  else {
                    return elem.scrollTop;
                  }
                };
                
                Handsontable.Dom.getScrollLeft = function (elem) {
                  if (elem === window) {
                    return Handsontable.Dom.getWindowScrollLeft(elem);
                  }
                  else {
                    return elem.scrollLeft;
                  }
                };
                
                Handsontable.Dom.getComputedStyle = function (elem) {
                  return elem.currentStyle || document.defaultView.getComputedStyle(elem);
                };
                
                Handsontable.Dom.outerWidth = function (elem) {
                  return elem.offsetWidth;
                };
                
                Handsontable.Dom.outerHeight = function (elem) {
                  if (this.hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
                    //fixes problem with Firefox ignoring <caption> in TABLE.offsetHeight
                    //jQuery (1.10.1) still has this unsolved
                    //may be better to just switch to getBoundingClientRect
                    //http://bililite.com/blog/2009/03/27/finding-the-size-of-a-table/
                    //http://lists.w3.org/Archives/Public/www-style/2009Oct/0089.html
                    //http://bugs.jquery.com/ticket/2196
                    //http://lists.w3.org/Archives/Public/www-style/2009Oct/0140.html#start140
                    return elem.offsetHeight + elem.firstChild.offsetHeight;
                  }
                  else {
                    return elem.offsetHeight;
                  }
                };
                
                Handsontable.Dom.innerHeight = function (elem) {
                  return elem.clientHeight;
                };
                
                Handsontable.Dom.innerWidth = function (elem) {
                  return elem.innerWidth;
                };
                
                (function () {
                  var hasCaptionProblem;
                
                  function detectCaptionProblem() {
                    var TABLE = document.createElement('TABLE');
                    TABLE.style.borderSpacing = 0;
                    TABLE.style.borderWidth = 0;
                    TABLE.style.padding = 0;
                    var TBODY = document.createElement('TBODY');
                    TABLE.appendChild(TBODY);
                    TBODY.appendChild(document.createElement('TR'));
                    TBODY.firstChild.appendChild(document.createElement('TD'));
                    TBODY.firstChild.firstChild.innerHTML = '<tr><td>t<br>t</td></tr>';
                
                    var CAPTION = document.createElement('CAPTION');
                    CAPTION.innerHTML = 'c<br>c<br>c<br>c';
                    CAPTION.style.padding = 0;
                    CAPTION.style.margin = 0;
                    TABLE.insertBefore(CAPTION, TBODY);
                
                    document.body.appendChild(TABLE);
                    hasCaptionProblem = (TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight); //boolean
                    document.body.removeChild(TABLE);
                  }
                
                  Handsontable.Dom.hasCaptionProblem = function () {
                    if (hasCaptionProblem === void 0) {
                      detectCaptionProblem();
                    }
                    return hasCaptionProblem;
                  };
                
                  /**
                   * Returns caret position in text input
                   * @author http://stackoverflow.com/questions/263743/how-to-get-caret-position-in-textarea
                   * @return {Number}
                   */
                  Handsontable.Dom.getCaretPosition = function (el) {
                    if (el.selectionStart) {
                      return el.selectionStart;
                    }
                    else if (document.selection) { //IE8
                      el.focus();
                      var r = document.selection.createRange();
                      if (r == null) {
                        return 0;
                      }
                      var re = el.createTextRange(),
                        rc = re.duplicate();
                      re.moveToBookmark(r.getBookmark());
                      rc.setEndPoint('EndToStart', re);
                      return rc.text.length;
                    }
                    return 0;
                  };
                
                  /**
                   * Returns end of the selection in text input
                   * @return {Number}
                   */
                  Handsontable.Dom.getSelectionEndPosition = function (el) {
                    if(el.selectionEnd) {
                      return el.selectionEnd;
                    } else if(document.selection) { //IE8
                      var r = document.selection.createRange();
                      if(r == null) {
                        return 0;
                      }
                      var re = el.createTextRange();
                
                      return re.text.indexOf(r.text) + r.text.length;
                    }
                  };
                
                  /**
                   * Sets caret position in text input
                   * @author http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/
                   * @param {Element} el
                   * @param {Number} pos
                   * @param {Number} endPos
                   */
                  Handsontable.Dom.setCaretPosition = function (el, pos, endPos) {
                    if (endPos === void 0) {
                      endPos = pos;
                    }
                    if (el.setSelectionRange) {
                      el.focus();
                      el.setSelectionRange(pos, endPos);
                    }
                    else if (el.createTextRange) { //IE8
                      var range = el.createTextRange();
                      range.collapse(true);
                      range.moveEnd('character', endPos);
                      range.moveStart('character', pos);
                      range.select();
                    }
                  };
                
                  var cachedScrollbarWidth;
                  //http://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes
                  function walkontableCalculateScrollbarWidth() {
                    var inner = document.createElement('p');
                    inner.style.width = "100%";
                    inner.style.height = "200px";
                
                    var outer = document.createElement('div');
                    outer.style.position = "absolute";
                    outer.style.top = "0px";
                    outer.style.left = "0px";
                    outer.style.visibility = "hidden";
                    outer.style.width = "200px";
                    outer.style.height = "150px";
                    outer.style.overflow = "hidden";
                    outer.appendChild(inner);
                
                    (document.body || document.documentElement).appendChild(outer);
                    var w1 = inner.offsetWidth;
                    outer.style.overflow = 'scroll';
                    var w2 = inner.offsetWidth;
                    if (w1 == w2) w2 = outer.clientWidth;
                
                    (document.body || document.documentElement).removeChild(outer);
                
                    return (w1 - w2);
                  }
                
                  /**
                   * Returns the computed width of the native browser scroll bar
                   * @return {Number} width
                   */
                  Handsontable.Dom.getScrollbarWidth = function () {
                    if (cachedScrollbarWidth === void 0) {
                      cachedScrollbarWidth = walkontableCalculateScrollbarWidth();
                    }
                    return cachedScrollbarWidth;
                  }
                })();
                
                /**
                 * Handsontable TableView constructor
                 * @param {Object} instance
                 */
                Handsontable.TableView = function (instance) {
                  var that = this
                    , $documentElement = $(document.documentElement);
                
                  this.instance = instance;
                  this.settings = instance.getSettings();
                
                  instance.rootElement.data('originalStyle', instance.rootElement[0].getAttribute('style')); //needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions
                  // in IE7 getAttribute('style') returns an object instead of a string, but we only support IE8+
                
                  instance.rootElement.addClass('handsontable');
                
                  var table = document.createElement('TABLE');
                  table.className = 'htCore';
                  this.THEAD = document.createElement('THEAD');
                  table.appendChild(this.THEAD);
                  this.TBODY = document.createElement('TBODY');
                  table.appendChild(this.TBODY);
                
                  instance.$table = $(table);
                  instance.container.prepend(instance.$table);
                
                  instance.rootElement.on('mousedown.handsontable', function (event) {
                    if (!that.isTextSelectionAllowed(event.target)) {
                      clearTextSelection();
                      event.preventDefault();
                      window.focus(); //make sure that window that contains HOT is active. Important when HOT is in iframe.
                    }
                  });
                
                  $documentElement.on('keyup.' + instance.guid, function (event) {
                    if (instance.selection.isInProgress() && !event.shiftKey) {
                      instance.selection.finish();
                    }
                  });
                
                  var isMouseDown;
                  this.isMouseDown = function() {
                    return isMouseDown;
                  };
                
                  $documentElement.on('mouseup.' + instance.guid, function (event) {
                    if (instance.selection.isInProgress() && event.which === 1) { //is left mouse button
                      instance.selection.finish();
                    }
                
                    isMouseDown = false;
                
                    if (Handsontable.helper.isOutsideInput(document.activeElement)) {
                      instance.unlisten();
                    }
                  });
                
                  $documentElement.on('mousedown.' + instance.guid, function (event) {
                    var next = event.target;
                
                    if (next.shadowRoot) {
                      return; //click inside Web Component
                    }
                
                    if (next !== that.wt.wtTable.spreader) { //immediate click on "spreader" means click on the right side of vertical scrollbar
                      while (next !== document.documentElement) {
                        if (next === null) {
                          return; //click on something that was a row but now is detached (possibly because your click triggered a rerender)
                        }
                        if (next === instance.rootElement[0]) {
                          return; //click inside container
                        }
                        next = next.parentNode;
                      }
                    }
                
                    //function did not return until here, we have an outside click!
                
                    if (that.settings.outsideClickDeselects) {
                      instance.deselectCell();
                    }
                    else {
                      instance.destroyEditor();
                    }
                  });
                
                  instance.$table.on('selectstart', function (event) {
                    if (that.settings.fragmentSelection) {
                      return;
                    }
                
                    //https://github.com/handsontable/jquery-handsontable/issues/160
                    //selectstart is IE only event. Prevent text from being selected when performing drag down in IE8
                    event.preventDefault();
                  });
                
                  var clearTextSelection = function () {
                    //http://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript
                    if (window.getSelection) {
                      if (window.getSelection().empty) {  // Chrome
                        window.getSelection().empty();
                      } else if (window.getSelection().removeAllRanges) {  // Firefox
                        window.getSelection().removeAllRanges();
                      }
                    } else if (document.selection) {  // IE?
                      document.selection.empty();
                    }
                  };
                
                  var walkontableConfig = {
                    debug: function () {
                      return that.settings.debug;
                    },
                    table: table,
                    stretchH: this.settings.stretchH,
                    data: instance.getDataAtCell,
                    totalRows: instance.countRows,
                    totalColumns: instance.countCols,
                    offsetRow: 0,
                    fixedColumnsLeft: function () {
                      return that.settings.fixedColumnsLeft;
                    },
                    fixedRowsTop: function () {
                      return that.settings.fixedRowsTop;
                    },
                    renderAllRows: that.settings.renderAllRows,
                    rowHeaders: function () {
                      return instance.hasRowHeaders() ? [function (index, TH) {
                        that.appendRowHeader(index, TH);
                      }] : []
                    },
                    columnHeaders: function () {
                      return instance.hasColHeaders() ? [function (index, TH) {
                        that.appendColHeader(index, TH);
                      }] : []
                    },
                    columnWidth: instance.getColWidth,
                    rowHeight: instance.getRowHeight,
                    cellRenderer: function (row, col, TD) {
                
                      var prop = that.instance.colToProp(col)
                        , cellProperties = that.instance.getCellMeta(row, col)
                        , renderer = that.instance.getCellRenderer(cellProperties);
                
                      var value = that.instance.getDataAtRowProp(row, prop);
                
                      renderer(that.instance, TD, row, col, prop, value, cellProperties);
                      Handsontable.hooks.run(that.instance, 'afterRenderer', TD, row, col, prop, value, cellProperties);
                
                    },
                    selections: [
                      {
                        className: 'current',
                        border: {
                          width: 2,
                          color: '#5292F7',
                          //style: 'solid', //not used
                          cornerVisible: function () {
                            return that.settings.fillHandle && !that.isCellEdited() && !instance.selection.isMultiple()
                          }
                        }
                      },
                      {
                        className: 'area',
                        border: {
                          width: 1,
                          color: '#89AFF9',
                          //style: 'solid', // not used
                          cornerVisible: function () {
                            return that.settings.fillHandle && !that.isCellEdited() && instance.selection.isMultiple()
                          }
                        }
                      },
                      {
                        className: 'highlight',
                        highlightRowClassName: that.settings.currentRowClassName,
                        highlightColumnClassName: that.settings.currentColClassName
                      },
                      {
                        className: 'fill',
                        border: {
                          width: 1,
                          color: 'red'
                          //style: 'solid' // not used
                        }
                      }
                    ],
                    hideBorderOnMouseDownOver: function () {
                      return that.settings.fragmentSelection;
                    },
                    onCellMouseDown: function (event, coords, TD, wt) {
                      instance.listen();
                      that.activeWt = wt;
                
                      isMouseDown = true;
                
                      if (event.button === 2 && instance.selection.inInSelection(coords)) { //right mouse button
                        //do nothing
                      }
                      else if (event.shiftKey) {
                        if (coords.row >= 0 && coords.col >= 0) {
                          instance.selection.setRangeEnd(coords);
                        }
                      }
                      else {
                        if (coords.row < 0 || coords.col < 0) {
                          if (coords.row < 0) {
                            instance.selectCell(0, coords.col, instance.countRows() - 1, coords.col);
                          }
                          if (coords.col < 0) {
                            instance.selectCell(coords.row, 0, coords.row, instance.countCols() - 1);
                          }
                        }
                        else {
                          instance.selection.setRangeStart(coords);
                        }
                      }
                
                      Handsontable.hooks.run(instance, 'afterOnCellMouseDown', event, coords, TD);
                
                      that.activeWt = that.wt;
                    },
                    /*onCellMouseOut: function (/*event, coords, TD* /) {
                     if (isMouseDown && that.settings.fragmentSelection === 'single') {
                     clearTextSelection(); //otherwise text selection blinks during multiple cells selection
                     }
                     },*/
                    onCellMouseOver: function (event, coords, TD, wt) {
                      that.activeWt = wt;
                      if (coords.row >= 0 && coords.col >= 0) { //is not a header
                        if (isMouseDown) {
                          /*if (that.settings.fragmentSelection === 'single') {
                           clearTextSelection(); //otherwise text selection blinks during multiple cells selection
                           }*/
                          instance.selection.setRangeEnd(coords);
                        }
                      }
                      Handsontable.hooks.run(instance, 'afterOnCellMouseOver', event, coords, TD);
                      that.activeWt = that.wt;
                    },
                    onCellCornerMouseDown: function (event) {
                      event.preventDefault();
                      Handsontable.hooks.run(instance, 'afterOnCellCornerMouseDown', event);
                    },
                    beforeDraw: function (force) {
                      that.beforeRender(force);
                    },
                    onDraw: function(force){
                      that.onDraw(force);
                    },
                    onScrollVertically: function () {
                      instance.runHooks('afterScrollVertically');
                    },
                    onScrollHorizontally: function () {
                      instance.runHooks('afterScrollHorizontally');
                    }
                  };
                
                  Handsontable.hooks.run(instance, 'beforeInitWalkontable', walkontableConfig);
                
                  this.wt = new Walkontable(walkontableConfig);
                  this.activeWt = this.wt;
                
                  $(that.wt.wtTable.spreader).on('mousedown.handsontable, contextmenu.handsontable', function (event) {
                    if (event.target === that.wt.wtTable.spreader && event.which === 3) { //right mouse button exactly on spreader means right clickon the right hand side of vertical scrollbar
                      event.stopPropagation();
                    }
                  });
                
                  $documentElement.on('click.' + instance.guid, function () {
                    if (that.settings.observeDOMVisibility) {
                      if (that.wt.drawInterrupted) {
                        that.instance.forceFullRender = true;
                        that.render();
                      }
                    }
                  });
                };
                
                Handsontable.TableView.prototype.isTextSelectionAllowed = function (el) {
                  if ( Handsontable.helper.isInput(el) ) {
                    return (true);
                  }
                  if (this.settings.fragmentSelection && Handsontable.Dom.isChildOf(el, this.TBODY)) {
                    return (true);
                  }
                  return false;
                };
                
                Handsontable.TableView.prototype.isCellEdited = function () {
                  var activeEditor = this.instance.getActiveEditor();
                  return activeEditor && activeEditor.isOpened();
                };
                
                Handsontable.TableView.prototype.beforeRender = function (force) {
                  if (force) { //force = did Walkontable decide to do full render
                    Handsontable.hooks.run(this.instance, 'beforeRender', this.instance.forceFullRender); //this.instance.forceFullRender = did Handsontable request full render?
                  }
                };
                
                Handsontable.TableView.prototype.onDraw = function(force){
                  if (force) { //force = did Walkontable decide to do full render
                    Handsontable.hooks.run(this.instance, 'afterRender', this.instance.forceFullRender); //this.instance.forceFullRender = did Handsontable request full render?
                  }
                };
                
                Handsontable.TableView.prototype.render = function () {
                  this.wt.draw(!this.instance.forceFullRender);
                  this.instance.forceFullRender = false;
                  this.instance.rootElement.triggerHandler('render.handsontable');
                };
                
                /**
                 * Returns td object given coordinates
                 * @param {WalkontableCellCoords} coords
                 */
                Handsontable.TableView.prototype.getCellAtCoords = function (coords) {
                  var td = this.wt.wtTable.getCell(coords);
                  if (td < 0) { //there was an exit code (cell is out of bounds)
                    return null;
                  }
                  else {
                    return td;
                  }
                };
                
                /**
                 * Scroll viewport to selection
                 * @param {WalkontableCellCoords} coords
                 */
                Handsontable.TableView.prototype.scrollViewport = function (coords) {
                  this.wt.scrollViewport(coords);
                };
                
                /**
                 * Append row header to a TH element
                 * @param row
                 * @param TH
                 */
                Handsontable.TableView.prototype.appendRowHeader = function (row, TH) {
                  var DIV = document.createElement('DIV'),
                      SPAN = document.createElement('SPAN');
                
                  DIV.className = 'relative';
                  SPAN.className = 'rowHeader';
                
                  if (row > -1) {
                    Handsontable.Dom.fastInnerHTML(SPAN, this.instance.getRowHeader(row));
                  } else {
                    Handsontable.Dom.fastInnerText(SPAN, '\u00A0');
                  }
                
                  DIV.appendChild(SPAN);
                  Handsontable.Dom.empty(TH);
                
                  TH.appendChild(DIV);
                
                  Handsontable.hooks.run(this.instance, 'afterGetRowHeader', row, TH);
                };
                
                /**
                 * Append column header to a TH element
                 * @param col
                 * @param TH
                 */
                Handsontable.TableView.prototype.appendColHeader = function (col, TH) {
                  var DIV = document.createElement('DIV')
                    , SPAN = document.createElement('SPAN');
                
                  DIV.className = 'relative';
                  SPAN.className = 'colHeader';
                
                  Handsontable.Dom.fastInnerHTML(SPAN, this.instance.getColHeader(col));
                  DIV.appendChild(SPAN);
                
                  Handsontable.Dom.empty(TH);
                  TH.appendChild(DIV);
                  Handsontable.hooks.run(this.instance, 'afterGetColHeader', col, TH);
                };
                
                /**
                 * Given a element's left position relative to the viewport, returns maximum element width until the right edge of the viewport (before scrollbar)
                 * @param {Number} leftOffset
                 * @return {Number}
                 */
                Handsontable.TableView.prototype.maximumVisibleElementWidth = function (leftOffset) {
                  this.wt.wtScrollbars.horizontal.readWindowSize();
                  var workspaceWidth = this.wt.wtViewport.getWorkspaceWidth();
                  var maxWidth = workspaceWidth - leftOffset;
                  return maxWidth > 0 ? maxWidth : 0;
                };
                
                /**
                 * Given a element's top position relative to the viewport, returns maximum element height until the bottom edge of the viewport (before scrollbar)
                 * @param {Number} topOffset
                 * @return {Number}
                 */
                Handsontable.TableView.prototype.maximumVisibleElementHeight = function (topOffset) {
                  this.wt.wtScrollbars.vertical.readWindowSize();
                  var workspaceHeight = this.wt.wtViewport.getWorkspaceHeight();
                  var maxHeight = workspaceHeight - topOffset;
                  return maxHeight > 0 ? maxHeight : 0;
                };
                
                Handsontable.TableView.prototype.mainViewIsActive = function () {
                  return this.wt === this.activeWt;
                };
                
                /**
                 * Utility to register editors and common namespace for keeping reference to all editor classes
                 */
                (function (Handsontable) {
                  
                
                  function RegisteredEditor(editorClass) {
                    var clazz, instances;
                
                    instances = {};
                    clazz = editorClass;
                
                    this.getInstance = function (hotInstance) {
                      if (!(hotInstance.guid in instances)) {
                        instances[hotInstance.guid] = new clazz(hotInstance);
                      }
                
                      return instances[hotInstance.guid];
                    }
                
                  }
                
                  var registeredEditorNames = {};
                  var registeredEditorClasses = new WeakMap();
                
                  Handsontable.editors = {
                
                    /**
                     * Registers editor under given name
                     * @param {String} editorName
                     * @param {Function} editorClass
                     */
                    registerEditor: function (editorName, editorClass) {
                      var editor = new RegisteredEditor(editorClass);
                      if (typeof editorName === "string") {
                        registeredEditorNames[editorName] = editor;
                      }
                      registeredEditorClasses.set(editorClass, editor);
                    },
                
                    /**
                     * Returns instance (singleton) of editor class
                     * @param {String|Function} editorName/editorClass
                     * @returns {Function} editorClass
                     */
                    getEditor: function (editorName, hotInstance) {
                      var editor;
                      if (typeof editorName == 'function') {
                        if (!(registeredEditorClasses.get(editorName))) {
                          this.registerEditor(null, editorName);
                        }
                        editor = registeredEditorClasses.get(editorName);
                      }
                      else if (typeof editorName == 'string') {
                        editor = registeredEditorNames[editorName];
                      }
                      else {
                        throw Error('Only strings and functions can be passed as "editor" parameter ');
                      }
                
                      if (!editor) {
                        throw Error('No editor registered under name "' + editorName + '"');
                      }
                
                      return editor.getInstance(hotInstance);
                    }
                
                  };
                
                
                })(Handsontable);
                
                (function(Handsontable){
                  
                
                  Handsontable.EditorManager = function(instance, priv, selection){
                    var that = this;
                    var $document = $(document);
                    var keyCodes = Handsontable.helper.keyCode;
                    var destroyed = false;
                
                    var activeEditor;
                
                    var init = function () {
                
                      function onKeyDown(event) {
                
                        if (!instance.isListening()) {
                          return;
                        }
                
                        if (priv.settings.beforeOnKeyDown) { // HOT in HOT Plugin
                          priv.settings.beforeOnKeyDown.call(instance, event);
                        }
                
                        Handsontable.hooks.run(instance, 'beforeKeyDown', event);
                
                        if(destroyed) {
                          return;
                        }
                
                        if (!event.isImmediatePropagationStopped()) {
                
                          priv.lastKeyCode = event.keyCode;
                          if (selection.isSelected()) {
                            var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
                
                            if (!activeEditor.isWaiting()) {
                              if (!Handsontable.helper.isMetaKey(event.keyCode) && !ctrlDown && !that.isEditorOpened()) {
                
                                var charCode = event.keyCode;
                                var charStr = String.fromCharCode(charCode);
                                var isUp = (charCode >= 65 && charCode <= 90) ? true : false; // uppercase
                                var isLow = (charCode >= 97 && charCode <= 122) ? true : false; // lowercase
                                // uppercase w/out shift or lowercase with shift == caps lock
                                if ((isUp && !event.shiftKey) || (isLow && event.shiftKey)) {
                                  charStr = charStr.toLowerCase();
                                }
                                that.openEditor(charStr);
                
                                event.preventDefault();
                                event.stopPropagation(); //required by HandsontableEditor
                                return;
                              }
                            }
                
                            var rangeModifier = event.shiftKey ? selection.setRangeEnd : selection.setRangeStart;
                
                              switch (event.keyCode) {
                
                                case keyCodes.A:
                                  if (ctrlDown) {
                                    selection.selectAll(); //select all cells
                
                                    event.preventDefault();
                                    event.stopPropagation();
                                    break;
                                  }
                
                                case keyCodes.ARROW_UP:
                
                                  if (that.isEditorOpened() && !activeEditor.isWaiting()){
                                    that.closeEditorAndSaveChanges(ctrlDown);
                                  }
                
                                  moveSelectionUp(event.shiftKey);
                
                                  event.preventDefault();
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.ARROW_DOWN:
                                  if (that.isEditorOpened() && !activeEditor.isWaiting()){
                                    that.closeEditorAndSaveChanges(ctrlDown);
                                  }
                
                                  moveSelectionDown(event.shiftKey);
                
                                  event.preventDefault();
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.ARROW_RIGHT:
                                  if(that.isEditorOpened()  && !activeEditor.isWaiting()){
                                    that.closeEditorAndSaveChanges(ctrlDown);
                                  }
                
                                  moveSelectionRight(event.shiftKey);
                
                                  event.preventDefault();
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.ARROW_LEFT:
                                  if(that.isEditorOpened() && !activeEditor.isWaiting()){
                                    that.closeEditorAndSaveChanges(ctrlDown);
                                  }
                
                                  moveSelectionLeft(event.shiftKey);
                
                                  event.preventDefault();
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.TAB:
                                  var tabMoves = typeof priv.settings.tabMoves === 'function' ? priv.settings.tabMoves(event) : priv.settings.tabMoves;
                                  if (event.shiftKey) {
                                    selection.transformStart(-tabMoves.row, -tabMoves.col); //move selection left
                                  }
                                  else {
                                    selection.transformStart(tabMoves.row, tabMoves.col, true); //move selection right (add a new column if needed)
                                  }
                                  event.preventDefault();
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.BACKSPACE:
                                case keyCodes.DELETE:
                                  selection.empty(event);
                                  that.prepareEditor();
                                  event.preventDefault();
                                  break;
                
                                case keyCodes.F2: /* F2 */
                                  that.openEditor();
                                  event.preventDefault(); //prevent Opera from opening Go to Page dialog
                                  break;
                
                                case keyCodes.ENTER: /* return/enter */
                                  if(that.isEditorOpened()){
                
                                    if (activeEditor.state !== Handsontable.EditorState.WAITING){
                                      that.closeEditorAndSaveChanges(ctrlDown);
                                    }
                
                                    moveSelectionAfterEnter(event.shiftKey);
                
                                  } else {
                
                                    if (instance.getSettings().enterBeginsEditing){
                                      that.openEditor();
                                    } else {
                                      moveSelectionAfterEnter(event.shiftKey);
                                    }
                
                                  }
                
                                  event.preventDefault(); //don't add newline to field
                                  event.stopImmediatePropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.ESCAPE:
                                  if(that.isEditorOpened()){
                                    that.closeEditorAndRestoreOriginalValue(ctrlDown);
                                  }
                                  event.preventDefault();
                                  break;
                
                                case keyCodes.HOME:
                                  if (event.ctrlKey || event.metaKey) {
                                    rangeModifier(new WalkontableCellCoords(0, priv.selRange.from.col));
                                  }
                                  else {
                                    rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, 0));
                                  }
                                  event.preventDefault(); //don't scroll the window
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.END:
                                  if (event.ctrlKey || event.metaKey) {
                                    rangeModifier(new WalkontableCellCoords(instance.countRows() - 1, priv.selRange.from.col));
                                  }
                                  else {
                                    rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, instance.countCols() - 1));
                                  }
                                  event.preventDefault(); //don't scroll the window
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.PAGE_UP:
                                  selection.transformStart(-instance.countVisibleRows(), 0);
                                  instance.view.wt.scrollVertical(-instance.countVisibleRows());
                                  instance.view.render();
                                  event.preventDefault(); //don't page up the window
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                case keyCodes.PAGE_DOWN:
                                  selection.transformStart(instance.countVisibleRows(), 0);
                                  instance.view.wt.scrollVertical(instance.countVisibleRows());
                                  instance.view.render();
                                  event.preventDefault(); //don't page down the window
                                  event.stopPropagation(); //required by HandsontableEditor
                                  break;
                
                                default:
                                  break;
                              }
                
                          }
                        }
                      }
                
                      instance.addHook('afterDocumentKeyDown', function(originalEvent){
                        onKeyDown(originalEvent);
                      });
                
                      $document.on('keydown.' + instance.guid, function(ev) {
                        instance.runHooks('afterDocumentKeyDown', ev);
                      });
                
                      function onDblClick(event, coords, elem) {
                        if(elem.nodeName == "TD") { //may be TD or TH
                          //that.instance.destroyEditor();
                          that.openEditor();
                        }
                      }
                
                      instance.view.wt.update('onCellDblClick', onDblClick);
                
                      instance.addHook('afterDestroy', function(){
                        destroyed = true;
                      });
                
                      function moveSelectionAfterEnter(shiftKey){
                        var enterMoves = typeof priv.settings.enterMoves === 'function' ? priv.settings.enterMoves(event) : priv.settings.enterMoves;
                
                        if (shiftKey) {
                          selection.transformStart(-enterMoves.row, -enterMoves.col); //move selection up
                        }
                        else {
                          selection.transformStart(enterMoves.row, enterMoves.col, true); //move selection down (add a new row if needed)
                        }
                      }
                
                      function moveSelectionUp(shiftKey){
                        if (shiftKey) {
                          selection.transformEnd(-1, 0);
                        }
                        else {
                          selection.transformStart(-1, 0);
                        }
                      }
                
                      function moveSelectionDown(shiftKey){
                        if (shiftKey) {
                          selection.transformEnd(1, 0); //expanding selection down with shift
                        }
                        else {
                          selection.transformStart(1, 0); //move selection down
                        }
                      }
                
                      function moveSelectionRight(shiftKey){
                        if (shiftKey) {
                          selection.transformEnd(0, 1);
                        }
                        else {
                          selection.transformStart(0, 1);
                        }
                      }
                
                      function moveSelectionLeft(shiftKey){
                        if (shiftKey) {
                          selection.transformEnd(0, -1);
                        }
                        else {
                          selection.transformStart(0, -1);
                        }
                      }
                    };
                
                    /**
                     * Destroy current editor, if exists
                     * @param {Boolean} revertOriginal
                     */
                    this.destroyEditor = function (revertOriginal) {
                      this.closeEditor(revertOriginal);
                    };
                
                    this.getActiveEditor = function () {
                      return activeEditor;
                    };
                
                    /**
                     * Prepare text input to be displayed at given grid cell
                     */
                    this.prepareEditor = function () {
                
                      if (activeEditor && activeEditor.isWaiting()){
                
                        this.closeEditor(false, false, function(dataSaved){
                          if(dataSaved){
                            that.prepareEditor();
                          }
                        });
                
                        return;
                      }
                
                      var row = priv.selRange.highlight.row;
                      var col = priv.selRange.highlight.col;
                      var prop = instance.colToProp(col);
                      var td = instance.getCell(row, col);
                      var originalValue = instance.getDataAtCell(row, col);
                      var cellProperties = instance.getCellMeta(row, col);
                
                      var editorClass = instance.getCellEditor(cellProperties);
                      activeEditor = Handsontable.editors.getEditor(editorClass, instance);
                
                      activeEditor.prepare(row, col, prop, td, originalValue, cellProperties);
                
                    };
                
                    this.isEditorOpened = function () {
                      return activeEditor.isOpened();
                    };
                
                    this.openEditor = function (initialValue) {
                      if (!activeEditor.cellProperties.readOnly){
                        activeEditor.beginEditing(initialValue);
                      }
                    };
                
                    this.closeEditor = function (restoreOriginalValue, ctrlDown, callback) {
                
                      if (!activeEditor){
                        if(callback) {
                          callback(false);
                        }
                      }
                      else {
                        activeEditor.finishEditing(restoreOriginalValue, ctrlDown, callback);
                      }
                    };
                
                    this.closeEditorAndSaveChanges = function(ctrlDown){
                      return this.closeEditor(false, ctrlDown);
                    };
                
                    this.closeEditorAndRestoreOriginalValue = function(ctrlDown){
                      return this.closeEditor(true, ctrlDown);
                    };
                
                    init();
                  };
                
                })(Handsontable);
                
                /**
                 * Utility to register renderers and common namespace for keeping reference to all renderers classes
                 */
                (function (Handsontable) {
                  
                
                  var registeredRenderers = {};
                
                  Handsontable.renderers = {
                
                    /**
                     * Registers renderer under given name
                     * @param {String} rendererName
                     * @param {Function} rendererFunction
                     */
                    registerRenderer: function (rendererName, rendererFunction) {
                      registeredRenderers[rendererName] = rendererFunction
                    },
                
                    /**
                     * @param {String|Function} rendererName/rendererFunction
                     * @returns {Function} rendererFunction
                     */
                    getRenderer: function (rendererName) {
                      if (typeof rendererName == 'function'){
                        return rendererName;
                      }
                
                      if (typeof rendererName != 'string'){
                        throw Error('Only strings and functions can be passed as "renderer" parameter ');
                      }
                
                      if (!(rendererName in registeredRenderers)) {
                        throw Error('No editor registered under name "' + rendererName + '"');
                      }
                
                      return registeredRenderers[rendererName];
                    }
                
                  };
                
                
                })(Handsontable);
                
                /**
                 * Returns true if keyCode represents a printable character
                 * @param {Number} keyCode
                 * @return {Boolean}
                 */
                Handsontable.helper.isPrintableChar = function (keyCode) {
                  return ((keyCode == 32) || //space
                    (keyCode >= 48 && keyCode <= 57) || //0-9
                    (keyCode >= 96 && keyCode <= 111) || //numpad
                    (keyCode >= 186 && keyCode <= 192) || //;=,-./`
                    (keyCode >= 219 && keyCode <= 222) || //[]{}\|"'
                    keyCode >= 226 || //special chars (229 for Asian chars)
                    (keyCode >= 65 && keyCode <= 90)); //a-z
                };
                
                Handsontable.helper.isMetaKey = function (keyCode) {
                  var keyCodes = Handsontable.helper.keyCode;
                  var metaKeys = [
                    keyCodes.ARROW_DOWN,
                    keyCodes.ARROW_UP,
                    keyCodes.ARROW_LEFT,
                    keyCodes.ARROW_RIGHT,
                    keyCodes.HOME,
                    keyCodes.END,
                    keyCodes.DELETE,
                    keyCodes.BACKSPACE,
                    keyCodes.F1,
                    keyCodes.F2,
                    keyCodes.F3,
                    keyCodes.F4,
                    keyCodes.F5,
                    keyCodes.F6,
                    keyCodes.F7,
                    keyCodes.F8,
                    keyCodes.F9,
                    keyCodes.F10,
                    keyCodes.F11,
                    keyCodes.F12,
                    keyCodes.TAB,
                    keyCodes.PAGE_DOWN,
                    keyCodes.PAGE_UP,
                    keyCodes.ENTER,
                    keyCodes.ESCAPE,
                    keyCodes.SHIFT,
                    keyCodes.CAPS_LOCK,
                    keyCodes.ALT
                  ];
                
                  return metaKeys.indexOf(keyCode) != -1;
                };
                
                Handsontable.helper.isCtrlKey = function (keyCode) {
                
                  var keys = Handsontable.helper.keyCode;
                
                  return [keys.CONTROL_LEFT, 224, keys.COMMAND_LEFT, keys.COMMAND_RIGHT].indexOf(keyCode) != -1;
                };
                
                /**
                 * Converts a value to string
                 * @param value
                 * @return {String}
                 */
                Handsontable.helper.stringify = function (value) {
                  switch (typeof value) {
                    case 'string':
                    case 'number':
                      return value + '';
                      break;
                
                    case 'object':
                      if (value === null) {
                        return '';
                      }
                      else {
                        return value.toString();
                      }
                      break;
                
                    case 'undefined':
                      return '';
                      break;
                
                    default:
                      return value.toString();
                  }
                };
                
                /**
                 * Generates spreadsheet-like column names: A, B, C, ..., Z, AA, AB, etc
                 * @param index
                 * @returns {String}
                 */
                Handsontable.helper.spreadsheetColumnLabel = function (index) {
                  var dividend = index + 1;
                  var columnLabel = '';
                  var modulo;
                  while (dividend > 0) {
                    modulo = (dividend - 1) % 26;
                    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
                    dividend = parseInt((dividend - modulo) / 26, 10);
                  }
                  return columnLabel;
                };
                
                /**
                 * Checks if value of n is a numeric one
                 * http://jsperf.com/isnan-vs-isnumeric/4
                 * @param n
                 * @returns {boolean}
                 */
                Handsontable.helper.isNumeric = function (n) {
                    var t = typeof n;
                    return t == 'number' ? !isNaN(n) && isFinite(n) :
                           t == 'string' ? !n.length ? false :
                           n.length == 1 ? /\d/.test(n) :
                           /^\s*[+-]?\s*(?:(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/i.test(n) :
                           t == 'object' ? !!n && typeof n.valueOf() == "number" && !(n instanceof Date) : false;
                };
                
                /**
                 * Checks if child is a descendant of given parent node
                 * http://stackoverflow.com/questions/2234979/how-to-check-in-javascript-if-one-element-is-a-child-of-another
                 * @param parent
                 * @param child
                 * @returns {boolean}
                 */
                Handsontable.helper.isDescendant = function (parent, child) {
                  var node = child.parentNode;
                  while (node != null) {
                    if (node == parent) {
                      return true;
                    }
                    node = node.parentNode;
                  }
                  return false;
                };
                
                /**
                 * Generates a random hex string. Used as namespace for Handsontable instance events.
                 * @return {String} - 16 character random string: "92b1bfc74ec4"
                 */
                Handsontable.helper.randomString = function () {
                  return walkontableRandomString();
                };
                
                /**
                 * Inherit without without calling parent constructor, and setting `Child.prototype.constructor` to `Child` instead of `Parent`.
                 * Creates temporary dummy function to call it as constructor.
                 * Described in ticket: https://github.com/handsontable/jquery-handsontable/pull/516
                 * @param  {Object} Child  child class
                 * @param  {Object} Parent parent class
                 * @return {Object}        extended Child
                 */
                Handsontable.helper.inherit = function (Child, Parent) {
                  Parent.prototype.constructor = Parent;
                  Child.prototype = new Parent();
                  Child.prototype.constructor = Child;
                  return Child;
                };
                
                /**
                 * Perform shallow extend of a target object with extension's own properties
                 * @param {Object} target An object that will receive the new properties
                 * @param {Object} extension An object containing additional properties to merge into the target
                 */
                Handsontable.helper.extend = function (target, extension) {
                  for (var i in extension) {
                    if (extension.hasOwnProperty(i)) {
                      target[i] = extension[i];
                    }
                  }
                };
                
                Handsontable.helper.getPrototypeOf = function (obj) {
                  var prototype;
                
                  if(typeof obj.__proto__ == "object"){
                    prototype = obj.__proto__;
                  } else {
                    var oldConstructor,
                        constructor = obj.constructor;
                
                    if (typeof obj.constructor == "function") {
                      oldConstructor = constructor;
                
                      if (delete obj.constructor){
                        constructor = obj.constructor; // get real constructor
                        obj.constructor = oldConstructor; // restore constructor
                      }
                
                
                    }
                
                    prototype = constructor ? constructor.prototype : null; // needed for IE
                
                  }
                
                  return prototype;
                };
                
                /**
                 * Factory for columns constructors.
                 * @param {Object} GridSettings
                 * @param {Array} conflictList
                 * @return {Object} ColumnSettings
                 */
                Handsontable.helper.columnFactory = function (GridSettings, conflictList) {
                  function ColumnSettings () {}
                
                  Handsontable.helper.inherit(ColumnSettings, GridSettings);
                
                  // Clear conflict settings
                  for (var i = 0, len = conflictList.length; i < len; i++) {
                    ColumnSettings.prototype[conflictList[i]] = void 0;
                  }
                
                  return ColumnSettings;
                };
                
                Handsontable.helper.translateRowsToColumns = function (input) {
                  var i
                    , ilen
                    , j
                    , jlen
                    , output = []
                    , olen = 0;
                
                  for (i = 0, ilen = input.length; i < ilen; i++) {
                    for (j = 0, jlen = input[i].length; j < jlen; j++) {
                      if (j == olen) {
                        output.push([]);
                        olen++;
                      }
                      output[j].push(input[i][j])
                    }
                  }
                  return output;
                };
                
                Handsontable.helper.to2dArray = function (arr) {
                  var i = 0
                    , ilen = arr.length;
                  while (i < ilen) {
                    arr[i] = [arr[i]];
                    i++;
                  }
                };
                
                Handsontable.helper.extendArray = function (arr, extension) {
                  var i = 0
                    , ilen = extension.length;
                  while (i < ilen) {
                    arr.push(extension[i]);
                    i++;
                  }
                };
                
                /**
                 * Determines if the given DOM element is an input field.
                 * Notice: By 'input' we mean input, textarea and select nodes
                 * @param element - DOM element
                 * @returns {boolean}
                 */
                Handsontable.helper.isInput = function (element) {
                  var inputs = ['INPUT', 'SELECT', 'TEXTAREA'];
                
                  return inputs.indexOf(element.nodeName) > -1;
                }
                
                /**
                 * Determines if the given DOM element is an input field placed OUTSIDE of HOT.
                 * Notice: By 'input' we mean input, textarea and select nodes
                 * @param element - DOM element
                 * @returns {boolean}
                 */
                Handsontable.helper.isOutsideInput = function (element) {
                  return Handsontable.helper.isInput(element) && element.className.indexOf('handsontableInput') == -1;
                };
                
                Handsontable.helper.keyCode = {
                  MOUSE_LEFT: 1,
                  MOUSE_RIGHT: 3,
                  MOUSE_MIDDLE: 2,
                  BACKSPACE: 8,
                  COMMA: 188,
                  DELETE: 46,
                  END: 35,
                  ENTER: 13,
                  ESCAPE: 27,
                  CONTROL_LEFT: 91,
                  COMMAND_LEFT: 17,
                  COMMAND_RIGHT: 93,
                  ALT: 18,
                  HOME: 36,
                  PAGE_DOWN: 34,
                  PAGE_UP: 33,
                  PERIOD: 190,
                  SPACE: 32,
                  SHIFT: 16,
                  CAPS_LOCK: 20,
                  TAB: 9,
                  ARROW_RIGHT: 39,
                  ARROW_LEFT: 37,
                  ARROW_UP: 38,
                  ARROW_DOWN: 40,
                  F1: 112,
                  F2: 113,
                  F3: 114,
                  F4: 115,
                  F5: 116,
                  F6: 117,
                  F7: 118,
                  F8: 119,
                  F9: 120,
                  F10: 121,
                  F11: 122,
                  F12: 123,
                  A: 65,
                  X: 88,
                  C: 67,
                  V: 86
                };
                
                /**
                 * Determines whether given object is a plain Object.
                 * Note: String and Array are not plain Objects
                 * @param {*} obj
                 * @returns {boolean}
                 */
                Handsontable.helper.isObject = function (obj) {
                  return Object.prototype.toString.call(obj) == '[object Object]';
                };
                
                /**
                 * Determines whether given object is an Array.
                 * Note: String is not an Array
                 * @param {*} obj
                 * @returns {boolean}
                 */
                Handsontable.helper.isArray = function(obj){
                  return Array.isArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) == '[object Array]';
                };
                
                Handsontable.helper.pivot = function (arr) {
                  var pivotedArr = [];
                
                  if(!arr || arr.length == 0 || !arr[0] || arr[0].length == 0){
                    return pivotedArr;
                  }
                
                  var rowCount = arr.length;
                  var colCount = arr[0].length;
                
                  for(var i = 0; i < rowCount; i++){
                    for(var j = 0; j < colCount; j++){
                      if(!pivotedArr[j]){
                        pivotedArr[j] = [];
                      }
                
                      pivotedArr[j][i] = arr[i][j];
                    }
                  }
                
                  return pivotedArr;
                
                };
                
                Handsontable.helper.proxy = function (fun, context) {
                  return function () {
                    return fun.apply(context, arguments);
                  };
                };
                
                /**
                 * Factory that produces a function for searching methods (or any properties) which could be defined directly in
                 * table configuration or implicitly, within cell type definition.
                 *
                 * For example: renderer can be defined explicitly using "renderer" property in column configuration or it can be
                 * defined implicitly using "type" property.
                 *
                 * Methods/properties defined explicitly always takes precedence over those defined through "type".
                 *
                 * If the method/property is not found in an object, searching is continued recursively through prototype chain, until
                 * it reaches the Object.prototype.
                 *
                 *
                 * @param methodName {String} name of the method/property to search (i.e. 'renderer', 'validator', 'copyable')
                 * @param allowUndefined {Boolean} [optional] if false, the search is continued if methodName has not been found in cell "type"
                 * @returns {Function}
                 */
                Handsontable.helper.cellMethodLookupFactory = function (methodName, allowUndefined) {
                
                  allowUndefined = typeof allowUndefined == 'undefined' ? true : allowUndefined;
                
                  return function cellMethodLookup (row, col) {
                
                    return (function getMethodFromProperties(properties) {
                
                      if (!properties){
                
                        return;                       //method not found
                
                      }
                      else if (properties.hasOwnProperty(methodName) && properties[methodName] !== void 0) { //check if it is own and is not empty
                
                        return properties[methodName];  //method defined directly
                
                      } else if (properties.hasOwnProperty('type') && properties.type) { //check if it is own and is not empty
                
                        var type;
                
                        if(typeof properties.type != 'string' ){
                          throw new Error('Cell type must be a string ');
                        }
                
                        type = translateTypeNameToObject(properties.type);
                
                        if (type.hasOwnProperty(methodName)) {
                          return type[methodName]; //method defined in type.
                        } else if (allowUndefined) {
                          return; //method does not defined in type (eg. validator), returns undefined
                        }
                
                      }
                
                      return getMethodFromProperties(Handsontable.helper.getPrototypeOf(properties));
                
                    })(typeof row == 'number' ? this.getCellMeta(row, col) : row);
                
                  };
                
                  function translateTypeNameToObject(typeName) {
                    var type = Handsontable.cellTypes[typeName];
                
                    if(typeof type == 'undefined'){
                      throw new Error('You declared cell type "' + typeName + '" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
                    }
                
                    return type;
                  }
                
                };
                
                Handsontable.helper.toString = function (obj) {
                  return '' + obj;
                };
                
                (function (Handsontable) {
                  
                
                  /**
                   * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names
                   * TODO refactor arguments of methods getRange, getText to be numbers (not objects)
                   * TODO remove priv, GridSettings from object constructor
                   *
                   * @param instance
                   * @param priv
                   * @param GridSettings
                   * @constructor
                   */
                  Handsontable.DataMap = function (instance, priv, GridSettings) {
                    this.instance = instance;
                    this.priv = priv;
                    this.GridSettings = GridSettings;
                    this.dataSource = this.instance.getSettings().data;
                
                    if (this.dataSource[0]) {
                      this.duckSchema = this.recursiveDuckSchema(this.dataSource[0]);
                    }
                    else {
                      this.duckSchema = {};
                    }
                    this.createMap();
                  };
                
                  Handsontable.DataMap.prototype.DESTINATION_RENDERER = 1;
                  Handsontable.DataMap.prototype.DESTINATION_CLIPBOARD_GENERATOR = 2;
                
                  Handsontable.DataMap.prototype.recursiveDuckSchema = function (obj) {
                    var schema;
                    if ($.isPlainObject(obj)) {
                      schema = {};
                      for (var i in obj) {
                        if (obj.hasOwnProperty(i)) {
                          if ($.isPlainObject(obj[i])) {
                            schema[i] = this.recursiveDuckSchema(obj[i]);
                          }
                          else {
                            schema[i] = null;
                          }
                        }
                      }
                    }
                    else {
                      schema = [];
                    }
                    return schema;
                  };
                
                  Handsontable.DataMap.prototype.recursiveDuckColumns = function (schema, lastCol, parent) {
                    var prop, i;
                    if (typeof lastCol === 'undefined') {
                      lastCol = 0;
                      parent = '';
                    }
                    if ($.isPlainObject(schema)) {
                      for (i in schema) {
                        if (schema.hasOwnProperty(i)) {
                          if (schema[i] === null) {
                            prop = parent + i;
                            this.colToPropCache.push(prop);
                            this.propToColCache.set(prop, lastCol);
                
                            lastCol++;
                          }
                          else {
                            lastCol = this.recursiveDuckColumns(schema[i], lastCol, i + '.');
                          }
                        }
                      }
                    }
                    return lastCol;
                  };
                
                  Handsontable.DataMap.prototype.createMap = function () {
                    if (typeof this.getSchema() === "undefined") {
                      throw new Error("trying to create `columns` definition but you didnt' provide `schema` nor `data`");
                    }
                    var i, ilen, schema = this.getSchema();
                    this.colToPropCache = [];
                    this.propToColCache = new MultiMap();
                    var columns = this.instance.getSettings().columns;
                    if (columns) {
                      for (i = 0, ilen = columns.length; i < ilen; i++) {
                
                        if (typeof columns[i].data != 'undefined'){
                          this.colToPropCache[i] = columns[i].data;
                          this.propToColCache.set(columns[i].data, i);
                        }
                
                      }
                    }
                    else {
                      this.recursiveDuckColumns(schema);
                    }
                  };
                
                  Handsontable.DataMap.prototype.colToProp = function (col) {
                    col = Handsontable.hooks.execute(this.instance, 'modifyCol', col);
                    if (this.colToPropCache && typeof this.colToPropCache[col] !== 'undefined') {
                      return this.colToPropCache[col];
                    }
                    else {
                      return col;
                    }
                  };
                
                  Handsontable.DataMap.prototype.propToCol = function (prop) {
                    var col;
                    if (typeof this.propToColCache.get(prop) !== 'undefined') {
                      col = this.propToColCache.get(prop);
                    } else {
                      col = prop;
                    }
                    col = Handsontable.hooks.execute(this.instance, 'modifyCol', col);
                    return col;
                  };
                
                  Handsontable.DataMap.prototype.getSchema = function () {
                    var schema = this.instance.getSettings().dataSchema;
                    if (schema) {
                      if (typeof schema === 'function') {
                        return schema();
                      }
                      return schema;
                    }
                    return this.duckSchema;
                  };
                
                  /**
                   * Creates row at the bottom of the data array
                   * @param {Number} [index] Optional. Index of the row before which the new row will be inserted
                   */
                  Handsontable.DataMap.prototype.createRow = function (index, amount, createdAutomatically) {
                    var row
                      , colCount = this.instance.countCols()
                      , numberOfCreatedRows = 0
                      , currentIndex;
                
                    if (!amount) {
                      amount = 1;
                    }
                
                    if (typeof index !== 'number' || index >= this.instance.countRows()) {
                      index = this.instance.countRows();
                    }
                
                    currentIndex = index;
                    var maxRows = this.instance.getSettings().maxRows;
                    while (numberOfCreatedRows < amount && this.instance.countRows() < maxRows) {
                
                      if (this.instance.dataType === 'array') {
                        row = [];
                        for (var c = 0; c < colCount; c++) {
                          row.push(null);
                        }
                      }
                      else if (this.instance.dataType === 'function') {
                        row = this.instance.getSettings().dataSchema(index);
                      }
                      else {
                        row = $.extend(true, {}, this.getSchema());
                      }
                
                      if (index === this.instance.countRows()) {
                        this.dataSource.push(row);
                      }
                      else {
                        this.dataSource.splice(index, 0, row);
                      }
                
                      numberOfCreatedRows++;
                      currentIndex++;
                    }
                
                
                    Handsontable.hooks.run(this.instance, 'afterCreateRow', index, numberOfCreatedRows, createdAutomatically);
                    this.instance.forceFullRender = true; //used when data was changed
                
                    return numberOfCreatedRows;
                  };
                
                  /**
                   * Creates col at the right of the data array
                   * @param {Number} [index] Optional. Index of the column before which the new column will be inserted
                   *   * @param {Number} [amount] Optional.
                   */
                  Handsontable.DataMap.prototype.createCol = function (index, amount, createdAutomatically) {
                    if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {
                      throw new Error("Cannot create new column. When data source in an object, " +
                        "you can only have as much columns as defined in first data row, data schema or in the 'columns' setting." +
                        "If you want to be able to add new columns, you have to use array datasource.");
                    }
                    var rlen = this.instance.countRows()
                      , data = this.dataSource
                      , constructor
                      , numberOfCreatedCols = 0
                      , currentIndex;
                
                    if (!amount) {
                      amount = 1;
                    }
                
                    currentIndex = index;
                
                    var maxCols = this.instance.getSettings().maxCols;
                    while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {
                      constructor = Handsontable.helper.columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);
                      if (typeof index !== 'number' || index >= this.instance.countCols()) {
                        for (var r = 0; r < rlen; r++) {
                          if (typeof data[r] === 'undefined') {
                            data[r] = [];
                          }
                          data[r].push(null);
                        }
                        // Add new column constructor
                        this.priv.columnSettings.push(constructor);
                      }
                      else {
                        for (var r = 0; r < rlen; r++) {
                          data[r].splice(currentIndex, 0, null);
                        }
                        // Add new column constructor at given index
                        this.priv.columnSettings.splice(currentIndex, 0, constructor);
                      }
                
                      numberOfCreatedCols++;
                      currentIndex++;
                    }
                
                    Handsontable.hooks.run(this.instance, 'afterCreateCol', index, numberOfCreatedCols, createdAutomatically);
                    this.instance.forceFullRender = true; //used when data was changed
                
                    return numberOfCreatedCols;
                  };
                
                  /**
                   * Removes row from the data array
                   * @param {Number} [index] Optional. Index of the row to be removed. If not provided, the last row will be removed
                   * @param {Number} [amount] Optional. Amount of the rows to be removed. If not provided, one row will be removed
                   */
                  Handsontable.DataMap.prototype.removeRow = function (index, amount) {
                    if (!amount) {
                      amount = 1;
                    }
                    if (typeof index !== 'number') {
                      index = -amount;
                    }
                
                    index = (this.instance.countRows() + index) % this.instance.countRows();
                
                    // We have to map the physical row ids to logical and than perform removing with (possibly) new row id
                    var logicRows = this.physicalRowsToLogical(index, amount);
                
                    var actionWasNotCancelled = Handsontable.hooks.execute(this.instance, 'beforeRemoveRow', index, amount);
                
                    if (actionWasNotCancelled === false) {
                      return;
                    }
                
                    var data = this.dataSource;
                    var newData = data.filter(function (row, index) {
                      return logicRows.indexOf(index) == -1;
                    });
                
                    data.length = 0;
                    Array.prototype.push.apply(data, newData);
                
                    Handsontable.hooks.run(this.instance, 'afterRemoveRow', index, amount);
                
                    this.instance.forceFullRender = true; //used when data was changed
                  };
                
                  /**
                   * Removes column from the data array
                   * @param {Number} [index] Optional. Index of the column to be removed. If not provided, the last column will be removed
                   * @param {Number} [amount] Optional. Amount of the columns to be removed. If not provided, one column will be removed
                   */
                  Handsontable.DataMap.prototype.removeCol = function (index, amount) {
                    if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {
                      throw new Error("cannot remove column with object data source or columns option specified");
                    }
                    if (!amount) {
                      amount = 1;
                    }
                    if (typeof index !== 'number') {
                      index = -amount;
                    }
                
                    index = (this.instance.countCols() + index) % this.instance.countCols();
                
                    var actionWasNotCancelled = Handsontable.hooks.execute(this.instance, 'beforeRemoveCol', index, amount);
                
                    if (actionWasNotCancelled === false) {
                      return;
                    }
                
                    var data = this.dataSource;
                    for (var r = 0, rlen = this.instance.countRows(); r < rlen; r++) {
                      data[r].splice(index, amount);
                    }
                    this.priv.columnSettings.splice(index, amount);
                
                    Handsontable.hooks.run(this.instance, 'afterRemoveCol', index, amount);
                    this.instance.forceFullRender = true; //used when data was changed
                  };
                
                  /**
                   * Add / removes data from the column
                   * @param {Number} col Index of column in which do you want to do splice.
                   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
                   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
                   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
                   */
                  Handsontable.DataMap.prototype.spliceCol = function (col, index, amount/*, elements...*/) {
                    var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];
                
                    var colData = this.instance.getDataAtCol(col);
                    var removed = colData.slice(index, index + amount);
                    var after = colData.slice(index + amount);
                
                    Handsontable.helper.extendArray(elements, after);
                    var i = 0;
                    while (i < amount) {
                      elements.push(null); //add null in place of removed elements
                      i++;
                    }
                    Handsontable.helper.to2dArray(elements);
                    this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');
                
                    return removed;
                  };
                
                  /**
                   * Add / removes data from the row
                   * @param {Number} row Index of row in which do you want to do splice.
                   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
                   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
                   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
                   */
                  Handsontable.DataMap.prototype.spliceRow = function (row, index, amount/*, elements...*/) {
                    var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];
                
                    var rowData = this.instance.getSourceDataAtRow(row);
                    var removed = rowData.slice(index, index + amount);
                    var after = rowData.slice(index + amount);
                
                    Handsontable.helper.extendArray(elements, after);
                    var i = 0;
                    while (i < amount) {
                      elements.push(null); //add null in place of removed elements
                      i++;
                    }
                    this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');
                
                    return removed;
                  };
                
                  /**
                   * Returns single value from the data array
                   * @param {Number} row
                   * @param {Number} prop
                   */
                  Handsontable.DataMap.prototype.get = function (row, prop) {
                    row = Handsontable.hooks.execute(this.instance, 'modifyRow', row);
                    if (typeof prop === 'string' && prop.indexOf('.') > -1) {
                      var sliced = prop.split(".");
                      var out = this.dataSource[row];
                      if (!out) {
                        return null;
                      }
                      for (var i = 0, ilen = sliced.length; i < ilen; i++) {
                        out = out[sliced[i]];
                        if (typeof out === 'undefined') {
                          return null;
                        }
                      }
                      return out;
                    }
                    else if (typeof prop === 'function') {
                      /**
                       *  allows for interacting with complex structures, for example
                       *  d3/jQuery getter/setter properties:
                       *
                       *    {columns: [{
                         *      data: function(row, value){
                         *        if(arguments.length === 1){
                         *          return row.property();
                         *        }
                         *        row.property(value);
                         *      }
                         *    }]}
                       */
                      return prop(this.dataSource.slice(
                        row,
                        row + 1
                      )[0]);
                    }
                    else {
                      return this.dataSource[row] ? this.dataSource[row][prop] : null;
                    }
                  };
                
                  var copyableLookup = Handsontable.helper.cellMethodLookupFactory('copyable', false);
                
                  /**
                   * Returns single value from the data array (intended for clipboard copy to an external application)
                   * @param {Number} row
                   * @param {Number} prop
                   * @return {String}
                   */
                  Handsontable.DataMap.prototype.getCopyable = function (row, prop) {
                    if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {
                      return this.get(row, prop);
                    }
                    return '';
                  };
                
                  /**
                   * Saves single value to the data array
                   * @param {Number} row
                   * @param {Number} prop
                   * @param {String} value
                   * @param {String} [source] Optional. Source of hook runner.
                   */
                  Handsontable.DataMap.prototype.set = function (row, prop, value, source) {
                    row = Handsontable.hooks.execute(this.instance, 'modifyRow', row, source || "datamapGet");
                    if (typeof prop === 'string' && prop.indexOf('.') > -1) {
                      var sliced = prop.split(".");
                      var out = this.dataSource[row];
                      for (var i = 0, ilen = sliced.length - 1; i < ilen; i++) {
                        out = out[sliced[i]];
                      }
                      out[sliced[i]] = value;
                    }
                    else if (typeof prop === 'function') {
                      /* see the `function` handler in `get` */
                      prop(this.dataSource.slice(
                        row,
                        row + 1
                      )[0], value);
                    }
                    else {
                      this.dataSource[row][prop] = value;
                    }
                  };
                
                  /**
                   * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.
                   * The trick is, the physical row id (stored in settings.data) is not necessary the same
                   * as the logical (displayed) row id (e.g. when sorting is applied).
                   */
                  Handsontable.DataMap.prototype.physicalRowsToLogical = function (index, amount) {
                    var totalRows = this.instance.countRows();
                    var physicRow = (totalRows + index) % totalRows;
                    var logicRows = [];
                    var rowsToRemove = amount;
                    var row;
                
                    while (physicRow < totalRows && rowsToRemove) {
                      row = Handsontable.hooks.execute(this.instance, 'modifyRow', physicRow);
                      logicRows.push(row);
                
                      rowsToRemove--;
                      physicRow++;
                    }
                
                    return logicRows;
                  };
                
                  /**
                   * Clears the data array
                   */
                  Handsontable.DataMap.prototype.clear = function () {
                    for (var r = 0; r < this.instance.countRows(); r++) {
                      for (var c = 0; c < this.instance.countCols(); c++) {
                        this.set(r, this.colToProp(c), '');
                      }
                    }
                  };
                
                  /**
                   * Returns the data array
                   * @return {Array}
                   */
                  Handsontable.DataMap.prototype.getAll = function () {
                    return this.dataSource;
                  };
                
                  /**
                   * Returns data range as array
                   * @param {Object} start Start selection position
                   * @param {Object} end End selection position
                   * @param {Number} destination Destination of datamap.get
                   * @return {Array}
                   */
                  Handsontable.DataMap.prototype.getRange = function (start, end, destination) {
                    var r, rlen, c, clen, output = [], row;
                    var getFn = destination === this.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
                    rlen = Math.max(start.row, end.row);
                    clen = Math.max(start.col, end.col);
                    for (r = Math.min(start.row, end.row); r <= rlen; r++) {
                      row = [];
                      for (c = Math.min(start.col, end.col); c <= clen; c++) {
                        row.push(getFn.call(this, r, this.colToProp(c)));
                      }
                      output.push(row);
                    }
                    return output;
                  };
                
                  /**
                   * Return data as text (tab separated columns)
                   * @param {Object} start (Optional) Start selection position
                   * @param {Object} end (Optional) End selection position
                   * @return {String}
                   */
                  Handsontable.DataMap.prototype.getText = function (start, end) {
                    return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_RENDERER));
                  };
                
                  /**
                   * Return data as copyable text (tab separated columns intended for clipboard copy to an external application)
                   * @param {Object} start (Optional) Start selection position
                   * @param {Object} end (Optional) End selection position
                   * @return {String}
                   */
                  Handsontable.DataMap.prototype.getCopyableText = function (start, end) {
                    return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_CLIPBOARD_GENERATOR));
                  };
                
                })(Handsontable);
                
                (function (Handsontable) {
                  
                
                  /*
                    Adds appropriate CSS class to table cell, based on cellProperties
                   */
                  Handsontable.renderers.cellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {
                    if (cellProperties.className) {
                      if(TD.className) {
                        TD.className = TD.className + " " + cellProperties.className;
                      } else {
                        TD.className = cellProperties.className;
                      }
                
                    }
                
                    if (cellProperties.readOnly) {
                      Handsontable.Dom.addClass(TD, cellProperties.readOnlyCellClassName);
                    }
                
                    if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
                      Handsontable.Dom.addClass(TD, cellProperties.invalidCellClassName);
                    }
                
                    if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
                      Handsontable.Dom.addClass(TD, cellProperties.noWordWrapClassName);
                    }
                
                    if (!value && cellProperties.placeholder) {
                      Handsontable.Dom.addClass(TD, cellProperties.placeholderCellClassName);
                    }
                  }
                
                })(Handsontable);
                /**
                 * Default text renderer
                 * @param {Object} instance Handsontable instance
                 * @param {Element} TD Table cell where to render
                 * @param {Number} row
                 * @param {Number} col
                 * @param {String|Number} prop Row object property name
                 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
                 * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
                 */
                (function (Handsontable) {
                  
                
                  var TextRenderer = function (instance, TD, row, col, prop, value, cellProperties) {
                
                    Handsontable.renderers.cellDecorator.apply(this, arguments);
                
                    if (!value && cellProperties.placeholder) {
                      value = cellProperties.placeholder;
                    }
                
                    var escaped = Handsontable.helper.stringify(value);
                
                    if (cellProperties.rendererTemplate) {
                      Handsontable.Dom.empty(TD);
                      var TEMPLATE = document.createElement('TEMPLATE');
                      TEMPLATE.setAttribute('bind', '{{}}');
                      TEMPLATE.innerHTML = cellProperties.rendererTemplate;
                      HTMLTemplateElement.decorate(TEMPLATE);
                      TEMPLATE.model = instance.getSourceDataAtRow(row);
                      TD.appendChild(TEMPLATE);
                    }
                    else {
                      Handsontable.Dom.fastInnerText(TD, escaped); //this is faster than innerHTML. See: https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
                    }
                
                  };
                
                  //Handsontable.TextRenderer = TextRenderer; //Left for backward compatibility
                  Handsontable.renderers.TextRenderer = TextRenderer;
                  Handsontable.renderers.registerRenderer('text', TextRenderer);
                
                })(Handsontable);
                
                (function (Handsontable) {
                
                  var clonableWRAPPER = document.createElement('DIV');
                  clonableWRAPPER.className = 'htAutocompleteWrapper';
                
                  var clonableARROW = document.createElement('DIV');
                  clonableARROW.className = 'htAutocompleteArrow';
                  clonableARROW.appendChild(document.createTextNode('\u25BC'));
                //this is faster than innerHTML. See: https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
                
                  var wrapTdContentWithWrapper = function(TD, WRAPPER){
                    WRAPPER.innerHTML = TD.innerHTML;
                    Handsontable.Dom.empty(TD);
                    TD.appendChild(WRAPPER);
                  };
                
                  /**
                   * Autocomplete renderer
                   * @param {Object} instance Handsontable instance
                   * @param {Element} TD Table cell where to render
                   * @param {Number} row
                   * @param {Number} col
                   * @param {String|Number} prop Row object property name
                   * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
                   * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
                   */
                  var AutocompleteRenderer = function (instance, TD, row, col, prop, value, cellProperties) {
                
                    var WRAPPER = clonableWRAPPER.cloneNode(true); //this is faster than createElement
                    var ARROW = clonableARROW.cloneNode(true); //this is faster than createElement
                
                    Handsontable.renderers.TextRenderer(instance, TD, row, col, prop, value, cellProperties);
                
                    TD.appendChild(ARROW);
                    Handsontable.Dom.addClass(TD, 'htAutocomplete');
                
                
                    if (!TD.firstChild) { //http://jsperf.com/empty-node-if-needed
                      //otherwise empty fields appear borderless in demo/renderers.html (IE)
                      TD.appendChild(document.createTextNode('\u00A0')); //\u00A0 equals &nbsp; for a text node
                      //this is faster than innerHTML. See: https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
                    }
                
                    if (!instance.acArrowListener) {
                      //not very elegant but easy and fast
                      instance.acArrowListener = function () {
                        instance.view.wt.getSetting('onCellDblClick', null, new WalkontableCellCoords(row, col), TD);
                      };
                
                      instance.rootElement.on('mousedown.htAutocompleteArrow', '.htAutocompleteArrow', instance.acArrowListener); //this way we don't bind event listener to each arrow. We rely on propagation instead
                
                      //We need to unbind the listener after the table has been destroyed
                      instance.addHookOnce('afterDestroy', function () {
                        this.rootElement.off('mousedown.htAutocompleteArrow');
                      });
                
                    }
                  };
                
                  Handsontable.AutocompleteRenderer = AutocompleteRenderer;
                  Handsontable.renderers.AutocompleteRenderer = AutocompleteRenderer;
                  Handsontable.renderers.registerRenderer('autocomplete', AutocompleteRenderer);
                })(Handsontable);
                /**
                 * Checkbox renderer
                 * @param {Object} instance Handsontable instance
                 * @param {Element} TD Table cell where to render
                 * @param {Number} row
                 * @param {Number} col
                 * @param {String|Number} prop Row object property name
                 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
                 * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
                 */
                (function (Handsontable) {
                
                  
                
                  var clonableINPUT = document.createElement('INPUT');
                  clonableINPUT.className = 'htCheckboxRendererInput';
                  clonableINPUT.type = 'checkbox';
                  clonableINPUT.setAttribute('autocomplete', 'off');
                
                  var CheckboxRenderer = function (instance, TD, row, col, prop, value, cellProperties) {
                
                    if (typeof cellProperties.checkedTemplate === "undefined") {
                      cellProperties.checkedTemplate = true;
                    }
                    if (typeof cellProperties.uncheckedTemplate === "undefined") {
                      cellProperties.uncheckedTemplate = false;
                    }
                
                    Handsontable.Dom.empty(TD); //TODO identify under what circumstances this line can be removed
                
                    var INPUT = clonableINPUT.cloneNode(false); //this is faster than createElement
                
                    if (value === cellProperties.checkedTemplate || value === Handsontable.helper.stringify(cellProperties.checkedTemplate)) {
                      INPUT.checked = true;
                      TD.appendChild(INPUT);
                    }
                    else if (value === cellProperties.uncheckedTemplate || value === Handsontable.helper.stringify(cellProperties.uncheckedTemplate)) {
                      TD.appendChild(INPUT);
                    }
                    else if (value === null) { //default value
                      INPUT.className += ' noValue';
                      TD.appendChild(INPUT);
                    }
                    else {
                      Handsontable.Dom.fastInnerText(TD, '#bad value#'); //this is faster than innerHTML. See: https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
                    }
                
                    var $input = $(INPUT);
                
                    if (cellProperties.readOnly) {
                      $input.on('click', function (event) {
                        event.preventDefault();
                      });
                    }
                    else {
                      $input.on('mousedown', function (event) {
                        event.stopPropagation(); //otherwise can confuse cell mousedown handler
                      });
                
                      $input.on('mouseup', function (event) {
                        event.stopPropagation(); //otherwise can confuse cell dblclick handler
                      });
                
                      $input.on('change', function(){
                        if (this.checked) {
                          instance.setDataAtRowProp(row, prop, cellProperties.checkedTemplate);
                        }
                        else {
                          instance.setDataAtRowProp(row, prop, cellProperties.uncheckedTemplate);
                        }
                      });
                    }
                
                    if(!instance.CheckboxRenderer || !instance.CheckboxRenderer.beforeKeyDownHookBound){
                      instance.CheckboxRenderer = {
                        beforeKeyDownHookBound : true
                      };
                
                      instance.addHook('beforeKeyDown', function(event){
                        if(event.keyCode == Handsontable.helper.keyCode.SPACE){
                
                          var cell, checkbox, cellProperties;
                
                          var selRange = instance.getSelectedRange();
                          var topLeft = selRange.getTopLeftCorner();
                          var bottomRight = selRange.getBottomRightCorner();
                
                          for(var row = topLeft.row; row <= bottomRight.row; row++ ){
                            for(var col = topLeft.col; col <= bottomRight.col; col++){
                              cell = instance.getCell(row, col);
                              cellProperties = instance.getCellMeta(row, col);
                
                              checkbox = cell.querySelectorAll('input[type=checkbox]');
                
                              if(checkbox.length > 0 && !cellProperties.readOnly){
                
                                if(!event.isImmediatePropagationStopped()){
                                  event.stopImmediatePropagation();
                                  event.preventDefault();
                                }
                
                                for(var i = 0, len = checkbox.length; i < len; i++){
                                  checkbox[i].checked = !checkbox[i].checked;
                                  $(checkbox[i]).trigger('change');
                                }
                
                              }
                
                            }
                          }
                        }
                      });
                    }
                
                  };
                
                  Handsontable.CheckboxRenderer = CheckboxRenderer;
                  Handsontable.renderers.CheckboxRenderer = CheckboxRenderer;
                  Handsontable.renderers.registerRenderer('checkbox', CheckboxRenderer);
                
                })(Handsontable);
                /**
                 * Numeric cell renderer
                 * @param {Object} instance Handsontable instance
                 * @param {Element} TD Table cell where to render
                 * @param {Number} row
                 * @param {Number} col
                 * @param {String|Number} prop Row object property name
                 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
                 * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
                 */
                (function (Handsontable) {
                
                  
                
                  var NumericRenderer = function (instance, TD, row, col, prop, value, cellProperties) {
                    if (Handsontable.helper.isNumeric(value)) {
                      if (typeof cellProperties.language !== 'undefined') {
                        numeral.language(cellProperties.language)
                      }
                      value = numeral(value).format(cellProperties.format || '0'); //docs: http://numeraljs.com/
                      Handsontable.Dom.addClass(TD, 'htNumeric');
                    }
                    Handsontable.renderers.TextRenderer(instance, TD, row, col, prop, value, cellProperties);
                  };
                
                  Handsontable.NumericRenderer = NumericRenderer; //Left for backward compatibility with versions prior 0.10.0
                  Handsontable.renderers.NumericRenderer = NumericRenderer;
                  Handsontable.renderers.registerRenderer('numeric', NumericRenderer);
                
                })(Handsontable);
                (function(Handosntable){
                
                  
                
                  var PasswordRenderer = function (instance, TD, row, col, prop, value, cellProperties) {
                    Handsontable.renderers.TextRenderer.apply(this, arguments);
                
                    value = TD.innerHTML;
                
                    var hash;
                    var hashLength = cellProperties.hashLength || value.length;
                    var hashSymbol = cellProperties.hashSymbol || '*';
                
                    for( hash = ''; hash.split(hashSymbol).length - 1 < hashLength; hash += hashSymbol);
                
                    Handsontable.Dom.fastInnerHTML(TD, hash);
                
                  };
                
                  Handosntable.PasswordRenderer = PasswordRenderer;
                  Handosntable.renderers.PasswordRenderer = PasswordRenderer;
                  Handosntable.renderers.registerRenderer('password', PasswordRenderer);
                
                })(Handsontable);
                (function (Handsontable) {
                
                  function HtmlRenderer(instance, TD, row, col, prop, value, cellProperties){
                
                    Handsontable.renderers.cellDecorator.apply(this, arguments);
                
                    Handsontable.Dom.fastInnerHTML(TD, value);
                  }
                
                  Handsontable.renderers.registerRenderer('html', HtmlRenderer);
                  Handsontable.renderers.HtmlRenderer = HtmlRenderer;
                
                })(Handsontable);
                
                (function (Handsontable) {
                  
                
                  Handsontable.EditorState = {
                    VIRGIN: 'STATE_VIRGIN', //before editing
                    EDITING: 'STATE_EDITING',
                    WAITING: 'STATE_WAITING', //waiting for async validation
                    FINISHED: 'STATE_FINISHED'
                  };
                
                  function BaseEditor(instance) {
                    this.instance = instance;
                    this.state = Handsontable.EditorState.VIRGIN;
                
                    this._opened = false;
                    this._closeCallback = null;
                
                    this.init();
                  }
                
                  BaseEditor.prototype._fireCallbacks = function(result) {
                    if(this._closeCallback){
                      this._closeCallback(result);
                      this._closeCallback = null;
                    }
                
                  }
                
                  BaseEditor.prototype.init = function(){};
                
                  BaseEditor.prototype.getValue = function(){
                    throw Error('Editor getValue() method unimplemented');
                  };
                
                  BaseEditor.prototype.setValue = function(newValue){
                    throw Error('Editor setValue() method unimplemented');
                  };
                
                  BaseEditor.prototype.open = function(){
                    throw Error('Editor open() method unimplemented');
                  };
                
                  BaseEditor.prototype.close = function(){
                    throw Error('Editor close() method unimplemented');
                  };
                
                  BaseEditor.prototype.prepare = function(row, col, prop, td, originalValue, cellProperties){
                    this.TD = td;
                    this.row = row;
                    this.col = col;
                    this.prop = prop;
                    this.originalValue = originalValue;
                    this.cellProperties = cellProperties;
                
                    this.state = Handsontable.EditorState.VIRGIN;
                  };
                
                  BaseEditor.prototype.extend = function(){
                    var baseClass = this.constructor;
                    function Editor(){
                      baseClass.apply(this, arguments);
                    }
                
                    function inherit(Child, Parent){
                      function Bridge() {
                      }
                
                      Bridge.prototype = Parent.prototype;
                      Child.prototype = new Bridge();
                      Child.prototype.constructor = Child;
                      return Child;
                    }
                
                    return inherit(Editor, baseClass);
                  };
                
                  BaseEditor.prototype.saveValue = function (val, ctrlDown) {
                    if (ctrlDown) { //if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)
                      var sel = this.instance.getSelected();
                      this.instance.populateFromArray(sel[0], sel[1], val, sel[2], sel[3], 'edit');
                    }
                    else {
                      this.instance.populateFromArray(this.row, this.col, val, null, null, 'edit');
                    }
                  };
                
                  BaseEditor.prototype.beginEditing = function(initialValue){
                    if (this.state != Handsontable.EditorState.VIRGIN) {
                      return;
                    }
                
                    this.instance.view.scrollViewport(new WalkontableCellCoords(this.row, this.col));
                    this.instance.view.render();
                
                    this.state = Handsontable.EditorState.EDITING;
                
                    initialValue = typeof initialValue == 'string' ? initialValue : this.originalValue;
                
                    this.setValue(Handsontable.helper.stringify(initialValue));
                
                    this.open();
                    this._opened = true;
                    this.focus();
                
                    this.instance.view.render(); //only rerender the selections (FillHandle should disappear when beginediting is triggered)
                  };
                
                  BaseEditor.prototype.finishEditing = function (restoreOriginalValue, ctrlDown, callback) {
                
                    if (callback) {
                      var previousCloseCallback = this._closeCallback;
                      this._closeCallback = function (result) {
                        if(previousCloseCallback){
                          previousCloseCallback(result);
                        }
                
                        callback(result);
                      };
                    }
                
                    if (this.isWaiting()) {
                      return;
                    }
                
                    if (this.state == Handsontable.EditorState.VIRGIN) {
                      var that = this;
                      this.instance._registerTimeout(setTimeout(function () {
                        that._fireCallbacks(true);
                      }, 0));
                      return;
                    }
                
                    if (this.state == Handsontable.EditorState.EDITING) {
                
                      if (restoreOriginalValue) {
                
                        this.cancelChanges();
                        return;
                
                      }
                
                
                      var val = [
                        [String.prototype.trim.call(this.getValue())] //String.prototype.trim is defined in Walkontable polyfill.js
                      ];
                
                      this.state = Handsontable.EditorState.WAITING;
                
                      this.saveValue(val, ctrlDown);
                
                      if(this.instance.getCellValidator(this.cellProperties)){
                        var that = this;
                        this.instance.addHookOnce('afterValidate', function (result) {
                          that.state = Handsontable.EditorState.FINISHED;
                          that.discardEditor(result);
                        });
                      } else {
                        this.state = Handsontable.EditorState.FINISHED;
                        this.discardEditor(true);
                      }
                
                    }
                  };
                
                  BaseEditor.prototype.cancelChanges = function () {
                    this.state = Handsontable.EditorState.FINISHED;
                    this.discardEditor();
                  };
                
                  BaseEditor.prototype.discardEditor = function (result) {
                    if (this.state !== Handsontable.EditorState.FINISHED) {
                      return;
                    }
                
                    if (result === false && this.cellProperties.allowInvalid !== true) { //validator was defined and failed
                
                      this.instance.selectCell(this.row, this.col);
                      this.focus();
                
                      this.state = Handsontable.EditorState.EDITING;
                
                      this._fireCallbacks(false);
                    }
                    else {
                      this.close();
                      this._opened = false;
                
                      this.state = Handsontable.EditorState.VIRGIN;
                
                      this._fireCallbacks(true);
                    }
                
                  };
                
                  BaseEditor.prototype.isOpened = function(){
                    return this._opened;
                  };
                
                  BaseEditor.prototype.isWaiting = function () {
                    return this.state === Handsontable.EditorState.WAITING;
                  };
                
                  Handsontable.editors.BaseEditor = BaseEditor;
                
                })(Handsontable);
                
                (function(Handsontable){
                  var TextEditor = Handsontable.editors.BaseEditor.prototype.extend();
                
                  TextEditor.prototype.init = function(){
                    this.createElements();
                    this.bindEvents();
                    this.autoResize = autoResize();
                  };
                
                  TextEditor.prototype.getValue = function(){
                    return this.TEXTAREA.value
                  };
                
                  TextEditor.prototype.setValue = function(newValue){
                    this.TEXTAREA.value = newValue;
                  };
                
                  var onBeforeKeyDown =  function onBeforeKeyDown(event){
                
                    var instance = this;
                    var that = instance.getActiveEditor();
                
                    var keyCodes = Handsontable.helper.keyCode;
                    var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
                
                
                    //Process only events that have been fired in the editor
                    if (event.target !== that.TEXTAREA || event.isImmediatePropagationStopped()){
                      return;
                    }
                
                    if (event.keyCode === 17 || event.keyCode === 224 || event.keyCode === 91 || event.keyCode === 93) {
                      //when CTRL or its equivalent is pressed and cell is edited, don't prepare selectable text in textarea
                      event.stopImmediatePropagation();
                      return;
                    }
                
                    switch (event.keyCode) {
                      case keyCodes.ARROW_RIGHT:
                        if (Handsontable.Dom.getCaretPosition(that.TEXTAREA) !== that.TEXTAREA.value.length) {
                          event.stopImmediatePropagation();
                        }
                        break;
                
                      case keyCodes.ARROW_LEFT: /* arrow left */
                        if (Handsontable.Dom.getCaretPosition(that.TEXTAREA) !== 0) {
                          event.stopImmediatePropagation();
                        }
                        break;
                
                      case keyCodes.ENTER:
                        var selected = that.instance.getSelected();
                        var isMultipleSelection = !(selected[0] === selected[2] && selected[1] === selected[3]);
                        if ((ctrlDown && !isMultipleSelection) || event.altKey) { //if ctrl+enter or alt+enter, add new line
                          if(that.isOpened()){
                            that.setValue(that.getValue() + '\n');
                            that.focus();
                          } else {
                            that.beginEditing(that.originalValue + '\n')
                          }
                          event.stopImmediatePropagation();
                        }
                        event.preventDefault(); //don't add newline to field
                        break;
                
                      case keyCodes.A:
                      case keyCodes.X:
                      case keyCodes.C:
                      case keyCodes.V:
                        if(ctrlDown){
                          event.stopImmediatePropagation(); //CTRL+A, CTRL+C, CTRL+V, CTRL+X should only work locally when cell is edited (not in table context)
                          break;
                        }
                      case keyCodes.BACKSPACE:
                      case keyCodes.DELETE:
                      case keyCodes.HOME:
                      case keyCodes.END:
                        event.stopImmediatePropagation(); //backspace, delete, home, end should only work locally when cell is edited (not in table context)
                        break;
                    }
                
                  };
                
                  TextEditor.prototype.open = function(){
                    this.refreshDimensions(); //need it instantly, to prevent https://github.com/handsontable/jquery-handsontable/issues/348
                
                    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
                  };
                
                  TextEditor.prototype.close = function(){
                    this.textareaParentStyle.display = 'none';
                
                    this.autoResize.unObserve();
                
                    if (document.activeElement === this.TEXTAREA) {
                      this.instance.listen(); //don't refocus the table if user focused some cell outside of HT on purpose
                    }
                
                    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
                  };
                
                  TextEditor.prototype.focus = function(){
                    this.TEXTAREA.focus();
                    Handsontable.Dom.setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
                  };
                
                  TextEditor.prototype.createElements = function () {
                    this.$body = $(document.body);
                
                    this.TEXTAREA = document.createElement('TEXTAREA');
                    this.$textarea = $(this.TEXTAREA);
                
                    Handsontable.Dom.addClass(this.TEXTAREA, 'handsontableInput');
                
                    this.textareaStyle = this.TEXTAREA.style;
                    this.textareaStyle.width = 0;
                    this.textareaStyle.height = 0;
                
                    this.TEXTAREA_PARENT = document.createElement('DIV');
                    Handsontable.Dom.addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');
                
                    this.textareaParentStyle = this.TEXTAREA_PARENT.style;
                    this.textareaParentStyle.top = 0;
                    this.textareaParentStyle.left = 0;
                    this.textareaParentStyle.display = 'none';
                
                    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
                
                    this.instance.rootElement[0].appendChild(this.TEXTAREA_PARENT);
                
                    var that = this;
                    this.instance._registerTimeout(setTimeout(function () {
                      that.refreshDimensions();
                    }, 0));
                  };
                
                  TextEditor.prototype.checkEditorSection = function () {
                    if(this.row < this.instance.getSettings().fixedRowsTop) {
                      if(this.col < this.instance.getSettings().fixedColumnsLeft) {
                        return 'corner';
                      } else {
                        return 'top';
                      }
                    } else {
                      if(this.col < this.instance.getSettings().fixedColumnsLeft) {
                        return 'left';
                      }
                    }
                  };
                
                  TextEditor.prototype.getEditedCell = function () {
                    var editorSection = this.checkEditorSection()
                      , editedCell;
                
                    switch (editorSection) {
                      case 'top':
                        editedCell = this.instance.view.wt.wtScrollbars.vertical.clone.wtTable.getCell({row: this.row, col: this.col});
                        this.textareaParentStyle.zIndex = 101;
                        break;
                      case 'corner':
                        editedCell = this.instance.view.wt.wtScrollbars.corner.clone.wtTable.getCell({row: this.row, col: this.col});
                        this.textareaParentStyle.zIndex = 103;
                        break;
                      case 'left':
                        editedCell = this.instance.view.wt.wtScrollbars.horizontal.clone.wtTable.getCell({row: this.row, col: this.col});
                        this.textareaParentStyle.zIndex = 102;
                        break;
                      default :
                        editedCell = this.instance.getCell(this.row, this.col);
                        this.textareaParentStyle.zIndex = "";
                        break;
                    }
                
                    return editedCell != -1 && editedCell != -2 ? editedCell : void 0;
                  };
                
                
                  TextEditor.prototype.refreshDimensions = function () {
                    if (this.state !== Handsontable.EditorState.EDITING) {
                      return;
                    }
                
                    ///start prepare textarea position
                //    this.TD = this.instance.getCell(this.row, this.col);
                    this.TD = this.getEditedCell();
                
                    if (!this.TD) {
                      //TD is outside of the viewport. Otherwise throws exception when scrolling the table while a cell is edited
                      return;
                    }
                    var $td = $(this.TD); //because old td may have been scrolled out with scrollViewport
                    var currentOffset = Handsontable.Dom.offset(this.TD);
                    var containerOffset = Handsontable.Dom.offset(this.instance.rootElement[0]);
                    var editTop = currentOffset.top - containerOffset.top - 1;
                    var editLeft = currentOffset.left - containerOffset.left - 1;
                
                    var settings = this.instance.getSettings();
                    var rowHeadersCount = settings.rowHeaders === false ? 0 : 1;
                    var colHeadersCount = settings.colHeaders === false ? 0 : 1;
                    var editorSection = this.checkEditorSection();
                
                
                    if (editTop < 0) {
                      editTop = 0;
                    }
                    if (editLeft < 0) {
                      editLeft = 0;
                    }
                
                    if (rowHeadersCount > 0 && parseInt($td.css('border-top-width'), 10) > 0) {
                      editTop += 1;
                    }
                    if (colHeadersCount > 0 && parseInt($td.css('border-left-width'), 10) > 0) {
                      editLeft += 1;
                    }
                
                    this.textareaParentStyle.top = editTop + 'px';
                    this.textareaParentStyle.left = editLeft + 'px';
                
                    ///end prepare textarea position
                
                
                    var cellTopOffset = this.TD.offsetTop,
                      cellLeftOffset = this.TD.offsetLeft - this.instance.view.wt.wtScrollbars.horizontal.getScrollPosition();
                
                    var width = $td.width()
                      , maxWidth = this.instance.view.maximumVisibleElementWidth(cellLeftOffset) - 10 //10 is TEXTAREAs border and padding
                      , height = $td.outerHeight() - 4
                      , maxHeight = this.instance.view.maximumVisibleElementHeight(cellTopOffset)-2; //10 is TEXTAREAs border and padding
                
                    if (parseInt($td.css('border-top-width'), 10) > 0) {
                      height -= 1;
                    }
                    if (parseInt($td.css('border-left-width'), 10) > 0) {
                      if (rowHeadersCount > 0) {
                        width -= 1;
                      }
                    }
                
                    this.autoResize.init(this.$textarea[0], {
                      fontSize: parseInt( window.getComputedStyle($td[0]).fontSize,10),
                      minHeight: Math.min(height, maxHeight),
                      maxHeight: maxHeight, //TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
                      minWidth: Math.min(width, maxWidth),
                      maxWidth: maxWidth //TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
                    });
                
                    this.textareaParentStyle.display = 'block';
                  };
                
                  TextEditor.prototype.bindEvents = function () {
                    var editor = this;
                
                    this.$textarea.on('cut.editor', function (event) {
                      event.stopPropagation();
                    });
                
                    this.$textarea.on('paste.editor', function (event) {
                      event.stopPropagation();
                    });
                
                    this.instance.addHook('afterScrollVertically', function () {
                      editor.refreshDimensions();
                    });
                  };
                
                
                  Handsontable.editors.TextEditor = TextEditor;
                  Handsontable.editors.registerEditor('text', Handsontable.editors.TextEditor);
                
                })(Handsontable);
                
                (function(Handsontable){
                
                  //Blank editor, because all the work is done by renderer
                  var CheckboxEditor = Handsontable.editors.BaseEditor.prototype.extend();
                
                  CheckboxEditor.prototype.beginEditing = function () {
                    var checkbox = this.TD.querySelector('input[type="checkbox"]');
                
                    if (checkbox) {
                      $(checkbox).trigger('click');
                    }
                
                  };
                
                  CheckboxEditor.prototype.finishEditing = function () {};
                
                  CheckboxEditor.prototype.init = function () {};
                  CheckboxEditor.prototype.open = function () {};
                  CheckboxEditor.prototype.close = function () {};
                  CheckboxEditor.prototype.getValue = function () {};
                  CheckboxEditor.prototype.setValue = function () {};
                  CheckboxEditor.prototype.focus = function () {};
                
                  Handsontable.editors.CheckboxEditor = CheckboxEditor;
                  Handsontable.editors.registerEditor('checkbox', CheckboxEditor);
                
                })(Handsontable);
                
                
                (function (Handsontable) {
                  var DateEditor = Handsontable.editors.TextEditor.prototype.extend();
                
                  DateEditor.prototype.init = function () {
                    if (!$.datepicker) {
                      throw new Error("jQuery UI Datepicker dependency not found. Did you forget to include jquery-ui.custom.js or its substitute?");
                    }
                
                    Handsontable.editors.TextEditor.prototype.init.apply(this, arguments);
                
                    this.isCellEdited = false;
                    var that = this;
                
                    this.instance.addHook('afterDestroy', function () {
                      that.destroyElements();
                    })
                
                  };
                
                  DateEditor.prototype.createElements = function () {
                    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);
                
                    this.datePicker = document.createElement('DIV');
                    Handsontable.Dom.addClass(this.datePicker, 'htDatepickerHolder');
                    this.datePickerStyle = this.datePicker.style;
                    this.datePickerStyle.position = 'absolute';
                    this.datePickerStyle.top = 0;
                    this.datePickerStyle.left = 0;
                    this.datePickerStyle.zIndex = 99;
                    document.body.appendChild(this.datePicker);
                    this.$datePicker = $(this.datePicker);
                
                    var that = this;
                    var defaultOptions = {
                      dateFormat: "yy-mm-dd",
                      showButtonPanel: true,
                      changeMonth: true,
                      changeYear: true,
                      onSelect: function (dateStr) {
                        that.setValue(dateStr);
                        that.finishEditing(false);
                      }
                    };
                    this.$datePicker.datepicker(defaultOptions);
                
                    /**
                     * Prevent recognizing clicking on jQuery Datepicker as clicking outside of table
                     */
                    this.$datePicker.on('mousedown', function (event) {
                      event.stopPropagation();
                    });
                
                    this.hideDatepicker();
                  };
                
                  DateEditor.prototype.destroyElements = function () {
                    this.$datePicker.datepicker('destroy');
                    this.$datePicker.remove();
                  };
                
                  DateEditor.prototype.open = function () {
                    Handsontable.editors.TextEditor.prototype.open.call(this);
                    this.showDatepicker();
                  };
                
                  DateEditor.prototype.finishEditing = function (isCancelled, ctrlDown) {
                    this.hideDatepicker();
                    Handsontable.editors.TextEditor.prototype.finishEditing.apply(this, arguments);
                  };
                
                  DateEditor.prototype.showDatepicker = function () {
                    var $td = $(this.TD);
                    var offset = $td.offset();
                    this.datePickerStyle.top = (offset.top + $td.height()) + 'px';
                    this.datePickerStyle.left = offset.left + 'px';
                
                    var dateOptions = {
                      defaultDate: this.originalValue || void 0
                    };
                    $.extend(dateOptions, this.cellProperties);
                    this.$datePicker.datepicker("option", dateOptions);
                    if (this.originalValue) {
                      this.$datePicker.datepicker("setDate", this.originalValue);
                    }
                    this.datePickerStyle.display = 'block';
                  };
                
                  DateEditor.prototype.hideDatepicker = function () {
                    this.datePickerStyle.display = 'none';
                  };
                
                
                  Handsontable.editors.DateEditor = DateEditor;
                  Handsontable.editors.registerEditor('date', DateEditor);
                })(Handsontable);
                /**
                 * This is inception. Using Handsontable as Handsontable editor
                 */
                (function (Handsontable) {
                  
                
                  var HandsontableEditor = Handsontable.editors.TextEditor.prototype.extend();
                
                  HandsontableEditor.prototype.createElements = function () {
                    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);
                
                    var DIV = document.createElement('DIV');
                    DIV.className = 'handsontableEditor';
                    this.TEXTAREA_PARENT.appendChild(DIV);
                
                    this.$htContainer = $(DIV);
                    this.$htContainer.handsontable();
                  };
                
                  HandsontableEditor.prototype.prepare = function (td, row, col, prop, value, cellProperties) {
                
                    Handsontable.editors.TextEditor.prototype.prepare.apply(this, arguments);
                
                    var parent = this;
                
                    var options = {
                      startRows: 0,
                      startCols: 0,
                      minRows: 0,
                      minCols: 0,
                      className: 'listbox',
                      copyPaste: false,
                      cells: function () {
                        return {
                          readOnly: true
                        }
                      },
                      fillHandle: false,
                      afterOnCellMouseDown: function () {
                        var value = this.getValue();
                        if (value !== void 0) { //if the value is undefined then it means we don't want to set the value
                          parent.setValue(value);
                        }
                        parent.instance.destroyEditor();
                      }
                    };
                
                    if (this.cellProperties.handsontable) {
                      options = $.extend(options, cellProperties.handsontable);
                    }
                    this.$htContainer.handsontable('destroy');
                    this.$htContainer.handsontable(options);
                  };
                
                  var onBeforeKeyDown = function (event) {
                
                    if (event.isImmediatePropagationStopped()) {
                      return;
                    }
                
                    var editor = this.getActiveEditor();
                    var innerHOT = editor.$htContainer.handsontable('getInstance');
                    var rowToSelect;
                
                    if (event.keyCode == Handsontable.helper.keyCode.ARROW_DOWN) {
                      if (!innerHOT.getSelected()) {
                        rowToSelect = 0;
                      }
                      else {
                        var selectedRow = innerHOT.getSelected()[0];
                        var lastRow = innerHOT.countRows() - 1;
                        rowToSelect = Math.min(lastRow, selectedRow + 1);
                      }
                    }
                    else if (event.keyCode == Handsontable.helper.keyCode.ARROW_UP) {
                      if (innerHOT.getSelected()) {
                        var selectedRow = innerHOT.getSelected()[0];
                        rowToSelect = selectedRow - 1;
                      }
                    }
                
                    if (rowToSelect !== void 0) {
                      if (rowToSelect < 0) {
                        innerHOT.deselectCell();
                      }
                      else {
                        innerHOT.selectCell(rowToSelect, 0);
                      }
                
                      event.preventDefault();
                      event.stopImmediatePropagation();
                
                      editor.instance.listen();
                      editor.TEXTAREA.focus();
                    }
                  };
                
                  HandsontableEditor.prototype.open = function () {
                
                    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
                
                    Handsontable.editors.TextEditor.prototype.open.apply(this, arguments);
                
                    this.$htContainer.handsontable('render');
                
                    if (this.cellProperties.strict) {
                      this.$htContainer.handsontable('selectCell', 0, 0);
                      this.$textarea[0].style.visibility = 'hidden';
                    } else {
                      this.$htContainer.handsontable('deselectCell');
                      this.$textarea[0].style.visibility = 'visible';
                    }
                
                    Handsontable.Dom.setCaretPosition(this.$textarea[0], 0, this.$textarea[0].value.length);
                
                  };
                
                  HandsontableEditor.prototype.close = function () {
                
                    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
                    this.instance.listen();
                
                    Handsontable.editors.TextEditor.prototype.close.apply(this, arguments);
                  };
                
                  HandsontableEditor.prototype.focus = function () {
                
                    this.instance.listen();
                
                    Handsontable.editors.TextEditor.prototype.focus.apply(this, arguments);
                  };
                
                  HandsontableEditor.prototype.beginEditing = function (initialValue) {
                    var onBeginEditing = this.instance.getSettings().onBeginEditing;
                    if (onBeginEditing && onBeginEditing() === false) {
                      return;
                    }
                
                    Handsontable.editors.TextEditor.prototype.beginEditing.apply(this, arguments);
                
                  };
                
                  HandsontableEditor.prototype.finishEditing = function (isCancelled, ctrlDown) {
                    if (this.$htContainer.handsontable('isListening')) { //if focus is still in the HOT editor
                      this.instance.listen(); //return the focus to the parent HOT instance
                    }
                
                    if (this.$htContainer.handsontable('getSelected')) {
                      var value = this.$htContainer.handsontable('getInstance').getValue();
                      if (value !== void 0) { //if the value is undefined then it means we don't want to set the value
                        this.setValue(value);
                      }
                    }
                
                    return Handsontable.editors.TextEditor.prototype.finishEditing.apply(this, arguments);
                  };
                
                  Handsontable.editors.HandsontableEditor = HandsontableEditor;
                  Handsontable.editors.registerEditor('handsontable', HandsontableEditor);
                
                })(Handsontable);
                
                
                
                
                
                
                (function (Handsontable) {
                  var AutocompleteEditor = Handsontable.editors.HandsontableEditor.prototype.extend();
                
                  AutocompleteEditor.prototype.init = function () {
                    Handsontable.editors.HandsontableEditor.prototype.init.apply(this, arguments);
                
                    this.query = null;
                    this.choices = [];
                  };
                
                  AutocompleteEditor.prototype.createElements = function(){
                    Handsontable.editors.HandsontableEditor.prototype.createElements.apply(this, arguments);
                
                    var getSystemSpecificPaddingClass = function () {
                      if(window.navigator.platform.indexOf('Mac') != -1) {
                        return "htMacScroll";
                      } else {
                        return "";
                      }
                    };
                
                    this.$htContainer.addClass('autocompleteEditor');
                    this.$htContainer.addClass(getSystemSpecificPaddingClass());
                
                  };
                
                  AutocompleteEditor.prototype.bindEvents = function () {
                    var that = this;
                    this.$textarea.on('keydown.autocompleteEditor', function (event) {
                      var keyCodes = Handsontable.helper.keyCode;
                      if (event.keyCode !== keyCodes.ARROW_DOWN && event.keyCode !== keyCodes.ARROW_UP) {
                        that.instance._registerTimeout(setTimeout(function () {
                          that.queryChoices(that.TEXTAREA.value);
                        }, 0));
                      }
                    });
                  };
                
                  AutocompleteEditor.prototype.open = function () {
                
                    Handsontable.editors.HandsontableEditor.prototype.open.apply(this, arguments);
                
                    this.$textarea[0].style.visibility = 'visible';
                    this.focus();
                
                    var choicesListHot = this.$htContainer.handsontable('getInstance');
                    var that = this;
                
                    choicesListHot.updateSettings({
                      'colWidths': [Handsontable.Dom.outerWidth(this.TEXTAREA) - 2],
                      afterRenderer: function (TD, row, col, prop, value) {
                        var caseSensitive = this.getCellMeta(row, col).filteringCaseSensitive === true;
                        var indexOfMatch =  caseSensitive ? value.indexOf(this.query) : value.toLowerCase().indexOf(that.query.toLowerCase());
                
                        if(indexOfMatch != -1){
                          var match = value.substr(indexOfMatch, that.query.length);
                          TD.innerHTML = value.replace(match, '<strong>' + match + '</strong>');
                        }
                      }
                    });
                
                    this.queryChoices(this.TEXTAREA.value);
                
                  };
                
                  AutocompleteEditor.prototype.close = function () {
                    Handsontable.editors.HandsontableEditor.prototype.close.apply(this, arguments);
                  };
                
                  AutocompleteEditor.prototype.queryChoices = function(query){
                    this.query = query;
                
                    if (typeof this.cellProperties.source == 'function'){
                      var that = this;
                
                      this.cellProperties.source(query, function(choices){
                        that.updateChoicesList(choices);
                      });
                
                    } else if (Handsontable.helper.isArray(this.cellProperties.source)) {
                
                      var choices;
                
                      if(!query || this.cellProperties.filter === false){
                        choices = this.cellProperties.source;
                      } else {
                
                        var filteringCaseSensitive = this.cellProperties.filteringCaseSensitive === true;
                        var lowerCaseQuery = query.toLowerCase();
                
                        choices = this.cellProperties.source.filter(function(choice){
                
                          if (filteringCaseSensitive) {
                            return choice.indexOf(query) != -1;
                          } else {
                            return choice.toLowerCase().indexOf(lowerCaseQuery) != -1;
                          }
                
                        });
                      }
                
                      this.updateChoicesList(choices);
                
                    } else {
                      this.updateChoicesList([]);
                    }
                
                  };
                
                  AutocompleteEditor.prototype.updateChoicesList = function (choices) {
                    var pos = Handsontable.Dom.getCaretPosition(this.TEXTAREA),
                        endPos = Handsontable.Dom.getSelectionEndPosition(this.TEXTAREA);
                
                    this.choices = choices;
                
                    this.$htContainer.handsontable('loadData', Handsontable.helper.pivot([choices]));
                    this.$htContainer.handsontable('updateSettings', {height: this.getDropdownHeight()});
                
                    if(this.cellProperties.strict === true) {
                      this.highlightBestMatchingChoice();
                    }
                
                    this.instance.listen();
                    this.TEXTAREA.focus();
                    Handsontable.Dom.setCaretPosition(this.TEXTAREA, pos, (pos != endPos ? endPos : void 0));
                  };
                
                  AutocompleteEditor.prototype.highlightBestMatchingChoice = function () {
                    var bestMatchingChoice = this.findBestMatchingChoice();
                
                    if ( typeof bestMatchingChoice == 'undefined' && this.cellProperties.allowInvalid === false){
                      bestMatchingChoice = 0;
                    }
                
                    if(typeof bestMatchingChoice == 'undefined'){
                      this.$htContainer.handsontable('deselectCell');
                    } else {
                      this.$htContainer.handsontable('selectCell', bestMatchingChoice, 0);
                    }
                  };
                
                  AutocompleteEditor.prototype.findBestMatchingChoice = function(){
                    var bestMatch = {};
                    var valueLength = this.getValue().length;
                    var currentItem;
                    var indexOfValue;
                    var charsLeft;
                
                
                    for(var i = 0, len = this.choices.length; i < len; i++){
                      currentItem = this.choices[i];
                
                      if(valueLength > 0){
                        indexOfValue = currentItem.indexOf(this.getValue())
                      } else {
                        indexOfValue = currentItem === this.getValue() ? 0 : -1;
                      }
                
                      if(indexOfValue == -1) continue;
                
                      charsLeft =  currentItem.length - indexOfValue - valueLength;
                
                      if( typeof bestMatch.indexOfValue == 'undefined'
                        || bestMatch.indexOfValue > indexOfValue
                        || ( bestMatch.indexOfValue == indexOfValue && bestMatch.charsLeft > charsLeft ) ){
                
                        bestMatch.indexOfValue = indexOfValue;
                        bestMatch.charsLeft = charsLeft;
                        bestMatch.index = i;
                
                      }
                
                    }
                
                
                    return bestMatch.index;
                  };
                
                  AutocompleteEditor.prototype.getDropdownHeight = function(){
                    var firstRowHeight = this.$htContainer.handsontable('getInstance').getRowHeight(0) || 23;
                    return this.choices.length >= 10 ? 10 * firstRowHeight : this.choices.length * firstRowHeight + 8;
                    //return 10 * this.$htContainer.handsontable('getInstance').getRowHeight(0);
                    //sorry, we can't measure row height before it was rendered. Let's use fixed height for now
                    return 230;
                  };
                
                
                  Handsontable.editors.AutocompleteEditor = AutocompleteEditor;
                  Handsontable.editors.registerEditor('autocomplete', AutocompleteEditor);
                
                })(Handsontable);
                
                (function(Handsontable){
                
                  var PasswordEditor = Handsontable.editors.TextEditor.prototype.extend();
                
                  PasswordEditor.prototype.createElements = function () {
                    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);
                
                    this.TEXTAREA = document.createElement('input');
                    this.TEXTAREA.setAttribute('type', 'password');
                    this.TEXTAREA.className = 'handsontableInput';
                    this.textareaStyle = this.TEXTAREA.style;
                    this.textareaStyle.width = 0;
                    this.textareaStyle.height = 0;
                    this.$textarea = $(this.TEXTAREA);
                
                    Handsontable.Dom.empty(this.TEXTAREA_PARENT);
                    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
                
                  };
                
                  Handsontable.editors.PasswordEditor = PasswordEditor;
                  Handsontable.editors.registerEditor('password', PasswordEditor);
                
                })(Handsontable);
                
                (function (Handsontable) {
                
                  var SelectEditor = Handsontable.editors.BaseEditor.prototype.extend();
                
                  SelectEditor.prototype.init = function(){
                    this.select = document.createElement('SELECT');
                    Handsontable.Dom.addClass(this.select, 'htSelectEditor');
                    this.select.style.display = 'none';
                    this.instance.rootElement[0].appendChild(this.select);
                  };
                
                  SelectEditor.prototype.prepare = function(){
                    Handsontable.editors.BaseEditor.prototype.prepare.apply(this, arguments);
                
                
                    var selectOptions = this.cellProperties.selectOptions;
                    var options;
                
                    if (typeof selectOptions == 'function'){
                      options =  this.prepareOptions(selectOptions(this.row, this.col, this.prop))
                    } else {
                      options =  this.prepareOptions(selectOptions);
                    }
                
                    Handsontable.Dom.empty(this.select);
                
                    for (var option in options){
                      if (options.hasOwnProperty(option)){
                        var optionElement = document.createElement('OPTION');
                        optionElement.value = option;
                        Handsontable.Dom.fastInnerHTML(optionElement, options[option]);
                        this.select.appendChild(optionElement);
                      }
                    }
                  };
                
                  SelectEditor.prototype.prepareOptions = function(optionsToPrepare){
                
                    var preparedOptions = {};
                
                    if (Handsontable.helper.isArray(optionsToPrepare)){
                      for(var i = 0, len = optionsToPrepare.length; i < len; i++){
                        preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
                      }
                    }
                    else if (typeof optionsToPrepare == 'object') {
                      preparedOptions = optionsToPrepare;
                    }
                
                    return preparedOptions;
                
                  };
                
                  SelectEditor.prototype.getValue = function () {
                    return this.select.value;
                  };
                
                  SelectEditor.prototype.setValue = function (value) {
                    this.select.value = value;
                  };
                
                  var onBeforeKeyDown = function (event) {
                    var instance = this;
                    var editor = instance.getActiveEditor();
                
                    switch (event.keyCode){
                      case Handsontable.helper.keyCode.ARROW_UP:
                
                        var previousOption = editor.select.find('option:selected').prev();
                
                        if (previousOption.length == 1){
                          previousOption.prop('selected', true);
                        }
                
                        event.stopImmediatePropagation();
                        event.preventDefault();
                        break;
                
                      case Handsontable.helper.keyCode.ARROW_DOWN:
                
                        var nextOption = editor.select.find('option:selected').next();
                
                        if (nextOption.length == 1){
                          nextOption.prop('selected', true);
                        }
                
                        event.stopImmediatePropagation();
                        event.preventDefault();
                        break;
                    }
                  };
                
                  SelectEditor.prototype.open = function () {
                    var width = Handsontable.Dom.outerWidth(this.TD); //important - group layout reads together for better performance
                    var height = Handsontable.Dom.outerHeight(this.TD);
                    var rootOffset = Handsontable.Dom.offset(this.instance.rootElement[0]);
                    var tdOffset = Handsontable.Dom.offset(this.TD);
                
                    this.select.style.height = height + 'px';
                    this.select.style.minWidth = width + 'px';
                    this.select.style.top = tdOffset.top - rootOffset.top + 'px';
                    this.select.style.left = tdOffset.left - rootOffset.left + 'px';
                    this.select.style.margin = '0px';
                    this.select.style.display = '';
                
                    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
                  };
                
                  SelectEditor.prototype.close = function () {
                    this.select.style.display = 'none';
                    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
                  };
                
                  SelectEditor.prototype.focus = function () {
                    this.select.focus();
                  };
                
                  Handsontable.editors.SelectEditor = SelectEditor;
                  Handsontable.editors.registerEditor('select', SelectEditor);
                
                })(Handsontable);
                
                (function (Handsontable) {
                
                  var DropdownEditor = Handsontable.editors.AutocompleteEditor.prototype.extend();
                
                  DropdownEditor.prototype.prepare = function () {
                    Handsontable.editors.AutocompleteEditor.prototype.prepare.apply(this, arguments);
                
                    this.cellProperties.filter = false;
                    this.cellProperties.strict = true;
                
                  };
                
                
                  Handsontable.editors.DropdownEditor = DropdownEditor;
                  Handsontable.editors.registerEditor('dropdown', DropdownEditor);
                
                
                })(Handsontable);
                /**
                 * Numeric cell validator
                 * @param {*} value - Value of edited cell
                 * @param {*} callback - Callback called with validation result
                 */
                Handsontable.NumericValidator = function (value, callback) {
                  if (value === null) {
                    value = '';
                  }
                  callback(/^-?\d*(\.|\,)?\d*$/.test(value));
                };
                /**
                 * Function responsible for validation of autocomplete value
                 * @param {*} value - Value of edited cell
                 * @param {*} calback - Callback called with validation result
                 */
                var process = function (value, callback) {
                
                  var originalVal  = value;
                  var lowercaseVal = typeof originalVal === 'string' ? originalVal.toLowerCase() : null;
                
                  return function (source) {
                    var found = false;
                    for (var s = 0, slen = source.length; s < slen; s++) {
                      if (originalVal === source[s]) {
                        found = true; //perfect match
                        break;
                      }
                      else if (lowercaseVal === source[s].toLowerCase()) {
                        // changes[i][3] = source[s]; //good match, fix the case << TODO?
                        found = true;
                        break;
                      }
                    }
                
                    callback(found);
                  }
                };
                
                /**
                 * Autocomplete cell validator
                 * @param {*} value - Value of edited cell
                 * @param {*} calback - Callback called with validation result
                 */
                Handsontable.AutocompleteValidator = function (value, callback) {
                  if (this.strict && this.source) {
                    typeof this.source === 'function' ? this.source(value, process(value, callback)) : process(value, callback)(this.source);
                  } else {
                    callback(true);
                  }
                };
                
                /**
                 * Cell type is just a shortcut for setting bunch of cellProperties (used in getCellMeta)
                 */
                
                Handsontable.AutocompleteCell = {
                  editor: Handsontable.editors.AutocompleteEditor,
                  renderer: Handsontable.renderers.AutocompleteRenderer,
                  validator: Handsontable.AutocompleteValidator
                };
                
                Handsontable.CheckboxCell = {
                  editor: Handsontable.editors.CheckboxEditor,
                  renderer: Handsontable.renderers.CheckboxRenderer
                };
                
                Handsontable.TextCell = {
                  editor: Handsontable.editors.TextEditor,
                  renderer: Handsontable.renderers.TextRenderer
                };
                
                Handsontable.NumericCell = {
                  editor: Handsontable.editors.TextEditor,
                  renderer: Handsontable.renderers.NumericRenderer,
                  validator: Handsontable.NumericValidator,
                  dataType: 'number'
                };
                
                Handsontable.DateCell = {
                  editor: Handsontable.editors.DateEditor,
                  renderer: Handsontable.renderers.AutocompleteRenderer //displays small gray arrow on right side of the cell
                };
                
                Handsontable.HandsontableCell = {
                  editor: Handsontable.editors.HandsontableEditor,
                  renderer: Handsontable.renderers.AutocompleteRenderer //displays small gray arrow on right side of the cell
                };
                
                Handsontable.PasswordCell = {
                  editor: Handsontable.editors.PasswordEditor,
                  renderer: Handsontable.renderers.PasswordRenderer,
                  copyable: false
                };
                
                Handsontable.DropdownCell = {
                  editor: Handsontable.editors.DropdownEditor,
                  renderer: Handsontable.renderers.AutocompleteRenderer, //displays small gray arrow on right side of the cell
                  validator: Handsontable.AutocompleteValidator
                };
                
                //here setup the friendly aliases that are used by cellProperties.type
                Handsontable.cellTypes = {
                  text: Handsontable.TextCell,
                  date: Handsontable.DateCell,
                  numeric: Handsontable.NumericCell,
                  checkbox: Handsontable.CheckboxCell,
                  autocomplete: Handsontable.AutocompleteCell,
                  handsontable: Handsontable.HandsontableCell,
                  password: Handsontable.PasswordCell,
                  dropdown: Handsontable.DropdownCell
                };
                
                //here setup the friendly aliases that are used by cellProperties.renderer and cellProperties.editor
                Handsontable.cellLookup = {
                  validator: {
                    numeric: Handsontable.NumericValidator,
                    autocomplete: Handsontable.AutocompleteValidator
                  }
                };
                /**
                 * autoResize - resizes a DOM element to the width and height of another DOM element
                 *
                 * Copyright 2014, Marcin Warpechowski
                 * Licensed under the MIT license
                 */
                var autoResize = function () {
                  var defaults = {
                      minHeight: 200,
                      maxHeight: 300,
                      minWidth: 100,
                      maxWidth: 300,
                      fontSize: 11
                    },
                    el,
                    body = document.body,
                    text = document.createTextNode(''),
                    span = document.createElement('SPAN'),
                    observe = function (element, event, handler) {
                      if (window.attachEvent) {
                        element.attachEvent('on' + event, handler);
                      } else {
                        element.addEventListener(event, handler, false);
                      }
                    },
                    unObserve = function (element, event, handler) {
                      if (window.detachEvent) {
                        element.detachEvent('on' + event, handler);
                      } else {
                        element.removeEventListener(event, handler, false);
                      }
                    },
                    resize = function () {
                      if (text.textContent !== void 0) {
                        text.textContent = el.value;
                      }
                      else {
                        text.data = el.value; //IE8
                      }
                      span.style.fontSize = defaults.fontSize + 'px';
                
                      body.appendChild(span);
                      var width = span.clientWidth;
                      body.removeChild(span);
                
                      el.style.height = defaults.minHeight + 'px';
                
                      if (defaults.minWidth > width) {
                        el.style.width = defaults.minWidth + 'px';
                      } else if (width > defaults.maxWidth) {
                        el.style.width = defaults.maxWidth + 'px';
                      } else {
                        el.style.width = width + 'px';
                      }
                
                      var scrollHeight = el.scrollHeight;
                      if (defaults.minHeight > scrollHeight) {
                        el.style.height = defaults.minHeight + 'px';
                      } else if (defaults.maxHeight < scrollHeight) {
                        el.style.height = defaults.maxHeight + 'px';
                        el.style.overflowY = 'visible';
                      } else {
                        el.style.height = scrollHeight + 'px';
                      }
                
                    },
                    delayedResize = function () {
                      window.setTimeout(resize, 0);
                    },
                    extendDefaults = function (config) {
                
                      if (config && config.minHeight) {
                        if (config.minHeight == 'inherit') {
                          defaults.minHeight = el.clientHeight;
                        } else {
                          var minHeight = parseInt(config.minHeight);
                          if (!isNaN(minHeight)) {
                            defaults.minHeight = minHeight
                          }
                        }
                      }
                
                      if (config && config.maxHeight) {
                        if (config.maxHeight == 'inherit') {
                          defaults.maxHeight = el.clientHeight;
                        } else {
                          var maxHeight = parseInt(config.maxHeight);
                          if (!isNaN(maxHeight)) {
                            defaults.maxHeight = maxHeight
                          }
                        }
                      }
                
                      if (config && config.minWidth) {
                        if (config.minWidth == 'inherit') {
                          defaults.minWidth = el.clientWidth;
                        } else {
                          var minWidth = parseInt(config.minWidth);
                          if (!isNaN(minWidth)) {
                            defaults.minWidth = minWidth
                          }
                        }
                      }
                
                      if (config && config.maxWidth) {
                        if (config.maxWidth == 'inherit') {
                          defaults.maxWidth = el.clientWidth;
                        } else {
                          var maxWidth = parseInt(config.maxWidth);
                          if (!isNaN(maxWidth)) {
                            defaults.maxWidth = maxWidth
                          }
                        }
                      }
                
                      if (config && config.fontSize) {
                        if (config.fontSize == 'inherit') {
                          defaults.fontSize = el.fontSize;
                        } else {
                          var fontSize = parseInt(config.fontSize);
                          if (!isNaN(fontSize)) {
                            defaults.fontSize = fontSize
                          }
                        }
                      }
                
                      if(!span.firstChild) {
                        span.className = "autoResize";
                        span.style.display = 'inline-block';
                        span.appendChild(text);
                      }
                    },
                    init = function (el_, config) {
                      el = el_;
                      extendDefaults(config);
                
                      if (el.nodeName == 'TEXTAREA') {
                
                        el.style.resize = 'none';
                        el.style.overflowY = '';
                        el.style.height = defaults.minHeight + 'px';
                        el.style.minWidth = defaults.minWidth + 'px';
                        el.style.maxWidth = defaults.maxWidth + 'px';
                        el.style.fontSize = defaults.fontSize + 'px';
                        el.style.overflowY = 'hidden';
                      }
                
                
                      observe(el, 'change', resize);
                      observe(el, 'cut', delayedResize);
                      observe(el, 'paste', delayedResize);
                      observe(el, 'drop', delayedResize);
                      observe(el, 'keydown', delayedResize);
                
                      resize();
                    };
                
                  return {
                    init: function (el_, config) {
                      init(el_, config);
                    },
                    unObserve: function () {
                      unObserve(el, 'change', resize);
                      unObserve(el, 'cut', delayedResize);
                      unObserve(el, 'paste', delayedResize);
                      unObserve(el, 'drop', delayedResize);
                      unObserve(el, 'keydown', delayedResize);
                    }
                  }
                
                };
                
                /**
                 * SheetClip - Spreadsheet Clipboard Parser
                 * version 0.2
                 *
                 * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,
                 * Google Docs and Microsoft Excel.
                 *
                 * Copyright 2012, Marcin Warpechowski
                 * Licensed under the MIT license.
                 * http://github.com/warpech/sheetclip/
                 */
                /*jslint white: true*/
                (function (global) {
                  
                
                  function countQuotes(str) {
                    return str.split('"').length - 1;
                  }
                
                  global.SheetClip = {
                    parse: function (str) {
                      var r, rlen, rows, arr = [], a = 0, c, clen, multiline, last;
                      rows = str.split('\n');
                      if (rows.length > 1 && rows[rows.length - 1] === '') {
                        rows.pop();
                      }
                      for (r = 0, rlen = rows.length; r < rlen; r += 1) {
                        rows[r] = rows[r].split('\t');
                        for (c = 0, clen = rows[r].length; c < clen; c += 1) {
                          if (!arr[a]) {
                            arr[a] = [];
                          }
                          if (multiline && c === 0) {
                            last = arr[a].length - 1;
                            arr[a][last] = arr[a][last] + '\n' + rows[r][0];
                            if (multiline && (countQuotes(rows[r][0]) & 1)) { //& 1 is a bitwise way of performing mod 2
                              multiline = false;
                              arr[a][last] = arr[a][last].substring(0, arr[a][last].length - 1).replace(/""/g, '"');
                            }
                          }
                          else {
                            if (c === clen - 1 && rows[r][c].indexOf('"') === 0) {
                              arr[a].push(rows[r][c].substring(1).replace(/""/g, '"'));
                              multiline = true;
                            }
                            else {
                              arr[a].push(rows[r][c].replace(/""/g, '"'));
                              multiline = false;
                            }
                          }
                        }
                        if (!multiline) {
                          a += 1;
                        }
                      }
                      return arr;
                    },
                
                    stringify: function (arr) {
                      var r, rlen, c, clen, str = '', val;
                      for (r = 0, rlen = arr.length; r < rlen; r += 1) {
                        for (c = 0, clen = arr[r].length; c < clen; c += 1) {
                          if (c > 0) {
                            str += '\t';
                          }
                          val = arr[r][c];
                          if (typeof val === 'string') {
                            if (val.indexOf('\n') > -1) {
                              str += '"' + val.replace(/"/g, '""') + '"';
                            }
                            else {
                              str += val;
                            }
                          }
                          else if (val === null || val === void 0) { //void 0 resolves to undefined
                            str += '';
                          }
                          else {
                            str += val;
                          }
                        }
                        if (r < rlen - 1) {
                          str += '\n';
                        }
                      }
                      return str;
                    }
                  };
                }(window));
                /**
                 * CopyPaste.js
                 * Creates a textarea that stays hidden on the page and gets focused when user presses CTRL while not having a form input focused
                 * In future we may implement a better driver when better APIs are available
                 * @constructor
                 */
                var CopyPaste = (function () {
                  var instance;
                  return {
                    getInstance: function () {
                      if (!instance) {
                        instance = new CopyPasteClass();
                      } else if (instance.hasBeenDestroyed()){
                        instance.init();
                      }
                
                      instance.refCounter++;
                
                      return instance;
                    }
                  };
                })();
                
                function CopyPasteClass() {
                  this.refCounter = 0;
                  this.init();
                }
                
                CopyPasteClass.prototype.init = function () {
                  var that = this
                    , style
                    , parent;
                
                  this.copyCallbacks = [];
                  this.cutCallbacks = [];
                  this.pasteCallbacks = [];
                
                  this.listenerElement = document.documentElement;
                  parent = document.body;
                
                  if (document.getElementById('CopyPasteDiv')) {
                    this.elDiv = document.getElementById('CopyPasteDiv');
                    this.elTextarea = this.elDiv.firstChild;
                  }
                  else {
                    this.elDiv = document.createElement('DIV');
                    this.elDiv.id = 'CopyPasteDiv';
                    style = this.elDiv.style;
                    style.position = 'fixed';
                    style.top = '-10000px';
                    style.left = '-10000px';
                    parent.appendChild(this.elDiv);
                
                    this.elTextarea = document.createElement('TEXTAREA');
                    this.elTextarea.className = 'copyPaste';
                    style = this.elTextarea.style;
                    style.width = '10000px';
                    style.height = '10000px';
                    style.overflow = 'hidden';
                    this.elDiv.appendChild(this.elTextarea);
                
                    if (typeof style.opacity !== 'undefined') {
                      style.opacity = 0;
                    }
                    else {
                      /*@cc_on @if (@_jscript)
                       if(typeof style.filter === 'string') {
                       style.filter = 'alpha(opacity=0)';
                       }
                       @end @*/
                    }
                  }
                
                  this.keydownListener = function (event) {
                    var isCtrlDown = false;
                    if (event.metaKey) { //mac
                      isCtrlDown = true;
                    }
                    else if (event.ctrlKey && navigator.userAgent.indexOf('Mac') === -1) { //pc
                      isCtrlDown = true;
                    }
                
                    if (isCtrlDown) {
                      if (document.activeElement !== that.elTextarea && (that.getSelectionText() != '' || ['INPUT', 'SELECT', 'TEXTAREA'].indexOf(document.activeElement.nodeName) != -1)) {
                        return; //this is needed by fragmentSelection in Handsontable. Ignore copypaste.js behavior if fragment of cell text is selected
                      }
                
                      that.selectNodeText(that.elTextarea);
                      setTimeout(function () {
                        that.selectNodeText(that.elTextarea);
                      }, 0);
                    }
                
                    /* 67 = c
                     * 86 = v
                     * 88 = x
                     */
                    if (isCtrlDown && (event.keyCode === 67 || event.keyCode === 86 || event.keyCode === 88)) {
                      // that.selectNodeText(that.elTextarea);
                
                      if (event.keyCode === 88) { //works in all browsers, incl. Opera < 12.12
                        setTimeout(function () {
                          that.triggerCut(event);
                        }, 0);
                      }
                      else if (event.keyCode === 86) {
                        setTimeout(function () {
                          that.triggerPaste(event);
                        }, 0);
                      }
                    }
                  }
                
                  this._bindEvent(this.listenerElement, 'keydown', this.keydownListener);
                };
                
                //http://jsperf.com/textara-selection
                //http://stackoverflow.com/questions/1502385/how-can-i-make-this-code-work-in-ie
                CopyPasteClass.prototype.selectNodeText = function (el) {
                  el.select();
                };
                
                //http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text
                CopyPasteClass.prototype.getSelectionText = function () {
                  var text = "";
                  if (window.getSelection) {
                    text = window.getSelection().toString();
                  } else if (document.selection && document.selection.type != "Control") {
                    text = document.selection.createRange().text;
                  }
                  return text;
                };
                
                CopyPasteClass.prototype.copyable = function (str) {
                  if (typeof str !== 'string' && str.toString === void 0) {
                    throw new Error('copyable requires string parameter');
                  }
                  this.elTextarea.value = str;
                };
                
                /*CopyPasteClass.prototype.onCopy = function (fn) {
                  this.copyCallbacks.push(fn);
                };*/
                
                CopyPasteClass.prototype.onCut = function (fn) {
                  this.cutCallbacks.push(fn);
                };
                
                CopyPasteClass.prototype.onPaste = function (fn) {
                  this.pasteCallbacks.push(fn);
                };
                
                CopyPasteClass.prototype.removeCallback = function (fn) {
                  var i, ilen;
                  for (i = 0, ilen = this.copyCallbacks.length; i < ilen; i++) {
                    if (this.copyCallbacks[i] === fn) {
                      this.copyCallbacks.splice(i, 1);
                      return true;
                    }
                  }
                  for (i = 0, ilen = this.cutCallbacks.length; i < ilen; i++) {
                    if (this.cutCallbacks[i] === fn) {
                      this.cutCallbacks.splice(i, 1);
                      return true;
                    }
                  }
                  for (i = 0, ilen = this.pasteCallbacks.length; i < ilen; i++) {
                    if (this.pasteCallbacks[i] === fn) {
                      this.pasteCallbacks.splice(i, 1);
                      return true;
                    }
                  }
                  return false;
                };
                
                CopyPasteClass.prototype.triggerCut = function (event) {
                  var that = this;
                  if (that.cutCallbacks) {
                    setTimeout(function () {
                      for (var i = 0, ilen = that.cutCallbacks.length; i < ilen; i++) {
                        that.cutCallbacks[i](event);
                      }
                    }, 50);
                  }
                };
                
                CopyPasteClass.prototype.triggerPaste = function (event, str) {
                  var that = this;
                  if (that.pasteCallbacks) {
                    setTimeout(function () {
                      var val = (str || that.elTextarea.value).replace(/\n$/, ''); //remove trailing newline
                      for (var i = 0, ilen = that.pasteCallbacks.length; i < ilen; i++) {
                        that.pasteCallbacks[i](val, event);
                      }
                    }, 50);
                  }
                };
                
                CopyPasteClass.prototype.destroy = function () {
                
                  if(!this.hasBeenDestroyed() && --this.refCounter == 0){
                    if (this.elDiv && this.elDiv.parentNode) {
                      this.elDiv.parentNode.removeChild(this.elDiv);
                      this.elDiv = null;
                      this.elTextarea = null;
                    }
                
                    this._unbindEvent(this.listenerElement, 'keydown', this.keydownListener);
                
                  }
                
                };
                
                CopyPasteClass.prototype.hasBeenDestroyed = function () {
                  return !this.refCounter;
                };
                
                //old version used this:
                // - http://net.tutsplus.com/tutorials/javascript-ajax/javascript-from-null-cross-browser-event-binding/
                // - http://stackoverflow.com/questions/4643249/cross-browser-event-object-normalization
                //but that cannot work with jQuery.trigger
                CopyPasteClass.prototype._bindEvent = (function () {
                  if (window.jQuery) { //if jQuery exists, use jQuery event (for compatibility with $.trigger and $.triggerHandler, which can only trigger jQuery events - and we use that in tests)
                    return function (elem, type, cb) {
                      $(elem).on(type + '.copypaste', cb);
                    };
                  }
                  else {
                    return function (elem, type, cb) {
                      elem.addEventListener(type, cb, false); //sorry, IE8 will only work with jQuery
                    };
                  }
                })();
                
                CopyPasteClass.prototype._unbindEvent = (function () {
                  if (window.jQuery) { //if jQuery exists, use jQuery event (for compatibility with $.trigger and $.triggerHandler, which can only trigger jQuery events - and we use that in tests)
                    return function (elem, type, cb) {
                      $(elem).off(type + '.copypaste', cb);
                    };
                  }
                  else {
                    return function (elem, type, cb) {
                      elem.removeEventListener(type, cb, false); //sorry, IE8 will only work with jQuery
                    };
                  }
                })();
                // json-patch-duplex.js 0.3.6
                // (c) 2013 Joachim Wester
                // MIT license
                var jsonpatch;
                (function (jsonpatch) {
                    var objOps = {
                        add: function (obj, key) {
                            obj[key] = this.value;
                            return true;
                        },
                        remove: function (obj, key) {
                            delete obj[key];
                            return true;
                        },
                        replace: function (obj, key) {
                            obj[key] = this.value;
                            return true;
                        },
                        move: function (obj, key, tree) {
                            var temp = { op: "_get", path: this.from };
                            apply(tree, [temp]);
                            apply(tree, [
                                { op: "remove", path: this.from }
                            ]);
                            apply(tree, [
                                { op: "add", path: this.path, value: temp.value }
                            ]);
                            return true;
                        },
                        copy: function (obj, key, tree) {
                            var temp = { op: "_get", path: this.from };
                            apply(tree, [temp]);
                            apply(tree, [
                                { op: "add", path: this.path, value: temp.value }
                            ]);
                            return true;
                        },
                        test: function (obj, key) {
                            return (JSON.stringify(obj[key]) === JSON.stringify(this.value));
                        },
                        _get: function (obj, key) {
                            this.value = obj[key];
                        }
                    };
                
                    var arrOps = {
                        add: function (arr, i) {
                            arr.splice(i, 0, this.value);
                            return true;
                        },
                        remove: function (arr, i) {
                            arr.splice(i, 1);
                            return true;
                        },
                        replace: function (arr, i) {
                            arr[i] = this.value;
                            return true;
                        },
                        move: objOps.move,
                        copy: objOps.copy,
                        test: objOps.test,
                        _get: objOps._get
                    };
                
                    var observeOps = {
                        add: function (patches, path) {
                            var patch = {
                                op: "add",
                                path: path + escapePathComponent(this.name),
                                value: this.object[this.name]
                            };
                            patches.push(patch);
                        },
                        'delete': function (patches, path) {
                            var patch = {
                                op: "remove",
                                path: path + escapePathComponent(this.name)
                            };
                            patches.push(patch);
                        },
                        update: function (patches, path) {
                            var patch = {
                                op: "replace",
                                path: path + escapePathComponent(this.name),
                                value: this.object[this.name]
                            };
                            patches.push(patch);
                        }
                    };
                
                    function escapePathComponent(str) {
                        if (str.indexOf('/') === -1 && str.indexOf('~') === -1)
                            return str;
                        return str.replace(/~/g, '~0').replace(/\//g, '~1');
                    }
                
                    function _getPathRecursive(root, obj) {
                        var found;
                        for (var key in root) {
                            if (root.hasOwnProperty(key)) {
                                if (root[key] === obj) {
                                    return escapePathComponent(key) + '/';
                                } else if (typeof root[key] === 'object') {
                                    found = _getPathRecursive(root[key], obj);
                                    if (found != '') {
                                        return escapePathComponent(key) + '/' + found;
                                    }
                                }
                            }
                        }
                        return '';
                    }
                
                    function getPath(root, obj) {
                        if (root === obj) {
                            return '/';
                        }
                        var path = _getPathRecursive(root, obj);
                        if (path === '') {
                            throw new Error("Object not found in root");
                        }
                        return '/' + path;
                    }
                
                    var beforeDict = [];
                
                    jsonpatch.intervals;
                
                    var Mirror = (function () {
                        function Mirror(obj) {
                            this.observers = [];
                            this.obj = obj;
                        }
                        return Mirror;
                    })();
                
                    var ObserverInfo = (function () {
                        function ObserverInfo(callback, observer) {
                            this.callback = callback;
                            this.observer = observer;
                        }
                        return ObserverInfo;
                    })();
                
                    function getMirror(obj) {
                        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {
                            if (beforeDict[i].obj === obj) {
                                return beforeDict[i];
                            }
                        }
                    }
                
                    function getObserverFromMirror(mirror, callback) {
                        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {
                            if (mirror.observers[j].callback === callback) {
                                return mirror.observers[j].observer;
                            }
                        }
                    }
                
                    function removeObserverFromMirror(mirror, observer) {
                        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {
                            if (mirror.observers[j].observer === observer) {
                                mirror.observers.splice(j, 1);
                                return;
                            }
                        }
                    }
                
                    function unobserve(root, observer) {
                        generate(observer);
                        if (Object.observe) {
                            _unobserve(observer, root);
                        } else {
                            clearTimeout(observer.next);
                        }
                
                        var mirror = getMirror(root);
                        removeObserverFromMirror(mirror, observer);
                    }
                    jsonpatch.unobserve = unobserve;
                
                    function observe(obj, callback) {
                        var patches = [];
                        var root = obj;
                        var observer;
                        var mirror = getMirror(obj);
                
                        if (!mirror) {
                            mirror = new Mirror(obj);
                            beforeDict.push(mirror);
                        } else {
                            observer = getObserverFromMirror(mirror, callback);
                        }
                
                        if (observer) {
                            return observer;
                        }
                
                        if (Object.observe) {
                            observer = function (arr) {
                                //This "refresh" is needed to begin observing new object properties
                                _unobserve(observer, obj);
                                _observe(observer, obj);
                
                                var a = 0, alen = arr.length;
                                while (a < alen) {
                                    if (!(arr[a].name === 'length' && _isArray(arr[a].object)) && !(arr[a].name === '__Jasmine_been_here_before__')) {
                                        var type = arr[a].type;
                
                                        switch (type) {
                                            case 'new':
                                                type = 'add';
                                                break;
                
                                            case 'deleted':
                                                type = 'delete';
                                                break;
                
                                            case 'updated':
                                                type = 'update';
                                                break;
                                        }
                
                                        observeOps[type].call(arr[a], patches, getPath(root, arr[a].object));
                                    }
                                    a++;
                                }
                
                                if (patches) {
                                    if (callback) {
                                        callback(patches);
                                    }
                                }
                                observer.patches = patches;
                                patches = [];
                            };
                        } else {
                            observer = {};
                
                            mirror.value = JSON.parse(JSON.stringify(obj));
                
                            if (callback) {
                                //callbacks.push(callback); this has no purpose
                                observer.callback = callback;
                                observer.next = null;
                                var intervals = this.intervals || [100, 1000, 10000, 60000];
                                var currentInterval = 0;
                
                                var dirtyCheck = function () {
                                    generate(observer);
                                };
                                var fastCheck = function () {
                                    clearTimeout(observer.next);
                                    observer.next = setTimeout(function () {
                                        dirtyCheck();
                                        currentInterval = 0;
                                        observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
                                    }, 0);
                                };
                                var slowCheck = function () {
                                    dirtyCheck();
                                    if (currentInterval == intervals.length)
                                        currentInterval = intervals.length - 1;
                                    observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
                                };
                                if (typeof window !== 'undefined') {
                                    if (window.addEventListener) {
                                        window.addEventListener('mousedown', fastCheck);
                                        window.addEventListener('mouseup', fastCheck);
                                        window.addEventListener('keydown', fastCheck);
                                    } else {
                                        window.attachEvent('onmousedown', fastCheck);
                                        window.attachEvent('onmouseup', fastCheck);
                                        window.attachEvent('onkeydown', fastCheck);
                                    }
                                }
                                observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
                            }
                        }
                        observer.patches = patches;
                        observer.object = obj;
                
                        mirror.observers.push(new ObserverInfo(callback, observer));
                
                        return _observe(observer, obj);
                    }
                    jsonpatch.observe = observe;
                
                    /// Listen to changes on an object tree, accumulate patches
                    function _observe(observer, obj) {
                        if (Object.observe) {
                            Object.observe(obj, observer);
                            for (var key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    var v = obj[key];
                                    if (v && typeof (v) === "object") {
                                        _observe(observer, v);
                                    }
                                }
                            }
                        }
                        return observer;
                    }
                
                    function _unobserve(observer, obj) {
                        if (Object.observe) {
                            Object.unobserve(obj, observer);
                            for (var key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    var v = obj[key];
                                    if (v && typeof (v) === "object") {
                                        _unobserve(observer, v);
                                    }
                                }
                            }
                        }
                        return observer;
                    }
                
                    function generate(observer) {
                        if (Object.observe) {
                            Object.deliverChangeRecords(observer);
                        } else {
                            var mirror;
                            for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {
                                if (beforeDict[i].obj === observer.object) {
                                    mirror = beforeDict[i];
                                    break;
                                }
                            }
                            _generate(mirror.value, observer.object, observer.patches, "");
                        }
                        var temp = observer.patches;
                        if (temp.length > 0) {
                            observer.patches = [];
                            if (observer.callback) {
                                observer.callback(temp);
                            }
                        }
                        return temp;
                    }
                    jsonpatch.generate = generate;
                
                    var _objectKeys;
                    if (Object.keys) {
                        _objectKeys = Object.keys;
                    } else {
                        _objectKeys = function (obj) {
                            var keys = [];
                            for (var o in obj) {
                                if (obj.hasOwnProperty(o)) {
                                    keys.push(o);
                                }
                            }
                            return keys;
                        };
                    }
                
                    // Dirty check if obj is different from mirror, generate patches and update mirror
                    function _generate(mirror, obj, patches, path) {
                        var newKeys = _objectKeys(obj);
                        var oldKeys = _objectKeys(mirror);
                        var changed = false;
                        var deleted = false;
                
                        for (var t = oldKeys.length - 1; t >= 0; t--) {
                            var key = oldKeys[t];
                            var oldVal = mirror[key];
                            if (obj.hasOwnProperty(key)) {
                                var newVal = obj[key];
                                if (oldVal instanceof Object) {
                                    _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key));
                                } else {
                                    if (oldVal != newVal) {
                                        changed = true;
                                        patches.push({ op: "replace", path: path + "/" + escapePathComponent(key), value: newVal });
                                        mirror[key] = newVal;
                                    }
                                }
                            } else {
                                patches.push({ op: "remove", path: path + "/" + escapePathComponent(key) });
                                delete mirror[key];
                                deleted = true;
                            }
                        }
                
                        if (!deleted && newKeys.length == oldKeys.length) {
                            return;
                        }
                
                        for (var t = 0; t < newKeys.length; t++) {
                            var key = newKeys[t];
                            if (!mirror.hasOwnProperty(key)) {
                                patches.push({ op: "add", path: path + "/" + escapePathComponent(key), value: obj[key] });
                                mirror[key] = JSON.parse(JSON.stringify(obj[key]));
                            }
                        }
                    }
                
                    var _isArray;
                    if (Array.isArray) {
                        _isArray = Array.isArray;
                    } else {
                        _isArray = function (obj) {
                            return obj.push && typeof obj.length === 'number';
                        };
                    }
                
                    /// Apply a json-patch operation on an object tree
                    function apply(tree, patches) {
                        var result = false, p = 0, plen = patches.length, patch;
                        while (p < plen) {
                            patch = patches[p];
                
                            // Find the object
                            var keys = patch.path.split('/');
                            var obj = tree;
                            var t = 1;
                            var len = keys.length;
                            while (true) {
                                if (_isArray(obj)) {
                                    var index = parseInt(keys[t], 10);
                                    t++;
                                    if (t >= len) {
                                        result = arrOps[patch.op].call(patch, obj, index, tree);
                                        break;
                                    }
                                    obj = obj[index];
                                } else {
                                    var key = keys[t];
                                    if (key.indexOf('~') != -1)
                                        key = key.replace(/~1/g, '/').replace(/~0/g, '~');
                                    t++;
                                    if (t >= len) {
                                        result = objOps[patch.op].call(patch, obj, key, tree);
                                        break;
                                    }
                                    obj = obj[key];
                                }
                            }
                            p++;
                        }
                        return result;
                    }
                    jsonpatch.apply = apply;
                })(jsonpatch || (jsonpatch = {}));
                
                if (typeof exports !== "undefined") {
                    exports.apply = jsonpatch.apply;
                    exports.observe = jsonpatch.observe;
                    exports.unobserve = jsonpatch.unobserve;
                    exports.generate = jsonpatch.generate;
                }
                
                Handsontable.PluginHookClass = (function () {
                
                  var Hooks = function () {
                    return {
                      // Hooks
                      beforeInitWalkontable: [],
                
                      beforeInit: [],
                      beforeRender: [],
                      beforeSetRangeEnd: [],
                      beforeChange: [],
                      beforeChangeRender: [],
                      beforeRemoveCol: [],
                      beforeRemoveRow: [],
                      beforeValidate: [],
                      beforeGetCellMeta: [],
                      beforeAutofill: [],
                      beforeKeyDown: [],
                
                      afterInit : [],
                      afterLoadData : [],
                      afterUpdateSettings: [],
                      afterRender : [],
                      afterRenderer : [],
                      afterChange : [],
                      afterValidate: [],
                      afterGetCellMeta: [],
                      afterSetCellMeta: [],
                      afterGetColHeader: [],
                      afterGetRowHeader: [],
                      afterDestroy: [],
                      afterRemoveRow: [],
                      afterCreateRow: [],
                      afterRemoveCol: [],
                      afterCreateCol: [],
                      afterDeselect: [],
                      afterSelection: [],
                      afterSelectionByProp: [],
                      afterSelectionEnd: [],
                      afterSelectionEndByProp: [],
                      afterOnCellMouseDown: [],
                      afterOnCellMouseOver: [],
                      afterOnCellCornerMouseDown: [],
                      afterScrollVertically: [],
                      afterScrollHorizontally: [],
                	  afterCellMetaReset:[],
                      afterDocumentKeyDown: [],
                
                      // Modifiers
                      modifyColWidth: [],
                      modifyRowHeight: [],
                      modifyRow: [],
                      modifyCol: []
                    }
                  };
                
                  var legacy = {
                    onBeforeChange: "beforeChange",
                    onChange: "afterChange",
                    onCreateRow: "afterCreateRow",
                    onCreateCol: "afterCreateCol",
                    onSelection: "afterSelection",
                    onCopyLimit: "afterCopyLimit",
                    onSelectionEnd: "afterSelectionEnd",
                    onSelectionByProp: "afterSelectionByProp",
                    onSelectionEndByProp: "afterSelectionEndByProp"
                  };
                
                  function PluginHookClass() {
                
                    this.hooks = Hooks();
                    this.globalBucket = {};
                    this.legacy = legacy;
                
                  }
                
                  PluginHookClass.prototype.getBucket = function (instance) {
                    if(instance) {
                      if(!instance.pluginHookBucket) {
                        instance.pluginHookBucket = {};
                      }
                      return instance.pluginHookBucket;
                    }
                    return this.globalBucket;
                  };
                
                  PluginHookClass.prototype.add = function (key, fn, instance) {
                    //if fn is array, run this for all the array items
                    if (Handsontable.helper.isArray(fn)) {
                      for (var i = 0, len = fn.length; i < len; i++) {
                        this.add(key, fn[i]);
                      }
                    }
                    else {
                      // provide support for old versions of HOT
                      if (key in legacy) {
                        key = legacy[key];
                      }
                
                      var bucket = this.getBucket(instance);
                
                      if (typeof bucket[key] === "undefined") {
                        bucket[key] = [];
                      }
                
                      fn.skip = false;
                
                      if (bucket[key].indexOf(fn) == -1) {
                        bucket[key].push(fn); //only add a hook if it has not already be added (adding the same hook twice is now silently ignored)
                      }
                    }
                    return this;
                  };
                
                  PluginHookClass.prototype.once = function(key, fn, instance){
                
                    if(Handsontable.helper.isArray(fn)){
                
                      for(var i = 0, len = fn.length; i < len; i++){
                        fn[i].runOnce = true;
                        this.add(key, fn[i], instance);
                      }
                
                    } else {
                      fn.runOnce = true;
                      this.add(key, fn, instance);
                
                    }
                
                  };
                
                  PluginHookClass.prototype.remove = function (key, fn, instance) {
                    var status = false;
                
                    // provide support for old versions of HOT
                    if (key in legacy) {
                      key = legacy[key];
                    }
                
                    var bucket = this.getBucket(instance);
                
                    if (typeof bucket[key] !== 'undefined') {
                
                      for (var i = 0, leni = bucket[key].length; i < leni; i++) {
                
                        if (bucket[key][i] == fn) {
                          bucket[key][i].skip = true;
                          status = true;
                          break;
                        }
                
                      }
                
                    }
                
                    return status;
                  };
                
                  PluginHookClass.prototype.run = function (instance, key, p1, p2, p3, p4, p5, p6) {
                    // provide support for old versions of HOT
                    if (key in legacy) {
                      key = legacy[key];
                    }
                
                    this._runBucket(this.globalBucket, instance, key, p1, p2, p3, p4, p5, p6);
                    this._runBucket(this.getBucket(instance), instance, key, p1, p2, p3, p4, p5, p6);
                  };
                
                  PluginHookClass.prototype._runBucket = function (bucket, instance, key, p1, p2, p3, p4, p5, p6) {
                    var handlers = bucket[key];
                    if (handlers) {
                      for (var i = 0, leni = handlers.length; i < leni; i++) {
                        if (!handlers[i].skip) {
                          handlers[i].call(instance, p1, p2, p3, p4, p5, p6);
                
                          if (handlers[i].runOnce) {
                            this.remove(key, handlers[i], bucket === this.globalBucket ? null : instance);
                          }
                        }
                      }
                    }
                  };
                
                  PluginHookClass.prototype.destroy = function (instance) {
                    var bucket = this.getBucket(instance);
                    for (var key in bucket) {
                      if (bucket.hasOwnProperty(key)) {
                        for (var i = 0, leni = bucket[key].length; i < leni; i++) {
                          this.remove(key, bucket[key], instance);
                        }
                      }
                    }
                  };
                
                  PluginHookClass.prototype.execute = function (instance, key, p1, p2, p3, p4, p5, p6) {
                    // provide support for old versions of HOT
                    if (key in legacy) {
                      key = legacy[key];
                    }
                
                    p1 = this._executeBucket(this.globalBucket, instance, key, p1, p2, p3, p4, p5, p6);
                    p1 = this._executeBucket(this.getBucket(instance), instance, key, p1, p2, p3, p4, p5, p6);
                    return p1;
                  };
                
                  PluginHookClass.prototype._executeBucket = function (bucket, instance, key, p1, p2, p3, p4, p5, p6) {
                    var res,
                      handlers = bucket[key];
                
                    //performance considerations - http://jsperf.com/call-vs-apply-for-a-plugin-architecture
                    if (handlers) {
                      for (var i = 0, leni = handlers.length; i < leni; i++) {
                        if (!handlers[i].skip) {
                          res = handlers[i].call(instance, p1, p2, p3, p4, p5, p6);
                          if (res !== void 0) {
                            p1 = res;
                          }
                
                          if (handlers[i].runOnce) {
                            this.remove(key, handlers[i], bucket === this.globalBucket ? null : instance);
                          }
                
                          if (res === false) { //if any handler returned false
                            return false; //event has been cancelled and further execution of handler queue is being aborted
                          }
                        }
                      }
                    }
                
                    return p1;
                  };
                
                  /**
                   * Registers a hook name (adds it to the list of the known hook names). Used by plugins. It is not neccessary to call,
                   * register, but if you use it, your plugin hook will be used returned by getRegistered
                   * (which itself is used in the demo http://handsontable.com/demo/callbacks.html)
                   * @param key {String}
                   */
                  PluginHookClass.prototype.register = function (key) {
                    if (!this.isRegistered(key)) {
                      this.hooks[key] = [];
                    }
                  };
                
                  /**
                   * Deregisters a hook name (removes it from the list of known hook names)
                   * @param key {String}
                   */
                  PluginHookClass.prototype.deregister = function (key) {
                    delete this.hooks[key];
                  };
                
                  /**
                   * Returns boolean information if a hook by such name has been registered
                   * @param key {String}
                   */
                  PluginHookClass.prototype.isRegistered = function (key) {
                    return (typeof this.hooks[key] !== "undefined");
                  };
                
                  /**
                   * Returns an array of registered hooks
                   * @returns {Array}
                   */
                  PluginHookClass.prototype.getRegistered = function () {
                    return Object.keys(this.hooks);
                  };
                
                  return PluginHookClass;
                
                })();
                
                Handsontable.hooks = new Handsontable.PluginHookClass();
                Handsontable.PluginHooks = Handsontable.hooks; //in future move this line to legacy.js
                
                (function (Handsontable) {
                
                  function HandsontableAutoColumnSize() {
                    var plugin = this
                      , sampleCount = 5; //number of samples to take of each value length
                
                    this.beforeInit = function () {
                      var instance = this;
                      instance.autoColumnWidths = [];
                
                      if (instance.getSettings().autoColumnSize !== false) {
                        if (!instance.autoColumnSizeTmp) {
                          instance.autoColumnSizeTmp = {
                            table: null,
                            tableStyle: null,
                            theadTh: null,
                            tbody: null,
                            container: null,
                            containerStyle: null,
                            determineBeforeNextRender: true
                          };
                
                          instance.addHook('beforeRender', htAutoColumnSize.determineIfChanged);
                          instance.addHook('modifyColWidth', htAutoColumnSize.modifyColWidth);
                          instance.addHook('afterDestroy', htAutoColumnSize.afterDestroy);
                
                          instance.determineColumnWidth = plugin.determineColumnWidth;
                        }
                      } else {
                        if (instance.autoColumnSizeTmp) {
                          instance.removeHook('beforeRender', htAutoColumnSize.determineIfChanged);
                          instance.removeHook('modifyColWidth', htAutoColumnSize.modifyColWidth);
                          instance.removeHook('afterDestroy', htAutoColumnSize.afterDestroy);
                
                          delete instance.determineColumnWidth;
                
                          plugin.afterDestroy.call(instance);
                        }
                      }
                    };
                
                    this.determineIfChanged = function (force) {
                      if (force) {
                        htAutoColumnSize.determineColumnsWidth.apply(this, arguments);
                      }
                    };
                
                    this.determineColumnWidth = function (col) {
                      var instance = this
                        , tmp = instance.autoColumnSizeTmp;
                
                      if (!tmp.container) {
                        createTmpContainer.call(tmp, instance);
                      }
                
                      tmp.container.className = instance.rootElement[0].className + ' htAutoColumnSize';
                      tmp.table.className = instance.$table[0].className;
                
                      var rows = instance.countRows();
                      var samples = {};
                      var maxLen = 0;
                      for (var r = 0; r < rows; r++) {
                        var value = Handsontable.helper.stringify(instance.getDataAtCell(r, col));
                        var len = value.length;
                        if (len > maxLen) {
                          maxLen = len;
                        }
                        if (!samples[len]) {
                          samples[len] = {
                            needed: sampleCount,
                            strings: []
                          };
                        }
                        if (samples[len].needed) {
                          samples[len].strings.push({value: value, row: r});
                          samples[len].needed--;
                        }
                      }
                
                      var settings = instance.getSettings();
                      if (settings.colHeaders) {
                        instance.view.appendColHeader(col, tmp.theadTh); //TH innerHTML
                      }
                
                      Handsontable.Dom.empty(tmp.tbody);
                
                      for (var i in samples) {
                        if (samples.hasOwnProperty(i)) {
                          for (var j = 0, jlen = samples[i].strings.length; j < jlen; j++) {
                            var row = samples[i].strings[j].row;
                
                            var cellProperties = instance.getCellMeta(row, col);
                            cellProperties.col = col;
                            cellProperties.row = row;
                
                            var renderer = instance.getCellRenderer(cellProperties);
                
                            var tr = document.createElement('tr');
                            var td = document.createElement('td');
                
                            renderer(instance, td, row, col, instance.colToProp(col), samples[i].strings[j].value, cellProperties);
                            r++;
                            tr.appendChild(td);
                            tmp.tbody.appendChild(tr);
                          }
                        }
                      }
                
                      var parent = instance.rootElement[0].parentNode;
                      parent.appendChild(tmp.container);
                      var width = Handsontable.Dom.outerWidth(tmp.table);
                      parent.removeChild(tmp.container);
                
                      return width;
                    };
                
                    this.determineColumnsWidth = function () {
                      var instance = this;
                      var settings = this.getSettings();
                      if (settings.autoColumnSize || !settings.colWidths) {
                        var cols = this.countCols();
                        for (var c = 0; c < cols; c++) {
                          if (!instance._getColWidthFromSettings(c)) {
                            this.autoColumnWidths[c] = plugin.determineColumnWidth.call(instance, c);
                          }
                        }
                      }
                    };
                
                    this.modifyColWidth = function (width, col) {
                      if (this.autoColumnWidths[col] && this.autoColumnWidths[col] > width) {
                        return this.autoColumnWidths[col];
                      }
                      return width;
                    };
                
                    this.afterDestroy = function () {
                      var instance = this;
                      if (instance.autoColumnSizeTmp && instance.autoColumnSizeTmp.container && instance.autoColumnSizeTmp.container.parentNode) {
                        instance.autoColumnSizeTmp.container.parentNode.removeChild(instance.autoColumnSizeTmp.container);
                      }
                      instance.autoColumnSizeTmp = null;
                    };
                
                    function createTmpContainer(instance) {
                      var d = document
                        , tmp = this;
                
                      tmp.table = d.createElement('table');
                      tmp.theadTh = d.createElement('th');
                      tmp.table.appendChild(d.createElement('thead')).appendChild(d.createElement('tr')).appendChild(tmp.theadTh);
                
                      tmp.tableStyle = tmp.table.style;
                      tmp.tableStyle.tableLayout = 'auto';
                      tmp.tableStyle.width = 'auto';
                
                      tmp.tbody = d.createElement('tbody');
                      tmp.table.appendChild(tmp.tbody);
                
                      tmp.container = d.createElement('div');
                      tmp.container.className = instance.rootElement[0].className + ' hidden';
                      tmp.containerStyle = tmp.container.style;
                
                      tmp.container.appendChild(tmp.table);
                    }
                  }
                
                  var htAutoColumnSize = new HandsontableAutoColumnSize();
                
                  Handsontable.hooks.add('beforeInit', htAutoColumnSize.beforeInit);
                  Handsontable.hooks.add('afterUpdateSettings', htAutoColumnSize.beforeInit);
                
                })(Handsontable);
                
                /**
                 * This plugin sorts the view by a column (but does not sort the data source!)
                 * @constructor
                 */
                function HandsontableColumnSorting() {
                  var plugin = this;
                
                  this.init = function (source) {
                    var instance = this;
                    var sortingSettings = instance.getSettings().columnSorting;
                    var sortingColumn, sortingOrder;
                
                    instance.sortingEnabled = !!(sortingSettings);
                
                    if (instance.sortingEnabled) {
                      instance.sortIndex = [];
                
                      var loadedSortingState = loadSortingState.call(instance);
                
                      if (typeof loadedSortingState != 'undefined') {
                        sortingColumn = loadedSortingState.sortColumn;
                        sortingOrder = loadedSortingState.sortOrder;
                      } else {
                        sortingColumn = sortingSettings.column;
                        sortingOrder = sortingSettings.sortOrder;
                      }
                      plugin.sortByColumn.call(instance, sortingColumn, sortingOrder);
                
                      instance.sort = function(){
                        var args = Array.prototype.slice.call(arguments);
                
                        return plugin.sortByColumn.apply(instance, args)
                      };
                
                      if (typeof instance.getSettings().observeChanges == 'undefined'){
                        enableObserveChangesPlugin.call(instance);
                      }
                
                      if (source == 'afterInit') {
                        bindColumnSortingAfterClick.call(instance);
                
                        instance.addHook('afterCreateRow', plugin.afterCreateRow);
                        instance.addHook('afterRemoveRow', plugin.afterRemoveRow);
                        instance.addHook('afterLoadData', plugin.init);
                      }
                    } else {
                      delete instance.sort;
                
                      instance.removeHook('afterCreateRow', plugin.afterCreateRow);
                      instance.removeHook('afterRemoveRow', plugin.afterRemoveRow);
                      instance.removeHook('afterLoadData', plugin.init);
                    }
                  };
                
                  this.setSortingColumn = function (col, order) {
                    var instance = this;
                
                    if (typeof col == 'undefined') {
                      delete instance.sortColumn;
                      delete instance.sortOrder;
                
                      return;
                    } else if (instance.sortColumn === col && typeof order == 'undefined') {
                      instance.sortOrder = !instance.sortOrder;
                    } else {
                      instance.sortOrder = typeof order != 'undefined' ? order : true;
                    }
                
                    instance.sortColumn = col;
                
                  };
                
                  this.sortByColumn = function (col, order) {
                    var instance = this;
                
                    plugin.setSortingColumn.call(instance, col, order);
                
                    if(typeof instance.sortColumn == 'undefined'){
                      return;
                    }
                
                    Handsontable.hooks.run(instance, 'beforeColumnSort', instance.sortColumn, instance.sortOrder);
                
                    plugin.sort.call(instance);
                    instance.render();
                
                    saveSortingState.call(instance);
                
                    Handsontable.hooks.run(instance, 'afterColumnSort', instance.sortColumn, instance.sortOrder);
                  };
                
                  var saveSortingState = function () {
                    var instance = this;
                
                    var sortingState = {};
                
                    if (typeof instance.sortColumn != 'undefined') {
                      sortingState.sortColumn = instance.sortColumn;
                    }
                
                    if (typeof instance.sortOrder != 'undefined') {
                      sortingState.sortOrder = instance.sortOrder;
                    }
                
                    if (sortingState.hasOwnProperty('sortColumn') || sortingState.hasOwnProperty('sortOrder')) {
                      Handsontable.hooks.run(instance, 'persistentStateSave', 'columnSorting', sortingState);
                    }
                
                  };
                
                  var loadSortingState = function () {
                    var instance = this;
                    var storedState = {};
                    Handsontable.hooks.run(instance, 'persistentStateLoad', 'columnSorting', storedState);
                
                    return storedState.value;
                  };
                
                  var bindColumnSortingAfterClick = function () {
                    var instance = this;
                
                    instance.rootElement.on('click.handsontable', '.columnSorting', function (e) {
                      if (Handsontable.Dom.hasClass(e.target, 'columnSorting')) {
                        var col = getColumn(e.target);
                        plugin.sortByColumn.call(instance, col);
                      }
                    });
                
                    function countRowHeaders() {
                      var THs = instance.view.TBODY.querySelector('tr').querySelectorAll('th');
                      return THs.length;
                    }
                
                    function getColumn(target) {
                      var TH = Handsontable.Dom.closest(target, 'TH');
                      return Handsontable.Dom.index(TH) - countRowHeaders();
                    }
                  };
                
                  function enableObserveChangesPlugin () {
                    var instance = this;
                    instance._registerTimeout(setTimeout(function(){
                      instance.updateSettings({
                        observeChanges: true
                      });
                    }, 0));
                  }
                
                  function defaultSort(sortOrder) {
                    return function (a, b) {
                      if (a[1] === b[1]) {
                        return 0;
                      }
                      if (a[1] === null) {
                        return 1;
                      }
                      if (b[1] === null) {
                        return -1;
                      }
                      if (a[1] < b[1]) return sortOrder ? -1 : 1;
                      if (a[1] > b[1]) return sortOrder ? 1 : -1;
                      return 0;
                    }
                  }
                
                  function dateSort(sortOrder) {
                    return function (a, b) {
                      if (a[1] === b[1]) {
                        return 0;
                      }
                      if (a[1] === null) {
                        return 1;
                      }
                      if (b[1] === null) {
                        return -1;
                      }
                
                      var aDate = new Date(a[1]);
                      var bDate = new Date(b[1]);
                
                      if (aDate < bDate) return sortOrder ? -1 : 1;
                      if (aDate > bDate) return sortOrder ? 1 : -1;
                
                      return 0;
                    }
                  }
                
                  this.sort = function () {
                    var instance = this;
                
                    if (typeof instance.sortOrder == 'undefined') {
                      return;
                    }
                
                    instance.sortingEnabled = false; //this is required by translateRow plugin hook
                    instance.sortIndex.length = 0;
                
                    var colOffset = this.colOffset();
                    for (var i = 0, ilen = this.countRows() - instance.getSettings()['minSpareRows']; i < ilen; i++) {
                      this.sortIndex.push([i, instance.getDataAtCell(i, this.sortColumn + colOffset)]);
                    }
                
                    var colMeta = instance.getCellMeta(0, instance.sortColumn);
                    var sortFunction;
                    switch (colMeta.type) {
                      case 'date':
                        sortFunction = dateSort;
                        break;
                      default:
                        sortFunction = defaultSort;
                    }
                
                    this.sortIndex.sort(sortFunction(instance.sortOrder));
                
                    //Append spareRows
                    for(var i = this.sortIndex.length; i < instance.countRows(); i++){
                      this.sortIndex.push([i, instance.getDataAtCell(i, this.sortColumn + colOffset)]);
                    }
                
                    instance.sortingEnabled = true; //this is required by translateRow plugin hook
                  };
                
                  this.translateRow = function (row) {
                    var instance = this;
                
                    if (instance.sortingEnabled && instance.sortIndex && instance.sortIndex.length && instance.sortIndex[row]) {
                      return instance.sortIndex[row][0];
                    }
                
                    return row;
                  };
                
                  this.untranslateRow = function (row) {
                    var instance = this;
                    if (instance.sortingEnabled && instance.sortIndex && instance.sortIndex.length) {
                      for (var i = 0; i < instance.sortIndex.length; i++) {
                        if (instance.sortIndex[i][0] == row) {
                          return i;
                        }
                      }
                    }
                  };
                
                  this.getColHeader = function (col, TH) {
                    if (this.getSettings().columnSorting) {
                      Handsontable.Dom.addClass(TH.querySelector('.colHeader'), 'columnSorting');
                    }
                  };
                
                  function isSorted(instance){
                    return typeof instance.sortColumn != 'undefined';
                  }
                
                  this.afterCreateRow = function(index, amount){
                    var instance = this;
                
                    if(!isSorted(instance)){
                      return;
                    }
                
                
                    for(var i = 0; i < instance.sortIndex.length; i++){
                      if (instance.sortIndex[i][0] >= index){
                        instance.sortIndex[i][0] += amount;
                      }
                    }
                
                    for(var i=0; i < amount; i++){
                      instance.sortIndex.splice(index+i, 0, [index+i, instance.getData()[index+i][instance.sortColumn + instance.colOffset()]]);
                    }
                
                
                
                    saveSortingState.call(instance);
                
                  };
                
                  this.afterRemoveRow = function(index, amount){
                    var instance = this;
                
                    if(!isSorted(instance)){
                      return;
                    }
                
                    var physicalRemovedIndex = plugin.translateRow.call(instance, index);
                
                    instance.sortIndex.splice(index, amount);
                
                    for(var i = 0; i < instance.sortIndex.length; i++){
                
                      if (instance.sortIndex[i][0] > physicalRemovedIndex){
                        instance.sortIndex[i][0] -= amount;
                      }
                    }
                
                    saveSortingState.call(instance);
                
                  };
                
                  this.afterChangeSort = function (changes/*, source*/) {
                    var instance = this;
                    var sortColumnChanged = false;
                    var selection = {};
                    if (!changes) {
                      return;
                    }
                
                    for (var i = 0; i < changes.length; i++) {
                      if (changes[i][1] == instance.sortColumn) {
                        sortColumnChanged = true;
                        selection.row = plugin.translateRow.call(instance, changes[i][0]);
                        selection.col = changes[i][1];
                        break;
                      }
                    }
                
                    if (sortColumnChanged) {
                      instance._registerTimeout(setTimeout(function () {
                        plugin.sort.call(instance);
                        instance.render();
                        instance.selectCell(plugin.untranslateRow.call(instance, selection.row), selection.col);
                      }, 0));
                    }
                  };
                }
                var htSortColumn = new HandsontableColumnSorting();
                
                Handsontable.hooks.add('afterInit', function () {
                  htSortColumn.init.call(this, 'afterInit')
                });
                Handsontable.hooks.add('afterUpdateSettings', function () {
                  htSortColumn.init.call(this, 'afterUpdateSettings')
                });
                Handsontable.hooks.add('modifyRow', htSortColumn.translateRow);
                Handsontable.hooks.add('afterGetColHeader', htSortColumn.getColHeader);
                
                Handsontable.hooks.register('beforeColumnSort');
                Handsontable.hooks.register('afterColumnSort');
                
                
                (function (Handsontable) {
                  
                
                  function prepareVerticalAlignClass (className, alignment) {
                    if (className.indexOf(alignment)!= -1){
                      return className;
                    }
                
                    className =  className
                      .replace('htTop','')
                      .replace('htMiddle','')
                      .replace('htBottom','')
                      .replace('  ','');
                
                    className += " " + alignment;
                    return className;
                  }
                
                  function prepareHorizontalAlignClass (className, alignment) {
                    if (className.indexOf(alignment)!= -1){
                      return className;
                    }
                
                    className =  className
                      .replace('htLeft','')
                      .replace('htCenter','')
                      .replace('htRight','')
                      .replace('htJustify','')
                      .replace('  ','');
                
                    className += " " + alignment;
                    return className;
                  }
                
                  function doAlign (row, col, type, alignment) {
                      var cellMeta = this.getCellMeta(row, col),
                        className = alignment;
                
                      if (cellMeta.className) {
                        if(type === 'vertical') {
                          className = prepareVerticalAlignClass(cellMeta.className, alignment);
                        } else {
                          className = prepareHorizontalAlignClass(cellMeta.className, alignment);
                        }
                      }
                
                      this.setCellMeta(row, col, 'className',className);
                      this.render();
                  }
                
                  function align (range, type, alignment) {
                    if (range.from.row == range.to.row && range.from.col == range.to.col){
                      doAlign.call(this,range.from.row, range.from.col, type, alignment);
                    } else {
                      for(var row = range.from.row; row<= range.to.row; row++) {
                        for (var col = range.from.col; col <= range.to.col; col++) {
                          doAlign.call(this,row, col, type, alignment);
                        }
                      }
                    }
                  }
                
                  function ContextMenu(instance, customOptions){
                    this.instance = instance;
                    var contextMenu = this;
                		contextMenu.menus = [];
                		contextMenu.triggerRows = [];
                
                    this.enabled = true;
                
                    this.instance.addHook('afterDestroy', function () {
                       contextMenu.destroy();
                    });
                
                    this.defaultOptions = {
                      items: {
                        'row_above': {
                          name: 'Insert row above',
                          callback: function(key, selection){
                            this.alter("insert_row", selection.start.row);
                          },
                          disabled: function () {
                            var selected = this.getSelected(),
                              entireColumnSelection = [0,selected[1],this.view.wt.wtTable.getRowStrategy().cellCount-1,selected[1]],
                              columnSelected = entireColumnSelection.join(',') == selected.join(',');
                
                            return selected[0] < 0 || this.countRows() >= this.getSettings().maxRows || columnSelected;
                          }
                        },
                				'row_below': {
                          name: 'Insert row below',
                          callback: function(key, selection){
                            this.alter("insert_row", selection.end.row + 1);
                          },
                          disabled: function () {
                            var selected = this.getSelected(),
                              entireColumnSelection = [0,selected[1],this.view.wt.wtTable.getRowStrategy().cellCount-1,selected[1]],
                              columnSelected = entireColumnSelection.join(',') == selected.join(',');
                
                            return this.getSelected()[0] < 0 || this.countRows() >= this.getSettings().maxRows || columnSelected;
                          }
                        },
                        "hsep1": ContextMenu.SEPARATOR,
                        'col_left': {
                          name: 'Insert column on the left',
                          callback: function(key, selection){
                            this.alter("insert_col", selection.start.col);
                          },
                          disabled: function () {
                            var selected = this.getSelected(),
                              entireRowSelection = [selected[0],0, selected[0],this.view.wt.wtTable.getColumnStrategy().cellCount-1],
                              rowSelected = entireRowSelection.join(',') == selected.join(',');
                
                            return this.getSelected()[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
                          }
                        },
                        'col_right': {
                          name: 'Insert column on the right',
                          callback: function(key, selection){
                            this.alter("insert_col", selection.end.col + 1);
                          },
                          disabled: function () {
                            var selected = this.getSelected(),
                              entireRowSelection = [selected[0],0, selected[0],this.view.wt.wtTable.getColumnStrategy().cellCount-1],
                              rowSelected = entireRowSelection.join(',') == selected.join(',');
                
                            return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
                          }
                        },
                        "hsep2": ContextMenu.SEPARATOR,
                        'remove_row': {
                          name: 'Remove row',
                          callback: function(key, selection){
                            var amount = selection.end.row - selection.start.row + 1;
                            this.alter("remove_row", selection.start.row, amount);
                          },
                          disabled: function () {
                            var selected = this.getSelected(),
                              entireColumnSelection = [0,selected[1],this.view.wt.wtTable.getRowStrategy().cellCount-1,selected[1]],
                              columnSelected = entireColumnSelection.join(',') == selected.join(',');
                            return (selected[0] < 0 || columnSelected);
                          }
                        },
                        'remove_col': {
                          name: 'Remove column',
                          callback: function(key, selection){
                            var amount = selection.end.col - selection.start.col + 1;
                            this.alter("remove_col", selection.start.col, amount);
                          },
                          disabled: function (){
                            var selected = this.getSelected(),
                              entireRowSelection = [selected[0],0, selected[0],this.view.wt.wtTable.getColumnStrategy().cellCount-1],
                              rowSelected = entireRowSelection.join(',') == selected.join(',');
                            return (selected[1] < 0 || rowSelected);
                          }
                        },
                        "hsep3": ContextMenu.SEPARATOR,
                        'undo': {
                          name: 'Undo',
                          callback: function(){
                            this.undo();
                          },
                          disabled: function () {
                            return this.undoRedo && !this.undoRedo.isUndoAvailable();
                          }
                        },
                        'redo': {
                          name: 'Redo',
                          callback: function(){
                            this.redo();
                          },
                          disabled: function () {
                            return this.undoRedo && !this.undoRedo.isRedoAvailable();
                          }
                        },
                        "hsep4": ContextMenu.SEPARATOR,
                        'make_read_only': {
                          name: function() {
                            var label = "Read only";
                            var atLeastOneReadOnly = contextMenu.checkSelectionReadOnlyConsistency(this);
                            if (atLeastOneReadOnly) {
                              label = contextMenu.markSelected(label);
                            }
                            return label;
                          },
                          callback: function() {
                            var atLeastOneReadOnly = contextMenu.checkSelectionReadOnlyConsistency(this);
                
                            var that = this;
                            this.getSelectedRange().forAll(function(r, c) {
                              that.getCellMeta(r, c).readOnly = atLeastOneReadOnly ? false : true;
                            });
                
                            this.render();
                          }
                        },
                        "hsep5": ContextMenu.SEPARATOR,
                        'aligment':{
                          name: 'Alignment',
                          submenu: {
                            items: {
                							left: {
                								name: function () {
                									var label = "Left";
                									var hasClass = contextMenu.checkSelectionAlignment(this,'htLeft');
                
                									if (hasClass){
                										label = contextMenu.markSelected(label);
                									}
                									return label;
                								},
                								callback: function (){
                									align.call(this, this.getSelectedRange(),'horizontal','htLeft');
                								},
                								disabled: false
                							},
                							center: {
                								name: function () {
                									var label = "Center";
                									var hasClass = contextMenu.checkSelectionAlignment(this,'htCenter');
                
                									if (hasClass){
                										label = contextMenu.markSelected(label);
                									}
                									return label;
                								},
                								callback: function () {
                									align.call(this, this.getSelectedRange(),'horizontal','htCenter');
                								},
                								disabled: false
                							},
                							right: {
                								name: function () {
                									var label = "Right";
                									var hasClass = contextMenu.checkSelectionAlignment(this,'htRight');
                
                									if (hasClass){
                										label = contextMenu.markSelected(label);
                									}
                									return label;
                								},
                								callback: function () {
                									align.call(this, this.getSelectedRange(),'horizontal','htRight');
                								},
                								disabled: false
                							},
                							justify: {
                								name: function () {
                									var label = "Justify";
                									var hasClass = contextMenu.checkSelectionAlignment(this,'htJustify');
                
                									if (hasClass){
                										label = contextMenu.markSelected(label);
                									}
                									return label;
                								},
                								callback: function () {
                									align.call(this, this.getSelectedRange(),'horizontal','htJustify');
                								},
                								disabled: false
                							},
                							"hsep1": ContextMenu.SEPARATOR,
                							top: {
                								name: function () {
                									var label = "Top";
                									var hasClass = contextMenu.checkSelectionAlignment(this,'htTop');
                
                									if (hasClass){
                										label = contextMenu.markSelected(label);
                									}
                									return label;
                								},
                								callback: function() {
                									align.call(this, this.getSelectedRange(),'vertical','htTop');
                								},
                								disabled: false
                							},
                							middle:{
                								name: function () {
                									var label = "Middle";
                									var hasClass = contextMenu.checkSelectionAlignment(this,'htMiddle');
                
                									if (hasClass){
                										label = contextMenu.markSelected(label);
                									}
                									return label;
                								},
                								callback: function() {
                									align.call(this, this.getSelectedRange(),'vertical','htMiddle');
                								},
                								disabled: false
                							},
                							bottom: {
                								name: function () {
                									var label = "Bottom";
                									var hasClass = contextMenu.checkSelectionAlignment(this,'htBottom');
                
                									if (hasClass){
                										label = contextMenu.markSelected(label);
                									}
                									return label;
                								},
                								callback: function() {
                									align.call(this, this.getSelectedRange(),'vertical','htBottom');
                								},
                								disabled: false
                							}
                
                            }
                          }
                        }
                      }
                    };
                
                		contextMenu.options = {};
                
                		Handsontable.helper.extend(contextMenu.options, this.defaultOptions);
                
                		this.updateOptions(customOptions, this.options);
                
                		this.bindMouseEvents();
                
                    this.markSelected = function (label) {
                      return "<span class='selected'>✓</span>" + label;
                    };
                
                    this.checkSelectionAlignment = function (hot, className){
                      var hasAlignment = false;
                
                      hot.getSelectedRange().forAll(function(r, c) {
                        var metaClassName = hot.getCellMeta(r, c).className;
                        if (metaClassName && metaClassName.indexOf(className)!= -1) {
                          hasAlignment = true;
                          return false;
                        }
                      });
                
                      return hasAlignment;
                    };
                
                    this.checkSelectionReadOnlyConsistency = function(hot) {
                      var atLeastOneReadOnly = false;
                
                      hot.getSelectedRange().forAll(function(r, c) {
                        if(hot.getCellMeta(r, c).readOnly) {
                          atLeastOneReadOnly = true;
                          return false; //breaks forAll
                        }
                      });
                
                      return atLeastOneReadOnly;
                    };
                
                    Handsontable.hooks.run(instance, 'afterContextMenuDefaultOptions', this.defaultOptions);
                
                	}
                
                	ContextMenu.prototype.createMenu = function (menuName, row) {
                		if (menuName) {
                      menuName = menuName.replace(/ /g, '_'); // replace all spaces in name
                			menuName = 'htContextSubMenu_' + menuName;
                		}
                
                		var menu;
                		if (menuName) {
                			menu = $('body > .htContextMenu.' + menuName)[0];
                		} else {
                			menu = $('body > .htContextMenu')[0];
                		}
                
                		if(!menu){
                			menu = document.createElement('DIV');
                			Handsontable.Dom.addClass(menu, 'htContextMenu');
                			if(menuName) {
                				Handsontable.Dom.addClass(menu, menuName);
                			}
                			document.getElementsByTagName('body')[0].appendChild(menu);
                		}
                
                		if(this.menus.indexOf(menu) < 0){
                			this.menus.push(menu);
                			row = row || 0;
                			this.triggerRows.push(row);
                		}
                
                		return menu;
                	};
                
                	ContextMenu.prototype.bindMouseEvents = function (){
                    function contextMenuOpenListener(event){
                			this.closeAll();
                
                			event.preventDefault();
                      event.stopPropagation();
                
                      var showRowHeaders = this.instance.getSettings().rowHeaders,
                          showColHeaders = this.instance.getSettings().colHeaders;
                
                      if(!(showRowHeaders || showColHeaders)) {
                        if(event.target.nodeName != 'TD' && !(Handsontable.Dom.hasClass(event.target, 'current') && Handsontable.Dom.hasClass(event.target, 'wtBorder'))){
                          return;
                        }
                      }
                			var menu = this.createMenu();
                      var items = this.getItems(this.options);
                
                      this.show(menu, items);
                			this.setMenuPosition(event, menu);
                
                			$(document).on('mousedown.htContextMenu', Handsontable.helper.proxy(ContextMenu.prototype.closeAll, this));
                    }
                
                		this.instance.rootElement.on('contextmenu.htContextMenu', Handsontable.helper.proxy(contextMenuOpenListener, this));
                  };
                
                  ContextMenu.prototype.bindTableEvents = function () {
                    var that = this;
                
                    this._afterScrollCallback = function () {
                      // that.close();
                    };
                
                    this.instance.addHook('afterScrollVertically', this._afterScrollCallback);
                    this.instance.addHook('afterScrollHorizontally', this._afterScrollCallback);
                  };
                
                  ContextMenu.prototype.unbindTableEvents = function () {
                    if(this._afterScrollCallback){
                      this.instance.removeHook('afterScrollVertically', this._afterScrollCallback);
                      this.instance.removeHook('afterScrollHorizontally', this._afterScrollCallback);
                      this._afterScrollCallback = null;
                    }
                  };
                
                  ContextMenu.prototype.performAction = function (event, menu){
                		var contextMenu = this;
                		var hot = $(menu).handsontable('getInstance');
                		var selectedItemIndex = hot.getSelected()[0];
                    var selectedItem = hot.getData()[selectedItemIndex];
                
                		if (selectedItem.disabled === true || (typeof selectedItem.disabled == 'function' && selectedItem.disabled.call(this.instance) === true)){
                			return;
                		}
                
                		if (!selectedItem.hasOwnProperty('submenu')) {
                			if(typeof selectedItem.callback != 'function'){
                				return;
                			}
                			var selRange = this.instance.getSelectedRange();
                			var normalizedSelection = ContextMenu.utils.normalizeSelection(selRange);
                
                			selectedItem.callback.call(this.instance, selectedItem.key, normalizedSelection, event);
                			contextMenu.closeAll();
                      this.instance.deselectCell();
                		}
                  };
                
                  ContextMenu.prototype.unbindMouseEvents = function () {
                    this.instance.rootElement.off('contextmenu.htContextMenu');
                    $(document).off('mousedown.htContextMenu');
                  };
                
                  ContextMenu.prototype.show = function(menu, items){
                		menu.style.display = 'block';
                
                		var that = this;
                		$(menu)
                			.off('mousedown.htContextMenu')
                			.on('mousedown.htContextMenu',  function (event) {
                				that.performAction(event, menu)
                			});
                
                		$(menu).handsontable({
                      data: ContextMenu.utils.convertItemsToArray(items),
                      colHeaders: false,
                      colWidths: [200],
                      readOnly: true,
                      copyPaste: false,
                      columns: [
                        {
                          data: 'name',
                          renderer: Handsontable.helper.proxy(this.renderer, this)
                        }
                      ],
                      beforeKeyDown: function (event) {
                				that.onBeforeKeyDown(event, menu);
                			},
                			afterOnCellMouseOver: function (event, coords, TD) {
                				that.onCellMouseOver(event, coords, TD, menu);
                			},
                
                			renderAllRows: true
                    });
                
                		this.bindTableEvents();
                
                    $(menu).handsontable('listen');
                
                  };
                
                  ContextMenu.prototype.close = function (menu) {
                		this.hide(menu);
                    $(document).off('mousedown.htContextMenu');
                    this.unbindTableEvents();
                    this.instance.listen();
                  };
                
                	ContextMenu.prototype.closeAll = function () {
                		while(this.menus.length > 0) {
                			var menu = this.menus.pop();
                			if (menu) {
                				this.close(menu);
                			}
                
                		}
                		this.triggerRows = [];
                	};
                
                	ContextMenu.prototype.closeLastOpenedSubMenu = function (){
                		var menu = this.menus.pop();
                		if (menu) {
                			this.hide(menu);
                //			this.close(menu);
                		}
                
                	};
                
                  ContextMenu.prototype.hide = function(menu){
                		menu.style.display = 'none';
                		$(menu).handsontable('destroy');
                  };
                
                  ContextMenu.prototype.renderer = function(instance, TD, row, col, prop, value){
                    var contextMenu = this;
                    var item = instance.getData()[row];
                    var wrapper = document.createElement('DIV');
                
                    if(typeof value === 'function') {
                      value = value.call(this.instance);
                    }
                
                    Handsontable.Dom.empty(TD);
                    TD.appendChild(wrapper);
                
                    if(itemIsSeparator(item)){
                      Handsontable.Dom.addClass(TD, 'htSeparator');
                    } else {
                      Handsontable.Dom.fastInnerHTML(wrapper, value);
                    }
                
                    if (itemIsDisabled(item)){
                      Handsontable.Dom.addClass(TD, 'htDisabled');
                
                      $(wrapper).on('mouseenter', function () {
                        instance.deselectCell();
                      });
                
                    } else {
                			if (isSubMenu(item)) {
                				Handsontable.Dom.addClass(TD, 'htSubmenu');
                
                				$(wrapper).on('mouseenter', function () {
                					instance.selectCell(row, col);
                				});
                
                			} else {
                				Handsontable.Dom.removeClass(TD, 'htSubmenu');
                				Handsontable.Dom.removeClass(TD, 'htDisabled');
                
                				$(wrapper).on('mouseenter', function () {
                					instance.selectCell(row, col);
                				});
                			}
                    }
                
                
                		function isSubMenu(item) {
                			return item.hasOwnProperty('submenu');
                		}
                
                    function itemIsSeparator(item){
                      return new RegExp(ContextMenu.SEPARATOR, 'i').test(item.name);
                    }
                
                    function itemIsDisabled(item){
                      return item.disabled === true || (typeof item.disabled == 'function' && item.disabled.call(contextMenu.instance) === true);
                    }
                
                
                
                  };
                
                	ContextMenu.prototype.onCellMouseOver = function (event, coords, TD, menu) {
                
                		var hot = $(menu).handsontable('getInstance');
                    var menusLength = this.menus.length;
                
                    if (menusLength > 0) {
                      var lastMenu = this.menus[menusLength-1];
                      if(lastMenu.id != menu.id) {
                        this.closeLastOpenedSubMenu();
                      }
                    }else {
                      this.closeLastOpenedSubMenu();
                    }
                
                    if(TD.className.indexOf('htSubmenu')!=-1){
                      var selectedItem = hot.getData()[coords.row];
                      var items = this.getItems(selectedItem.submenu);
                
                      var subMenu = this.createMenu(selectedItem.name, coords.row);
                      var tdCoords = TD.getBoundingClientRect();
                
                      this.show(subMenu, items);
                      this.setSubMenuPosition(tdCoords, subMenu);
                
                    }
                	};
                
                  ContextMenu.prototype.onBeforeKeyDown = function (event, menu) {
                		var contextMenu = this;
                		var instance = $(menu).handsontable('getInstance');
                		var selection = instance.getSelected();
                
                    switch(event.keyCode){
                
                      case Handsontable.helper.keyCode.ESCAPE:
                        contextMenu.closeAll();
                        event.preventDefault();
                        event.stopImmediatePropagation();
                        break;
                
                      case Handsontable.helper.keyCode.ENTER:
                        if(selection){
                					contextMenu.performAction(event, menu);
                        }
                        break;
                
                      case Handsontable.helper.keyCode.ARROW_DOWN:
                
                				if(!selection){
                
                          selectFirstCell(instance, contextMenu);
                
                        } else {
                
                          selectNextCell(selection[0], selection[1], instance, contextMenu);
                
                        }
                
                        event.preventDefault();
                        event.stopImmediatePropagation();
                
                        break;
                
                      case Handsontable.helper.keyCode.ARROW_UP:
                        if(!selection){
                
                          selectLastCell(instance, contextMenu);
                
                        }  else {
                
                          selectPrevCell(selection[0], selection[1], instance, contextMenu);
                
                        }
                
                        event.preventDefault();
                        event.stopImmediatePropagation();
                
                        break;
                			case Handsontable.helper.keyCode.ARROW_RIGHT:
                				if(selection){
                					var row = selection[0];
                					var cell = instance.getCell(selection[0], 0);
                
                					if(ContextMenu.utils.hasSubMenu(cell)) {
                						openSubMenu(instance, contextMenu, cell, row);
                					}
                				}
                				event.preventDefault();
                				event.stopImmediatePropagation();
                
                				break;
                
                			case Handsontable.helper.keyCode.ARROW_LEFT:
                				if (selection) {
                
                					if (menu.className.indexOf('htContextSubMenu_')!= -1) {
                						contextMenu.closeLastOpenedSubMenu();
                						var index = contextMenu.menus.length;
                
                						if (index > 0){
                							menu = contextMenu.menus[index - 1];
                							var triggerRow = contextMenu.triggerRows.pop();
                							instance = $(menu).handsontable('getInstance');
                							instance.selectCell(triggerRow,0);
                						}
                
                					}
                
                					event.preventDefault();
                					event.stopImmediatePropagation();
                				}
                				break;
                
                
                    }
                
                    function selectFirstCell(instance) {
                
                			var firstCell = instance.getCell(0, 0);
                
                      if(ContextMenu.utils.isSeparator(firstCell) || ContextMenu.utils.isDisabled(firstCell)){
                        selectNextCell(0, 0, instance);
                      } else {
                        instance.selectCell(0, 0);
                      }
                
                    }
                
                
                    function selectLastCell(instance) {
                
                      var lastRow = instance.countRows() - 1;
                      var lastCell = instance.getCell(lastRow, 0);
                
                      if(ContextMenu.utils.isSeparator(lastCell) || ContextMenu.utils.isDisabled(lastCell)){
                        selectPrevCell(lastRow, 0, instance);
                      } else {
                        instance.selectCell(lastRow, 0);
                      }
                
                    }
                
                    function selectNextCell(row, col, instance){
                      var nextRow = row + 1;
                      var nextCell =  nextRow < instance.countRows() ? instance.getCell(nextRow, col) : null;
                
                      if(!nextCell){
                        return;
                      }
                
                      if(ContextMenu.utils.isSeparator(nextCell) || ContextMenu.utils.isDisabled(nextCell)){
                        selectNextCell(nextRow, col, instance);
                      } else {
                        instance.selectCell(nextRow, col);
                      }
                    }
                
                    function selectPrevCell(row, col, instance) {
                
                      var prevRow = row - 1;
                      var prevCell = prevRow >= 0 ? instance.getCell(prevRow, col) : null;
                
                      if (!prevCell) {
                        return;
                      }
                
                      if(ContextMenu.utils.isSeparator(prevCell) || ContextMenu.utils.isDisabled(prevCell)){
                        selectPrevCell(prevRow, col, instance);
                      } else {
                        instance.selectCell(prevRow, col);
                      }
                
                    }
                
                		function openSubMenu (instance, contextMenu, cell, row) {
                			var selectedItem = instance.getData()[row];
                			var items = contextMenu.getItems(selectedItem.submenu);
                			var subMenu = contextMenu.createMenu(selectedItem.name, row);
                			var coords = cell.getBoundingClientRect();
                
                			contextMenu.show(subMenu, items);
                			contextMenu.setSubMenuPosition(coords,subMenu);
                			var subMenuInstance = $(subMenu).handsontable('getInstance');
                			subMenuInstance.selectCell(0,0);
                		}
                
                  };
                
                  ContextMenu.prototype.getItems = function (options) {
                		var items = {};
                    function Item(rawItem){
                      if(typeof rawItem == 'string'){
                        this.name = rawItem;
                      } else {
                        Handsontable.helper.extend(this, rawItem);
                      }
                    }
                    Item.prototype = options;
                
                    for(var itemName in options.items){
                      if(options.items.hasOwnProperty(itemName) && (!this.itemsFilter || this.itemsFilter.indexOf(itemName) != -1)){
                        items[itemName] = new Item(options.items[itemName]);
                      }
                    }
                    return items;
                
                  };
                
                  ContextMenu.prototype.updateOptions = function(newOptions, options){
                    newOptions = newOptions || {};
                
                    if(newOptions.items){
                      for(var itemName in newOptions.items){
                        var item = {};
                
                        if(newOptions.items.hasOwnProperty(itemName)) {
                          if(this.defaultOptions.items.hasOwnProperty(itemName)
                            && Handsontable.helper.isObject(newOptions.items[itemName])){
                            Handsontable.helper.extend(item, this.defaultOptions.items[itemName]);
                            Handsontable.helper.extend(item, newOptions.items[itemName]);
                            newOptions.items[itemName] = item;
                          }
                        }
                
                      }
                    }
                
                		Handsontable.helper.extend(options, newOptions);
                  };
                
                	ContextMenu.prototype.setSubMenuPosition = function (coords, menu) {
                		var scrollTop = Handsontable.Dom.getWindowScrollTop();
                		var scrollLeft = Handsontable.Dom.getWindowScrollLeft();
                
                		var cursor = {
                			top: scrollTop + coords.top,
                			topRelative: coords.top ,
                			left: coords.left,
                			leftRelative: coords.left - scrollLeft,
                			scrollTop: scrollTop,
                			scrollLeft: scrollLeft,
                			cellHeight: coords.height,
                			cellWidth: coords.width
                		};
                
                		if(this.menuFitsBelowCursor(cursor, menu)){
                			this.positionMenuBelowCursor(cursor, menu, true);
                		} else {
                			if (this.menuFitsAboveCursor(cursor, menu)) {
                				this.positionMenuAboveCursor(cursor, menu, true);
                			} else {
                				this.positionMenuBelowCursor(cursor, menu, true);
                			}
                		}
                
                		if(this.menuFitsOnRightOfCursor(cursor, menu)){
                			this.positionMenuOnRightOfCursor(cursor, menu, true);
                		} else {
                			this.positionMenuOnLeftOfCursor(cursor, menu, true);
                		}
                	};
                
                  ContextMenu.prototype.setMenuPosition = function (event, menu) {
                    var cursorY = event.pageY;
                		var cursorX = event.pageX;
                		var scrollTop = Handsontable.Dom.getWindowScrollTop();
                    var scrollLeft = Handsontable.Dom.getWindowScrollLeft();
                
                    var cursor = {
                      top:  cursorY,
                      topRelative: cursorY - scrollTop,
                      left: cursorX,
                      leftRelative:cursorX - scrollLeft,
                      scrollTop: scrollTop,
                      scrollLeft: scrollLeft,
                			cellHeight: event.target.clientHeight,
                			cellWidth: event.target.clientWidth
                    };
                
                    if(this.menuFitsBelowCursor(cursor, menu)){
                      this.positionMenuBelowCursor(cursor, menu);
                    } else {
                      if (this.menuFitsAboveCursor(cursor, menu)) {
                        this.positionMenuAboveCursor(cursor, menu);
                      } else {
                        this.positionMenuBelowCursor(cursor, menu);
                      }
                    }
                
                    if(this.menuFitsOnRightOfCursor(cursor, menu)){
                      this.positionMenuOnRightOfCursor(cursor, menu);
                    } else {
                      this.positionMenuOnLeftOfCursor(cursor, menu);
                    }
                
                  };
                
                  ContextMenu.prototype.menuFitsAboveCursor = function (cursor, menu) {
                    return cursor.topRelative >= menu.offsetHeight;
                  };
                
                  ContextMenu.prototype.menuFitsBelowCursor = function (cursor, menu) {
                    return cursor.topRelative + menu.offsetHeight <= cursor.scrollTop + document.body.clientHeight;
                  };
                
                  ContextMenu.prototype.menuFitsOnRightOfCursor = function (cursor, menu) {
                    return cursor.leftRelative + menu.offsetWidth <= cursor.scrollLeft + document.body.clientWidth;
                  };
                
                  ContextMenu.prototype.positionMenuBelowCursor = function (cursor, menu) {
                		menu.style.top = cursor.top + 'px';
                  };
                
                  ContextMenu.prototype.positionMenuAboveCursor = function (cursor, menu, subMenu) {
                    if (subMenu) {
                			menu.style.top = (cursor.top + cursor.cellHeight  - menu.offsetHeight) + 'px';
                		} else {
                			menu.style.top = (cursor.top - menu.offsetHeight) + 'px';
                		}
                  };
                
                  ContextMenu.prototype.positionMenuOnRightOfCursor = function (cursor, menu, subMenu) {
                    if (subMenu) {
                			menu.style.left = 1 + cursor.left + cursor.cellWidth  + 'px';
                		} else {
                			menu.style.left = 1 + cursor.left + 'px';
                		}
                  };
                
                  ContextMenu.prototype.positionMenuOnLeftOfCursor = function (cursor, menu, subMenu) {
                    if (subMenu) {
                			menu.style.left = (cursor.left - menu.offsetWidth) + 'px';
                		} else {
                			menu.style.left = (cursor.left - menu.offsetWidth) + 'px';
                		}
                  };
                
                  ContextMenu.utils = {};
                  ContextMenu.utils.convertItemsToArray = function (items) {
                    var itemArray = [];
                    var item;
                    for(var itemName in items){
                      if(items.hasOwnProperty(itemName)){
                        if(typeof items[itemName] == 'string'){
                          item = {name: items[itemName]};
                        } else if (items[itemName].visible !== false) {
                          item = items[itemName];
                        } else {
                          continue;
                        }
                
                        item.key = itemName;
                        itemArray.push(item);
                      }
                    }
                
                    return itemArray;
                  };
                
                  ContextMenu.utils.normalizeSelection = function(selRange){
                    return {
                      start: selRange.getTopLeftCorner(),
                      end: selRange.getBottomRightCorner()
                    }
                  };
                
                  ContextMenu.utils.isSeparator = function (cell) {
                    return Handsontable.Dom.hasClass(cell, 'htSeparator');
                  };
                
                	ContextMenu.utils.hasSubMenu = function (cell){
                		return Handsontable.Dom.hasClass(cell, 'htSubmenu');
                	};
                
                  ContextMenu.utils.isDisabled = function (cell) {
                    return Handsontable.Dom.hasClass(cell, 'htDisabled');
                  };
                
                  ContextMenu.prototype.enable = function () {
                    if(!this.enabled){
                      this.enabled = true;
                      this.bindMouseEvents();
                    }
                  };
                
                  ContextMenu.prototype.disable = function () {
                    if(this.enabled){
                      this.enabled = false;
                      this.closeAll();
                      this.unbindMouseEvents();
                      this.unbindTableEvents();
                    }
                  };
                
                  ContextMenu.prototype.destroy = function () {
                    this.closeAll();
                		while(this.menus.length > 0) {
                			var menu = this.menus.pop();
                			this.triggerRows.pop();
                			if (menu) {
                				this.close(menu);
                				if(!this.isMenuEnabledByOtherHotInstance()){
                					this.removeMenu(menu);
                				}
                			}
                		}
                
                    this.unbindMouseEvents();
                    this.unbindTableEvents();
                
                  };
                
                  ContextMenu.prototype.isMenuEnabledByOtherHotInstance = function () {
                    var hotContainers = $('.handsontable');
                    var menuEnabled = false;
                
                    for(var i = 0, len = hotContainers.length; i < len; i++){
                      var instance = $(hotContainers[i]).handsontable('getInstance');
                      if(instance && instance.getSettings().contextMenu){
                        menuEnabled = true;
                        break;
                      }
                    }
                
                    return menuEnabled;
                  };
                
                  ContextMenu.prototype.removeMenu = function (menu) {
                		if(menu.parentNode){
                      this.menu.parentNode.removeChild(menu);
                    }
                  };
                
                  ContextMenu.prototype.filterItems = function(itemsToLeave){
                    this.itemsFilter = itemsToLeave;
                  };
                
                  ContextMenu.SEPARATOR = "---------";
                
                  function updateHeight() {
                
                    if(this.rootElement[0].className.indexOf('htContextMenu')) {
                      return;
                    }
                
                    var realSeparatorHeight = 0,
                        realEntrySize = 0,
                        dataSize = this.getSettings().data.length;
                
                    for(var i = 0; i < dataSize; i++) {
                      if(this.getSettings().data[i].name == ContextMenu.SEPARATOR) {
                        realSeparatorHeight += 2;
                      } else {
                        realEntrySize += 26;
                      }
                    }
                
                    this.view.wt.wtScrollbars.vertical.fixedContainer.style.height = realEntrySize + realSeparatorHeight + "px";
                  }
                
                  function init(){
                    var instance = this;
                    var contextMenuSetting = instance.getSettings().contextMenu;
                    var customOptions = Handsontable.helper.isObject(contextMenuSetting) ? contextMenuSetting : {};
                
                    if(contextMenuSetting){
                      if(!instance.contextMenu){
                        instance.contextMenu = new ContextMenu(instance, customOptions);
                      }
                
                      instance.contextMenu.enable();
                
                      if(Handsontable.helper.isArray(contextMenuSetting)){
                        instance.contextMenu.filterItems(contextMenuSetting);
                      }
                
                    }  else if(instance.contextMenu){
                      instance.contextMenu.destroy();
                      delete instance.contextMenu;
                    }
                
                  }
                
                  Handsontable.hooks.add('afterInit', init);
                  Handsontable.hooks.add('afterUpdateSettings', init);
                  Handsontable.hooks.add('afterInit',updateHeight);
                
                  if(Handsontable.PluginHooks.register) { //HOT 0.11+
                    Handsontable.PluginHooks.register('afterContextMenuDefaultOptions');
                  }
                
                
                
                  Handsontable.ContextMenu = ContextMenu;
                
                })(Handsontable);
                
                function Comments(instance) {
                
                  var doSaveComment = function (row, col, comment, instance) {
                      instance.setCellMeta(row, col, 'comment', comment);
                      instance.render();
                    },
                    saveComment = function (range, comment, instance) {
                		 //LIKE IN EXCEL (TOP LEFT CELL)
                      doSaveComment(range.from.row, range.from.col, comment, instance);
                    },
                    hideCommentTextArea = function () {
                      var commentBox = createCommentBox();
                      commentBox.style.display = 'none';
                      commentBox.value = '';
                    },
                    bindMouseEvent = function (range) {
                
                			function commentsListener(event) {
                				$(document).off('mouseover.htCommment');
                        if (!(event.target.className == 'htCommentTextArea' || event.target.innerHTML.indexOf('Comment') != -1)) {
                          var value = document.getElementsByClassName('htCommentTextArea')[0].value;
                          if (value.trim().length > 1) {
                            saveComment(range, value, instance);
                          }
                		      unBindMouseEvent();
                          hideCommentTextArea();
                        }
                      }
                
                      $(document).on('mousedown.htCommment', Handsontable.helper.proxy(commentsListener));
                    },
                    unBindMouseEvent = function () {
                      $(document).off('mousedown.htCommment');
                			$(document).on('mouseover.htCommment', Handsontable.helper.proxy(commentsMouseOverListener));
                    },
                    placeCommentBox = function (range, commentBox) {
                      var TD = instance.view.wt.wtTable.getCell(range.from),
                        offset = Handsontable.Dom.offset(TD),
                        lastColWidth = instance.getColWidth(range.from.col);
                
                      commentBox.style.position = 'absolute';
                      commentBox.style.left = offset.left + lastColWidth + 'px';
                      commentBox.style.top = offset.top + 'px';
                      commentBox.style.zIndex = 2;
                      bindMouseEvent(range, commentBox);
                    },
                    createCommentBox = function (value) {
                      var comments = document.getElementsByClassName('htComments')[0];
                
                      if (!comments) {
                        comments = document.createElement('DIV');
                
                        var textArea = document.createElement('TEXTAREA');
                        Handsontable.Dom.addClass(textArea, 'htCommentTextArea');
                        comments.appendChild(textArea);
                
                        Handsontable.Dom.addClass(comments, 'htComments');
                        document.getElementsByTagName('body')[0].appendChild(comments);
                      }
                
                			value = value ||'';
                
                      document.getElementsByClassName('htCommentTextArea')[0].value = value;
                
                      //var tA = document.getElementsByClassName('htCommentTextArea')[0];
                      //tA.focus();
                      return comments;
                    },
                    commentsMouseOverListener = function (event) {
                        if(event.target.className.indexOf('htCommentCell') != -1) {
                						unBindMouseEvent();
                            var coords = instance.view.wt.wtTable.getCoords(event.target);
                            var range = {
                                from: new WalkontableCellCoords(coords.row, coords.col)
                            };
                
                            Handsontable.Comments.showComment(range);
                        }
                        else if(event.target.className !='htCommentTextArea'){
                            hideCommentTextArea();
                        }
                    };
                
                  return {
                    init: function () {
                        $(document).on('mouseover.htCommment', Handsontable.helper.proxy(commentsMouseOverListener));
                    },
                    showComment: function (range) {
                			var meta = instance.getCellMeta(range.from.row, range.from.col),
                        value = '';
                
                      if (meta.comment) {
                        value = meta.comment;
                      }
                      var commentBox = createCommentBox(value);
                      commentBox.style.display = 'block';
                      placeCommentBox(range, commentBox);
                    },
                    removeComment: function (row, col) {
                      instance.removeCellMeta(row, col, 'comment');
                      instance.render();
                    },
                    checkSelectionCommentsConsistency : function () {
                      var hasComment = false;
                      // IN EXCEL THERE IS COMMENT ONLY FOR TOP LEFT CELL IN SELECTION
                      var cell = instance.getSelectedRange().from;
                
                      if(instance.getCellMeta(cell.row,cell.col).comment) {
                        hasComment = true;
                      }
                      return hasComment;
                    }
                
                
                  };
                }
                
                
                var init = function () {
                    var instance = this;
                    var commentsSetting = instance.getSettings().comments;
                
                    if (commentsSetting) {
                      Handsontable.Comments = new Comments(instance);
                        Handsontable.Comments.init();
                    }
                  },
                  afterRenderer = function (TD, row, col, prop, value, cellProperties) {
                    if(cellProperties.comment) {
                      Handsontable.Dom.addClass(TD, cellProperties.commentedCellClassName);
                    }
                  },
                  addCommentsActionsToContextMenu = function (defaultOptions) {
                    var instance = this;
                    if (!instance.getSettings().comments) {
                      return;
                    }
                
                    defaultOptions.items.commentsCellsSeparator = Handsontable.ContextMenu.SEPARATOR;
                
                    defaultOptions.items.commentsAddEdit = {
                      name: function () {
                        var hasComment = Handsontable.Comments.checkSelectionCommentsConsistency();
                        return hasComment ? "Edit Comment" : "Add Comment";
                
                      },
                      callback: function (key, selection, event) {
                          Handsontable.Comments.showComment(this.getSelectedRange());
                      },
                      disabled: function () {
                        return false;
                      }
                    };
                
                    defaultOptions.items.commentsRemove = {
                      name: function () {
                        return "Delete Comment"
                      },
                      callback: function (key, selection, event) {
                        Handsontable.Comments.removeComment(selection.start.row, selection.start.col);
                      },
                      disabled: function () {
                        var hasComment = Handsontable.Comments.checkSelectionCommentsConsistency();
                        return !hasComment;
                      }
                    }
                  };
                
                Handsontable.hooks.add('beforeInit', init);
                Handsontable.hooks.add('afterContextMenuDefaultOptions', addCommentsActionsToContextMenu);
                Handsontable.hooks.add('afterRenderer', afterRenderer);
                //$(document).on('mouseover.htCommment', Handsontable.helper.proxy(commentsMouseOverListener));
                
                /**
                 * HandsontableManualColumnMove
                 *
                 * Has 2 UI components:
                 * - handle - the draggable element that sets the desired position of the column
                 * - guide - the helper guide that shows the desired position as a vertical guide
                 *
                 * Warning! Whenever you make a change in this file, make an analogous change in manualRowMove.js
                 * @constructor
                 */
                (function (Handsontable) {
                function HandsontableManualColumnMove() {
                  var startCol
                    , endCol
                    , startX
                    , startOffset
                    , currentCol
                    , instance
                    , currentTH
                    , handle = document.createElement('DIV')
                    , guide = document.createElement('DIV')
                    , $window = $(window);
                
                  handle.className = 'manualColumnMover';
                  guide.className = 'manualColumnMoverGuide';
                
                  var saveManualColumnPositions = function () {
                    var instance = this;
                    Handsontable.hooks.run(instance, 'persistentStateSave', 'manualColumnPositions', instance.manualColumnPositions);
                  };
                
                  var loadManualColumnPositions = function () {
                    var instance = this;
                    var storedState = {};
                    Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualColumnPositions', storedState);
                    return storedState.value;
                  };
                
                  function setupHandlePosition(TH) {
                    instance = this;
                    currentTH = TH;
                
                    var col = this.view.wt.wtTable.getCoords(TH).col; //getCoords returns WalkontableCellCoords
                    if (col >= 0) { //if not row header
                      currentCol = col;
                      var box = currentTH.getBoundingClientRect();
                      startOffset = box.left;
                      handle.style.top = box.top + 'px';
                      handle.style.left = startOffset + 'px';
                      instance.rootElement[0].appendChild(handle);
                    }
                  }
                
                  function refreshHandlePosition(TH) {
                    var box = TH.getBoundingClientRect();
                    handle.style.left = box.left + 'px';
                  }
                
                  function setupGuidePosition() {
                    var instance = this;
                    Handsontable.Dom.addClass(handle, 'active');
                    Handsontable.Dom.addClass(guide, 'active');
                    var box = currentTH.getBoundingClientRect();
                    guide.style.width = box.width + 'px';
                    guide.style.height = instance.view.maximumVisibleElementHeight(0) + 'px';
                    guide.style.top = handle.style.top;
                    guide.style.left = startOffset + 'px';
                    instance.rootElement[0].appendChild(guide);
                  }
                
                  function refreshGuidePosition(diff) {
                    guide.style.left = startOffset + diff + 'px';
                  }
                
                  function hideHandleAndGuide() {
                    Handsontable.Dom.removeClass(handle, 'active');
                    Handsontable.Dom.removeClass(guide, 'active');
                  }
                
                  var bindEvents = function () {
                    var instance = this;
                    var pressed;
                
                    instance.rootElement.on('mouseenter.manualColumnMove.' + instance.guid, 'table thead tr > th', function (e) {
                      if (pressed) {
                        endCol = instance.view.wt.wtTable.getCoords(e.currentTarget).col;
                        refreshHandlePosition(e.currentTarget);
                      }
                      else {
                        setupHandlePosition.call(instance, e.currentTarget);
                      }
                    });
                
                    instance.rootElement.on('mousedown.manualColumnMove.' + instance.guid, '.manualColumnMover', function (e) {
                      startX = e.pageX;
                      setupGuidePosition.call(instance);
                      pressed = instance;
                
                      startCol = currentCol;
                      endCol = currentCol;
                    });
                
                    $window.on('mousemove.manualColumnMove.' + instance.guid, function (e) {
                      if (pressed) {
                        refreshGuidePosition(e.pageX - startX);
                      }
                    });
                
                    $window.on('mouseup.manualColumnMove.' + instance.guid, function () {
                      if (pressed) {
                        hideHandleAndGuide();
                        pressed = false;
                
                        if (startCol < endCol) {
                          endCol--;
                        }
                        createPositionData(instance.manualColumnPositions, instance.countCols());
                        instance.manualColumnPositions.splice(endCol, 0, instance.manualColumnPositions.splice(startCol, 1)[0]);
                
                        instance.forceFullRender = true;
                        instance.view.render(); //updates all
                
                        saveManualColumnPositions.call(instance);
                
                        Handsontable.hooks.run(instance, 'afterColumnMove', startCol, endCol);
                
                        setupHandlePosition.call(instance, currentTH);
                      }
                    });
                
                    instance.addHook('afterDestroy', unbindEvents);
                  };
                
                  var unbindEvents = function(){
                    var instance = this;
                    instance.rootElement.off('mouseenter.manualColumnMove.' + instance.guid, 'table thead tr > th');
                    instance.rootElement.off('mousedown.manualColumnMove.' + instance.guid, '.manualColumnMover');
                    $window.off('mousemove.manualColumnMove.' + instance.guid);
                    $window.off('mouseup.manualColumnMove.' + instance.guid);
                  };
                
                  var createPositionData = function (positionArr, len) {
                    if (positionArr.length < len) {
                      for (var i = positionArr.length; i < len; i++) {
                        positionArr[i] = i;
                      }
                    }
                  };
                
                  this.beforeInit = function () {
                    this.manualColumnPositions = [];
                  };
                
                  this.init = function (source) {
                    var instance = this;
                
                    var manualColMoveEnabled = !!(this.getSettings().manualColumnMove);
                
                    if (manualColMoveEnabled) {
                      var initialManualColumnPositions = this.getSettings().manualColumnMove;
                
                      var loadedManualColumnPositions = loadManualColumnPositions.call(instance);
                
                      if (typeof loadedManualColumnPositions != 'undefined') {
                        this.manualColumnPositions = loadedManualColumnPositions;
                      } else if (initialManualColumnPositions instanceof Array) {
                        this.manualColumnPositions = initialManualColumnPositions;
                      } else {
                        this.manualColumnPositions = [];
                      }
                
                      if (source == 'afterInit') {
                        bindEvents.call(this);
                        if (this.manualColumnPositions.length > 0) {
                          this.forceFullRender = true;
                          this.render();
                        }
                      }
                
                    } else {
                      unbindEvents.call(this);
                      this.manualColumnPositions = [];
                    }
                  };
                
                  this.modifyCol = function (col) {
                    //TODO test performance: http://jsperf.com/object-wrapper-vs-primitive/2
                    if (this.getSettings().manualColumnMove) {
                      if (typeof this.manualColumnPositions[col] === 'undefined') {
                        createPositionData(this.manualColumnPositions, col + 1);
                      }
                      return this.manualColumnPositions[col];
                    }
                    return col;
                  };
                
                }
                var htManualColumnMove = new HandsontableManualColumnMove();
                
                Handsontable.hooks.add('beforeInit', htManualColumnMove.beforeInit);
                Handsontable.hooks.add('afterInit', function () {
                  htManualColumnMove.init.call(this, 'afterInit')
                });
                
                Handsontable.hooks.add('afterUpdateSettings', function () {
                  htManualColumnMove.init.call(this, 'afterUpdateSettings')
                });
                Handsontable.hooks.add('modifyCol', htManualColumnMove.modifyCol);
                
                Handsontable.hooks.register('afterColumnMove');
                
                })(Handsontable);
                
                
                
                /**
                 * HandsontableManualColumnResize
                 *
                 * Has 2 UI components:
                 * - handle - the draggable element that sets the desired width of the column
                 * - guide - the helper guide that shows the desired width as a vertical guide
                 *
                 * Warning! Whenever you make a change in this file, make an analogous change in manualRowResize.js
                 * @constructor
                 */
                (function (Handsontable) {
                function HandsontableManualColumnResize() {
                  var currentTH
                    , currentCol
                    , currentWidth
                    , instance
                    , newSize
                    , startX
                    , startWidth
                    , startOffset
                    , handle = document.createElement('DIV')
                    , guide = document.createElement('DIV')
                    , $window = $(window);
                
                  handle.className = 'manualColumnResizer';
                  guide.className = 'manualColumnResizerGuide';
                
                  var saveManualColumnWidths = function () {
                    var instance = this;
                    Handsontable.hooks.run(instance, 'persistentStateSave', 'manualColumnWidths', instance.manualColumnWidths);
                  };
                
                  var loadManualColumnWidths = function () {
                    var instance = this;
                    var storedState = {};
                    Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualColumnWidths', storedState);
                    return storedState.value;
                  };
                
                  function setupHandlePosition(TH) {
                    instance = this;
                    currentTH = TH;
                
                    var col = this.view.wt.wtTable.getCoords(TH).col; //getCoords returns WalkontableCellCoords
                    if (col >= 0) { //if not row header
                      currentCol = col;
                      var box = currentTH.getBoundingClientRect();
                      startOffset = box.left - 6;
                      startWidth = parseInt(box.width, 10);
                      handle.style.top = box.top + 'px';
                      handle.style.left = startOffset + startWidth + 'px';
                      instance.rootElement[0].appendChild(handle);
                    }
                  }
                
                  function refreshHandlePosition() {
                    handle.style.left = startOffset + currentWidth + 'px';
                  }
                
                  function setupGuidePosition() {
                    var instance = this;
                    Handsontable.Dom.addClass(handle, 'active');
                    Handsontable.Dom.addClass(guide, 'active');
                    guide.style.top = handle.style.top;
                    guide.style.left = handle.style.left;
                    guide.style.height = instance.view.maximumVisibleElementHeight(0) + 'px';
                    instance.rootElement[0].appendChild(guide);
                  }
                
                  function refreshGuidePosition() {
                    guide.style.left = handle.style.left;
                  }
                
                  function hideHandleAndGuide() {
                    Handsontable.Dom.removeClass(handle, 'active');
                    Handsontable.Dom.removeClass(guide, 'active');
                  }
                
                  var bindEvents = function () {
                    var instance = this;
                    var pressed;
                    var dblclick = 0;
                    var autoresizeTimeout = null;
                
                    instance.rootElement.on('mouseenter.manualColumnResize.' + instance.guid, 'table thead tr > th', function (e) {
                      if (!pressed) {
                        setupHandlePosition.call(instance, e.currentTarget);
                      }
                    });
                
                    instance.rootElement.on('mousedown.manualColumnResize.' + instance.guid, '.manualColumnResizer', function (e) {
                      setupGuidePosition.call(instance);
                      pressed = instance;
                
                      if (autoresizeTimeout == null) {
                        autoresizeTimeout = setTimeout(function () {
                          if (dblclick >= 2) {
                            newSize = instance.determineColumnWidth.call(instance, currentCol);
                            setManualSize(currentCol, newSize);
                            instance.forceFullRender = true;
                            instance.view.render(); //updates all
                            Handsontable.hooks.run(instance, 'afterColumnResize', currentCol, newSize);
                          }
                          dblclick = 0;
                          autoresizeTimeout = null;
                        }, 500);
                        instance._registerTimeout(autoresizeTimeout);
                      }
                      dblclick++;
                
                      startX = e.pageX;
                      newSize = startWidth;
                    });
                
                    $window.on('mousemove.manualColumnResize.' + instance.guid, function (e) {
                      if (pressed) {
                        currentWidth = startWidth + (e.pageX - startX);
                        newSize = setManualSize(currentCol, currentWidth); //save col width
                        refreshHandlePosition();
                        refreshGuidePosition();
                      }
                    });
                
                    $window.on('mouseup.manualColumnResize.' + instance.guid, function () {
                      if (pressed) {
                        hideHandleAndGuide();
                        pressed = false;
                
                        if(newSize != startWidth){
                          instance.forceFullRender = true;
                          instance.view.render(); //updates all
                
                          saveManualColumnWidths.call(instance);
                
                          Handsontable.hooks.run(instance, 'afterColumnResize', currentCol, newSize);
                        }
                
                        setupHandlePosition.call(instance, currentTH);
                      }
                    });
                
                    instance.addHook('afterDestroy', unbindEvents);
                  };
                
                  var unbindEvents = function(){
                    var instance = this;
                    instance.rootElement.off('mouseenter.manualColumnResize.' + instance.guid, 'table thead tr > th');
                    instance.rootElement.off('mousedown.manualColumnResize.' + instance.guid, '.manualColumnResizer');
                    $window.off('mousemove.manualColumnResize.' + instance.guid);
                    $window.off('mouseup.manualColumnResize.' + instance.guid);
                  };
                
                  this.beforeInit = function () {
                    this.manualColumnWidths = [];
                  };
                
                  this.init = function (source) {
                    var instance = this;
                    var manualColumnWidthEnabled = !!(this.getSettings().manualColumnResize);
                
                    if (manualColumnWidthEnabled) {
                      var initialColumnWidths = this.getSettings().manualColumnResize;
                
                      var loadedManualColumnWidths = loadManualColumnWidths.call(instance);
                
                      if (typeof loadedManualColumnWidths != 'undefined') {
                        this.manualColumnWidths = loadedManualColumnWidths;
                      } else if (initialColumnWidths instanceof Array) {
                        this.manualColumnWidths = initialColumnWidths;
                      } else {
                        this.manualColumnWidths = [];
                      }
                
                      if (source == 'afterInit') {
                        bindEvents.call(this);
                        if (this.manualColumnWidths.length > 0) {
                          this.forceFullRender = true;
                          this.render();
                        }
                      }
                    }
                    else {
                      unbindEvents.call(this);
                      this.manualColumnWidths = [];
                    }
                  };
                
                
                  var setManualSize = function (col, width) {
                    width = Math.max(width, 20);
                
                    /**
                     *  We need to run col through modifyCol hook, in case the order of displayed columns is different than the order
                     *  in data source. For instance, this order can be modified by manualColumnMove plugin.
                     */
                    col = Handsontable.hooks.execute(instance, 'modifyCol', col);
                
                    instance.manualColumnWidths[col] = width;
                    return width;
                  };
                
                  this.modifyColWidth = function (width, col) {
                    col = this.runHooksAndReturn('modifyCol', col);
                    if (this.getSettings().manualColumnResize && this.manualColumnWidths[col]) {
                      return this.manualColumnWidths[col];
                    }
                    return width;
                  };
                }
                var htManualColumnResize = new HandsontableManualColumnResize();
                
                Handsontable.hooks.add('beforeInit', htManualColumnResize.beforeInit);
                Handsontable.hooks.add('afterInit', function () {
                  htManualColumnResize.init.call(this, 'afterInit')
                });
                Handsontable.hooks.add('afterUpdateSettings', function () {
                  htManualColumnResize.init.call(this, 'afterUpdateSettings')
                });
                Handsontable.hooks.add('modifyColWidth', htManualColumnResize.modifyColWidth);
                
                Handsontable.hooks.register('afterColumnResize');
                
                })(Handsontable);
                /**
                 * HandsontableManualRowResize
                 *
                 * Has 2 UI components:
                 * - handle - the draggable element that sets the desired height of the row
                 * - guide - the helper guide that shows the desired height as a horizontal guide
                 *
                 * Warning! Whenever you make a change in this file, make an analogous change in manualRowResize.js
                 * @constructor
                 */
                (function (Handsontable) {
                  function HandsontableManualRowResize () {
                
                    var currentTH
                      , currentRow
                      , currentHeight
                      , instance
                      , newSize
                      , startY
                      , startHeight
                      , startOffset
                      , handle = document.createElement('DIV')
                      , guide = document.createElement('DIV')
                      , $window = $(window);
                
                    handle.className = 'manualRowResizer';
                    guide.className = 'manualRowResizerGuide';
                
                    var saveManualRowHeights = function () {
                      var instance = this;
                      Handsontable.hooks.run(instance, 'persistentStateSave', 'manualRowHeights', instance.manualRowHeights);
                    };
                
                    var loadManualRowHeights = function () {
                      var instance = this
                        , storedState = {};
                      Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualRowHeights', storedState);
                      return storedState.value;
                    };
                
                    function setupHandlePosition(TH) {
                      instance = this;
                      currentTH = TH;
                
                      var row = this.view.wt.wtTable.getCoords(TH).row; //getCoords returns WalkontableCellCoords
                      if (row >= 0) { //if not col header
                        currentRow = row;
                        var box = currentTH.getBoundingClientRect();
                        startOffset = box.top - 6;
                        startHeight = parseInt(box.height, 10);
                        handle.style.left = box.left + 'px';
                        handle.style.top = startOffset + startHeight + 'px';
                        instance.rootElement[0].appendChild(handle);
                      }
                    }
                
                    function refreshHandlePosition() {
                      handle.style.top = startOffset + currentHeight + 'px';
                    }
                
                    function setupGuidePosition() {
                      var instance = this;
                      Handsontable.Dom.addClass(handle, 'active');
                      Handsontable.Dom.addClass(guide, 'active');
                      guide.style.top = handle.style.top;
                      guide.style.left = handle.style.left;
                      guide.style.width = instance.view.maximumVisibleElementWidth(0) + 'px';
                      instance.rootElement[0].appendChild(guide);
                    }
                
                    function refreshGuidePosition() {
                      guide.style.top = handle.style.top;
                    }
                
                    function hideHandleAndGuide() {
                      Handsontable.Dom.removeClass(handle, 'active');
                      Handsontable.Dom.removeClass(guide, 'active');
                    }
                
                    var bindEvents = function () {
                      var instance = this;
                      var pressed;
                      var dblclick = 0;
                      var autoresizeTimeout = null;
                
                      instance.rootElement.on('mouseenter.manualRowResize.' + instance.guid, 'table tbody tr > th', function (e) {
                        if (!pressed) {
                          setupHandlePosition.call(instance, e.currentTarget);
                        }
                      });
                
                      instance.rootElement.on('mousedown.manualRowResize.' + instance.guid, '.manualRowResizer', function (e) {
                        setupGuidePosition.call(instance);
                        pressed = instance;
                
                        if (autoresizeTimeout == null) {
                          autoresizeTimeout = setTimeout(function () {
                            if (dblclick >= 2) {
                              setManualSize(currentRow, null); //double click sets auto row size
                              instance.forceFullRender = true;
                              instance.view.render(); //updates all
                              Handsontable.hooks.run(instance, 'afterRowResize', currentRow, newSize);
                            }
                            dblclick = 0;
                            autoresizeTimeout = null;
                          }, 500);
                          instance._registerTimeout(autoresizeTimeout);
                        }
                        dblclick++;
                
                        startY = e.pageY;
                        newSize = startHeight;
                      });
                
                      $window.on('mousemove.manualRowResize.' + instance.guid, function (e) {
                        if (pressed) {
                          currentHeight = startHeight + (e.pageY - startY);
                          newSize = setManualSize(currentRow, currentHeight);
                          refreshHandlePosition();
                          refreshGuidePosition();
                        }
                      });
                
                      $window.on('mouseup.manualRowResize.' + instance.guid, function () {
                        if (pressed) {
                          hideHandleAndGuide();
                          pressed = false;
                
                          if(newSize != startHeight){
                            instance.forceFullRender = true;
                            instance.view.render(); //updates all
                
                            saveManualRowHeights.call(instance);
                
                            Handsontable.hooks.run(instance, 'afterRowResize', currentRow, newSize);
                          }
                
                          setupHandlePosition.call(instance, currentTH);
                        }
                      });
                
                      instance.addHook('afterDestroy', unbindEvents);
                    };
                
                    var unbindEvents = function(){
                      var instance = this;
                      instance.rootElement.off('mouseenter.manualRowResize.' + instance.guid, 'table tbody tr > th');
                      instance.rootElement.off('mousedown.manualRowResize.' + instance.guid, '.manualRowResizer');
                      $window.off('mousemove.manualRowResize.' + instance.guid);
                      $window.off('mouseup.manualRowResize.' + instance.guid);
                    };
                
                    this.beforeInit = function () {
                      this.manualRowHeights = [];
                    };
                
                    this.init = function (source) {
                
                      var instance = this;
                      var manualColumnHeightEnabled = !!(this.getSettings().manualRowResize);
                
                      if (manualColumnHeightEnabled) {
                
                        var initialRowHeights = this.getSettings().manualRowResize;
                
                        var loadedManualRowHeights = loadManualRowHeights.call(instance);
                
                        if (typeof loadedManualRowHeights != 'undefined') {
                          this.manualRowHeights = loadedManualRowHeights;
                        } else if (initialRowHeights instanceof Array) {
                          this.manualRowHeights = initialRowHeights;
                        } else {
                          this.manualRowHeights = [];
                        }
                
                        if (source === 'afterInit') {
                          bindEvents.call(this);
                          if (this.manualRowHeights.length > 0) {
                            this.forceFullRender = true;
                            this.render();
                          }
                        }
                        else {
                          this.forceFullRender = true;
                          this.render();
                
                        }
                      }
                      else {
                        unbindEvents.call(this);
                        this.manualRowHeights = [];
                      }
                    };
                
                    var setManualSize = function (row, height) {
                      row = Handsontable.hooks.execute(instance, 'modifyRow', row);
                
                      instance.manualRowHeights[row] = height;
                      return height;
                    };
                
                    this.modifyRowHeight = function (height, row) {
                      if (this.getSettings().manualRowResize) {
                        row = this.runHooksAndReturn('modifyRow', row);
                        if (this.manualRowHeights[row] !== void 0) {
                          return this.manualRowHeights[row];
                        }
                      }
                      return height;
                    };
                  }
                
                  var htManualRowResize = new HandsontableManualRowResize();
                
                  Handsontable.hooks.add('beforeInit', htManualRowResize.beforeInit);
                  Handsontable.hooks.add('afterInit', function () {
                    htManualRowResize.init.call(this, 'afterInit');
                  });
                
                  Handsontable.hooks.add('afterUpdateSettings', function () {
                    htManualRowResize.init.call(this, 'afterUpdateSettings')
                  });
                
                  Handsontable.hooks.add('modifyRowHeight', htManualRowResize.modifyRowHeight);
                
                  Handsontable.hooks.register('afterRowResize');
                
                })(Handsontable);
                
                (function HandsontableObserveChanges() {
                
                  Handsontable.hooks.add('afterLoadData', init);
                  Handsontable.hooks.add('afterUpdateSettings', init);
                
                  Handsontable.hooks.register('afterChangesObserved');
                
                  function init() {
                    var instance = this;
                    var pluginEnabled = instance.getSettings().observeChanges;
                
                    if (pluginEnabled) {
                      if(instance.observer) {
                        destroy.call(instance); //destroy observer for old data object
                      }
                      createObserver.call(instance);
                      bindEvents.call(instance);
                
                    } else if (!pluginEnabled){
                      destroy.call(instance);
                    }
                  }
                
                  function createObserver(){
                    var instance = this;
                
                    instance.observeChangesActive = true;
                
                    instance.pauseObservingChanges = function(){
                      instance.observeChangesActive = false;
                    };
                
                    instance.resumeObservingChanges = function(){
                      instance.observeChangesActive = true;
                    };
                
                    instance.observedData = instance.getData();
                    instance.observer = jsonpatch.observe(instance.observedData, function (patches) {
                      if(instance.observeChangesActive){
                        runHookForOperation.call(instance, patches);
                        instance.render();
                      }
                
                      instance.runHooks('afterChangesObserved');
                    });
                  }
                
                  function runHookForOperation(rawPatches){
                    var instance = this;
                    var patches = cleanPatches(rawPatches);
                
                    for(var i = 0, len = patches.length; i < len; i++){
                      var patch = patches[i];
                      var parsedPath = parsePath(patch.path);
                
                
                      switch(patch.op){
                        case 'add':
                          if(isNaN(parsedPath.col)){
                            instance.runHooks('afterCreateRow', parsedPath.row);
                          } else {
                            instance.runHooks('afterCreateCol', parsedPath.col);
                          }
                          break;
                
                        case 'remove':
                          if(isNaN(parsedPath.col)){
                            instance.runHooks('afterRemoveRow', parsedPath.row, 1);
                          } else {
                            instance.runHooks('afterRemoveCol', parsedPath.col, 1);
                          }
                          break;
                
                        case 'replace':
                          instance.runHooks('afterChange', [parsedPath.row, parsedPath.col, null, patch.value], 'external');
                          break;
                      }
                    }
                
                    function cleanPatches(rawPatches){
                      var patches;
                
                      patches = removeLengthRelatedPatches(rawPatches);
                      patches = removeMultipleAddOrRemoveColPatches(patches);
                
                      return patches;
                    }
                
                    /**
                     * Removing or adding column will produce one patch for each table row.
                     * This function leaves only one patch for each column add/remove operation
                     */
                    function removeMultipleAddOrRemoveColPatches(rawPatches){
                      var newOrRemovedColumns = [];
                
                      return rawPatches.filter(function(patch){
                        var parsedPath = parsePath(patch.path);
                
                        if(['add', 'remove'].indexOf(patch.op) != -1 && !isNaN(parsedPath.col)){
                          if(newOrRemovedColumns.indexOf(parsedPath.col) != -1){
                            return false;
                          } else {
                            newOrRemovedColumns.push(parsedPath.col);
                          }
                        }
                
                        return true;
                      });
                
                    }
                
                    /**
                     * If observeChanges uses native Object.observe method, then it produces patches for length property.
                     * This function removes them.
                     */
                    function removeLengthRelatedPatches(rawPatches){
                      return rawPatches.filter(function(patch){
                        return !/[/]length/ig.test(patch.path);
                      })
                    }
                
                    function parsePath(path){
                      var match = path.match(/^\/(\d+)\/?(.*)?$/);
                      return {
                        row: parseInt(match[1], 10),
                        col: /^\d*$/.test(match[2]) ? parseInt(match[2], 10) : match[2]
                      }
                    }
                  }
                
                  function destroy(){
                    var instance = this;
                
                    if (instance.observer){
                      destroyObserver.call(instance);
                      unbindEvents.call(instance);
                    }
                  }
                
                  function destroyObserver(){
                    var instance = this;
                
                    jsonpatch.unobserve(instance.observedData, instance.observer);
                    delete instance.observeChangesActive;
                    delete instance.pauseObservingChanges;
                    delete instance.resumeObservingChanges;
                  }
                
                  function bindEvents(){
                    var instance = this;
                    instance.addHook('afterDestroy', destroy);
                
                    instance.addHook('afterCreateRow', afterTableAlter);
                    instance.addHook('afterRemoveRow', afterTableAlter);
                
                    instance.addHook('afterCreateCol', afterTableAlter);
                    instance.addHook('afterRemoveCol', afterTableAlter);
                
                    instance.addHook('afterChange', function(changes, source){
                      if(source != 'loadData'){
                        afterTableAlter.call(this);
                      }
                    });
                  }
                
                  function unbindEvents(){
                    var instance = this;
                    instance.removeHook('afterDestroy', destroy);
                
                    instance.removeHook('afterCreateRow', afterTableAlter);
                    instance.removeHook('afterRemoveRow', afterTableAlter);
                
                    instance.removeHook('afterCreateCol', afterTableAlter);
                    instance.removeHook('afterRemoveCol', afterTableAlter);
                
                    instance.removeHook('afterChange', afterTableAlter);
                  }
                
                  function afterTableAlter(){
                    var instance = this;
                
                    instance.pauseObservingChanges();
                
                    instance.addHookOnce('afterChangesObserved', function(){
                      instance.resumeObservingChanges();
                    });
                
                  }
                })();
                
                
                /*
                 *
                 * Plugin enables saving table state
                 *
                 * */
                
                
                function Storage(prefix) {
                
                  var savedKeys;
                
                  var saveSavedKeys = function () {
                    window.localStorage[prefix + '__' + 'persistentStateKeys'] = JSON.stringify(savedKeys);
                  };
                
                  var loadSavedKeys = function () {
                    var keysJSON = window.localStorage[prefix + '__' + 'persistentStateKeys'];
                    var keys = typeof keysJSON == 'string' ? JSON.parse(keysJSON) : void 0;
                    savedKeys = keys ? keys : [];
                  };
                
                  var clearSavedKeys = function () {
                    savedKeys = [];
                    saveSavedKeys();
                  };
                
                  loadSavedKeys();
                
                  this.saveValue = function (key, value) {
                    window.localStorage[prefix + '_' + key] = JSON.stringify(value);
                    if (savedKeys.indexOf(key) == -1) {
                      savedKeys.push(key);
                      saveSavedKeys();
                    }
                
                  };
                
                  this.loadValue = function (key, defaultValue) {
                
                    key = typeof key != 'undefined' ? key : defaultValue;
                
                    var value = window.localStorage[prefix + '_' + key];
                
                    return typeof value == "undefined" ? void 0 : JSON.parse(value);
                
                  };
                
                  this.reset = function (key) {
                    window.localStorage.removeItem(prefix + '_' + key);
                  };
                
                  this.resetAll = function () {
                    for (var index = 0; index < savedKeys.length; index++) {
                      window.localStorage.removeItem(prefix + '_' + savedKeys[index]);
                    }
                
                    clearSavedKeys();
                  };
                
                }
                
                
                (function (StorageClass) {
                  function HandsontablePersistentState() {
                    var plugin = this;
                
                
                    this.init = function () {
                      var instance = this,
                        pluginSettings = instance.getSettings()['persistentState'];
                
                      plugin.enabled = !!(pluginSettings);
                
                      if (!plugin.enabled) {
                        removeHooks.call(instance);
                        return;
                      }
                
                      if (!instance.storage) {
                        instance.storage = new StorageClass(instance.rootElement[0].id);
                      }
                
                      instance.resetState = plugin.resetValue;
                
                      addHooks.call(instance);
                
                    };
                
                    this.saveValue = function (key, value) {
                      var instance = this;
                
                      instance.storage.saveValue(key, value);
                    };
                
                    this.loadValue = function (key, saveTo) {
                      var instance = this;
                
                      saveTo.value = instance.storage.loadValue(key);
                    };
                
                    this.resetValue = function (key) {
                      var instance = this;
                
                      if (typeof  key != 'undefined') {
                        instance.storage.reset(key);
                      } else {
                        instance.storage.resetAll();
                      }
                
                    };
                
                    var hooks = {
                      'persistentStateSave': plugin.saveValue,
                      'persistentStateLoad': plugin.loadValue,
                      'persistentStateReset': plugin.resetValue
                    };
                
                    for (var hookName in hooks) {
                      if (hooks.hasOwnProperty(hookName)) {
                        Handsontable.hooks.register(hookName);
                      }
                    }
                
                    function addHooks() {
                      var instance = this;
                
                      for (var hookName in hooks) {
                        if (hooks.hasOwnProperty(hookName)) {
                          instance.addHook(hookName, hooks[hookName]);
                        }
                      }
                    }
                
                    function removeHooks() {
                      var instance = this;
                
                      for (var hookName in hooks) {
                        if (hooks.hasOwnProperty(hookName)) {
                          instance.removeHook(hookName, hooks[hookName]);
                        }
                      }
                    }
                  }
                
                  var htPersistentState = new HandsontablePersistentState();
                  Handsontable.hooks.add('beforeInit', htPersistentState.init);
                  Handsontable.hooks.add('afterUpdateSettings', htPersistentState.init);
                })(Storage);
                
                /**
                 * Handsontable UndoRedo class
                 */
                (function(Handsontable){
                  Handsontable.UndoRedo = function (instance) {
                    var plugin = this;
                    this.instance = instance;
                    this.doneActions = [];
                    this.undoneActions = [];
                    this.ignoreNewActions = false;
                    instance.addHook("afterChange", function (changes, origin) {
                      if(changes){
                        var action = new Handsontable.UndoRedo.ChangeAction(changes);
                        plugin.done(action);
                      }
                    });
                
                    instance.addHook("afterCreateRow", function (index, amount, createdAutomatically) {
                
                      if (createdAutomatically) {
                        return;
                      }
                
                      var action = new Handsontable.UndoRedo.CreateRowAction(index, amount);
                      plugin.done(action);
                    });
                
                    instance.addHook("beforeRemoveRow", function (index, amount) {
                      var originalData = plugin.instance.getData();
                      index = ( originalData.length + index ) % originalData.length;
                      var removedData = originalData.slice(index, index + amount);
                      var action = new Handsontable.UndoRedo.RemoveRowAction(index, removedData);
                      plugin.done(action);
                    });
                
                    instance.addHook("afterCreateCol", function (index, amount, createdAutomatically) {
                
                      if (createdAutomatically) {
                        return;
                      }
                
                      var action = new Handsontable.UndoRedo.CreateColumnAction(index, amount);
                      plugin.done(action);
                    });
                
                    instance.addHook("beforeRemoveCol", function (index, amount) {
                      var originalData = plugin.instance.getData();
                      index = ( plugin.instance.countCols() + index ) % plugin.instance.countCols();
                      var removedData = [];
                
                      for (var i = 0, len = originalData.length; i < len; i++) {
                        removedData[i] = originalData[i].slice(index, index + amount);
                      }
                
                      var headers;
                      if(Handsontable.helper.isArray(instance.getSettings().colHeaders)){
                        headers = instance.getSettings().colHeaders.slice(index, index + removedData.length);
                      }
                
                      var action = new Handsontable.UndoRedo.RemoveColumnAction(index, removedData, headers);
                      plugin.done(action);
                    });
                  };
                
                  Handsontable.UndoRedo.prototype.done = function (action) {
                    if (!this.ignoreNewActions) {
                      this.doneActions.push(action);
                      this.undoneActions.length = 0;
                    }
                  };
                
                  /**
                   * Undo operation from current revision
                   */
                  Handsontable.UndoRedo.prototype.undo = function () {
                    if (this.isUndoAvailable()) {
                      var action = this.doneActions.pop();
                
                      this.ignoreNewActions = true;
                      var that = this;
                      action.undo(this.instance, function () {
                        that.ignoreNewActions = false;
                        that.undoneActions.push(action);
                      });
                
                
                
                    }
                  };
                
                  /**
                   * Redo operation from current revision
                   */
                  Handsontable.UndoRedo.prototype.redo = function () {
                    if (this.isRedoAvailable()) {
                      var action = this.undoneActions.pop();
                
                      this.ignoreNewActions = true;
                      var that = this;
                      action.redo(this.instance, function () {
                        that.ignoreNewActions = false;
                        that.doneActions.push(action);
                      });
                
                
                
                    }
                  };
                
                  /**
                   * Returns true if undo point is available
                   * @return {Boolean}
                   */
                  Handsontable.UndoRedo.prototype.isUndoAvailable = function () {
                    return this.doneActions.length > 0;
                  };
                
                  /**
                   * Returns true if redo point is available
                   * @return {Boolean}
                   */
                  Handsontable.UndoRedo.prototype.isRedoAvailable = function () {
                    return this.undoneActions.length > 0;
                  };
                
                  /**
                   * Clears undo history
                   */
                  Handsontable.UndoRedo.prototype.clear = function () {
                    this.doneActions.length = 0;
                    this.undoneActions.length = 0;
                  };
                
                  Handsontable.UndoRedo.Action = function () {
                  };
                  Handsontable.UndoRedo.Action.prototype.undo = function () {
                  };
                  Handsontable.UndoRedo.Action.prototype.redo = function () {
                  };
                
                  Handsontable.UndoRedo.ChangeAction = function (changes) {
                    this.changes = changes;
                  };
                  Handsontable.helper.inherit(Handsontable.UndoRedo.ChangeAction, Handsontable.UndoRedo.Action);
                  Handsontable.UndoRedo.ChangeAction.prototype.undo = function (instance, undoneCallback) {
                    var data = $.extend(true, [], this.changes),
                        emptyRowsAtTheEnd = instance.countEmptyRows(true),
                        emptyColsAtTheEnd = instance.countEmptyCols(true);
                
                    for (var i = 0, len = data.length; i < len; i++) {
                      data[i].splice(3, 1);
                    }
                
                    instance.addHookOnce('afterChange', undoneCallback);
                
                    instance.setDataAtRowProp(data, null, null, 'undo');
                
                    for (var i = 0, len = data.length; i < len; i++) {
                     if(instance.getSettings().minSpareRows &&
                      data[i][0] + 1 + instance.getSettings().minSpareRows === instance.countRows()
                      && emptyRowsAtTheEnd == instance.getSettings().minSpareRows) {
                        instance.alter('remove_row', parseInt(data[i][0]+1,10), instance.getSettings().minSpareRows);
                
                        instance.undoRedo.doneActions.pop();
                
                      }
                
                      if (instance.getSettings().minSpareCols &&
                      data[i][1] + 1 + instance.getSettings().minSpareCols === instance.countCols()
                      && emptyColsAtTheEnd == instance.getSettings().minSpareCols) {
                        instance.alter('remove_col', parseInt(data[i][1]+1,10), instance.getSettings().minSpareCols);
                
                        instance.undoRedo.doneActions.pop();
                      }
                    }
                
                  };
                  Handsontable.UndoRedo.ChangeAction.prototype.redo = function (instance, onFinishCallback) {
                    var data = $.extend(true, [], this.changes);
                    for (var i = 0, len = data.length; i < len; i++) {
                      data[i].splice(2, 1);
                    }
                
                    instance.addHookOnce('afterChange', onFinishCallback);
                
                    instance.setDataAtRowProp(data, null, null, 'redo');
                
                  };
                
                  Handsontable.UndoRedo.CreateRowAction = function (index, amount) {
                    this.index = index;
                    this.amount = amount;
                  };
                  Handsontable.helper.inherit(Handsontable.UndoRedo.CreateRowAction, Handsontable.UndoRedo.Action);
                  Handsontable.UndoRedo.CreateRowAction.prototype.undo = function (instance, undoneCallback) {
                    instance.addHookOnce('afterRemoveRow', undoneCallback);
                    instance.alter('remove_row', this.index, this.amount);
                  };
                  Handsontable.UndoRedo.CreateRowAction.prototype.redo = function (instance, redoneCallback) {
                    instance.addHookOnce('afterCreateRow', redoneCallback);
                    instance.alter('insert_row', this.index + 1, this.amount);
                  };
                
                  Handsontable.UndoRedo.RemoveRowAction = function (index, data) {
                    this.index = index;
                    this.data = data;
                  };
                  Handsontable.helper.inherit(Handsontable.UndoRedo.RemoveRowAction, Handsontable.UndoRedo.Action);
                  Handsontable.UndoRedo.RemoveRowAction.prototype.undo = function (instance, undoneCallback) {
                    var spliceArgs = [this.index, 0];
                    Array.prototype.push.apply(spliceArgs, this.data);
                
                    Array.prototype.splice.apply(instance.getData(), spliceArgs);
                
                    instance.addHookOnce('afterRender', undoneCallback);
                    instance.render();
                  };
                  Handsontable.UndoRedo.RemoveRowAction.prototype.redo = function (instance, redoneCallback) {
                    instance.addHookOnce('afterRemoveRow', redoneCallback);
                    instance.alter('remove_row', this.index, this.data.length);
                  };
                
                  Handsontable.UndoRedo.CreateColumnAction = function (index, amount) {
                    this.index = index;
                    this.amount = amount;
                  };
                  Handsontable.helper.inherit(Handsontable.UndoRedo.CreateColumnAction, Handsontable.UndoRedo.Action);
                  Handsontable.UndoRedo.CreateColumnAction.prototype.undo = function (instance, undoneCallback) {
                    instance.addHookOnce('afterRemoveCol', undoneCallback);
                    instance.alter('remove_col', this.index, this.amount);
                  };
                  Handsontable.UndoRedo.CreateColumnAction.prototype.redo = function (instance, redoneCallback) {
                    instance.addHookOnce('afterCreateCol', redoneCallback);
                    instance.alter('insert_col', this.index + 1, this.amount);
                  };
                
                  Handsontable.UndoRedo.RemoveColumnAction = function (index, data, headers) {
                    this.index = index;
                    this.data = data;
                    this.amount = this.data[0].length;
                    this.headers = headers;
                  };
                  Handsontable.helper.inherit(Handsontable.UndoRedo.RemoveColumnAction, Handsontable.UndoRedo.Action);
                  Handsontable.UndoRedo.RemoveColumnAction.prototype.undo = function (instance, undoneCallback) {
                    var row, spliceArgs;
                    for (var i = 0, len = instance.getData().length; i < len; i++) {
                      row = instance.getSourceDataAtRow(i);
                
                      spliceArgs = [this.index, 0];
                      Array.prototype.push.apply(spliceArgs, this.data[i]);
                
                      Array.prototype.splice.apply(row, spliceArgs);
                
                    }
                
                    if(typeof this.headers != 'undefined'){
                      spliceArgs = [this.index, 0];
                      Array.prototype.push.apply(spliceArgs, this.headers);
                      Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArgs);
                    }
                
                    instance.addHookOnce('afterRender', undoneCallback);
                    instance.render();
                  };
                  Handsontable.UndoRedo.RemoveColumnAction.prototype.redo = function (instance, redoneCallback) {
                    instance.addHookOnce('afterRemoveCol', redoneCallback);
                    instance.alter('remove_col', this.index, this.amount);
                  };
                })(Handsontable);
                
                (function(Handsontable){
                
                  function init(){
                    var instance = this;
                    var pluginEnabled = typeof instance.getSettings().undo == 'undefined' || instance.getSettings().undo;
                
                    if(pluginEnabled){
                      if(!instance.undoRedo){
                        instance.undoRedo = new Handsontable.UndoRedo(instance);
                
                        exposeUndoRedoMethods(instance);
                
                        instance.addHook('beforeKeyDown', onBeforeKeyDown);
                        instance.addHook('afterChange', onAfterChange);
                      }
                    } else {
                      if(instance.undoRedo){
                        delete instance.undoRedo;
                
                        removeExposedUndoRedoMethods(instance);
                
                        instance.removeHook('beforeKeyDown', onBeforeKeyDown);
                        instance.removeHook('afterChange', onAfterChange);
                      }
                    }
                  }
                
                  function onBeforeKeyDown(event){
                    var instance = this;
                
                    var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
                
                    if(ctrlDown){
                      if (event.keyCode === 89 || (event.shiftKey && event.keyCode === 90)) { //CTRL + Y or CTRL + SHIFT + Z
                        instance.undoRedo.redo();
                        event.stopImmediatePropagation();
                      }
                      else if (event.keyCode === 90) { //CTRL + Z
                        instance.undoRedo.undo();
                        event.stopImmediatePropagation();
                      }
                    }
                  }
                
                  function onAfterChange(changes, source){
                    var instance = this;
                    if (source == 'loadData'){
                      return instance.undoRedo.clear();
                    }
                  }
                
                  function exposeUndoRedoMethods(instance){
                    instance.undo = function(){
                      return instance.undoRedo.undo();
                    };
                
                    instance.redo = function(){
                      return instance.undoRedo.redo();
                    };
                
                    instance.isUndoAvailable = function(){
                      return instance.undoRedo.isUndoAvailable();
                    };
                
                    instance.isRedoAvailable = function(){
                      return instance.undoRedo.isRedoAvailable();
                    };
                
                    instance.clearUndo = function(){
                      return instance.undoRedo.clear();
                    };
                  }
                
                  function removeExposedUndoRedoMethods(instance){
                    delete instance.undo;
                    delete instance.redo;
                    delete instance.isUndoAvailable;
                    delete instance.isRedoAvailable;
                    delete instance.clearUndo;
                  }
                
                  Handsontable.hooks.add('afterInit', init);
                  Handsontable.hooks.add('afterUpdateSettings', init);
                
                })(Handsontable);
                
                /**
                 * Plugin used to scroll Handsontable by selecting a cell and dragging outside of visible viewport
                 * @constructor
                 */
                function DragToScroll() {
                  this.boundaries = null;
                  this.callback = null;
                }
                
                /**
                 * @param boundaries {Object} compatible with getBoundingClientRect
                 */
                DragToScroll.prototype.setBoundaries = function (boundaries) {
                  this.boundaries = boundaries;
                };
                
                /**
                 * @param callback {Function}
                 */
                DragToScroll.prototype.setCallback = function (callback) {
                  this.callback = callback;
                };
                
                /**
                 * Check if mouse position (x, y) is outside of the viewport
                 * @param x
                 * @param y
                 */
                DragToScroll.prototype.check = function (x, y) {
                  var diffX = 0;
                  var diffY = 0;
                
                  if (y < this.boundaries.top) {
                    //y is less than top
                    diffY = y - this.boundaries.top;
                  }
                  else if (y > this.boundaries.bottom) {
                    //y is more than bottom
                    diffY = y - this.boundaries.bottom;
                  }
                
                  if (x < this.boundaries.left) {
                    //x is less than left
                    diffX = x - this.boundaries.left;
                  }
                  else if (x > this.boundaries.right) {
                    //x is more than right
                    diffX = x - this.boundaries.right;
                  }
                
                  this.callback(diffX, diffY);
                };
                
                var dragToScroll;
                var instance;
                
                if (typeof Handsontable !== 'undefined') {
                  var setupListening = function (instance) {
                    instance.dragToScrollListening = false;
                    var scrollHandler = instance.view.wt.wtScrollbars.vertical.scrollHandler; //native scroll
                    dragToScroll = new DragToScroll();
                    if (scrollHandler === window) {
                      //not much we can do currently
                      return;
                    }
                    else if (scrollHandler) {
                      dragToScroll.setBoundaries(scrollHandler.getBoundingClientRect());
                    }
                    else {
                      dragToScroll.setBoundaries(instance.$table[0].getBoundingClientRect());
                    }
                
                    dragToScroll.setCallback(function (scrollX, scrollY) {
                      if (scrollX < 0) {
                        if (scrollHandler) {
                          scrollHandler.scrollLeft -= 50;
                        }
                        else {
                          instance.view.wt.scrollHorizontal(-1).draw();
                        }
                      }
                      else if (scrollX > 0) {
                        if (scrollHandler) {
                          scrollHandler.scrollLeft += 50;
                        }
                        else {
                          instance.view.wt.scrollHorizontal(1).draw();
                        }
                      }
                
                      if (scrollY < 0) {
                        if (scrollHandler) {
                          scrollHandler.scrollTop -= 20;
                        }
                        else {
                          instance.view.wt.scrollVertical(-1).draw();
                        }
                      }
                      else if (scrollY > 0) {
                        if (scrollHandler) {
                          scrollHandler.scrollTop += 20;
                        }
                        else {
                          instance.view.wt.scrollVertical(1).draw();
                        }
                      }
                    });
                
                    instance.dragToScrollListening = true;
                  };
                
                  Handsontable.hooks.add('afterInit', function () {
                    var instance = this;
                
                    $(document).on('mouseup.' + this.guid, function () {
                      instance.dragToScrollListening = false;
                    });
                
                    $(document).on('mousemove.' + this.guid, function (event) {
                      if (instance.dragToScrollListening) {
                        dragToScroll.check(event.clientX, event.clientY);
                      }
                    });
                  });
                
                  Handsontable.hooks.add('afterDestroy', function () {
                    $(document).off('.' + this.guid);
                  });
                
                  Handsontable.hooks.add('afterOnCellMouseDown', function () {
                    setupListening(this);
                  });
                
                  Handsontable.hooks.add('afterOnCellCornerMouseDown', function () {
                    setupListening(this);
                  });
                
                  Handsontable.plugins.DragToScroll = DragToScroll;
                }
                
                (function (Handsontable, CopyPaste, SheetClip) {
                
                  function CopyPastePlugin(instance) {
                    this.copyPasteInstance = CopyPaste.getInstance();
                
                    this.copyPasteInstance.onCut(onCut);
                    this.copyPasteInstance.onPaste(onPaste);
                    var plugin = this;
                
                    instance.addHook('beforeKeyDown', onBeforeKeyDown);
                
                    function onCut() {
                      if (!instance.isListening()) {
                        return;
                      }
                
                      instance.selection.empty();
                    }
                
                    function onPaste(str) {
                      if (!instance.isListening() || !instance.selection.isSelected()) {
                        return;
                      }
                
                      var input = str.replace(/^[\r\n]*/g, '').replace(/[\r\n]*$/g, '') //remove newline from the start and the end of the input
                        , inputArray = SheetClip.parse(input)
                        , selected = instance.getSelected()
                        , coordsFrom = new WalkontableCellCoords(selected[0], selected[1])
                        , coordsTo = new WalkontableCellCoords(selected[2], selected[3])
                        , cellRange = new WalkontableCellRange(coordsFrom, coordsFrom, coordsTo)
                        , topLeftCorner = cellRange.getTopLeftCorner()
                        , bottomRightCorner = cellRange.getBottomRightCorner()
                        , areaStart = topLeftCorner
                        , areaEnd = new WalkontableCellCoords(
                          Math.max(bottomRightCorner.row, inputArray.length - 1 + topLeftCorner.row),
                          Math.max(bottomRightCorner.col, inputArray[0].length - 1 + topLeftCorner.col)
                        );
                
                      instance.addHookOnce('afterChange', function (changes, source) {
                        if (changes && changes.length) {
                          this.selectCell(areaStart.row, areaStart.col, areaEnd.row, areaEnd.col);
                        }
                      });
                
                      instance.populateFromArray(areaStart.row, areaStart.col, inputArray, areaEnd.row, areaEnd.col, 'paste', instance.getSettings().pasteMode);
                    };
                
                    function onBeforeKeyDown (event) {
                      if (Handsontable.helper.isCtrlKey(event.keyCode) && instance.getSelected()) {
                        //when CTRL is pressed, prepare selectable text in textarea
                        //http://stackoverflow.com/questions/3902635/how-does-one-capture-a-macs-command-key-via-javascript
                        plugin.setCopyableText();
                        event.stopImmediatePropagation();
                        return;
                      }
                
                      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
                
                      if (event.keyCode == Handsontable.helper.keyCode.A && ctrlDown) {
                        instance._registerTimeout(setTimeout(Handsontable.helper.proxy(plugin.setCopyableText, plugin), 0));
                      }
                
                    }
                
                    this.destroy = function () {
                      this.copyPasteInstance.removeCallback(onCut);
                      this.copyPasteInstance.removeCallback(onPaste);
                      this.copyPasteInstance.destroy();
                      instance.removeHook('beforeKeyDown', onBeforeKeyDown);
                    };
                
                    instance.addHook('afterDestroy', Handsontable.helper.proxy(this.destroy, this));
                
                    this.triggerPaste = Handsontable.helper.proxy(this.copyPasteInstance.triggerPaste, this.copyPasteInstance);
                    this.triggerCut = Handsontable.helper.proxy(this.copyPasteInstance.triggerCut, this.copyPasteInstance);
                
                    /**
                     * Prepares copyable text in the invisible textarea
                     */
                    this.setCopyableText = function () {
                
                      var settings = instance.getSettings();
                      var copyRowsLimit = settings.copyRowsLimit;
                      var copyColsLimit = settings.copyColsLimit;
                
                      var selRange = instance.getSelectedRange();
                      var topLeft = selRange.getTopLeftCorner();
                      var bottomRight = selRange.getBottomRightCorner();
                      var startRow = topLeft.row;
                      var startCol = topLeft.col;
                      var endRow = bottomRight.row;
                      var endCol = bottomRight.col;
                      var finalEndRow = Math.min(endRow, startRow + copyRowsLimit - 1);
                      var finalEndCol = Math.min(endCol, startCol + copyColsLimit - 1);
                
                      instance.copyPaste.copyPasteInstance.copyable(instance.getCopyableData(startRow, startCol, finalEndRow, finalEndCol));
                
                      if (endRow !== finalEndRow || endCol !== finalEndCol) {
                        Handsontable.hooks.run(instance, "afterCopyLimit", endRow - startRow + 1, endCol - startCol + 1, copyRowsLimit, copyColsLimit);
                      }
                    };
                
                  }
                
                
                
                  function init() {
                    var instance  = this;
                    var pluginEnabled = instance.getSettings().copyPaste !== false;
                
                    if(pluginEnabled && !instance.copyPaste){
                
                      instance.copyPaste = new CopyPastePlugin(instance);
                
                    } else if (!pluginEnabled && instance.copyPaste) {
                
                      instance.copyPaste.destroy();
                      delete instance.copyPaste;
                
                    }
                
                  }
                
                  Handsontable.hooks.add('afterInit', init);
                  Handsontable.hooks.add('afterUpdateSettings', init);
                
                  Handsontable.hooks.register('afterCopyLimit');
                })(Handsontable, CopyPaste, SheetClip);
                (function (Handsontable) {
                
                  
                
                  Handsontable.Search = function Search(instance) {
                    this.query = function (queryStr, callback, queryMethod) {
                      var rowCount = instance.countRows();
                      var colCount = instance.countCols();
                      var queryResult = [];
                
                      if (!callback) {
                        callback = Handsontable.Search.global.getDefaultCallback();
                      }
                
                      if (!queryMethod) {
                        queryMethod = Handsontable.Search.global.getDefaultQueryMethod();
                      }
                
                      for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
                        for (var colIndex = 0; colIndex < colCount; colIndex++) {
                          var cellData = instance.getDataAtCell(rowIndex, colIndex);
                          var cellProperties = instance.getCellMeta(rowIndex, colIndex);
                          var cellCallback = cellProperties.search.callback || callback;
                          var cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
                          var testResult = cellQueryMethod(queryStr, cellData);
                
                          if (testResult) {
                            var singleResult = {
                              row: rowIndex,
                              col: colIndex,
                              data: cellData
                            };
                
                            queryResult.push(singleResult);
                          }
                
                          if (cellCallback) {
                            cellCallback(instance, rowIndex, colIndex, cellData, testResult);
                          }
                        }
                      }
                
                      return queryResult;
                
                    };
                
                  };
                
                  Handsontable.Search.DEFAULT_CALLBACK = function (instance, row, col, data, testResult) {
                    instance.getCellMeta(row, col).isSearchResult = testResult;
                  };
                
                  Handsontable.Search.DEFAULT_QUERY_METHOD = function (query, value) {
                
                    if (typeof query == 'undefined' || query == null || !query.toLowerCase || query.length == 0){
                      return false;
                    }
                
                    if(typeof value == 'undefined' || value == null) {
                      return false;
                    }
                
                    return value.toString().toLowerCase().indexOf(query.toLowerCase()) != -1;
                  };
                
                  Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS = 'htSearchResult';
                
                  Handsontable.Search.global = (function () {
                
                    var defaultCallback = Handsontable.Search.DEFAULT_CALLBACK;
                    var defaultQueryMethod = Handsontable.Search.DEFAULT_QUERY_METHOD;
                    var defaultSearchResultClass = Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS;
                
                    return {
                      getDefaultCallback: function () {
                        return defaultCallback;
                      },
                
                      setDefaultCallback: function (newDefaultCallback) {
                        defaultCallback = newDefaultCallback;
                      },
                
                      getDefaultQueryMethod: function () {
                        return defaultQueryMethod;
                      },
                
                      setDefaultQueryMethod: function (newDefaultQueryMethod) {
                        defaultQueryMethod = newDefaultQueryMethod;
                      },
                
                      getDefaultSearchResultClass: function () {
                        return defaultSearchResultClass;
                      },
                
                      setDefaultSearchResultClass: function (newSearchResultClass) {
                        defaultSearchResultClass = newSearchResultClass;
                      }
                    }
                
                  })();
                
                
                
                  Handsontable.SearchCellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {
                
                    var searchResultClass = (typeof cellProperties.search == 'object' && cellProperties.search.searchResultClass) || Handsontable.Search.global.getDefaultSearchResultClass();
                
                    if(cellProperties.isSearchResult){
                      Handsontable.Dom.addClass(TD, searchResultClass);
                    } else {
                      Handsontable.Dom.removeClass(TD, searchResultClass);
                    }
                  };
                
                
                
                  var originalDecorator = Handsontable.renderers.cellDecorator;
                
                  Handsontable.renderers.cellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {
                    originalDecorator.apply(this, arguments);
                    Handsontable.SearchCellDecorator.apply(this, arguments);
                  };
                
                  function init() {
                    var instance = this;
                
                    var pluginEnabled = !!instance.getSettings().search;
                
                    if (pluginEnabled) {
                      instance.search = new Handsontable.Search(instance);
                    } else {
                      delete instance.search;
                    }
                
                  }
                
                  Handsontable.hooks.add('afterInit', init);
                  Handsontable.hooks.add('afterUpdateSettings', init);
                
                
                })(Handsontable);
                function CellInfoCollection() {
                
                  var collection = [];
                
                  collection.getInfo = function (row, col) {
                    for (var i = 0, ilen = this.length; i < ilen; i++) {
                      if (this[i].row <= row && this[i].row + this[i].rowspan - 1 >= row && this[i].col <= col && this[i].col + this[i].colspan - 1 >= col) {
                        return this[i];
                      }
                    }
                  };
                
                  collection.setInfo = function (info) {
                    for (var i = 0, ilen = this.length; i < ilen; i++) {
                      if (this[i].row === info.row && this[i].col === info.col) {
                        this[i] = info;
                        return;
                      }
                    }
                    this.push(info);
                  };
                
                  collection.removeInfo = function (row, col) {
                    for (var i = 0, ilen = this.length; i < ilen; i++) {
                      if (this[i].row === row && this[i].col === col) {
                        this.splice(i, 1);
                        break;
                      }
                    }
                  };
                
                  return collection;
                
                }
                
                
                /**
                 * Plugin used to merge cells in Handsontable
                 * @constructor
                 */
                function MergeCells(mergeCellsSetting) {
                  this.mergedCellInfoCollection = new CellInfoCollection();
                
                  if (Handsontable.helper.isArray(mergeCellsSetting)) {
                    for (var i = 0, ilen = mergeCellsSetting.length; i < ilen; i++) {
                      this.mergedCellInfoCollection.setInfo(mergeCellsSetting[i]);
                    }
                  }
                }
                
                /**
                 * @param cellRange (WalkontableCellRange)
                 */
                MergeCells.prototype.canMergeRange = function (cellRange) {
                  //is more than one cell selected
                  return !cellRange.isSingle();
                };
                
                MergeCells.prototype.mergeRange = function (cellRange) {
                  if (!this.canMergeRange(cellRange)) {
                    return;
                  }
                
                  //normalize top left corner
                  var topLeft = cellRange.getTopLeftCorner();
                  var bottomRight = cellRange.getBottomRightCorner();
                
                  var mergeParent = {};
                  mergeParent.row = topLeft.row;
                  mergeParent.col = topLeft.col;
                  mergeParent.rowspan = bottomRight.row - topLeft.row + 1; //TD has rowspan == 1 by default. rowspan == 2 means spread over 2 cells
                  mergeParent.colspan = bottomRight.col - topLeft.col + 1;
                  this.mergedCellInfoCollection.setInfo(mergeParent);
                };
                
                MergeCells.prototype.mergeOrUnmergeSelection = function (cellRange) {
                  var info = this.mergedCellInfoCollection.getInfo(cellRange.from.row, cellRange.from.col);
                  if (info) {
                    //unmerge
                    this.unmergeSelection(cellRange.from);
                  }
                  else {
                    //merge
                    this.mergeSelection(cellRange);
                  }
                };
                
                MergeCells.prototype.mergeSelection = function (cellRange) {
                  this.mergeRange(cellRange);
                };
                
                MergeCells.prototype.unmergeSelection = function (cellRange) {
                  var info = this.mergedCellInfoCollection.getInfo(cellRange.row, cellRange.col);
                  this.mergedCellInfoCollection.removeInfo(info.row, info.col);
                };
                
                MergeCells.prototype.applySpanProperties = function (TD, row, col) {
                  var info = this.mergedCellInfoCollection.getInfo(row, col);
                  if (info) {
                    if (info.row === row && info.col === col) {
                      TD.setAttribute('rowspan', info.rowspan);
                      TD.setAttribute('colspan', info.colspan);
                    }
                    else {
                      TD.style.display = "none";
                    }
                  }
                  else {
                    TD.removeAttribute('rowspan');
                    TD.removeAttribute('colspan');
                  }
                };
                
                MergeCells.prototype.modifyTransform = function (hook, currentSelectedRange, delta) {
                  var current;
                  switch (hook) {
                    case 'modifyTransformStart':
                      current = currentSelectedRange.highlight;
                      break;
                
                    case 'modifyTransformEnd':
                      current = currentSelectedRange.to;
                      break;
                  }
                
                  if (hook == "modifyTransformStart") {
                    //in future - can this take the logic from modifyTransformEnd?
                    var mergeParent = this.mergedCellInfoCollection.getInfo(current.row + delta.row, current.col + delta.col);
                    if (mergeParent) {
                      if (current.row > mergeParent.row) { //entering merge by going up or left
                        this.lastDesiredCoords = new WalkontableCellCoords(current.row + delta.row, current.col + delta.col); //copy
                        delta.row += (mergeParent.row - current.row) - delta.row;
                      }
                      else if (current.row == mergeParent.row && delta.row > 0) { //leaving merge by going down
                        delta.row += mergeParent.row - current.row + mergeParent.rowspan - 1;
                      }
                      else { //leaving merge by going right
                        if (this.lastDesiredCoords && delta.row === 0) {
                          delta.row += this.lastDesiredCoords.row - current.row;
                          this.lastDesiredCoords = null;
                        }
                      }
                
                      if (current.col > mergeParent.col) { //entering merge by going up or left
                        if (!this.lastDesiredCoords) {
                          this.lastDesiredCoords = new WalkontableCellCoords(current.row + delta.row, current.col + delta.col); //copy
                        }
                        delta.col += (mergeParent.col - current.col) - delta.col;
                      }
                      else if (current.col == mergeParent.col && delta.col > 0) { //leaving merge by going right
                        delta.col += mergeParent.col - current.col + mergeParent.colspan - 1;
                      }
                      else { //leaving merge by going down
                        if (this.lastDesiredCoords && delta.col === 0) {
                          delta.col += this.lastDesiredCoords.col - current.col;
                          this.lastDesiredCoords = null;
                        }
                      }
                    }
                    else {
                      if (this.lastDesiredCoords) {
                        if (delta.col == 0) { //leaving merge by going up
                          delta.col += this.lastDesiredCoords.col - current.col;
                        }
                        else if (delta.row == 0) { //leaving merge by going left
                          delta.row += this.lastDesiredCoords.row - current.row;
                        }
                        this.lastDesiredCoords = null;
                      }
                    }
                  }
                  else {
                    //modify transform end
                    var hightlightMergeParent = this.mergedCellInfoCollection.getInfo(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col);
                    if (hightlightMergeParent) {
                      if (currentSelectedRange.isSingle()) {
                        currentSelectedRange.from = new WalkontableCellCoords(hightlightMergeParent.row, hightlightMergeParent.col);
                        currentSelectedRange.to = new WalkontableCellCoords(hightlightMergeParent.row + hightlightMergeParent.rowspan - 1, hightlightMergeParent.col + hightlightMergeParent.colspan - 1);
                      }
                    }
                
                    if (currentSelectedRange.isSingle()) {
                      //make sure objects are clones but not reference to the same instance
                      //because we will mutate them
                      currentSelectedRange.from = new WalkontableCellCoords(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col);
                      currentSelectedRange.to = new WalkontableCellCoords(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col);
                    }
                
                    var solveDimension = function (dim) {
                      var altDim = dim == "col" ? "row" : "col";
                
                      function changeCoords(obj, altDimValue, dimValue) {
                        obj[altDim] = altDimValue;
                        obj[dim] = dimValue;
                      }
                
                      if (delta[dim] != 0) {
                        var topLeft;
                        var bottomRight;
                
                        var updateCornerInfo = function () {
                          topLeft = currentSelectedRange.getTopLeftCorner();
                          bottomRight = currentSelectedRange.getBottomRightCorner();
                        }
                        updateCornerInfo();
                
                        var expanding = false; //expanding false means shrinking
                        var examinedCol;
                        //now check if maybe we are expanding?
                        if (delta[dim] < 0) {
                          examinedCol = bottomRight[dim] + delta[dim];
                          if (bottomRight[dim] == currentSelectedRange.highlight[dim]) {
                            examinedCol = topLeft[dim] + delta[dim];
                            expanding = true;
                          }
                          else {
                            for (var i = topLeft[altDim]; i <= bottomRight[altDim]; i++) {
                              var mergeParent = this.mergedCellInfoCollection.getInfo(i, bottomRight[dim]);
                              if (mergeParent) {
                                if (mergeParent[dim] <= currentSelectedRange.highlight[dim]) {
                                  examinedCol = topLeft[dim] + delta[dim];
                                  expanding = true;
                                  break;
                                }
                              }
                            }
                          }
                        }
                        else if (delta[dim] > 0) {
                          examinedCol = topLeft[dim] + delta[dim];
                          if (topLeft[dim] == currentSelectedRange.highlight[dim]) {
                            examinedCol = bottomRight[dim] + delta[dim];
                            expanding = true;
                          }
                          else {
                            for (var i = topLeft[altDim]; i <= bottomRight[altDim]; i++) {
                              var mergeParent = this.mergedCellInfoCollection.getInfo(i, topLeft[dim]);
                              if (mergeParent) {
                                if (mergeParent[dim] + mergeParent[dim + "span"] > currentSelectedRange.highlight[dim]) {
                                  examinedCol = bottomRight[dim] + delta[dim];
                                  expanding = true;
                                  break;
                                }
                              }
                            }
                          }
                        }
                
                        if (expanding) {
                          if (delta[dim] > 0) { //moving East wall further East
                            changeCoords(currentSelectedRange.from, topLeft[altDim], topLeft[dim]);
                            changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.max(bottomRight[dim], examinedCol));
                            updateCornerInfo();
                          }
                          else { //moving West wall further West
                            changeCoords(currentSelectedRange.from, topLeft[altDim], Math.min(topLeft[dim], examinedCol));
                            changeCoords(currentSelectedRange.to, bottomRight[altDim], bottomRight[dim]);
                            updateCornerInfo();
                          }
                
                        }
                        else {
                          if (delta[dim] > 0) { //shrinking West wall towards East
                            changeCoords(currentSelectedRange.from, topLeft[altDim], Math.max(topLeft[dim], examinedCol));
                            changeCoords(currentSelectedRange.to, bottomRight[altDim], bottomRight[dim]);
                            updateCornerInfo();
                          }
                          else { //shrinking East wall towards West
                            changeCoords(currentSelectedRange.from, topLeft[altDim], topLeft[dim]);
                            changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.min(bottomRight[dim], examinedCol));
                            updateCornerInfo();
                          }
                        }
                
                        for (var i = topLeft[altDim]; i <= bottomRight[altDim]; i++) {
                          var mergeParent = dim == "col" ? this.mergedCellInfoCollection.getInfo(i, examinedCol) : this.mergedCellInfoCollection.getInfo(examinedCol, i);
                          if (mergeParent) {
                            if (expanding) {
                              if (delta[dim] > 0) { //moving East wall further East
                                changeCoords(currentSelectedRange.from, Math.min(topLeft[altDim], mergeParent[altDim]), Math.min(topLeft[dim], mergeParent[dim]));
                                if (examinedCol > mergeParent[dim]) {
                                  changeCoords(currentSelectedRange.to, Math.max(bottomRight[altDim], mergeParent[altDim] + mergeParent[altDim + "span"] - 1), Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"]));
                                }
                                else {
                                  changeCoords(currentSelectedRange.to, Math.max(bottomRight[altDim], mergeParent[altDim] + mergeParent[altDim + "span"] - 1), Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"] - 1));
                                }
                                updateCornerInfo();
                              }
                              else { //moving West wall further West
                                changeCoords(currentSelectedRange.from, Math.min(topLeft[altDim], mergeParent[altDim]), Math.min(topLeft[dim], mergeParent[dim]));
                                changeCoords(currentSelectedRange.to, Math.max(bottomRight[altDim], mergeParent[altDim] + mergeParent[altDim + "span"] - 1), Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"] - 1));
                                updateCornerInfo();
                              }
                            }
                            else {
                              if (delta[dim] > 0) { //shrinking West wall towards East
                                if (examinedCol > mergeParent[dim]) {
                                  changeCoords(currentSelectedRange.from, topLeft[altDim], Math.max(topLeft[dim], mergeParent[dim] + mergeParent[dim + "span"]));
                                  changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"]));
                                }
                                else {
                                  changeCoords(currentSelectedRange.from, topLeft[altDim], Math.max(topLeft[dim], mergeParent[dim]));
                                  changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"] - 1));
                                }
                                updateCornerInfo();
                              }
                              else { //shrinking East wall towards West
                                if (examinedCol < mergeParent[dim] + mergeParent[dim + "span"] - 1) {
                                  changeCoords(currentSelectedRange.from, topLeft[altDim], Math.min(topLeft[dim], mergeParent[dim] - 1));
                                  changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.min(bottomRight[dim], mergeParent[dim] - 1));
                                }
                                else {
                                  changeCoords(currentSelectedRange.from, topLeft[altDim], Math.min(topLeft[dim], mergeParent[dim]));
                                  changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.min(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"]));
                                }
                                updateCornerInfo();
                              }
                            }
                          }
                        }
                
                        /*if (expanding) {
                         //check if corners are not part of merged cells as well
                         var oneLastCheck = function (row, col) {
                         var mergeParent = this.mergedCellInfoCollection.getInfo(row, col);
                         if (mergeParent) {
                         currentSelectedRange.expand(new WalkontableCellCoords(mergeParent.row, mergeParent.col));
                         currentSelectedRange.expand(new WalkontableCellCoords(mergeParent.row + mergeParent.rowspan - 1, mergeParent.col + mergeParent.colspan - 1));
                         updateCornerInfo();
                         }
                         }
                         oneLastCheck.call(this, topLeft.row, topLeft.col);
                         oneLastCheck.call(this, topLeft.row, bottomRight.col);
                         oneLastCheck.call(this, bottomRight.row, bottomRight.col);
                         oneLastCheck.call(this, bottomRight.row, topLeft.col);
                         }
                         else {
                         //TODO there is still a glitch if you go to merge_cells.html, go to D5 and press up, right, down
                         }*/
                      }
                    };
                
                    solveDimension.call(this, "col");
                    solveDimension.call(this, "row");
                
                    delta.row = 0;
                    delta.col = 0;
                  }
                };
                
                if (typeof Handsontable == 'undefined') {
                  throw new Error('Handsontable is not defined');
                }
                
                var init = function () {
                  var instance = this;
                  var mergeCellsSetting = instance.getSettings().mergeCells;
                
                  if (mergeCellsSetting) {
                    if (!instance.mergeCells) {
                      instance.mergeCells = new MergeCells(mergeCellsSetting);
                    }
                  }
                };
                
                var onBeforeKeyDown = function (event) {
                  if (!this.mergeCells) {
                    return;
                  }
                
                  var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;
                
                  if (ctrlDown) {
                    if (event.keyCode === 77) { //CTRL + M
                      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());
                      this.render();
                      event.stopImmediatePropagation();
                    }
                  }
                };
                
                var addMergeActionsToContextMenu = function (defaultOptions) {
                  if (!this.getSettings().mergeCells) {
                    return;
                  }
                
                  defaultOptions.items.mergeCellsSeparator = Handsontable.ContextMenu.SEPARATOR;
                
                  defaultOptions.items.mergeCells = {
                    name: function () {
                      var sel = this.getSelected();
                      var info = this.mergeCells.mergedCellInfoCollection.getInfo(sel[0], sel[1]);
                      if (info) {
                        return 'Unmerge cells';
                      }
                      else {
                        return 'Merge cells';
                      }
                    },
                    callback: function () {
                      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());
                      this.render();
                    },
                    disabled: function () {
                      return false;
                    }
                  };
                };
                
                var afterRenderer = function (TD, row, col, prop, value, cellProperties) {
                  if (this.mergeCells) {
                    this.mergeCells.applySpanProperties(TD, row, col);
                  }
                };
                
                var modifyTransformFactory = function (hook) {
                  return function (delta) {
                    var mergeCellsSetting = this.getSettings().mergeCells;
                    if (mergeCellsSetting) {
                      var currentSelectedRange = this.getSelectedRange();
                      this.mergeCells.modifyTransform(hook, currentSelectedRange, delta);
                
                      if (hook === "modifyTransformEnd") {
                        //sanitize "from" (core.js will sanitize to)
                        var totalRows = this.countRows();
                        var totalCols = this.countCols();
                        if (currentSelectedRange.from.row < 0) {
                          currentSelectedRange.from.row = 0;
                        }
                        else if (currentSelectedRange.from.row > 0 && currentSelectedRange.from.row >= totalRows) {
                          currentSelectedRange.from.row = currentSelectedRange.from - 1;
                        }
                
                        if (currentSelectedRange.from.col < 0) {
                          currentSelectedRange.from.col = 0;
                        }
                        else if (currentSelectedRange.from.col > 0 && currentSelectedRange.from.col >= totalCols) {
                          currentSelectedRange.from.col = totalCols - 1;
                        }
                      }
                    }
                  }
                };
                
                /**
                 * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell
                 * @param coords
                 */
                var beforeSetRangeEnd = function (coords) {
                  this.lastDesiredCoords = null; //unset lastDesiredCoords when selection is changed with mouse
                  var mergeCellsSetting = this.getSettings().mergeCells;
                  if (mergeCellsSetting) {
                    var selRange = this.getSelectedRange();
                    selRange.highlight = new WalkontableCellCoords(selRange.highlight.row, selRange.highlight.col); //clone in case we will modify its reference
                    selRange.to = coords;
                
                    for (var i = 0, ilen = this.mergeCells.mergedCellInfoCollection.length; i < ilen; i++) {
                      var cellInfo = this.mergeCells.mergedCellInfoCollection[i];
                      var mergedCellTopLeft = new WalkontableCellCoords(cellInfo.row, cellInfo.col);
                      var mergedCellBottomRight = new WalkontableCellCoords(cellInfo.row + cellInfo.rowspan - 1, cellInfo.col + cellInfo.colspan - 1);
                
                      var mergedCellRange = new WalkontableCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
                      if (selRange.expandByRange(mergedCellRange)) {
                        var selRangeBottomRight = selRange.getBottomRightCorner();
                        coords.row = selRangeBottomRight.row;
                        coords.col = selRangeBottomRight.col;
                      }
                    }
                  }
                };
                
                var afterGetCellMeta = function(row, col, cellProperties) {
                  var mergeCellsSetting = this.getSettings().mergeCells;
                  if (mergeCellsSetting) {
                    var mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(row, col);
                    if(mergeParent && (mergeParent.row != row || mergeParent.col != col)) {
                      cellProperties.copyable = false;
                    }
                  }
                };
                
                Handsontable.hooks.add('beforeInit', init);
                Handsontable.hooks.add('beforeKeyDown', onBeforeKeyDown);
                Handsontable.hooks.add('modifyTransformStart', modifyTransformFactory('modifyTransformStart'));
                Handsontable.hooks.add('modifyTransformEnd', modifyTransformFactory('modifyTransformEnd'));
                Handsontable.hooks.add('beforeSetRangeEnd', beforeSetRangeEnd);
                Handsontable.hooks.add('afterRenderer', afterRenderer);
                Handsontable.hooks.add('afterContextMenuDefaultOptions', addMergeActionsToContextMenu);
                Handsontable.hooks.add('afterGetCellMeta', afterGetCellMeta);
                
                Handsontable.MergeCells = MergeCells;
                
                
                (function () {
                
                  function CustomBorders () {
                
                  }
                
                  /***
                   * Array for all custom border objects (for redraw)
                   * @type {{}}
                   */
                  var bordersArray = {},
                    /***
                     * Flag for prevent redraw borders after each AfterRender hook
                     * @type {boolean}
                     */
                    initialDraw = false,
                
                    /***
                     * Current instance (table where borders should be placed)
                     */
                    instance;
                
                
                  /***
                   * Check if plugin should be enabled
                   */
                  var init = function () {
                
                    var customBorders = this.getSettings().customBorders;
                    var enable = false;
                
                    if(typeof customBorders === "boolean"){
                      if (customBorders == true){
                        enable = true;
                      }
                    }
                
                    if(typeof customBorders === "object"){
                      if(customBorders.length > 0) {
                        initialDraw = true;
                        enable = true;
                      }
                    }
                
                    if(enable){
                      if(!this.customBorders){
                        instance = this;
                        this.customBorders = new CustomBorders();
                      }
                    }
                  };
                
                  /***
                   * Prepare borders from setting (single cell)
                   *
                   * @param row
                   * @param col
                   * @param borderObj
                   */
                  var prepareBorderFromCustomAdded = function (row, col, borderObj){
                    var border = createEmptyBorders(row, col);
                    border = extendDefaultBorder(border, borderObj);
                    this.setCellMeta(row, col, 'borders', border);
                    insertBorderToArray(border);
                  };
                
                  /***
                   * Prepare borders from setting (object)
                   * @param rowObj
                   */
                  var prepareBorderFromCustomAddedRange = function (rowObj) {
                    var range = rowObj.range;
                
                    for (var row = range.from.row; row <= range.to.row; row ++) {
                      for (var col = range.from.col; col<= range.to.col; col++){
                
                        var border = createEmptyBorders(row, col);
                        var add = 0;
                
                        if(row == range.from.row) {
                          add++;
                          if(rowObj.hasOwnProperty('top')){
                            border.top = rowObj.top;
                          }
                        }
                
                        if(row == range.to.row){
                          add++;
                          if(rowObj.hasOwnProperty('bottom')){
                            border.bottom = rowObj.bottom;
                          }
                        }
                
                        if(col == range.from.col) {
                          add++;
                          if(rowObj.hasOwnProperty('left')){
                            border.left = rowObj.left;
                          }
                        }
                
                
                        if (col == range.to.col) {
                          add++;
                          if(rowObj.hasOwnProperty('right')){
                            border.right = rowObj.right;
                          }
                        }
                
                
                        if(add>0){
                          this.setCellMeta(row, col, 'borders', border);
                          insertBorderToArray(border);
                        }
                      }
                    }
                  };
                
                  /***
                   * Create separated class name for borders for each cell
                   * @param row
                   * @param col
                   * @returns {string}
                   */
                  var createClassName = function (row, col) {
                    return "border_row" + row + "col" + col;
                  };
                
                
                  /***
                   * Create default single border for each position (top/right/bottom/left)
                   * @returns {{width: number, color: string}}
                   */
                  var createDefaultCustomBorder = function () {
                    return {
                      width: 1,
                      color: '#000'
                    };
                  };
                
                
                  /***
                   * Create default object for empty border
                   * @returns {{hide: boolean}}
                   */
                  var createSingleEmptyBorder = function () {
                    return {
                      hide: true
                    }
                  };
                
                
                  /***
                   * Create default Handsontable border object
                   * @returns {{width: number, color: string, cornerVisible: boolean}}
                   */
                  var createDefaultHtBorder = function () {
                    return {
                      width: 1,
                      color: '#000',
                      cornerVisible: false
                    }
                  };
                
                  /***
                   * Prepare empty border for each cell with all custom borders hidden
                   *
                   * @param row
                   * @param col
                   * @returns {{className: *, border: *, row: *, col: *, top: {hide: boolean}, right: {hide: boolean}, bottom: {hide: boolean}, left: {hide: boolean}}}
                   */
                  var createEmptyBorders = function (row, col){
                    return {
                      className: createClassName(row, col),
                      border: createDefaultHtBorder(),
                      row: row,
                      col: col,
                      top: createSingleEmptyBorder(),
                      right: createSingleEmptyBorder(),
                      bottom: createSingleEmptyBorder(),
                      left: createSingleEmptyBorder()
                    }
                  };
                
                
                  var extendDefaultBorder = function (defaultBorder, customBorder){
                
                    if(customBorder.hasOwnProperty('border')){
                      defaultBorder.border = customBorder.border;
                    }
                
                    if(customBorder.hasOwnProperty('top')){
                      defaultBorder.top = customBorder.top;
                    }
                
                    if(customBorder.hasOwnProperty('right')){
                      defaultBorder.right = customBorder.right;
                    }
                
                    if(customBorder.hasOwnProperty('bottom')){
                      defaultBorder.bottom = customBorder.bottom;
                    }
                
                    if(customBorder.hasOwnProperty('left')){
                      defaultBorder.left = customBorder.left;
                    }
                    return defaultBorder;
                  };
                
                  /***
                   * Insert object with borders for each cell to bordersArray
                   *
                   * @param bordersObj
                   */
                  var insertBorderToArray = function (bordersObj) {
                    bordersArray[bordersObj.className] = bordersObj;
                  };
                
                  /***
                   * Clean bordersArray for cell when custom border has been removed
                   *
                   * @param className
                   */
                  var removeBorderFromArray = function (className) {
                    delete bordersArray[className];
                  };
                
                
                  /***
                   * Remove borders divs from DOM
                   *
                   * @param borderClassName
                   */
                  var removeBordersFromDom = function (borderClassName) {
                    var borders = document.getElementsByClassName(borderClassName)[0];
                
                    if(borders){
                      var parent = borders.parentNode;
                      parent.parentNode.removeChild(parent);
                    }
                
                  };
                
                
                  /***
                   * Remove border (triggered from context menu)
                   *
                   * @param row
                   * @param col
                   */
                  var removeAllBorders = function(row,col) {
                    var borderClassName = createClassName(row,col);
                    removeBordersFromDom(borderClassName);
                    removeBorderFromArray(borderClassName);
                
                    this.removeCellMeta(row, col, 'borders');
                  };
                
                  /***
                   * Draw borders for single cell
                   *
                   * @param borderObj
                   */
                  var drawBorders = function (borderObj) {
                    var bordersInDOM = document.getElementsByClassName(createClassName(borderObj.row,borderObj.col)),
                      bordersExist = bordersInDOM.length > 0;
                
                    if(bordersExist){
                      removeBordersFromDom(createClassName(borderObj.row,borderObj.col));
                    }
                
                    var border = new WalkontableBorder(this.view.wt,borderObj);
                    border.appear([borderObj.row,borderObj.col,borderObj.row,borderObj.col]);
                  };
                
                
                  /***
                   * Set borders for each cell re. to border position
                   *
                   * @param row
                   * @param col
                   * @param place
                   * @param remove
                   */
                  var setBorder = function (row, col,place, remove){
                    var bordersMeta = this.getCellMeta(row, col).borders;
                    if (!bordersMeta || bordersMeta.border == undefined){
                      bordersMeta = createEmptyBorders(row, col);
                    }
                
                    if (remove) {
                      bordersMeta[place] = createSingleEmptyBorder();
                    } else {
                      bordersMeta[place] = createDefaultCustomBorder();
                    }
                
                
                    this.setCellMeta(row, col, 'borders', bordersMeta);
                    insertBorderToArray(bordersMeta);
                //    doDraw = true;
                    this.render();
                  };
                
                
                  /***
                   * Prepare borders based on cell and border position
                   *
                   * @param range
                   * @param place
                   * @param remove
                   */
                  var prepareBorder = function (range, place, remove) {
                    if (range.from.row == range.to.row && range.from.col == range.to.col){
                      if(place == "noBorders"){
                        removeAllBorders.call(this, range.from.row, range.from.col);
                      } else {
                        setBorder.call(this, range.from.row, range.from.col, place, remove);
                      }
                    } else {
                      switch (place) {
                        case "noBorders":
                          for(var column = range.from.col; column <= range.to.col; column++){
                            for(var row = range.from.row; row <= range.to.row; row++) {
                              removeAllBorders.call(this, row, column);
                            }
                          }
                          break;
                        case "top":
                          for(var topCol = range.from.col; topCol <= range.to.col; topCol++){
                            setBorder.call(this, range.from.row, topCol, place, remove);
                          }
                          break;
                        case "right":
                          for(var rowRight = range.from.row; rowRight <=range.to.row; rowRight++){
                            setBorder.call(this,rowRight, range.to.col, place);
                          }
                          break;
                        case "bottom":
                          for(var bottomCol = range.from.col; bottomCol <= range.to.col; bottomCol++){
                            setBorder.call(this, range.to.row, bottomCol, place);
                          }
                          break;
                        case "left":
                          for(var rowLeft = range.from.row; rowLeft <=range.to.row; rowLeft++){
                            setBorder.call(this,rowLeft, range.from.col, place);
                          }
                          break;
                      }
                    }
                  };
                
                  /***
                   * Check if selection has border by className
                   *
                   * @param hot
                   * @param direction
                   */
                  var checkSelectionBorders = function (hot, direction) {
                    var atLeastOneHasBorder = false;
                
                    hot.getSelectedRange().forAll(function(r, c) {
                      var metaBorders = hot.getCellMeta(r,c).borders;
                
                      if (metaBorders) {
                        if(direction) {
                          if (!metaBorders[direction].hasOwnProperty('hide')){
                            atLeastOneHasBorder = true;
                            return false; //breaks forAll
                          }
                        } else {
                          atLeastOneHasBorder = true;
                          return false; //breaks forAll
                        }
                      }
                    });
                    return atLeastOneHasBorder;
                  };
                
                
                  /***
                   * Mark label in contextMenu as selected
                   *
                   * @param label
                   * @returns {string}
                   */
                  var markSelected = function (label) {
                    return "<span class='selected'>✓</span>" + label;
                  };
                
                  /***
                   * Add border options to context menu
                   *
                   * @param defaultOptions
                   */
                  var addBordersOptionsToContextMenu = function (defaultOptions) {
                    if(!this.getSettings().customBorders){
                      return;
                    }
                
                    defaultOptions.items.bordersCellsSeparator = Handsontable.ContextMenu.SEPARATOR;
                
                    defaultOptions.items.borders = {
                      name: 'Borders',
                      submenu: {
                        items: {
                          top: {
                            name: function () {
                              var label = "Top";
                              var hasBorder = checkSelectionBorders(this, 'top');
                              if(hasBorder) {
                                label = markSelected(label);
                              }
                
                              return label;
                            },
                            callback: function () {
                              var hasBorder = checkSelectionBorders(this, 'top');
                              prepareBorder.call(this, this.getSelectedRange(), 'top', hasBorder);
                            },
                            disabled: false
                          },
                          right: {
                            name: function () {
                              var label = 'Right';
                              var hasBorder = checkSelectionBorders(this, 'right');
                              if(hasBorder) {
                                label = markSelected(label);
                              }
                              return label;
                            },
                            callback: function () {
                              var hasBorder = checkSelectionBorders(this, 'right');
                              prepareBorder.call(this, this.getSelectedRange(), 'right', hasBorder);
                            },
                            disabled: false
                          },
                          bottom: {
                            name: function () {
                              var label = 'Bottom';
                              var hasBorder = checkSelectionBorders(this, 'bottom');
                              if(hasBorder) {
                                label = markSelected(label);
                              }
                              return label;
                            },
                            callback: function () {
                              var hasBorder = checkSelectionBorders(this, 'bottom');
                              prepareBorder.call(this, this.getSelectedRange(), 'bottom', hasBorder);
                            },
                            disabled: false
                          },
                          left: {
                            name: function () {
                              var label = 'Left';
                              var hasBorder = checkSelectionBorders(this, 'left');
                              if(hasBorder) {
                                label = markSelected(label);
                              }
                
                              return label
                            },
                            callback: function () {
                              var hasBorder = checkSelectionBorders(this, 'bottom');
                              prepareBorder.call(this, this.getSelectedRange(), 'left', hasBorder);
                            },
                            disabled: false
                          },
                          remove: {
                            name: 'Remove border(s)',
                            callback: function () {
                              prepareBorder.call(this, this.getSelectedRange(), 'noBorders');
                            },
                            disabled: function () {
                              return !checkSelectionBorders(this);
                            }
                          }
                        }
                      }
                    };
                  };
                
                  Handsontable.hooks.add('beforeInit', init);
                  Handsontable.hooks.add('afterContextMenuDefaultOptions', addBordersOptionsToContextMenu);
                  Handsontable.hooks.add('afterRender', function () {
                    var customBorders = this.getSettings().customBorders;
                
                    if (initialDraw){
                      for(var i = 0; i< customBorders.length; i++) {
                        if(customBorders[i].range){
                          prepareBorderFromCustomAddedRange.call(this,customBorders[i]);
                        } else {
                          prepareBorderFromCustomAdded.call(this,customBorders[i].row, customBorders[i].col, customBorders[i]);
                        }
                      }
                      initialDraw = false;
                    }
                
                    for (var key in bordersArray) {
                      if (bordersArray.hasOwnProperty(key)) {
                
                        drawBorders.call(this,bordersArray[key])
                      }
                    }
                
                  });
                  Handsontable.CustomBorders = CustomBorders;
                
                }());
                
                /**
                 * HandsontableManualRowMove
                 *
                 * Has 2 UI components:
                 * - handle - the draggable element that sets the desired position of the row
                 * - guide - the helper guide that shows the desired position as a horizontal guide
                 *
                 * Warning! Whenever you make a change in this file, make an analogous change in manualRowMove.js
                 * @constructor
                 */
                (function (Handsontable) {
                  function HandsontableManualRowMove() {
                
                    var startRow,
                        endRow,
                        startY,
                        startOffset,
                        currentRow,
                        currentTH,
                        handle = document.createElement('DIV'),
                        guide = document.createElement('DIV'),
                        $window = $(window);
                
                    handle.className = 'manualRowMover';
                    guide.className = 'manualRowMoverGuide';
                
                    var saveManualRowPositions = function () {
                      var instance = this;
                      Handsontable.hooks.run(instance, 'persistentStateSave', 'manualRowPositions', instance.manualRowPositions);
                    };
                
                    var loadManualRowPositions = function () {
                      var instance = this,
                          storedState = {};
                      Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualRowPositions', storedState);
                      return storedState.value;
                    };
                
                    function setupHandlePosition(TH) {
                      instance = this;
                      currentTH = TH;
                
                      var row = this.view.wt.wtTable.getCoords(TH).row; //getCoords returns WalkontableCellCoords
                      if (row >= 0) { //if not row header
                        currentRow = row;
                        var box = currentTH.getBoundingClientRect();
                        startOffset = box.top;
                        handle.style.top = startOffset + 'px';
                        handle.style.left = box.left + 'px';
                        instance.rootElement[0].appendChild(handle);
                      }
                    }
                
                    function refreshHandlePosition(TH) {
                      var box = TH.getBoundingClientRect();
                      handle.style.top = box.top + 'px';
                    }
                
                    function setupGuidePosition() {
                      var instance = this;
                      Handsontable.Dom.addClass(handle, 'active');
                      Handsontable.Dom.addClass(guide, 'active');
                      var box = currentTH.getBoundingClientRect();
                      guide.style.width = instance.view.maximumVisibleElementWidth(0) + 'px';
                      guide.style.height = box.height + 'px';
                      guide.style.top = startOffset + 'px';
                      guide.style.left = handle.style.left;
                      instance.rootElement[0].appendChild(guide);
                    }
                
                    function refreshGuidePosition(diff) {
                      guide.style.top = startOffset + diff + 'px';
                    }
                
                    function hideHandleAndGuide() {
                      Handsontable.Dom.removeClass(handle, 'active');
                      Handsontable.Dom.removeClass(guide, 'active');
                    }
                
                    var bindEvents = function () {
                      var instance = this;
                      var pressed;
                
                      instance.rootElement.on('mouseenter.manualRowMove.' + instance.guid, 'table tbody tr > th', function (e) {
                        if (pressed) {
                          endRow = instance.view.wt.wtTable.getCoords(e.currentTarget).row;
                          refreshHandlePosition(e.currentTarget);
                        }
                        else {
                          setupHandlePosition.call(instance, e.currentTarget);
                        }
                      });
                
                      instance.rootElement.on('mousedown.manualRowMove.' + instance.guid, '.manualRowMover', function (e) {
                        startY = e.pageY;
                        setupGuidePosition.call(instance);
                        pressed = instance;
                
                        startRow = currentRow;
                        endRow = currentRow;
                      });
                
                      $window.on('mousemove.manualRowMove.' + instance.guid, function (e) {
                        if (pressed) {
                          refreshGuidePosition(e.pageY - startY);
                        }
                      });
                
                      $window.on('mouseup.manualRowMove.' + instance.guid, function () {
                        if (pressed) {
                          hideHandleAndGuide();
                          pressed = false;
                
                          if (startRow < endRow) {
                            endRow--;
                          }
                          createPositionData(instance.manualRowPositions, instance.countRows());
                          instance.manualRowPositions.splice(endRow, 0, instance.manualRowPositions.splice(startRow, 1)[0]);
                
                          instance.forceFullRender = true;
                          instance.view.render(); //updates all
                
                          saveManualRowPositions.call(instance);
                
                          Handsontable.hooks.run(instance, 'afterRowMove', startRow, endRow);
                
                          setupHandlePosition.call(instance, currentTH);
                        }
                      });
                
                      instance.addHook('afterDestroy', unbindEvents);
                    };
                
                    var unbindEvents = function () {
                      var instance = this;
                      instance.rootElement.off('mouseenter.manualRowMove.' + instance.guid, 'table tbody tr > th');
                      instance.rootElement.off('mousedown.manualRowMove.' + instance.guid, '.manualRowMover');
                      $window.off('mousemove.manualRowMove.' + instance.guid);
                      $window.off('mouseup.manualRowMove.' + instance.guid);
                    };
                
                    var createPositionData = function (positionArr, len) {
                      if (positionArr.length < len) {
                        for (var i = positionArr.length; i < len; i++) {
                          positionArr[i] = i;
                        }
                      }
                    };
                
                    this.beforeInit = function () {
                      this.manualRowPositions = [];
                    };
                
                    this.init = function (source) {
                      var instance = this;
                
                      var manualRowMoveEnabled = !!(instance.getSettings().manualRowMove);
                
                      if (manualRowMoveEnabled) {
                        var initialManualRowPositions = instance.getSettings().manualRowMove;
                
                        var loadedManualRowPostions = loadManualRowPositions.call(instance);
                
                        if (typeof loadedManualRowPostions != 'undefined') {
                          this.manualRowPositions = loadedManualRowPostions;
                        } else if(initialManualRowPositions instanceof Array) {
                          this.manualRowPositions = initialManualRowPositions;
                        } else {
                          this.manualRowPositions = [];
                        }
                
                        if (source === 'afterInit') {
                          bindEvents.call(this);
                          if (this.manualRowPositions.length > 0) {
                            instance.forceFullRender = true;
                            instance.render();
                          }
                        }
                      } else {
                        unbindEvents.call(this);
                        instance.manualRowPositions = [];
                      }
                
                    };
                
                    this.modifyRow = function (row) {
                      var instance = this;
                      if (instance.getSettings().manualRowMove) {
                        if (typeof instance.manualRowPositions[row] === 'undefined') {
                          createPositionData(this.manualRowPositions, row + 1);
                        }
                        return instance.manualRowPositions[row];
                      }
                
                      return row;
                    };
                  }
                
                  var htManualRowMove = new HandsontableManualRowMove();
                
                  Handsontable.hooks.add('beforeInit', htManualRowMove.beforeInit);
                  Handsontable.hooks.add('afterInit',  function () {
                    htManualRowMove.init.call(this, 'afterInit');
                  });
                
                  Handsontable.hooks.add('afterUpdateSettings', function () {
                    htManualRowMove.init.call(this, 'afterUpdateSettings');
                  });
                
                  Handsontable.hooks.add('modifyRow', htManualRowMove.modifyRow);
                  Handsontable.hooks.register('afterRowMove');
                
                })(Handsontable);
                /**
                 * This plugin provides "drag-down" and "copy-down" functionalities, both operated
                 * using the small square in the right bottom of the cell selection.
                 *
                 * "Drag-down" expands the value of the selected cells to the neighbouring
                 * cells when you drag the small square in the corner.
                 *
                 * "Copy-down" copies the value of the selection to all empty cells
                 * below when you double click the small square.
                 */
                (function (Handsontable) {
                  
                
                  function Autofill(instance) {
                    this.instance = instance;
                    this.addingStarted = false;
                
                    var $document = $(document),
                      wtOnCellCornerMouseDown,
                      wtOnCellMouseOver,
                      mouseDownOnCellCorner = false,
                      plugin = this;
                
                
                    var mouseUpCallback = function (event) {
                      if(!instance.autofill) {
                        return true;
                      }
                
                      if (instance.autofill.handle && instance.autofill.handle.isDragged) {
                        if (instance.autofill.handle.isDragged > 1) {
                          instance.autofill.apply();
                        }
                        instance.autofill.handle.isDragged = 0;
                        mouseDownOnCellCorner = false;
                      }
                    };
                
                    $(document).off('mouseup.autofill.' + instance.guid, this.instance.rootElement).on('mouseup.autofill.' + instance.guid, this.instance.rootElement,  function (event) {
                      mouseUpCallback(event);
                    });
                
                    $(document).off('mousemove.moveOutside_' + instance.guid).on('mousemove.moveOutside_' + instance.guid, function (event) {
                      if (!plugin.instance.autofill) {
                        return 0;
                      }
                
                      var tableBottom = Handsontable.Dom.offset(plugin.instance.$table[0]).top - (window.pageYOffset || document.documentElement.scrollTop) + Handsontable.Dom.outerHeight(plugin.instance.$table[0])
                        , tableRight = Handsontable.Dom.offset(plugin.instance.$table[0]).left - (window.pageXOffset || document.documentElement.scrollLeft) + Handsontable.Dom.outerWidth(plugin.instance.$table[0]);
                
                      if (plugin.addingStarted === false && plugin.instance.autofill.handle.isDragged > 0 && event.clientY > tableBottom && event.clientX <= tableRight) { // dragged outside bottom
                        this.mouseDragOutside = true;
                        plugin.addingStarted = true;
                      } else {
                        this.mouseDragOutside = false;
                      }
                
                      if (this.mouseDragOutside) {
                        setTimeout(function () {
                          plugin.addingStarted = false;
                          plugin.instance.alter('insert_row');
                        }, 200);
                      }
                    });
                
                    /*
                     * Appeding autofill-specific methods to walkontable event settings
                     */
                    wtOnCellCornerMouseDown = this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown;
                    this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown = function (event) {
                      instance.autofill.handle.isDragged = 1;
                      mouseDownOnCellCorner = true;
                
                      wtOnCellCornerMouseDown(event);
                    };
                
                    wtOnCellMouseOver = this.instance.view.wt.wtSettings.settings.onCellMouseOver;
                    this.instance.view.wt.wtSettings.settings.onCellMouseOver = function (event, coords, TD, wt) {
                
                      if (instance.autofill && (mouseDownOnCellCorner && !instance.view.isMouseDown() && instance.autofill.handle && instance.autofill.handle.isDragged)) {
                        instance.autofill.handle.isDragged++;
                        instance.autofill.showBorder(coords);
                        instance.autofill.checkIfNewRowNeeded();
                      }
                
                      wtOnCellMouseOver(event, coords, TD, wt);
                    };
                
                    this.instance.view.wt.wtSettings.settings.onCellCornerDblClick = function () {
                      instance.autofill.selectAdjacent();
                    };
                
                  }
                
                  /**
                   * Create fill handle and fill border objects
                   */
                  Autofill.prototype.init = function () {
                    this.handle = {};
                  },
                
                  /**
                   * Hide fill handle and fill border permanently
                   */
                    Autofill.prototype.disable = function () {
                      this.handle.disabled = true;
                    },
                
                  /**
                   * Selects cells down to the last row in the left column, then fills down to that cell
                   */
                    Autofill.prototype.selectAdjacent = function () {
                      var select, data, r, maxR, c;
                
                      if (this.instance.selection.isMultiple()) {
                        select = this.instance.view.wt.selections.area.getCorners();
                      }
                      else {
                        select = this.instance.view.wt.selections.current.getCorners();
                      }
                
                      data = this.instance.getData();
                      rows : for (r = select[2] + 1; r < this.instance.countRows(); r++) {
                        for (c = select[1]; c <= select[3]; c++) {
                          if (data[r][c]) {
                            break rows;
                          }
                        }
                        if (!!data[r][select[1] - 1] || !!data[r][select[3] + 1]) {
                          maxR = r;
                        }
                      }
                      if (maxR) {
                        this.instance.view.wt.selections.fill.clear();
                        this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(select[0], select[1]));
                        this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(maxR, select[3]));
                        this.apply();
                      }
                    },
                
                  /**
                   * Apply fill values to the area in fill border, omitting the selection border
                   */
                    Autofill.prototype.apply = function () {
                      var drag, select, start, end, _data;
                
                      this.handle.isDragged = 0;
                
                      drag = this.instance.view.wt.selections.fill.getCorners();
                      if (!drag) {
                        return;
                      }
                
                      this.instance.view.wt.selections.fill.clear();
                
                      if (this.instance.selection.isMultiple()) {
                        select = this.instance.view.wt.selections.area.getCorners();
                      }
                      else {
                        select = this.instance.view.wt.selections.current.getCorners();
                      }
                
                      if (drag[0] === select[0] && drag[1] < select[1]) {
                        start = new WalkontableCellCoords(
                          drag[0],
                          drag[1]
                        );
                        end = new WalkontableCellCoords(
                          drag[2],
                            select[1] - 1
                        );
                      }
                      else if (drag[0] === select[0] && drag[3] > select[3]) {
                        start = new WalkontableCellCoords(
                          drag[0],
                            select[3] + 1
                        );
                        end = new WalkontableCellCoords(
                          drag[2],
                          drag[3]
                        );
                      }
                      else if (drag[0] < select[0] && drag[1] === select[1]) {
                        start = new WalkontableCellCoords(
                          drag[0],
                          drag[1]
                        );
                        end = new WalkontableCellCoords(
                            select[0] - 1,
                          drag[3]
                        );
                      }
                      else if (drag[2] > select[2] && drag[1] === select[1]) {
                        start = new WalkontableCellCoords(
                            select[2] + 1,
                          drag[1]
                        );
                        end = new WalkontableCellCoords(
                          drag[2],
                          drag[3]
                        );
                      }
                
                      if (start) {
                        var selRange = {from: this.instance.getSelectedRange().from, to: this.instance.getSelectedRange().to};
                
                        _data = this.instance.getData(selRange.from.row, selRange.from.col, selRange.to.row, selRange.to.col);
                
                        Handsontable.hooks.run(this.instance, 'beforeAutofill', start, end, _data);
                
                        this.instance.populateFromArray(start.row, start.col, _data, end.row, end.col, 'autofill');
                
                        this.instance.selection.setRangeStart(new WalkontableCellCoords(drag[0], drag[1]));
                        this.instance.selection.setRangeEnd(new WalkontableCellCoords(drag[2], drag[3]));
                      }
                      /*else {
                       //reset to avoid some range bug
                       selection.refreshBorders();
                       }*/
                    },
                
                  /**
                   * Show fill border
                   * @param {WalkontableCellCoords} coords
                   */
                    Autofill.prototype.showBorder = function (coords) {
                      var topLeft = this.instance.getSelectedRange().getTopLeftCorner();
                      var bottomRight = this.instance.getSelectedRange().getBottomRightCorner();
                      if (this.instance.getSettings().fillHandle !== 'horizontal' && (bottomRight.row < coords.row || topLeft.row > coords.row)) {
                        coords = new WalkontableCellCoords(coords.row, bottomRight.col);
                      }
                      else if (this.instance.getSettings().fillHandle !== 'vertical') {
                        coords = new WalkontableCellCoords(bottomRight.row, coords.col);
                      }
                      else {
                        return; //wrong direction
                      }
                
                      this.instance.view.wt.selections.fill.clear();
                      this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().from);
                      this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().to);
                      this.instance.view.wt.selections.fill.add(coords);
                      this.instance.view.render();
                    }
                
                  Autofill.prototype.checkIfNewRowNeeded = function () {
                    var fillCorners,
                      tableRows = this.instance.countRows(),
                      that = this;
                
                    if (this.instance.view.wt.selections.fill.cellRange && this.addingStarted === false) {
                      fillCorners = this.instance.view.wt.selections.fill.getCorners();
                
                      if (fillCorners[2] === tableRows - 1) {
                        this.addingStarted = true;
                
                        this.instance._registerTimeout(setTimeout(function () {
                          that.instance.alter('insert_row');
                          that.addingStarted = false;
                        }, 200));
                      }
                    }
                
                  };
                
                
                  Handsontable.hooks.add('afterInit', function () {
                    var autofill = new Autofill(this);
                
                    if (typeof this.getSettings().fillHandle !== "undefined") {
                      if (autofill.handle && this.getSettings().fillHandle === false) {
                        autofill.disable();
                      }
                      else if (!autofill.handle && this.getSettings().fillHandle !== false) {
                        this.autofill = autofill;
                        this.autofill.init();
                      }
                    }
                
                  });
                
                  Handsontable.Autofill = Autofill;
                
                })(Handsontable);
                
                /**
                 * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable
                 * and (optionally) implements behavior needed for native horizontal and vertical scrolling
                 */
                function WalkontableOverlay() {}
                
                /*
                 Possible optimizations:
                 [x] don't rerender if scroll delta is smaller than the fragment outside of the viewport
                 [ ] move .style.top change before .draw()
                 [ ] put .draw() in requestAnimationFrame
                 [ ] don't rerender rows that remain visible after the scroll
                 */
                
                WalkontableOverlay.prototype.init = function () {
                  this.TABLE = this.instance.wtTable.TABLE;
                  this.fixed = this.instance.wtTable.hider;
                  this.fixedContainer = this.instance.wtTable.holder;
                  this.scrollHandler = this.getScrollableElement(this.TABLE);
                  this.$scrollHandler = $(this.scrollHandler); //in future remove jQuery from here
                };
                
                WalkontableOverlay.prototype.makeClone = function (direction) {
                  var clone = document.createElement('DIV');
                  clone.className = 'ht_clone_' + direction + ' handsontable';
                	clone.style.position = 'absolute';
                  clone.style.overflow = 'hidden';
                
                  var table2 = document.createElement('TABLE');
                  table2.className = this.instance.wtTable.TABLE.className;
                  clone.appendChild(table2);
                
                  this.instance.wtTable.holder.parentNode.appendChild(clone);
                
                  return new Walkontable({
                    cloneSource: this.instance,
                    cloneOverlay: this,
                    table: table2
                  });
                };
                
                WalkontableOverlay.prototype.getScrollableElement = function (TABLE) {
                  var el = TABLE.parentNode;
                  while (el && el.style) {
                    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {
                      return el;
                    }
                    if (this instanceof WalkontableHorizontalScrollbarNative && el.style.overflowX !== 'visible' && el.style.overflowX !== '') {
                      return el;
                    }
                    el = el.parentNode;
                  }
                  return window;
                };
                
                WalkontableOverlay.prototype.onScroll = function () {
                
                  this.windowScrollPosition = this.getScrollPosition();
                  this.readSettings(); //read window scroll position
                
                  this.resetFixedPosition(); //may be redundant
                };
                
                WalkontableOverlay.prototype.availableSize = function () {
                  var availableSize;
                
                  if (this.windowScrollPosition > this.tableParentOffset /*&& last > -1*/) { //last -1 means that viewport is scrolled behind the table
                    if (this.instance.wtTable.getLastVisibleRow() === this.total - 1) {
                      availableSize = Handsontable.Dom.outerHeight(this.TABLE);
                    }
                    else {
                      availableSize = this.windowSize;
                    }
                  }
                  else {
                    availableSize = this.windowSize - (this.tableParentOffset);
                  }
                
                  return availableSize;
                };
                
                WalkontableOverlay.prototype.refresh = function (selectionsOnly) {
                  this.clone && this.clone.draw(selectionsOnly);
                };
                
                WalkontableOverlay.prototype.destroy = function () {
                  this.$scrollHandler.off('.' + this.clone.guid);
                  $(window).off('.' + this.clone.guid);
                  $(document).off('.' + this.clone.guid);
                  $(document.body).off('.' + this.clone.guid);
                };
                /**
                 * WalkontableAbstractStrategy (WalkontableColumnStrategy and WalkontableRowStrategy inherit from this)
                 * @constructor
                 */
                function WalkontableAbstractStrategy(instance) {
                  this.instance = instance;
                }
                
                WalkontableAbstractStrategy.prototype.getSize = function (index) {
                  return this.cellSizes[index];
                };
                
                WalkontableAbstractStrategy.prototype.getContainerSize = function (proposedSize) {
                  return typeof this.containerSizeFn === 'function' ? this.containerSizeFn(proposedSize) : this.containerSizeFn;
                };
                
                WalkontableAbstractStrategy.prototype.countVisible = function () {
                  return this.cellCount;
                };
                
                WalkontableAbstractStrategy.prototype.isLastIncomplete = function () {
                  return this.remainingSize > 0;
                };
                function WalkontableBorder(instance, settings) {
                  var style;
                
                  if(!settings){
                    return;
                  }
                
                  //reference to instance
                  this.instance = instance;
                  this.settings = settings;
                
                  this.main = document.createElement("div");
                  style = this.main.style;
                  style.position = 'absolute';
                  style.top = 0;
                  style.left = 0;
                
                  var borderDivs = ['top','left','bottom','right','corner'];
                
                  for (var i = 0; i < 5; i++) {
                    var position = borderDivs[i];
                
                    var DIV = document.createElement('DIV');
                    DIV.className = 'wtBorder ' + (this.settings.className || ''); // + borderDivs[i];
                    if(this.settings[position] && this.settings[position].hide){
                      DIV.className += " hidden";
                    }
                
                    style = DIV.style;
                    style.backgroundColor = (this.settings[position] && this.settings[position].color) ? this.settings[position].color : settings.border.color;
                    style.height = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';
                    style.width = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';
                
                    this.main.appendChild(DIV);
                  }
                
                  this.top = this.main.childNodes[0];
                  this.left = this.main.childNodes[1];
                  this.bottom = this.main.childNodes[2];
                  this.right = this.main.childNodes[3];
                
                  this.topStyle = this.top.style;
                  this.leftStyle = this.left.style;
                  this.bottomStyle = this.bottom.style;
                  this.rightStyle = this.right.style;
                
                  this.corner = this.main.childNodes[4];
                  this.corner.className += ' corner';
                  this.cornerStyle = this.corner.style;
                  this.cornerStyle.width = '5px';
                  this.cornerStyle.height = '5px';
                  this.cornerStyle.border = '2px solid #FFF';
                
                  this.disappear();
                  if (!instance.wtTable.bordersHolder) {
                    instance.wtTable.bordersHolder = document.createElement('div');
                    instance.wtTable.bordersHolder.className = 'htBorders';
                    instance.wtTable.hider.appendChild(instance.wtTable.bordersHolder);
                
                  }
                  instance.wtTable.bordersHolder.insertBefore(this.main, instance.wtTable.bordersHolder.firstChild);
                
                  var down = false;
                  var $body = $(document.body);
                
                  $body.on('mousedown.walkontable.' + instance.guid, function () {
                    down = true;
                  });
                
                  $body.on('mouseup.walkontable.' + instance.guid, function () {
                    down = false
                  });
                
                  $(this.main.childNodes).on('mouseenter', function (event) {
                    if (!down || !instance.getSetting('hideBorderOnMouseDownOver')) {
                      return;
                    }
                    event.preventDefault();
                    event.stopImmediatePropagation();
                
                    var bounds = this.getBoundingClientRect();
                
                    var $this = $(this);
                    $this.hide();
                
                    var isOutside = function (event) {
                      if (event.clientY < Math.floor(bounds.top)) {
                        return true;
                      }
                      if (event.clientY > Math.ceil(bounds.top + bounds.height)) {
                        return true;
                      }
                      if (event.clientX < Math.floor(bounds.left)) {
                        return true;
                      }
                      if (event.clientX > Math.ceil(bounds.left + bounds.width)) {
                        return true;
                      }
                    };
                
                    $body.on('mousemove.border.' + instance.guid, function (event) {
                      if (isOutside(event)) {
                        $body.off('mousemove.border.' + instance.guid);
                        $this.show();
                      }
                    });
                  });
                }
                
                /**
                 * Show border around one or many cells
                 * @param {Array} corners
                 */
                WalkontableBorder.prototype.appear = function (corners) {
                  var isMultiple, fromTD, toTD, fromOffset, toOffset, containerOffset, top, minTop, left, minLeft, height, width;
                  if (this.disabled) {
                    return;
                  }
                
                  var instance = this.instance;
                
                  var fromRow
                    , fromColumn
                    , toRow
                    , toColumn
                    , i
                    , ilen
                    , s;
                
                  if (instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
                    ilen = instance.getSetting('fixedRowsTop');
                  }
                  else {
                    ilen = instance.wtTable.getRowStrategy().countVisible();
                  }
                
                  for (i = 0; i < ilen; i++) {
                    s = instance.wtTable.rowFilter.visibleToSource(i);
                    if (s >= corners[0] && s <= corners[2]) {
                      fromRow = s;
                      break;
                    }
                  }
                
                  for (i = ilen - 1; i >= 0; i--) {
                    s = instance.wtTable.rowFilter.visibleToSource(i);
                    if (s >= corners[0] && s <= corners[2]) {
                      toRow = s;
                      break;
                    }
                  }
                
                  if (instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
                    ilen = instance.getSetting('fixedColumnsLeft');
                  }
                  else {
                    ilen = instance.wtTable.getColumnStrategy().cellCount;
                  }
                
                  for (i = 0; i < ilen; i++) {
                    s = instance.wtTable.columnFilter.visibleToSource(i);
                    if (s >= corners[1] && s <= corners[3]) {
                      fromColumn = s;
                      break;
                    }
                  }
                
                  for (i = ilen - 1; i >= 0; i--) {
                    s = instance.wtTable.columnFilter.visibleToSource(i);
                    if (s >= corners[1] && s <= corners[3]) {
                      toColumn = s;
                      break;
                    }
                  }
                
                  if (fromRow !== void 0 && fromColumn !== void 0) {
                    isMultiple = (fromRow !== toRow || fromColumn !== toColumn);
                    fromTD = instance.wtTable.getCell(new WalkontableCellCoords(fromRow, fromColumn));
                    toTD = isMultiple ? instance.wtTable.getCell(new WalkontableCellCoords(toRow, toColumn)) : fromTD;
                    fromOffset = Handsontable.Dom.offset(fromTD);
                    toOffset = isMultiple ? Handsontable.Dom.offset(toTD) : fromOffset;
                    containerOffset = Handsontable.Dom.offset(instance.wtTable.TABLE);
                
                    minTop = fromOffset.top;
                    height = toOffset.top + Handsontable.Dom.outerHeight(toTD) - minTop;
                    minLeft = fromOffset.left;
                    width = toOffset.left + Handsontable.Dom.outerWidth(toTD) - minLeft;
                
                    top = minTop - containerOffset.top - 1;
                    left = minLeft - containerOffset.left - 1;
                
                    var style = Handsontable.Dom.getComputedStyle(fromTD);
                    if (parseInt(style['borderTopWidth'], 10) > 0) {
                      top += 1;
                      height = height > 0 ? height - 1 : 0;
                    }
                    if (parseInt(style['borderLeftWidth'], 10) > 0) {
                      left += 1;
                      width = width > 0 ? width - 1 : 0;
                    }
                  }
                  else {
                    this.disappear();
                    return;
                  }
                
                  this.topStyle.top = top + 'px';
                  this.topStyle.left = left + 'px';
                  this.topStyle.width = width + 'px';
                  this.topStyle.display = 'block';
                
                
                
                  this.leftStyle.top = top + 'px';
                  this.leftStyle.left = left + 'px';
                  this.leftStyle.height = height + 'px';
                  this.leftStyle.display = 'block';
                
                  var delta = Math.floor(this.settings.border.width / 2);
                
                  this.bottomStyle.top = top + height - delta + 'px';
                  this.bottomStyle.left = left + 'px';
                  this.bottomStyle.width = width + 'px';
                  this.bottomStyle.display = 'block';
                
                  this.rightStyle.top = top + 'px';
                  this.rightStyle.left = left + width - delta + 'px';
                  this.rightStyle.height = height + 1 + 'px';
                  this.rightStyle.display = 'block';
                
                  if (!this.hasSetting(this.settings.border.cornerVisible)) {
                    this.cornerStyle.display = 'none';
                  }
                  else {
                    this.cornerStyle.top = top + height - 4 + 'px';
                    this.cornerStyle.left = left + width - 4 + 'px';
                    this.cornerStyle.display = 'block';
                  }
                };
                
                /**
                 * Hide border
                 */
                WalkontableBorder.prototype.disappear = function () {
                  this.topStyle.display = 'none';
                  this.leftStyle.display = 'none';
                  this.bottomStyle.display = 'none';
                  this.rightStyle.display = 'none';
                  this.cornerStyle.display = 'none';
                };
                
                WalkontableBorder.prototype.hasSetting = function (setting) {
                  if (typeof setting === 'function') {
                    return setting();
                  }
                  return !!setting;
                };
                
                /**
                 * WalkontableCellCoords holds cell coordinates (row, column) and few metiod to validate them and retrieve as an array or an object
                 * TODO: change interface to WalkontableCellCoords(row, col) everywhere, remove those unnecessary setter and getter functions
                 */
                
                function WalkontableCellCoords(row, col) {
                  if (typeof row !== 'undefined' && typeof col !== 'undefined') {
                    this.row = row;
                    this.col = col;
                  }
                  else {
                    this.row = null;
                    this.col = null;
                  }
                }
                
                /**
                 * Returns boolean information if given set of coordinates is valid in context of a given Walkontable instance
                 * @param instance
                 * @returns {boolean}
                 */
                WalkontableCellCoords.prototype.isValid = function (instance) {
                  //is it a valid cell index (0 or higher)
                  if (this.row < 0 || this.col < 0) {
                    return false;
                  }
                
                  //is selection within total rows and columns
                  if (this.row >= instance.getSetting('totalRows') || this.col >= instance.getSetting('totalColumns')) {
                    return false;
                  }
                
                  return true;
                };
                
                /**
                 * Returns boolean information if this cell coords are the same as cell coords given as a parameter
                 * @param {WalkontableCellCoords} cellCoords
                 * @returns {boolean}
                 */
                WalkontableCellCoords.prototype.isEqual = function (cellCoords) {
                  if (cellCoords === this) {
                    return true;
                  }
                  return (this.row === cellCoords.row && this.col === cellCoords.col);
                };
                
                WalkontableCellCoords.prototype.isSouthEastOf = function (testedCoords) {
                  return this.row >= testedCoords.row && this.col >= testedCoords.col;
                };
                
                WalkontableCellCoords.prototype.isNorthWestOf = function (testedCoords) {
                  return this.row <= testedCoords.row && this.col <= testedCoords.col;
                };
                
                window.WalkontableCellCoords = WalkontableCellCoords; //export
                /**
                 * A cell range is a set of exactly two WalkontableCellCoords (that can be the same or different)
                 */
                
                function WalkontableCellRange(highlight, from, to) {
                  this.highlight = highlight; //this property is used to draw bold border around a cell where selection was started and to edit the cell when you press Enter
                  this.from = from; //this property is usually the same as highlight, but in Excel there is distinction - one can change highlight within a selection
                  this.to = to;
                }
                
                WalkontableCellRange.prototype.isValid = function (instance) {
                  return (this.from.isValid(instance) && this.to.isValid(instance));
                };
                
                WalkontableCellRange.prototype.isSingle = function () {
                  return (this.from.row === this.to.row && this.from.col === this.to.col);
                };
                
                /**
                 * Returns boolean information if given cell coords is within `from` and `to` cell coords of this range
                 * @param {WalkontableCellCoords} cellCoords
                 * @returns {boolean}
                 */
                WalkontableCellRange.prototype.includes = function (cellCoords) {
                  var topLeft = this.getTopLeftCorner();
                  var bottomRight = this.getBottomRightCorner();
                  return (topLeft.row <= cellCoords.row && bottomRight.row >= cellCoords.row && topLeft.col <= cellCoords.col && bottomRight.col >= cellCoords.col);
                };
                
                WalkontableCellRange.prototype.includesRange = function (testedRange) {
                  return this.includes(testedRange.getTopLeftCorner()) && this.includes(testedRange.getBottomRightCorner());
                };
                
                /**
                 * Returns true if tested range overlaps with the range.
                 * Range A is considered to to be overlapping with range B if intersection of A and B or B and A is not empty.
                 * @param testedRange
                 * @returns {boolean}
                 */
                WalkontableCellRange.prototype.overlaps = function (testedRange) {
                  return testedRange.isSouthEastOf(this.getTopLeftCorner()) && testedRange.isNorthWestOf(this.getBottomRightCorner());
                };
                
                WalkontableCellRange.prototype.isSouthEastOf = function (testedCoords) {
                  return this.getTopLeftCorner().isSouthEastOf(testedCoords) || this.getBottomRightCorner().isSouthEastOf(testedCoords);
                };
                
                WalkontableCellRange.prototype.isNorthWestOf = function (testedCoords) {
                  return this.getTopLeftCorner().isNorthWestOf(testedCoords) || this.getBottomRightCorner().isNorthWestOf(testedCoords);
                };
                
                /**
                 * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded
                 * @param {WalkontableCellCoords} cellCoords
                 * @returns {boolean}
                 */
                WalkontableCellRange.prototype.expand = function (cellCoords) {
                  var topLeft = this.getTopLeftCorner();
                  var bottomRight = this.getBottomRightCorner();
                  if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {
                    this.from = new WalkontableCellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));
                    this.to = new WalkontableCellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));
                    return true;
                  }
                  return false;
                };
                
                WalkontableCellRange.prototype.expandByRange = function (expandingRange) {
                  if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)){
                    return false;
                  }
                
                  var topLeft = this.getTopLeftCorner();
                  var bottomRight = this.getBottomRightCorner();
                
                  var expandingTopLeft = expandingRange.getTopLeftCorner();
                  var expandingBottomRight = expandingRange.getBottomRightCorner();
                
                  var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);
                  var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);
                  var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);
                  var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);
                
                  this.from = new WalkontableCellCoords(resultTopRow, resultTopCol);
                  this.to = new WalkontableCellCoords(resultBottomRow, resultBottomCol);
                
                  return true;
                
                
                };
                
                WalkontableCellRange.prototype.getTopLeftCorner = function () {
                  return new WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
                };
                
                WalkontableCellRange.prototype.getBottomRightCorner = function () {
                  return new WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
                };
                
                WalkontableCellRange.prototype.getInner = function () {
                  var topLeft = this.getTopLeftCorner();
                  var bottomRight = this.getBottomRightCorner();
                  var out = [];
                  for (var r = topLeft.row; r <= bottomRight.row; r++) {
                    for (var c = topLeft.col; c <= bottomRight.col; c++) {
                      if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
                        out.push(new WalkontableCellCoords(r, c));
                      }
                    }
                  }
                  return out;
                };
                
                WalkontableCellRange.prototype.getAll = function () {
                  var topLeft = this.getTopLeftCorner();
                  var bottomRight = this.getBottomRightCorner();
                  var out = [];
                  for (var r = topLeft.row; r <= bottomRight.row; r++) {
                    for (var c = topLeft.col; c <= bottomRight.col; c++) {
                      if (topLeft.row === r && topLeft.col === c) {
                        out.push(topLeft);
                      }
                      else if (bottomRight.row === r && bottomRight.col === c) {
                        out.push(bottomRight);
                      }
                      else {
                        out.push(new WalkontableCellCoords(r, c));
                      }
                    }
                  }
                  return out;
                };
                
                /**
                 * Runs a callback function against all cells in the range. You can break the iteration by returning false in the callback function
                 * @param callback {Function}
                 */
                WalkontableCellRange.prototype.forAll = function (callback) {
                  var topLeft = this.getTopLeftCorner();
                  var bottomRight = this.getBottomRightCorner();
                  for (var r = topLeft.row; r <= bottomRight.row; r++) {
                    for (var c = topLeft.col; c <= bottomRight.col; c++) {
                      var breakIteration = callback(r, c);
                      if (breakIteration === false) {
                        return;
                      }
                    }
                  }
                };
                
                window.WalkontableCellRange = WalkontableCellRange; //export
                /**
                 * WalkontableClassNameList
                 * @constructor
                 */
                function WalkontableClassNameCache() {
                  this.cache = [];
                }
                
                WalkontableClassNameCache.prototype.add = function (r, c, cls) {
                  if (!this.cache[r]) {
                    this.cache[r] = [];
                  }
                  if (!this.cache[r][c]) {
                    this.cache[r][c] = [];
                  }
                  this.cache[r][c][cls] = true;
                };
                
                WalkontableClassNameCache.prototype.test = function (r, c, cls) {
                  return (this.cache[r] && this.cache[r][c] && this.cache[r][c][cls]);
                };
                /**
                 * WalkontableColumnFilter
                 * @constructor
                 */
                function WalkontableColumnFilter(total, countTH) {
                  this.total = total;
                  this.countTH = countTH;
                }
                
                WalkontableColumnFilter.prototype.visibleToSource = function (n) {
                  return n;
                };
                
                WalkontableColumnFilter.prototype.sourceToVisible = function (n) {
                  return n;
                };
                
                WalkontableColumnFilter.prototype.offsettedTH = function (n) {
                  return n - this.countTH;
                };
                
                WalkontableColumnFilter.prototype.unOffsettedTH = function (n) {
                  return n + this.countTH;
                };
                
                WalkontableColumnFilter.prototype.visibleRowHeadedColumnToSourceColumn = function (n) {
                  return this.visibleToSource(this.offsettedTH(n));
                };
                
                WalkontableColumnFilter.prototype.sourceColumnToVisibleRowHeadedColumn = function (n) {
                  return this.unOffsettedTH(this.sourceToVisible(n));
                };
                /**
                 * WalkontableColumnStrategy
                 * @param containerSizeFn
                 * @param sizeAtIndex
                 * @param strategy - all, last, none
                 * @constructor
                 */
                function WalkontableColumnStrategy(instance, containerSizeFn, sizeAtIndex, strategy) {
                  var size
                    , i = 0;
                
                  WalkontableAbstractStrategy.apply(this, arguments);
                
                  this.containerSizeFn = containerSizeFn;
                  this.cellSizesSum = 0;
                  this.cellSizes = [];
                  this.cellStretch = [];
                  this.cellCount = 0;
                  this.visibleCellCount = 0;
                  this.remainingSize = 0;
                  this.strategy = strategy;
                
                  //step 1 - determine cells that fit containerSize and cache their widths
                  while (true) {
                    size = sizeAtIndex(i);
                    if (size === void 0) {
                      break; //total columns exceeded
                    }
                    if (this.cellSizesSum < this.getContainerSize(this.cellSizesSum + size)) {
                      this.visibleCellCount++;
                    }
                    this.cellSizes.push(size);
                    this.cellSizesSum += size;
                    this.cellCount++;
                
                    i++;
                  }
                
                  var containerSize = this.getContainerSize(this.cellSizesSum);
                  this.remainingSize = this.cellSizesSum - containerSize;
                  //negative value means the last cell is fully visible and there is some space left for stretching
                  //positive value means the last cell is not fully visible
                }
                
                WalkontableColumnStrategy.prototype = new WalkontableAbstractStrategy();
                
                WalkontableColumnStrategy.prototype.getSize = function (index) {
                  return this.cellSizes[index] + (this.cellStretch[index] || 0);
                };
                
                WalkontableColumnStrategy.prototype.stretch = function () {
                  //step 2 - apply stretching strategy
                  var containerSize
                    , i = 0;
                
                  containerSize = this.instance.wtTable.allRowsInViewport() ? this.getContainerSize() : this.getContainerSize(Infinity);
                
                  this.remainingSize = this.cellSizesSum - containerSize;
                
                  this.cellStretch.length = 0; //clear previous stretch
                
                  if (this.strategy === 'all') {
                    if (this.remainingSize < 0) {
                      var ratio = containerSize / this.cellSizesSum;
                      var newSize;
                
                      while (i < this.cellCount - 1) { //"i < this.cellCount - 1" is needed because last cellSize is adjusted after the loop
                        newSize = Math.floor(ratio * this.cellSizes[i]);
                        this.remainingSize += newSize - this.cellSizes[i];
                        this.cellStretch[i] = newSize - this.cellSizes[i];
                        i++;
                      }
                      this.cellStretch[this.cellCount - 1] = -this.remainingSize;
                      this.remainingSize = 0;
                    }
                  }
                  else if (this.strategy === 'last') {
                    if (this.remainingSize < 0 && containerSize !== Infinity) { //Infinity is with native scroll when the table is wider than the viewport (TODO: test)
                      this.cellStretch[this.cellCount - 1] = -this.remainingSize;
                      this.remainingSize = 0;
                    }
                  }
                };
                
                WalkontableColumnStrategy.prototype.countVisible = function () {
                  return this.visibleCellCount;
                };
                
                WalkontableColumnStrategy.prototype.isLastIncomplete = function () {
                
                  var firstRow = this.instance.wtTable.getFirstVisibleRow();
                  var lastCol = this.instance.wtTable.getLastVisibleColumn();
                  var cell = this.instance.wtTable.getCell(new WalkontableCellCoords(firstRow, lastCol));
                  var cellOffset = Handsontable.Dom.offset(cell);
                  var cellWidth = Handsontable.Dom.outerWidth(cell);
                  var cellEnd = cellOffset.left + cellWidth;
                
                  var viewportOffsetLeft = this.instance.wtScrollbars.vertical.getScrollPosition();
                  var viewportWitdh = this.instance.wtViewport.getViewportWidth();
                  var viewportEnd = viewportOffsetLeft + viewportWitdh;
                
                
                  return viewportEnd >= cellEnd;
                };
                
                function Walkontable(settings) {
                  var originalHeaders = [];
                
                  this.guid = 'wt_' + walkontableRandomString(); //this is the namespace for global events
                
                  //bootstrap from settings
                  if (settings.cloneSource) {
                    this.cloneSource = settings.cloneSource;
                    this.cloneOverlay = settings.cloneOverlay;
                    this.wtSettings = settings.cloneSource.wtSettings;
                    this.wtTable = new WalkontableTable(this, settings.table);
                    this.wtScroll = new WalkontableScroll(this);
                    this.wtViewport = settings.cloneSource.wtViewport;
                    this.wtEvent = new WalkontableEvent(this);
                    this.selections = this.generateSelectionClones(this.cloneSource.selections);
                  }
                  else {
                    this.wtSettings = new WalkontableSettings(this, settings);
                    this.wtTable = new WalkontableTable(this, settings.table);
                    this.wtScroll = new WalkontableScroll(this);
                    this.wtViewport = new WalkontableViewport(this);
                    this.wtEvent = new WalkontableEvent(this);
                    var selectionSettings = this.getSetting('selections');
                    this.selections = selectionSettings ? this.generateSelections(selectionSettings) : [];
                
                    this.wtScrollbars = new WalkontableScrollbars(this);
                  }
                
                  //find original headers
                  if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
                    for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
                      originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
                    }
                    if (!this.getSetting('columnHeaders').length) {
                      this.update('columnHeaders', [function (column, TH) {
                        Handsontable.Dom.fastInnerText(TH, originalHeaders[column]);
                      }]);
                    }
                  }
                
                
                
                  this.drawn = false;
                  this.drawInterrupted = false;
                }
                
                Walkontable.prototype.draw = function (selectionsOnly) {
                  this.drawInterrupted = false;
                  if (!selectionsOnly && !Handsontable.Dom.isVisible(this.wtTable.TABLE)) {
                    this.drawInterrupted = true; //draw interrupted because TABLE is not visible
                    return;
                  }
                
                  selectionsOnly = selectionsOnly && this.getSetting('offsetRow') === this.lastOffsetRow;
                  this.lastOffsetRow = this.getSetting('offsetRow');
                
                  var totalRows = this.getSetting('totalRows');
                
                  if (this.lastOffsetRow > totalRows && totalRows > 0) {
                    this.scrollVertical(-Infinity); //TODO: probably very inefficient!
                    this.scrollViewport(new WalkontableCellCoords(totalRows - 1, 0));
                  }
                
                
                  this.wtTable.draw(selectionsOnly);
                  return this;
                };
                
                Walkontable.prototype.update = function (settings, value) {
                  return this.wtSettings.update(settings, value);
                };
                
                Walkontable.prototype.scrollVertical = function (delta) {
                  var result = this.wtScroll.scrollVertical(delta);
                
                  this.getSetting('onScrollVertically');
                
                  return result;
                };
                
                Walkontable.prototype.scrollHorizontal = function (delta) {
                  var result = this.wtScroll.scrollHorizontal(delta);
                
                  this.getSetting('onScrollHorizontally');
                
                  return result;
                };
                
                /**
                 * Scrolls the viewport to a cell (rerenders if needed)
                 * @param {WalkontableCellCoords} coords
                 * @returns {Walkontable}
                 */
                
                Walkontable.prototype.scrollViewport = function (coords) {
                  this.wtScroll.scrollViewport(coords);
                  return this;
                };
                
                Walkontable.prototype.getViewport = function () {
                  return [
                    this.wtTable.getFirstVisibleRow(),
                    this.wtTable.getFirstVisibleColumn(),
                    this.wtTable.getLastVisibleRow(),
                    this.wtTable.getLastVisibleColumn()
                  ];
                };
                
                Walkontable.prototype.getSetting = function (key, param1, param2, param3, param4) {
                  return this.wtSettings.getSetting(key, param1, param2, param3, param4); //this is faster than .apply - https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
                };
                
                Walkontable.prototype.hasSetting = function (key) {
                  return this.wtSettings.has(key);
                };
                
                Walkontable.prototype.generateSelections = function (settings) {
                  var selections = [];
                  for (var i = 0, ilen = settings.length; i < ilen; i++) {
                    var sel = new WalkontableSelection(this, settings[i]);
                    selections.push(sel);
                    if (sel.settings.className) {
                      selections[sel.settings.className] = sel; //create shorthand access
                    }
                  }
                  return selections;
                };
                
                Walkontable.prototype.generateSelectionClones = function (selections) {
                  var clones = [];
                  for (var i = 0, ilen = selections.length; i < ilen; i++) {
                    var sel = selections[i].makeClone(this);
                    clones.push(sel);
                    if (sel.settings.className) {
                      clones[sel.settings.className] = sel; //create shorthand access
                    }
                  }
                  return clones;
                };
                
                Walkontable.prototype.destroy = function () {
                  $(window).off('.' + this.guid);
                  $(document.body).off('.' + this.guid);
                  this.wtScrollbars.destroy();
                  this.wtEvent && this.wtEvent.destroy();
                };
                /**
                 * A overlay that renders ALL available rows & columns positioned on top of the original Walkontable instance and all other overlays.
                 * Used for debugging purposes to see if the other overlays (that render only part of the rows & columns) are positioned correctly
                 * @param instance
                 * @constructor
                 */
                function WalkontableDebugOverlay(instance) {
                  this.instance = instance;
                  this.init();
                  this.clone = this.makeClone('debug');
                  this.clone.wtTable.holder.style.opacity = 0.4;
                  this.clone.wtTable.holder.style.textShadow = '0 0 2px #ff0000';
                  this.lastTimeout = null;
                
                  var that = this;
                  var lastX = 0;
                  var lastY = 0;
                  var overlayContainer = that.clone.wtTable.holder.parentNode;
                
                  $(document.body).on('mousemove.' + this.instance.guid, function (event) {
                    if (!that.instance.wtTable.holder.parentNode) {
                      return; //removed from DOM
                    }
                    if ((event.clientX - lastX > -5 && event.clientX - lastX < 5) && (event.clientY - lastY > -5 && event.clientY - lastY < 5)) {
                      return; //ignore minor mouse movement
                    }
                    lastX = event.clientX;
                    lastY = event.clientY;
                    Handsontable.Dom.addClass(overlayContainer, 'wtDebugHidden');
                    Handsontable.Dom.removeClass(overlayContainer, 'wtDebugVisible');
                    clearTimeout(this.lastTimeout);
                    this.lastTimeout = setTimeout(function () {
                      Handsontable.Dom.removeClass(overlayContainer, 'wtDebugHidden');
                      Handsontable.Dom.addClass(overlayContainer, 'wtDebugVisible');
                    }, 1000);
                  });
                }
                
                WalkontableDebugOverlay.prototype = new WalkontableOverlay();
                
                WalkontableDebugOverlay.prototype.resetFixedPosition = function () {
                  if (!this.instance.wtTable.holder.parentNode) {
                    return; //removed from DOM
                  }
                  var elem = this.clone.wtTable.holder.parentNode;
                  var box = this.instance.wtTable.holder.getBoundingClientRect();
                  elem.style.top = Math.ceil(box.top, 10) + 'px';
                  elem.style.left = Math.ceil(box.left, 10) + 'px';
                };
                
                WalkontableDebugOverlay.prototype.getScrollPosition = function () {
                };
                
                WalkontableDebugOverlay.prototype.getLastCell = function () {
                };
                
                WalkontableDebugOverlay.prototype.applyToDOM = function () {
                };
                
                WalkontableDebugOverlay.prototype.scrollTo = function () {
                };
                
                WalkontableDebugOverlay.prototype.readWindowSize = function () {
                };
                
                WalkontableDebugOverlay.prototype.readSettings = function () {
                };
                
                WalkontableDebugOverlay.prototype.destroy = function () {
                  WalkontableOverlay.prototype.destroy.call(this);
                  clearTimeout(this.lastTimeout);
                };
                function WalkontableEvent(instance) {
                  var that = this;
                
                  //reference to instance
                  this.instance = instance;
                
                  var dblClickOrigin = [null, null];
                  this.dblClickTimeout = [null, null];
                
                  var onMouseDown = function (event) {
                    var cell = that.parentCell(event.target);
                    if (Handsontable.Dom.hasClass(event.target, 'corner')) {
                      that.instance.getSetting('onCellCornerMouseDown', event, event.target);
                    }
                    else if (cell.TD) {
                      if (that.instance.hasSetting('onCellMouseDown')) {
                        that.instance.getSetting('onCellMouseDown', event, cell.coords, cell.TD, that.instance);
                      }
                    }
                
                    if (event.button !== 2) { //if not right mouse button
                      if (cell.TD) {
                        dblClickOrigin[0] = cell.TD;
                        clearTimeout(that.dblClickTimeout[0]);
                        that.dblClickTimeout[0] = setTimeout(function () {
                          dblClickOrigin[0] = null;
                        }, 1000);
                      }
                    }
                  };
                
                  var lastMouseOver;
                  var onMouseOver = function (event) {
                    if (that.instance.hasSetting('onCellMouseOver')) {
                      var TABLE = that.instance.wtTable.TABLE;
                      var TD = Handsontable.Dom.closest(event.target, ['TD', 'TH'], TABLE);
                      if (TD && TD !== lastMouseOver && Handsontable.Dom.isChildOf(TD, TABLE)) {
                        lastMouseOver = TD;
                        that.instance.getSetting('onCellMouseOver', event, that.instance.wtTable.getCoords(TD), TD, that.instance);
                      }
                    }
                  };
                
                /*  var lastMouseOut;
                  var onMouseOut = function (event) {
                    if (that.instance.hasSetting('onCellMouseOut')) {
                      var TABLE = that.instance.wtTable.TABLE;
                      var TD = Handsontable.Dom.closest(event.target, ['TD', 'TH'], TABLE);
                      if (TD && TD !== lastMouseOut && Handsontable.Dom.isChildOf(TD, TABLE)) {
                        lastMouseOut = TD;
                        if (TD.nodeName === 'TD') {
                          that.instance.getSetting('onCellMouseOut', event, that.instance.wtTable.getCoords(TD), TD);
                        }
                      }
                    }
                  };*/
                
                  var onMouseUp = function (event) {
                    if (event.button !== 2) { //if not right mouse button
                      var cell = that.parentCell(event.target);
                
                      if (cell.TD === dblClickOrigin[0] && cell.TD === dblClickOrigin[1]) {
                        if (Handsontable.Dom.hasClass(event.target, 'corner')) {
                          that.instance.getSetting('onCellCornerDblClick', event, cell.coords, cell.TD, that.instance);
                        }
                        else {
                          that.instance.getSetting('onCellDblClick', event, cell.coords, cell.TD, that.instance);
                        }
                
                        dblClickOrigin[0] = null;
                        dblClickOrigin[1] = null;
                      }
                      else if (cell.TD === dblClickOrigin[0]) {
                        dblClickOrigin[1] = cell.TD;
                        clearTimeout(that.dblClickTimeout[1]);
                        that.dblClickTimeout[1] = setTimeout(function () {
                          dblClickOrigin[1] = null;
                        }, 500);
                      }
                    }
                  };
                
                  $(this.instance.wtTable.holder).on('mousedown', onMouseDown);
                  $(this.instance.wtTable.TABLE).on('mouseover', onMouseOver);
                  $(this.instance.wtTable.holder).on('mouseup', onMouseUp);
                
                  $(window).on('resize.' + this.instance.guid, function () {
                    that.instance.draw();
                  });
                }
                
                WalkontableEvent.prototype.parentCell = function (elem) {
                  var cell = {};
                  var TABLE = this.instance.wtTable.TABLE;
                  var TD = Handsontable.Dom.closest(elem, ['TD', 'TH'], TABLE);
                
                  if (TD && Handsontable.Dom.isChildOf(TD, TABLE)) {
                    cell.coords = this.instance.wtTable.getCoords(TD);
                    cell.TD = TD;
                  }
                  else if (Handsontable.Dom.hasClass(elem, 'wtBorder') && Handsontable.Dom.hasClass(elem, 'current')) {
                    cell.coords = this.instance.selections.current.cellRange.highlight;
                    cell.TD = this.instance.wtTable.getCell(cell.coords);
                  }
                  return cell;
                };
                
                WalkontableEvent.prototype.destroy = function () {
                  clearTimeout(this.dblClickTimeout[0]);
                  clearTimeout(this.dblClickTimeout[1]);
                };
                function walkontableRangesIntersect() {
                  var from = arguments[0];
                  var to = arguments[1];
                  for (var i = 1, ilen = arguments.length / 2; i < ilen; i++) {
                    if (from <= arguments[2 * i + 1] && to >= arguments[2 * i]) {
                      return true;
                    }
                  }
                  return false;
                }
                
                /**
                 * Generates a random hex string. Used as namespace for Walkontable instance events.
                 * @return {String} - 16 character random string: "92b1bfc74ec4"
                 */
                function walkontableRandomString() {
                  function s4() {
                    return Math.floor((1 + Math.random()) * 0x10000)
                      .toString(16)
                      .substring(1);
                  }
                
                  return s4() + s4() + s4() + s4();
                }
                /**
                 * http://notes.jetienne.com/2011/05/18/cancelRequestAnimFrame-for-paul-irish-requestAnimFrame.html
                 */
                window.requestAnimFrame = (function () {
                  return  window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    function (/* function */ callback, /* DOMElement */ element) {
                      return window.setTimeout(callback, 1000 / 60);
                    };
                })();
                
                window.cancelRequestAnimFrame = (function () {
                  return window.cancelAnimationFrame ||
                    window.webkitCancelRequestAnimationFrame ||
                    window.mozCancelRequestAnimationFrame ||
                    window.oCancelRequestAnimationFrame ||
                    window.msCancelRequestAnimationFrame ||
                    clearTimeout
                })();
                
                //http://snipplr.com/view/13523/
                //modified for speed
                //http://jsperf.com/getcomputedstyle-vs-style-vs-css/8
                if (!window.getComputedStyle) {
                  (function () {
                    var elem;
                
                    var styleObj = {
                      getPropertyValue: function getPropertyValue(prop) {
                        if (prop == 'float') prop = 'styleFloat';
                        return elem.currentStyle[prop.toUpperCase()] || null;
                      }
                    };
                
                    window.getComputedStyle = function (el) {
                      elem = el;
                      return styleObj;
                    }
                  })();
                }
                
                /**
                 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim
                 */
                if (!String.prototype.trim) {
                  var trimRegex = /^\s+|\s+$/g;
                  String.prototype.trim = function () {
                    return this.replace(trimRegex, '');
                  };
                }
                /**
                 * WalkontableRowFilter
                 * @constructor
                 */
                function WalkontableRowFilter(offset, total, countTH) {
                  this.offset = offset;
                  this.total = total;
                  this.countTH = countTH;
                }
                
                WalkontableRowFilter.prototype.offsetted = function (n) {
                  return n + this.offset;
                };
                
                WalkontableRowFilter.prototype.unOffsetted = function (n) {
                  return n - this.offset;
                };
                
                WalkontableRowFilter.prototype.visibleToSource = function (n) {
                  return this.offsetted(n);
                };
                
                WalkontableRowFilter.prototype.sourceToVisible = function (n) {
                  return this.unOffsetted(n);
                };
                
                WalkontableRowFilter.prototype.offsettedTH = function (n) {
                  return n - this.countTH;
                };
                
                WalkontableRowFilter.prototype.visibleColHeadedRowToSourceRow = function (n) {
                  return this.visibleToSource(this.offsettedTH(n));
                };
                
                WalkontableRowFilter.prototype.sourceRowToVisibleColHeadedRow = function (n) {
                  return this.unOffsettedTH(this.sourceToVisible(n));
                };
                
                /**
                 * WalkontableRowStrategy
                 * @param containerSizeFn
                 * @param sizeAtIndex
                 * @constructor
                 */
                function WalkontableRowStrategy(instance, containerSizeFn, sizeAtIndex) {
                
                  WalkontableAbstractStrategy.apply(this, arguments);
                
                  this.containerSizeFn = containerSizeFn;
                  this.sizeAtIndex = sizeAtIndex;
                  this.cellSizesSum = 0;
                  this.cellSizes = [];
                  this.cellCount = 0;
                  this.visiblCellCount = 0;
                  this.remainingSize = -Infinity;
                  this.maxOuts = 10; //max outs in one direction (before and after table)
                  this.curOuts = this.maxOuts;
                }
                
                WalkontableRowStrategy.prototype = new WalkontableAbstractStrategy();
                
                WalkontableRowStrategy.prototype.add = function (i, TD) {
                  if(!this.canRenderMoreRows()){
                    return false;
                  }
                
                  var size = this.sizeAtIndex(i, TD);
                
                  if (size === void 0) {
                    return false; //total rows exceeded
                  }
                
                  var containerSize = this.getContainerSize(this.cellSizesSum + size);
                  this.cellSizes.push(size);
                  this.cellSizesSum += size;
                
                  this.cellCount++;
                  this.remainingSize = this.cellSizesSum - containerSize;
                
                  if (this.remainingSize <= size ){
                    this.visiblCellCount++;
                  }
                
                  return true;
                };
                
                /**
                 * Checks whether the number of already rendered rows does not exceeds the number of rows visible in viewport + maximal
                 * number of rows rendered above and below viewport
                 * @returns {boolean}
                 */
                WalkontableRowStrategy.prototype.canRenderMoreRows = function () {
                  return this.remainingSize <= 0 || this.cellCount - this.visiblCellCount < this.curOuts;
                };
                
                WalkontableRowStrategy.prototype.remove = function () {
                  var size = this.cellSizes.pop();
                  this.cellSizesSum -= size;
                  this.cellCount--;
                  this.remainingSize -= size;
                };
                
                WalkontableRowStrategy.prototype.removeOutstanding = function () {
                  while (this.cellCount - this.visiblCellCount > this.curOuts) { //this row is completely off screen!
                    this.remove();
                  }
                };
                
                WalkontableRowStrategy.prototype.countRendered = function () {
                  return this.cellCount;
                }
                
                WalkontableRowStrategy.prototype.countVisible = function () {
                  return this.visiblCellCount;
                };
                
                WalkontableRowStrategy.prototype.isLastIncomplete = function () {
                  var lastRow = this.instance.wtTable.getLastVisibleRow();
                  var firstCol = this.instance.wtTable.getFirstVisibleColumn();
                  var cell = this.instance.wtTable.getCell(new WalkontableCellCoords(lastRow, firstCol));
                  var cellOffsetTop = Handsontable.Dom.offset(cell).top;
                  var cellHeight = Handsontable.Dom.outerHeight(cell);
                  var cellEnd = cellOffsetTop + cellHeight;
                
                  var viewportOffsetTop = this.instance.wtScrollbars.horizontal.scrollHandler.offsetTop + this.instance.wtScrollbars.vertical.getScrollPosition();
                  var viewportHeight = this.instance.wtViewport.getViewportHeight();
                  var viewportEnd = viewportOffsetTop + viewportHeight;
                
                
                  return viewportEnd < cellEnd;
                };
                
                function WalkontableScroll(instance) {
                  this.instance = instance;
                }
                
                WalkontableScroll.prototype.scrollVertical = function (delta) {
                  if (!this.instance.drawn) {
                    throw new Error('scrollVertical can only be called after table was drawn to DOM');
                  }
                
                  var instance = this.instance
                    , newOffset
                    , offset = instance.getSetting('offsetRow')
                    , fixedCount = instance.getSetting('fixedRowsTop')
                    , total = instance.getSetting('totalRows')
                    , maxSize = instance.wtViewport.getViewportHeight();
                
                  if (total > 0 && !this.instance.wtTable.isLastRowFullyVisible()) {
                    newOffset = this.scrollLogicVertical(delta, offset, total, fixedCount, maxSize, function (row) {
                      if (row - offset < fixedCount && row - offset >= 0) {
                        return instance.getSetting('rowHeight', row - offset);
                      }
                      else {
                        return instance.getSetting('rowHeight', row);
                      }
                    });
                
                  } else {
                    newOffset = 0;
                  }
                
                
                  if (newOffset !== offset) {
                    this.instance.wtScrollbars.vertical.scrollTo(newOffset);
                  }
                  return instance;
                };
                
                WalkontableScroll.prototype.scrollHorizontal = function (delta) {
                  this.instance.wtScrollbars.horizontal.scrollTo(delta);
                  return this.instance;
                };
                
                WalkontableScroll.prototype.scrollLogicVertical = function (delta, offset, total, fixedCount, maxSize, cellSizeFn) {
                  var newOffset = offset + delta;
                
                  if (newOffset >= total - fixedCount) {
                    newOffset = total - fixedCount - 1;
                  }
                
                  if (newOffset < 0) {
                    newOffset = 0;
                  }
                
                  return newOffset;
                };
                
                /**
                 * Scrolls viewport to a cell by minimum number of cells
                 * @param {WalkontableCellCoords} coords
                 */
                WalkontableScroll.prototype.scrollViewport = function (coords) {
                  if (!this.instance.drawn) {
                    return;
                  }
                
                  var offsetRow = this.instance.getSetting('offsetRow')
                    , totalRows = this.instance.getSetting('totalRows')
                    , totalColumns = this.instance.getSetting('totalColumns');
                
                
                  if (coords.row < 0 || coords.row > totalRows - 1) {
                    throw new Error('row ' + coords.row + ' does not exist');
                  }
                
                  if (coords.col < 0 || coords.col > totalColumns - 1) {
                    throw new Error('column ' + coords.col + ' does not exist');
                  }
                
                  var TD = this.instance.wtTable.getCell(coords);
                  if (typeof TD === 'object') {
                    if (coords.col >= this.instance.getSetting('fixedColumnsLeft')) {
                      this.scrollToRenderedCell(TD);
                    }
                  }  else if (coords.row >= this.instance.wtTable.getLastVisibleRow()) {
                
                    this.scrollVertical(coords.row - this.instance.wtTable.getLastVisibleRow());
                
                    if (coords.row == this.instance.wtTable.getLastVisibleRow() && this.instance.wtTable.getRowStrategy().isLastIncomplete()){
                      this.scrollViewport(coords)
                    }
                
                  } else if (coords.row >= this.instance.getSetting('fixedRowsTop')){
                    this.scrollVertical(coords.row - this.instance.wtTable.getFirstVisibleRow());
                  }
                };
                
                WalkontableScroll.prototype.scrollToRenderedCell = function (TD) {
                  var cellOffset = Handsontable.Dom.offset(TD);
                  var cellWidth = Handsontable.Dom.outerWidth(TD);
                  var cellHeight = Handsontable.Dom.outerHeight(TD);
                  var workspaceOffset = Handsontable.Dom.offset(this.instance.wtTable.TABLE);
                  var viewportScrollPosition = {
                    left: this.instance.wtScrollbars.horizontal.getScrollPosition(),
                    top: this.instance.wtScrollbars.vertical.getScrollPosition()
                  };
                
                  var workspaceWidth = this.instance.wtViewport.getWorkspaceWidth();
                  var workspaceHeight = this.instance.wtViewport.getWorkspaceHeight();
                  var leftCloneWidth = Handsontable.Dom.outerWidth(this.instance.wtScrollbars.horizontal.clone.wtTable.TABLE);
                  var topCloneHeight = Handsontable.Dom.outerHeight(this.instance.wtScrollbars.vertical.clone.wtTable.TABLE);
                
                  if (this.instance.wtScrollbars.horizontal.scrollHandler !== window) {
                    workspaceOffset.left = 0;
                    cellOffset.left -= Handsontable.Dom.offset(this.instance.wtScrollbars.horizontal.scrollHandler).left;
                  }
                
                  if (this.instance.wtScrollbars.vertical.scrollHandler !== window) {
                    workspaceOffset.top = 0;
                    cellOffset.top = cellOffset.top - Handsontable.Dom.offset(this.instance.wtScrollbars.vertical.scrollHandler).top;
                  }
                
                  if (cellWidth < workspaceWidth) {
                    if (cellOffset.left < viewportScrollPosition.left + leftCloneWidth) {
                      this.instance.wtScrollbars.horizontal.setScrollPosition(cellOffset.left - leftCloneWidth);
                    }
                    else if (cellOffset.left + cellWidth > workspaceOffset.left + viewportScrollPosition.left + workspaceWidth) {
                      var delta = (cellOffset.left + cellWidth) - (workspaceOffset.left + viewportScrollPosition.left + workspaceWidth);
                      this.instance.wtScrollbars.horizontal.setScrollPosition(viewportScrollPosition.left + delta);
                    }
                  }
                
                  if (cellHeight < workspaceHeight) {
                    if (cellOffset.top < viewportScrollPosition.top + topCloneHeight) {
                      this.instance.wtScrollbars.vertical.setScrollPosition(cellOffset.top - topCloneHeight);
                      this.instance.wtScrollbars.vertical.onScroll();
                    }
                    else if (cellOffset.top + cellHeight > viewportScrollPosition.top + workspaceHeight) {
                      this.instance.wtScrollbars.vertical.setScrollPosition(cellOffset.top - workspaceHeight + cellHeight);
                      this.instance.wtScrollbars.vertical.onScroll();
                    }
                  }
                
                };
                
                function WalkontableCornerScrollbarNative(instance) {
                  this.instance = instance;
                  this.type = 'corner';
                  this.init();
                  this.clone = this.makeClone('corner');
                }
                
                WalkontableCornerScrollbarNative.prototype = new WalkontableOverlay();
                
                WalkontableCornerScrollbarNative.prototype.resetFixedPosition = function () {
                  if (!this.instance.wtTable.holder.parentNode) {
                    return; //removed from DOM
                  }
                  var elem = this.clone.wtTable.holder.parentNode;
                
                  if (this.scrollHandler === window) {
                    var box = this.instance.wtTable.holder.getBoundingClientRect();
                    var top = Math.ceil(box.top);
                    var left = Math.ceil(box.left);
                
                    if (left < 0) {
                      elem.style.left = -left + 'px';
                    } else {
                      elem.style.left = '0';
                    }
                
                    if (top < 0) {
                      elem.style.top = -top + "px";
                    } else {
                      elem.style.top = "0";
                    }
                  }
                  else {
                    elem.style.top = this.instance.wtScrollbars.vertical.windowScrollPosition + "px";
                    elem.style.left = this.instance.wtScrollbars.horizontal.windowScrollPosition + "px";
                  }
                
                  elem.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 4 + 'px';
                  elem.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 4 + 'px';
                };
                
                WalkontableCornerScrollbarNative.prototype.refresh = function (selectionsOnly) {
                  WalkontableOverlay.prototype.refresh.call(this, selectionsOnly);
                };
                
                WalkontableCornerScrollbarNative.prototype.getScrollPosition = function () {
                };
                
                WalkontableCornerScrollbarNative.prototype.getLastCell = function () {
                };
                
                WalkontableCornerScrollbarNative.prototype.applyToDOM = function () {
                };
                
                WalkontableCornerScrollbarNative.prototype.scrollTo = function () {
                };
                
                WalkontableCornerScrollbarNative.prototype.readWindowSize = function () {
                };
                
                WalkontableCornerScrollbarNative.prototype.readSettings = function () {
                };
                function WalkontableHorizontalScrollbarNative(instance) {
                  this.instance = instance;
                  this.type = 'horizontal';
                  this.cellSize = 50;
                  this.offset = 0;
                  this.init();
                  this.clone = this.makeClone('left');
                }
                
                WalkontableHorizontalScrollbarNative.prototype = new WalkontableOverlay();
                
                //resetFixedPosition (in future merge it with this.refresh?)
                WalkontableHorizontalScrollbarNative.prototype.resetFixedPosition = function () {
                  if (!this.instance.wtTable.holder.parentNode) {
                    return; //removed from DOM
                  }
                  var elem = this.clone.wtTable.holder.parentNode;
                
                	if (this.scrollHandler === window) {
                    var box = this.instance.wtTable.holder.getBoundingClientRect();
                    var left = Math.ceil(box.left);
                
                    if (left < 0) {
                      elem.style.left = -left + 'px';
                    } else {
                      elem.style.left = '0';
                    }
                
                    elem.style.top = this.instance.wtTable.hider.style.top;
                  }
                  else {
                    elem.style.top = this.instance.wtTable.hider.style.top;
                    elem.style.left = this.windowScrollPosition + "px";
                  }
                
                  elem.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 'px';
                  elem.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 4 + 'px';
                };
                
                WalkontableHorizontalScrollbarNative.prototype.refresh = function (selectionsOnly) {
                  WalkontableOverlay.prototype.refresh.call(this, selectionsOnly);
                };
                
                WalkontableHorizontalScrollbarNative.prototype.getScrollPosition = function () {
                  return Handsontable.Dom.getScrollLeft(this.scrollHandler);
                };
                
                WalkontableHorizontalScrollbarNative.prototype.setScrollPosition = function (pos) {
                  if (this.scrollHandler === window){
                    window.scrollTo(pos, Handsontable.Dom.getWindowScrollTop());
                  } else {
                    this.scrollHandler.scrollLeft = pos;
                  }
                };
                
                WalkontableHorizontalScrollbarNative.prototype.onScroll = function () {
                  WalkontableOverlay.prototype.onScroll.call(this);
                
                  this.instance.getSetting('onScrollHorizontally');
                };
                
                WalkontableHorizontalScrollbarNative.prototype.getLastCell = function () {
                  return this.instance.wtTable.getLastVisibleColumn();
                };
                
                //applyToDOM (in future merge it with this.refresh?)
                WalkontableHorizontalScrollbarNative.prototype.applyToDOM = function () {
                  this.readWindowSize();
                };
                
                WalkontableHorizontalScrollbarNative.prototype.scrollTo = function (cell) {
                  this.setScrollPosition(this.tableParentOffset + cell * this.cellSize);
                };
                
                WalkontableHorizontalScrollbarNative.prototype.readWindowSize = function () {
                  if (this.scrollHandler === window) {
                    this.windowSize = document.documentElement.clientWidth;
                    this.tableParentOffset = this.instance.wtTable.holderOffset.left;
                  }
                  else {
                    this.windowSize = this.scrollHandler.clientWidth;
                    this.tableParentOffset = 0;
                  }
                  this.windowScrollPosition = this.getScrollPosition();
                };
                
                WalkontableHorizontalScrollbarNative.prototype.readSettings = function () {
                  this.readWindowSize();
                  this.total = this.instance.getSetting('totalColumns');
                };
                function WalkontableVerticalScrollbarNative(instance) {
                  this.instance = instance;
                  this.type = 'vertical';
                  this.cellSize = this.instance.wtSettings.settings.defaultRowHeight;
                  this.offset;
                  this.total;
                  this.init();
                  this.clone = this.makeClone('top');
                }
                
                WalkontableVerticalScrollbarNative.prototype = new WalkontableOverlay();
                
                //resetFixedPosition (in future merge it with this.refresh?)
                WalkontableVerticalScrollbarNative.prototype.resetFixedPosition = function () {
                  if (!this.instance.wtTable.holder.parentNode) {
                    return; //removed from DOM
                  }
                  var elem = this.clone.wtTable.holder.parentNode;
                
                  if (this.scrollHandler === window) {
                    var box = this.instance.wtTable.holder.getBoundingClientRect();
                    var top = Math.ceil(box.top);
                
                    elem.style.left = '0';
                
                    if (top < 0) {
                      elem.style.top = -top + "px";
                    } else {
                      elem.style.top = "0";
                    }
                  }
                  else {
                    elem.style.top = this.windowScrollPosition + "px";
                    elem.style.left = '0';
                  }
                
                  if (this.instance.wtScrollbars.horizontal.scrollHandler === window) {
                    elem.style.width = this.instance.wtViewport.getWorkspaceActualWidth() + 'px';
                  }
                  else {
                    elem.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 'px';
                  }
                
                  elem.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 4 + 'px';
                };
                
                WalkontableVerticalScrollbarNative.prototype.getScrollPosition = function () {
                  return Handsontable.Dom.getScrollTop(this.scrollHandler);
                };
                
                WalkontableVerticalScrollbarNative.prototype.setScrollPosition = function (pos) {
                  if (this.scrollHandler === window){
                    window.scrollTo(Handsontable.Dom.getWindowScrollLeft(), pos);
                  } else {
                    this.scrollHandler.scrollTop = pos;
                  }
                };
                
                WalkontableVerticalScrollbarNative.prototype.onScroll = function () {
                  WalkontableOverlay.prototype.onScroll.call(this);
                
                  this.instance.draw(true);//
                
                  this.instance.getSetting('onScrollVertically');
                };
                
                WalkontableVerticalScrollbarNative.prototype.getLastCell = function () {
                  return this.instance.getSetting('offsetRow') + this.instance.wtTable.tbodyChildrenLength - 1;
                };
                
                WalkontableVerticalScrollbarNative.prototype.sumCellSizes = function (from, length) {
                  var sum = 0;
                  while (from < length) {
                    sum += this.instance.wtSettings.settings.rowHeight(from) || this.instance.wtSettings.settings.defaultRowHeight; //TODO optimize getSetting, because this is MUCH faster then getSetting
                    from++;
                  }
                  return sum;
                };
                
                WalkontableVerticalScrollbarNative.prototype.refresh = function (selectionsOnly) {
                  this.applyToDOM();
                  WalkontableOverlay.prototype.refresh.call(this, selectionsOnly);
                };
                
                //applyToDOM (in future merge it with this.refresh?)
                WalkontableVerticalScrollbarNative.prototype.applyToDOM = function () {
                  var last = this.getLastCell();
                  this.measureBefore = this.sumCellSizes(0, this.offset);
                  if (last === -1) { //last -1 means that viewport is scrolled behind the table
                    this.measureAfter = 0;
                  }
                  else {
                    this.measureAfter = this.sumCellSizes(last, this.total - last);
                  }
                  var headerSize = this.instance.wtViewport.getColumnHeaderHeight();
                  this.fixedContainer.style.height = headerSize + this.sumCellSizes(0, this.total) + 4 + 'px'; //+4 is needed, otherwise vertical scroll appears in Chrome (window scroll mode) - maybe because of fill handle in last row or because of box shadow
                  this.fixed.style.top = this.measureBefore + 'px';
                  this.fixed.style.bottom = '';
                };
                
                WalkontableVerticalScrollbarNative.prototype.scrollTo = function (cell) {
                  var newY = this.tableParentOffset + cell * this.cellSize;
                  this.setScrollPosition(newY);
                  this.onScroll();
                };
                
                WalkontableVerticalScrollbarNative.prototype.readWindowSize = function () {
                  if (this.scrollHandler === window) {
                    this.windowSize = document.documentElement.clientHeight;
                    this.tableParentOffset = this.instance.wtTable.holderOffset.top;
                  }
                  else {
                    var elemHeight = Handsontable.Dom.outerHeight(this.scrollHandler);
                    this.windowSize = elemHeight > 0 && this.scrollHandler.clientHeight > 0 ? this.scrollHandler.clientHeight : Infinity; //returns height without DIV scrollbar
                    this.tableParentOffset = 0;
                  }
                  this.windowScrollPosition = this.getScrollPosition();
                };
                
                WalkontableVerticalScrollbarNative.prototype.readSettings = function () {
                  this.readWindowSize();
                
                  this.offset = this.instance.getSetting('offsetRow');
                  this.total = this.instance.getSetting('totalRows');
                
                  var scrollDelta = this.windowScrollPosition - this.tableParentOffset;
                
                  var sum = 0;
                  var last;
                  for (var i = 0; i < this.total; i++) {
                    last = this.instance.getSetting('rowHeight', i) || this.instance.wtSettings.settings.defaultRowHeight;
                    sum += last;
                    if (sum - 1 > scrollDelta) {
                      break;
                    }
                  }
                
                  this.offset = Math.min(i, this.total);
                  this.instance.update('offsetRow', this.offset);
                };
                function WalkontableScrollbars(instance) {
                  this.instance = instance;
                  instance.update('scrollbarWidth', Handsontable.Dom.getScrollbarWidth());
                  instance.update('scrollbarHeight', Handsontable.Dom.getScrollbarWidth());
                  this.vertical = new WalkontableVerticalScrollbarNative(instance);
                  this.horizontal = new WalkontableHorizontalScrollbarNative(instance);
                  this.corner = new WalkontableCornerScrollbarNative(instance);
                  if (instance.getSetting('debug')) {
                    this.debug = new WalkontableDebugOverlay(instance);
                  }
                  this.registerListeners();
                }
                
                WalkontableScrollbars.prototype.registerListeners = function () {
                  var that = this;
                
                  var oldVerticalScrollPosition
                    , oldHorizontalScrollPosition
                    , oldBoxTop
                    , oldBoxLeft;
                
                  function refreshAll() {
                    if(!that.instance.drawn) {
                      return;
                    }
                
                    if (!that.instance.wtTable.holder.parentNode) {
                      //Walkontable was detached from DOM, but this handler was not removed
                      that.destroy();
                      return;
                    }
                
                    that.vertical.windowScrollPosition = that.vertical.getScrollPosition();
                    that.horizontal.windowScrollPosition = that.horizontal.getScrollPosition();
                    that.box = that.instance.wtTable.hider.getBoundingClientRect();
                
                    if (that.vertical.windowScrollPosition !== oldVerticalScrollPosition || that.horizontal.windowScrollPosition !== oldHorizontalScrollPosition || that.box.top !== oldBoxTop || that.box.left !== oldBoxLeft) {
                      that.vertical.onScroll();
                      that.horizontal.onScroll(); //it's done here to make sure that all onScroll's are executed before changing styles
                      that.corner.onScroll();
                
                      oldVerticalScrollPosition = that.vertical.windowScrollPosition;
                      oldHorizontalScrollPosition = that.horizontal.windowScrollPosition;
                      oldBoxTop = that.box.top;
                      oldBoxLeft = that.box.left;
                    }
                  }
                
                  var $window = $(window);
                  this.vertical.$scrollHandler.on('scroll.' + this.instance.guid, refreshAll);
                  if (this.vertical.scrollHandler !== this.horizontal.scrollHandler) {
                    this.horizontal.$scrollHandler.on('scroll.' + this.instance.guid, refreshAll);
                  }
                
                  if (this.vertical.scrollHandler !== window && this.horizontal.scrollHandler !== window) {
                    $window.on('scroll.' + this.instance.guid, refreshAll);
                  }
                };
                
                WalkontableScrollbars.prototype.destroy = function () {
                  if (this.vertical) {
                    this.vertical.destroy();
                    this.vertical.$scrollHandler.off('scroll.' + this.instance.guid);
                  }
                  if (this.horizontal) {
                    this.horizontal.destroy();
                    this.vertical.$scrollHandler.off('scroll.' + this.instance.guid);
                  }
                  $(window).off('scroll.' + this.instance.guid);
                  this.corner && this.corner.destroy();
                  this.debug && this.debug.destroy();
                };
                
                WalkontableScrollbars.prototype.refresh = function (selectionsOnly) {
                  this.horizontal && this.horizontal.readSettings();
                  this.vertical && this.vertical.readSettings();
                  this.horizontal && this.horizontal.refresh(selectionsOnly);
                  this.vertical && this.vertical.refresh(selectionsOnly);
                  this.corner && this.corner.refresh(selectionsOnly);
                  this.debug && this.debug.refresh(selectionsOnly);
                };
                
                WalkontableScrollbars.prototype.applyToDOM = function () {
                  this.horizontal && this.horizontal.applyToDOM();
                  this.vertical && this.vertical.applyToDOM();
                  this.corner && this.corner.applyToDOM();
                  this.debug && this.debug.applyToDOM();
                };
                function WalkontableSelection(instance, settings) {
                  this.instance = instance;
                  this.settings = settings;
                  this.cellRange = null;
                  if (settings.border) {
                    this.border = new WalkontableBorder(instance, settings);
                  }
                }
                
                /**
                 * Returns boolean information if selection is empty
                 * @returns {boolean}
                 */
                WalkontableSelection.prototype.isEmpty = function () {
                  return (this.cellRange === null);
                };
                
                /**
                 * Adds a cell coords to the selection
                 * @param {WalkontableCellCoords} coords
                 */
                WalkontableSelection.prototype.add = function (coords) {
                  if (this.isEmpty()) {
                    this.cellRange = new WalkontableCellRange(coords, coords, coords);
                  }
                  else {
                    this.cellRange.expand(coords);
                  }
                };
                
                /**
                 * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean information about success
                 * @param {WalkontableCellCoords} oldCoords
                 * @param {WalkontableCellCoords} newCoords
                 * @return {boolean}
                 */
                WalkontableSelection.prototype.replace = function (oldCoords, newCoords) {
                  if (!this.isEmpty()) {
                    if(this.cellRange.from.isEqual(oldCoords)) {
                      this.cellRange.from = newCoords;
                      return true;
                    }
                    if(this.cellRange.to.isEqual(oldCoords)) {
                      this.cellRange.to = newCoords;
                      return true;
                    }
                  }
                  return false;
                };
                
                WalkontableSelection.prototype.clear = function () {
                  this.cellRange = null;
                };
                
                /**
                 * Returns the top left (TL) and bottom right (BR) selection coordinates
                 * @returns {Object}
                 */
                WalkontableSelection.prototype.getCorners = function () {
                  var topLeft = this.cellRange.getTopLeftCorner();
                  var bottomRight = this.cellRange.getBottomRightCorner();
                  return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];
                };
                
                WalkontableSelection.prototype.draw = function () {
                  var corners, r, c, source_r, source_c,
                    instance = this.instance,
                    visibleRows = instance.wtTable.getRowStrategy().countVisible(),
                    renderedColumns = instance.wtTable.getColumnStrategy().cellCount,
                    cacheLength;
                
                  if (!this.isEmpty()) {
                    corners = this.getCorners();
                
                    for (r = 0; r < visibleRows; r++) {
                      for (c = 0; c < renderedColumns; c++) {
                        source_r = instance.wtTable.rowFilter.visibleToSource(r);
                        source_c = instance.wtTable.columnFilter.visibleToSource(c);
                
                        if (source_r >= corners[0] && source_r <= corners[2] && source_c >= corners[1] && source_c <= corners[3]) {
                          //selected cell
                          if (this.settings.className) {
                            instance.wtTable.currentCellCache.add(r, c, this.settings.className);
                          }
                        }
                        else if (source_r >= corners[0] && source_r <= corners[2]) {
                          //selection is in this row
                          instance.wtTable.currentCellCache.add(r, c, this.settings.highlightRowClassName);
                
                          // selected row headers
                          instance.wtTable.currentCellCache.add(r,renderedColumns,this.settings.highlightRowClassName);
                        }
                        else if (source_c >= corners[1] && source_c <= corners[3]) {
                          //selection is in this column
                          instance.wtTable.currentCellCache.add(r, c, this.settings.highlightColumnClassName);
                
                          // selected column headers
                          instance.wtTable.currentCellCache.add(visibleRows,c,this.settings.highlightColumnClassName);
                        }
                      }
                    }
                
                    this.border && this.border.appear(corners); //warning! border.appear modifies corners!
                  }
                  else {
                    this.border && this.border.disappear();
                  }
                };
                
                /*
                  Make a clone of a selection by overriding the WOT instance and creating new WalkontableBorder for the new instance
                  Method is used for creating selections in overlays
                 */
                WalkontableSelection.prototype.makeClone = function (instance) {
                  function WalkontableSelectionClone(){}
                  WalkontableSelectionClone.prototype = this;
                
                  var clone = new WalkontableSelectionClone();
                
                  clone.instance = instance;
                
                  if (clone.border){
                    clone.border = new WalkontableBorder(instance, clone.settings);
                  }
                
                  return clone;
                
                };
                
                function WalkontableSettings(instance, settings) {
                  var that = this;
                  this.instance = instance;
                
                  //default settings. void 0 means it is required, null means it can be empty
                  this.defaults = {
                    table: void 0,
                    debug: false, //shows WalkontableDebugOverlay
                
                    //presentation mode
                    stretchH: 'none', //values: all, last, none
                    currentRowClassName: null,
                    currentColumnClassName: null,
                
                    //data source
                    data: void 0,
                    offsetRow: 0,
                    fixedColumnsLeft: 0,
                    fixedRowsTop: 0,
                    rowHeaders: function () {
                      return []
                    }, //this must be array of functions: [function (row, TH) {}]
                    columnHeaders: function () {
                      return []
                    }, //this must be array of functions: [function (column, TH) {}]
                    totalRows: void 0,
                    totalColumns: void 0,
                    width: null,
                    height: null,
                    cellRenderer: function (row, column, TD) {
                      var cellData = that.getSetting('data', row, column);
                      Handsontable.Dom.fastInnerText(TD, cellData === void 0 || cellData === null ? '' : cellData);
                    },
                    columnWidth: 50,
                    rowHeight: function (row) {
                      return 23;
                    },
                    defaultRowHeight: 23,
                    selections: null,
                    hideBorderOnMouseDownOver: false,
                
                    //callbacks
                    onCellMouseDown: null,
                    onCellMouseOver: null,
                //    onCellMouseOut: null,
                    onCellDblClick: null,
                    onCellCornerMouseDown: null,
                    onCellCornerDblClick: null,
                    beforeDraw: null,
                    onDraw: null,
                    onScrollVertically: null,
                    onScrollHorizontally: null,
                
                    //constants
                    scrollbarWidth: 10,
                    scrollbarHeight: 10,
                
                    renderAllRows: false
                  };
                
                  //reference to settings
                  this.settings = {};
                  for (var i in this.defaults) {
                    if (this.defaults.hasOwnProperty(i)) {
                      if (settings[i] !== void 0) {
                        this.settings[i] = settings[i];
                      }
                      else if (this.defaults[i] === void 0) {
                        throw new Error('A required setting "' + i + '" was not provided');
                      }
                      else {
                        this.settings[i] = this.defaults[i];
                      }
                    }
                  }
                }
                
                /**
                 * generic methods
                 */
                
                WalkontableSettings.prototype.update = function (settings, value) {
                  if (value === void 0) { //settings is object
                    for (var i in settings) {
                      if (settings.hasOwnProperty(i)) {
                        this.settings[i] = settings[i];
                      }
                    }
                  }
                  else { //if value is defined then settings is the key
                    this.settings[settings] = value;
                  }
                  return this.instance;
                };
                
                WalkontableSettings.prototype.getSetting = function (key, param1, param2, param3, param4) {
                  if (typeof this.settings[key] === 'function') {
                    return this.settings[key](param1, param2, param3, param4); //this is faster than .apply - https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
                  }
                  else if (param1 !== void 0 && Object.prototype.toString.call(this.settings[key]) === '[object Array]') { //perhaps this can be removed, it is only used in tests
                    return this.settings[key][param1];
                  }
                  else {
                    return this.settings[key];
                  }
                };
                
                WalkontableSettings.prototype.has = function (key) {
                  return !!this.settings[key]
                };
                function WalkontableTable(instance, table) {
                  //reference to instance
                  this.instance = instance;
                  this.TABLE = table;
                  Handsontable.Dom.removeTextNodes(this.TABLE);
                
                  //wtSpreader
                  var parent = this.TABLE.parentNode;
                  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {
                    var spreader = document.createElement('DIV');
                    spreader.className = 'wtSpreader';
                    if (parent) {
                      parent.insertBefore(spreader, this.TABLE); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
                    }
                    spreader.appendChild(this.TABLE);
                  }
                  this.spreader = this.TABLE.parentNode;
                
                  //wtHider
                  parent = this.spreader.parentNode;
                  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {
                    var hider = document.createElement('DIV');
                    hider.className = 'wtHider';
                    if (parent) {
                      parent.insertBefore(hider, this.spreader); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
                    }
                    hider.appendChild(this.spreader);
                  }
                  this.hider = this.spreader.parentNode;
                  this.hiderStyle = this.hider.style;
                  this.hiderStyle.position = 'relative';
                
                  //wtHolder
                  parent = this.hider.parentNode;
                  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {
                    var holder = document.createElement('DIV');
                    holder.style.position = 'relative';
                    holder.className = 'wtHolder';
                
                    if(!instance.cloneSource) {
                      holder.className += ' ht_master';
                    }
                
                    if (parent) {
                      parent.insertBefore(holder, this.hider); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
                    }
                    holder.appendChild(this.hider);
                  }
                  this.holder = this.hider.parentNode;
                
                  //bootstrap from settings
                  this.TBODY = this.TABLE.getElementsByTagName('TBODY')[0];
                  if (!this.TBODY) {
                    this.TBODY = document.createElement('TBODY');
                    this.TABLE.appendChild(this.TBODY);
                  }
                  this.THEAD = this.TABLE.getElementsByTagName('THEAD')[0];
                  if (!this.THEAD) {
                    this.THEAD = document.createElement('THEAD');
                    this.TABLE.insertBefore(this.THEAD, this.TBODY);
                  }
                  this.COLGROUP = this.TABLE.getElementsByTagName('COLGROUP')[0];
                  if (!this.COLGROUP) {
                    this.COLGROUP = document.createElement('COLGROUP');
                    this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
                  }
                
                  if (this.instance.getSetting('columnHeaders').length) {
                    if (!this.THEAD.childNodes.length) {
                      var TR = document.createElement('TR');
                      this.THEAD.appendChild(TR);
                    }
                  }
                
                  this.colgroupChildrenLength = this.COLGROUP.childNodes.length;
                  this.theadChildrenLength = this.THEAD.firstChild ? this.THEAD.firstChild.childNodes.length : 0;
                  this.tbodyChildrenLength = this.TBODY.childNodes.length;
                
                  this.oldCellCache = new WalkontableClassNameCache();
                  this.currentCellCache = new WalkontableClassNameCache();
                
                  this.rowFilter = null;
                  this.columnFilter = null;
                
                  this.columnWidthCache = [];
                }
                
                WalkontableTable.prototype.getRowStrategy = function () {
                  return this.isWorkingOnClone() ? this.instance.cloneSource.wtTable.rowStrategy : this.rowStrategy;
                };
                
                WalkontableTable.prototype.getColumnStrategy = function () {
                  return this.isWorkingOnClone() ? this.instance.cloneSource.wtTable.columnStrategy : this.columnStrategy;
                };
                
                WalkontableTable.prototype.isWorkingOnClone = function () {
                  return !!this.instance.cloneSource;
                };
                
                WalkontableTable.prototype.refreshHiderDimensions = function () {
                  var spreaderStyle = this.spreader.style;
                  spreaderStyle.position = 'relative';
                  spreaderStyle.width = 'auto';
                  spreaderStyle.height = 'auto';
                };
                
                WalkontableTable.prototype.draw = function (selectionsOnly) {
                  if (!selectionsOnly) {
                    if (this.isWorkingOnClone()) {
                      this.tableOffset = this.instance.cloneSource.wtTable.tableOffset;
                    }
                    else {
                      this.holderOffset = Handsontable.Dom.offset(this.holder);
                      this.tableOffset = Handsontable.Dom.offset(this.TABLE);
                      this.instance.wtScrollbars.vertical.readSettings();
                      this.instance.wtScrollbars.horizontal.readSettings();
                      this.instance.wtViewport.resetSettings();
                    }
                    var offsetRow;
                    if (this.instance.cloneOverlay instanceof WalkontableDebugOverlay
                        || this.instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative
                        || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
                      offsetRow = 0;
                    }
                    else {
                      offsetRow = this.instance.wtSettings.settings.offsetRow;
                    }
                
                    this.rowFilter = new WalkontableRowFilter(
                      offsetRow,
                      this.instance.getSetting('totalRows'),
                      this.instance.getSetting('columnHeaders').length
                    );
                    this.columnFilter = new WalkontableColumnFilter(
                      this.instance.getSetting('totalColumns'),
                      this.instance.getSetting('rowHeaders').length
                    );
                    this._doDraw();
                  }
                  else {
                    this.instance.wtScrollbars && this.instance.wtScrollbars.refresh(true);
                  }
                
                  this.refreshPositions(selectionsOnly);
                
                  if (!selectionsOnly) {
                    if (!this.isWorkingOnClone()) {
                      this.instance.wtScrollbars.vertical.resetFixedPosition();
                      this.instance.wtScrollbars.horizontal.resetFixedPosition();
                      this.instance.wtScrollbars.corner.resetFixedPosition();
                      this.instance.wtScrollbars.debug && this.instance.wtScrollbars.debug.resetFixedPosition();
                    }
                  }
                
                  this.instance.drawn = true;
                  return this;
                };
                
                WalkontableTable.prototype._doDraw = function () {
                  var wtRenderer = new WalkontableTableRenderer(this);
                  wtRenderer.render();
                };
                
                WalkontableTable.prototype.refreshPositions = function (selectionsOnly) {
                  this.refreshHiderDimensions();
                  this.refreshSelections(selectionsOnly);
                };
                
                WalkontableTable.prototype.refreshSelections = function (selectionsOnly) {
                  var vr
                    , r
                    , vc
                    , c
                    , s
                    , slen
                    , classNames = []
                    , visibleRows = this.getRowStrategy().countVisible()
                    , renderedCells = this.getColumnStrategy().cellCount
                    , cacheLength;
                
                
                  this.oldCellCache = this.currentCellCache;
                  this.currentCellCache = new WalkontableClassNameCache();
                
                  if (this.instance.selections) {
                    for (var i = 0, ilen = this.instance.selections.length; i < ilen; i++) {
                      this.instance.selections[i].draw();
                
                      if (this.instance.selections[i].settings.className) {
                        classNames.push(this.instance.selections[i].settings.className);
                      }
                      if (this.instance.selections[i].settings.highlightRowClassName) {
                        classNames.push(this.instance.selections[i].settings.highlightRowClassName);
                      }
                      if (this.instance.selections[i].settings.highlightColumnClassName) {
                        classNames.push(this.instance.selections[i].settings.highlightColumnClassName);
                      }
                    }
                  }
                
                  slen = classNames.length;
                
                  for (vr = 0; vr < visibleRows; vr++) {
                    for (vc = 0; vc < renderedCells; vc++) {
                      r = this.rowFilter.visibleToSource(vr);
                      c = this.columnFilter.visibleToSource(vc);
                      for (s = 0; s < slen; s++) {
                        var cell;
                        if (this.currentCellCache.test(vr, vc, classNames[s])) {
                          cell = this.getCell(new WalkontableCellCoords(r, c));
                          if (typeof cell == 'object' ) Handsontable.Dom.addClass(cell, classNames[s]);
                        }
                        else if (selectionsOnly && this.oldCellCache.test(vr, vc, classNames[s])) {
                          cell = this.getCell(new WalkontableCellCoords(r, c));
                          if (typeof cell == 'object' ) Handsontable.Dom.removeClass(cell, classNames[s]);
                
                        }
                
                        // for headers:
                        // column headers
                        cacheLength = this.currentCellCache.cache ? visibleRows : 0;
                        cell = this.getColumnHeader(vc);
                        if (this.currentCellCache.test(cacheLength, vc, classNames[s])) {
                          if (typeof cell == 'object' ) Handsontable.Dom.addClass(cell,classNames[s]);
                        } else {
                          if (typeof cell == 'object' ) Handsontable.Dom.removeClass(cell,classNames[s]);
                        }
                
                        // row headers
                        cacheLength = this.currentCellCache.cache[vr] ? renderedCells : 0;
                        cell = this.getRowHeader(vr) != -1 ? this.getRowHeader(vr) : undefined;
                
                        if (this.currentCellCache.test(vr, cacheLength, classNames[s])) {
                          if (typeof cell == 'object' ) Handsontable.Dom.addClass(cell,classNames[s]);
                        } else {
                          if (typeof cell == 'object' ) Handsontable.Dom.removeClass(cell,classNames[s]);
                       }
                
                      }
                    }
                  }
                
                };
                
                /**
                 * getCell
                 * @param {WalkontableCellCoords} coords
                 * @return {Object} HTMLElement on success or {Number} one of the exit codes on error:
                 *  -1 row before viewport
                 *  -2 row after viewport
                 *
                 */
                WalkontableTable.prototype.getCell = function (coords) {
                  if (this.isRowBeforeViewport(coords.row)) {
                    return -1; //row before viewport
                  }
                  else if (this.isRowAfterViewport(coords.row)) {
                    return -2; //row after viewport
                  }
                
                  var TR = this.TBODY.childNodes[this.rowFilter.sourceToVisible(coords.row)];
                
                  if (TR) {
                    return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(coords.col)];
                  }
                };
                
                /**
                 * getColumnHeader
                 * @param col
                 * @return {Object} HTMLElement on success or undefined on error
                 *
                 */
                WalkontableTable.prototype.getColumnHeader = function(col) {
                  var THEAD = this.THEAD.childNodes[0];
                  if (THEAD) {
                    return THEAD.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
                  }
                };
                
                /**
                 * getRowHeader
                 * @param row
                 * @return {Object} HTMLElement on success or {Number} one of the exit codes on error:
                 *  -1 table doesn't have row headers
                 *
                 */
                WalkontableTable.prototype.getRowHeader = function(row) {
                  if(this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) == 0) {
                    return -1;
                  }
                
                  var TR = this.TBODY.childNodes[this.rowFilter.sourceToVisible(row)];
                
                  if (TR) {
                    return TR.childNodes[0];
                  }
                };
                
                /**
                 * Returns cell coords object for a given TD
                 * @param TD
                 * @returns {WalkontableCellCoords}
                 */
                WalkontableTable.prototype.getCoords = function (TD) {
                  var TR = TD.parentNode;
                  var row = Handsontable.Dom.index(TR);
                  if (TR.parentNode === this.THEAD) {
                    row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
                  }
                  else {
                    row = this.rowFilter.visibleToSource(row);
                  }
                
                  return new WalkontableCellCoords(
                    row,
                    this.columnFilter.visibleRowHeadedColumnToSourceColumn(TD.cellIndex)
                  );
                };
                
                WalkontableTable.prototype.getTrForRow = function (row) {
                  return this.TBODY.childNodes[this.rowFilter.sourceToVisible(row)];
                };
                
                //returns -1 if no row is visible
                WalkontableTable.prototype.getFirstVisibleRow = function () {
                  return this.rowFilter.visibleToSource(0);
                };
                
                //returns -1 if no column is visible
                WalkontableTable.prototype.getFirstVisibleColumn = function () {
                
                  if (this.isWorkingOnClone()){
                    if (this.instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative){
                      return 0;
                    } else {
                      return this.instance.cloneSource.wtTable.getFirstVisibleColumn();
                    }
                  }
                
                  var leftOffset = this.instance.wtScrollbars.horizontal.getScrollPosition();
                  var columnCount = this.getColumnStrategy().cellCount;
                  var firstTR = this.TBODY.firstChild;
                
                  if (!firstTR){
                    return 0;
                  }
                
                  for (var colIndex = 0; colIndex < columnCount; colIndex++){
                    leftOffset -= firstTR.childNodes[colIndex].offsetWidth;
                
                    if (leftOffset < 0){
                      return colIndex;
                    }
                
                  }
                
                  return -1;
                };
                
                //returns -1 if no row is visible
                WalkontableTable.prototype.getLastVisibleRow = function () {
                  var lastVisibleRow =  this.rowFilter.visibleToSource(this.getRowStrategy().countVisible() - 1);
                  var instance = this.instance;
                
                  if (instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
                    var fixedRowsTop = this.instance.getSetting('fixedRowsTop');
                
                    return Math.min(fixedRowsTop - 1, lastVisibleRow);
                  } else {
                    return lastVisibleRow;
                  }
                
                };
                
                //returns -1 if no column is visible
                WalkontableTable.prototype.getLastVisibleColumn = function () {
                  var instance = this.instance;
                
                  if (this.isWorkingOnClone()){
                
                    if (instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative){
                      var lastVisibleColumn = this.getColumnStrategy().countVisible() - 1;
                      var fixedColumnsLeft =  instance.getSetting('fixedColumnsLeft');
                      return Math.min(fixedColumnsLeft - 1, lastVisibleColumn);
                    } else {
                      return this.instance.cloneSource.wtTable.getLastVisibleColumn();
                    }
                
                  }
                
                
                  var leftOffset = this.instance.wtScrollbars.horizontal.getScrollPosition();
                  var leftPartOfTable = leftOffset + this.instance.wtViewport.getWorkspaceWidth(Infinity);
                  var columnCount = this.getColumnStrategy().cellCount;
                  var rowHeaderCount = this.instance.getSetting('rowHeaders').length || 0;
                  var firstTR = this.TBODY.firstChild;
                
                  if (!columnCount) {
                    return -1;
                  }
                
                  for (var colIndex = 0; colIndex < columnCount + rowHeaderCount; colIndex++){
                    leftPartOfTable -= firstTR.childNodes[colIndex].offsetWidth;
                
                    if (leftPartOfTable <= 0){
                      return colIndex - rowHeaderCount;
                    }
                
                  }
                
                  return colIndex - rowHeaderCount - 1;
                };
                
                WalkontableTable.prototype.isRowBeforeViewport = function (r) {
                  return (this.rowFilter.sourceToVisible(r) < 0 && r >= 0);
                };
                
                WalkontableTable.prototype.isRowAfterViewport = function (r) {
                  return (r > this.getLastVisibleRow());
                };
                
                WalkontableTable.prototype.isColumnBeforeViewport = function (c) {
                  return (this.columnFilter.sourceToVisible(c) < 0 && c >= 0);
                };
                
                WalkontableTable.prototype.isColumnAfterViewport = function (c) {
                  return (c > this.getLastVisibleColumn());
                };
                
                WalkontableTable.prototype.isRowInViewport = function (r) {
                  return (!this.isRowBeforeViewport(r) && !this.isRowAfterViewport(r));
                };
                
                WalkontableTable.prototype.isColumnInViewport = function (c) {
                  return (!this.isColumnBeforeViewport(c) && !this.isColumnAfterViewport(c));
                };
                
                WalkontableTable.prototype.isLastRowFullyVisible = function () {
                  return (this.getLastVisibleRow() === this.instance.getSetting('totalRows') - 1 && !this.getRowStrategy().isLastIncomplete());
                };
                
                WalkontableTable.prototype.isLastColumnFullyVisible = function () {
                  return (this.getLastVisibleColumn() === this.instance.getSetting('totalColumns') - 1 && !this.getColumnStrategy().isLastIncomplete());
                };
                
                WalkontableTable.prototype.getVisibleRowsCount = function () {
                  return this.getRowStrategy().countVisible();
                };
                
                WalkontableTable.prototype.allRowsInViewport = function () {
                  return this.getRowStrategy().cellCount == this.getVisibleRowsCount();
                };
                
                function WalkontableTableRenderer(wtTable){
                  this.wtTable = wtTable;
                  this.instance = wtTable.instance;
                  this.rowFilter = wtTable.rowFilter;
                  this.columnFilter = wtTable.columnFilter;
                
                  this.TABLE = wtTable.TABLE;
                  this.THEAD = wtTable.THEAD;
                  this.TBODY = wtTable.TBODY;
                  this.COLGROUP = wtTable.COLGROUP;
                
                  this.utils = WalkontableTableRenderer.utils;
                
                }
                
                  WalkontableTableRenderer.prototype.render = function () {
                    if (!this.wtTable.isWorkingOnClone()) {
                      this.instance.getSetting('beforeDraw', true);
                    }
                
                    this.rowHeaders = this.instance.getSetting('rowHeaders');
                    this.rowHeaderCount = this.rowHeaders.length;
                    this.fixedRowsTop = this.instance.getSetting('fixedRowsTop');
                    this.columnHeaders = this.instance.getSetting('columnHeaders');
                
                  var visibleColIndex
                    , totalRows = this.instance.getSetting('totalRows')
                    , totalColumns = this.instance.getSetting('totalColumns')
                    , displayTds
                    , TR
                    , TD
                    , TH
                    , adjusted = false
                    , workspaceWidth
                    , res;
                
                  if (totalColumns > 0) {
                    var cloneLimit;
                    if (this.wtTable.isWorkingOnClone()) { //must be run after adjustAvailableNodes because otherwise this.rowStrategy is not yet defined
                      if (this.instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
                        cloneLimit = this.fixedRowsTop;
                      }
                      else if (this.instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative) {
                        cloneLimit = this.wtTable.getRowStrategy().cellCount;
                      }
                      //else if WalkontableDebugOverlay do nothing. No cloneLimit means render ALL rows
                    }
                
                    this.adjustAvailableNodes();
                    adjusted = true;
                
                    this.renderColGroups();
                
                    this.renderColumnHeaders();
                
                    displayTds = this.getColumnCount();
                
                    //Render table rows
                    this.renderRows(totalRows, cloneLimit, displayTds);
                
                    if (!this.wtTable.isWorkingOnClone()) {
                      workspaceWidth = this.instance.wtViewport.getWorkspaceWidth();
                      this.instance.wtViewport.containerWidth = null;
                      this.wtTable.getColumnStrategy().stretch();
                    }
                
                    this.adjustColumnWidths(displayTds);
                  }
                
                  if (!adjusted) {
                    this.adjustAvailableNodes();
                  }
                
                  if (!(this.instance.cloneOverlay instanceof WalkontableDebugOverlay)) {
                    this.removeRedundantRows();
                  }
                
                  if (!this.wtTable.isWorkingOnClone()) {
                    this.markOversizedRows();
                
                    this.instance.wtScrollbars.applyToDOM();
                
                    if (workspaceWidth !== this.instance.wtViewport.getWorkspaceWidth()) {
                      //workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching
                      this.instance.wtViewport.containerWidth = null;
                      this.wtTable.getColumnStrategy().stretch();
                      var cache = this.instance.wtTable.columnWidthCache;
                      for (visibleColIndex = 0; visibleColIndex < this.wtTable.getColumnStrategy().cellCount; visibleColIndex++) {
                        var width = this.wtTable.getColumnStrategy().getSize(visibleColIndex);
                        this.COLGROUP.childNodes[visibleColIndex + this.rowHeaderCount].style.width = width + 'px';
                        cache[visibleColIndex] = width;
                      }
                    }
                
                    this.instance.wtScrollbars.refresh(false);
                
                    this.instance.getSetting('onDraw', true);
                  }
                
                };
                
                WalkontableTableRenderer.prototype.removeRedundantRows = function () {
                  var renderedRowIndex = this.wtTable.getRowStrategy().countRendered();
                  while (this.wtTable.tbodyChildrenLength > renderedRowIndex) {
                    this.TBODY.removeChild(this.TBODY.lastChild);
                    this.wtTable.tbodyChildrenLength--;
                  }
                };
                
                WalkontableTableRenderer.prototype.renderRows = function (totalRows, cloneLimit, displayTds) {
                  var lastTD, TR, res;
                  var offsetRow = this.instance.getSetting('offsetRow');
                  var visibleRowIndex = 0;
                  var sourceRowIndex = this.rowFilter.visibleToSource(visibleRowIndex);
                  var isWorkingOnClone = this.wtTable.isWorkingOnClone();
                
                  while (sourceRowIndex < totalRows && sourceRowIndex >= 0) {
                    if (visibleRowIndex > 1000) {
                      throw new Error('Security brake: Too much TRs. Please define height for your table, which will enforce scrollbars.');
                    }
                
                    if (cloneLimit !== void 0 && visibleRowIndex === cloneLimit) {
                      break; //we have as much rows as needed for this clone
                    }
                
                    TR = this.getOrCreateTrForRow(visibleRowIndex, TR);
                
                    //Render row headers
                    this.renderRowHeaders(sourceRowIndex, TR);
                
                    this.adjustColumns(TR, displayTds + this.rowHeaderCount);
                
                    lastTD = this.renderCells(sourceRowIndex, TR, displayTds);
                
                    offsetRow = this.instance.getSetting('offsetRow'); //refresh the value
                
                    //after last column is rendered, check if last cell is fully displayed
                    if (!isWorkingOnClone) {
                      res = this.wtTable.getRowStrategy().add(visibleRowIndex, lastTD);
                
                      if (res === false) {
                        break;
                      }
                
                      if (visibleRowIndex == 0) { //rendering the first row may caused bottom scrollbar to appear, so we need to refresh the window size
                        this.instance.wtScrollbars.vertical.readWindowSize();
                      }
                
                      this.resetOversizedRow(sourceRowIndex);
                    }
                
                
                    if (TR.firstChild) {
                      var height = this.instance.getSetting('rowHeight', sourceRowIndex); //if I have 2 fixed columns with one-line content and the 3rd column has a multiline content, this is the way to make sure that the overlay will has same row height
                      if(height) {
                        TR.firstChild.style.height = height + 'px';
                      }
                      else {
                        TR.firstChild.style.height = '';
                      }
                    }
                
                    visibleRowIndex++;
                
                    sourceRowIndex = this.rowFilter.visibleToSource(visibleRowIndex);
                  }
                };
                
                WalkontableTableRenderer.prototype.resetOversizedRow = function (sourceRow) {
                  if (this.instance.wtTable.oversizedRows && this.instance.wtTable.oversizedRows[sourceRow]) {
                    this.instance.wtTable.oversizedRows[sourceRow] = void 0;  //void 0 is faster than delete, see http://jsperf.com/delete-vs-undefined-vs-null/16
                  }
                };
                
                WalkontableTableRenderer.prototype.markOversizedRows = function () {
                  var previousRowHeight
                    , trInnerHeight
                    , sourceRowIndex
                    , currentTr;
                
                  var rowCount = this.instance.wtTable.TBODY.childNodes.length;
                  while (rowCount) {
                    rowCount--;
                    sourceRowIndex = this.instance.wtTable.rowFilter.visibleToSource(rowCount);
                    previousRowHeight = this.instance.wtSettings.settings.rowHeight(sourceRowIndex);
                    currentTr = this.instance.wtTable.getTrForRow(sourceRowIndex);
                
                    trInnerHeight = Handsontable.Dom.innerHeight(currentTr) - 1;
                
                    if ((!previousRowHeight && this.instance.wtSettings.settings.defaultRowHeight < trInnerHeight || previousRowHeight < trInnerHeight)) {
                      if (!this.instance.wtTable.oversizedRows) {
                        this.instance.wtTable.oversizedRows = {};
                      }
                      this.instance.wtTable.oversizedRows[sourceRowIndex] = trInnerHeight;
                    }
                  }
                
                };
                
                WalkontableTableRenderer.prototype.renderCells = function (sourceRowIndex, TR, displayTds) {
                  var TD, sourceColIndex;
                  for (var visibleColIndex = 0; visibleColIndex < displayTds; visibleColIndex++) {
                    sourceColIndex = this.columnFilter.visibleToSource(visibleColIndex);
                    if (visibleColIndex === 0) {
                      TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(sourceColIndex)];
                    }
                    else {
                      TD = TD.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes
                    }
                
                    //If the number of headers has been reduced, we need to replace excess TH with TD
                    if (TD.nodeName == 'TH') {
                      TD = this.utils.replaceThWithTd(TD, TR);
                    }
                
                    TD.className = '';
                    TD.removeAttribute('style');
                
                    this.instance.getSetting('cellRenderer', sourceRowIndex, sourceColIndex, TD);
                
                  }
                
                  return TD;
                };
                
                WalkontableTableRenderer.prototype.adjustColumnWidths = function (displayTds) {
                  var cache = this.instance.wtTable.columnWidthCache;
                  var cacheChanged = false;
                  var width;
                  for (var visibleColIndex = 0; visibleColIndex < displayTds; visibleColIndex++) {
                    if(this.wtTable.isWorkingOnClone()) {
                      width = this.instance.cloneSource.wtTable.columnWidthCache[visibleColIndex];
                    }
                    else {
                      width = this.wtTable.getColumnStrategy().getSize(visibleColIndex);
                    }
                    if (width !== cache[visibleColIndex]) {
                      this.COLGROUP.childNodes[visibleColIndex + this.rowHeaderCount].style.width = width + 'px';
                      cache[visibleColIndex] = width;
                      cacheChanged = true;
                    }
                  }
                };
                
                WalkontableTableRenderer.prototype.appendToTbody = function (TR) {
                  this.TBODY.appendChild(TR);
                  this.wtTable.tbodyChildrenLength++;
                };
                
                WalkontableTableRenderer.prototype.getOrCreateTrForRow = function (rowIndex, currentTr) {
                  var TR;
                
                  if (rowIndex >= this.wtTable.tbodyChildrenLength) {
                    TR = this.createRow();
                    this.appendToTbody(TR);
                  } else if (rowIndex === 0) {
                    TR = this.TBODY.firstChild;
                  } else {
                    TR = currentTr.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes
                  }
                
                  return TR;
                };
                
                WalkontableTableRenderer.prototype.createRow = function() {
                  var TR = document.createElement('TR');
                  for (var visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
                    TR.appendChild(document.createElement('TH'));
                  }
                
                  return TR;
                };
                
                WalkontableTableRenderer.prototype.renderRowHeader = function(row, col, TH){
                  this.rowHeaders[col](row, TH);
                };
                
                WalkontableTableRenderer.prototype.renderRowHeaders = function(row, TR){
                  for (var TH = TR.firstChild, visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
                
                    //If the number of row headers increased we need to create TH or replace an existing TD node with TH
                    if (!TH){
                      TH = document.createElement('TH');
                      TR.appendChild(TH);
                    } else if (TH.nodeName == 'TD') {
                      TH = this.utils.replaceTdWithTh(TH, TR);
                    }
                
                    this.renderRowHeader(row, visibleColIndex, TH);
                    TH = TH.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes
                  }
                };
                
                WalkontableTableRenderer.prototype.adjustAvailableNodes = function () {
                
                  this.refreshStretching(); //actually it is wrong position because it assumes rowHeader would be always 50px wide (because we measure before it is filled with text). TODO: debug
                
                  //adjust COLGROUP
                  this.adjustColGroups();
                
                  //adjust THEAD
                  this.adjustThead();
                
                };
                
                WalkontableTableRenderer.prototype.renderColumnHeaders = function () {
                  if (!this.columnHeaders.length) {
                    return;
                  }
                
                  var columnCount = this.getColumnCount();
                
                  var TR = this.getTrForColumnHeaders();
                
                  for (var columnIndex = 0; columnIndex < columnCount; columnIndex++) {
                    if (this.columnHeaders.length) {
                     this.renderColumnHeader( this.columnFilter.visibleToSource(columnIndex), TR.childNodes[this.rowHeaderCount + columnIndex]);
                    }
                  }
                };
                
                WalkontableTableRenderer.prototype.adjustColGroups = function () {
                  var columnCount = this.getColumnCount();
                
                  //adjust COLGROUP
                  while (this.wtTable.colgroupChildrenLength < columnCount + this.rowHeaderCount) {
                    this.COLGROUP.appendChild(document.createElement('COL'));
                    this.wtTable.colgroupChildrenLength++;
                  }
                  while (this.wtTable.colgroupChildrenLength > columnCount + this.rowHeaderCount) {
                    this.COLGROUP.removeChild(this.COLGROUP.lastChild);
                    this.wtTable.colgroupChildrenLength--;
                    if(this.wtTable.columnWidthCache) {
                      this.wtTable.columnWidthCache.splice(-1,1);
                    }
                  }
                };
                
                WalkontableTableRenderer.prototype.adjustThead = function () {
                  var columnCount = this.getColumnCount();
                  var TR = this.THEAD.firstChild;
                  if (this.columnHeaders.length) {
                    if (!TR) {
                      TR = document.createElement('TR');
                      this.THEAD.appendChild(TR);
                    }
                
                    this.theadChildrenLength = TR.childNodes.length;
                    while (this.theadChildrenLength < columnCount + this.rowHeaderCount) {
                      TR.appendChild(document.createElement('TH'));
                      this.theadChildrenLength++;
                    }
                    while (this.theadChildrenLength > columnCount + this.rowHeaderCount) {
                      TR.removeChild(TR.lastChild);
                      this.theadChildrenLength--;
                    }
                  }
                  else if (TR) {
                    Handsontable.Dom.empty(TR);
                  }
                };
                
                WalkontableTableRenderer.prototype.getTrForColumnHeaders = function () {
                  var TR = this.THEAD.firstChild;
                  if (this.rowHeaderCount) {
                    this.renderRowHeaders(-1, TR);
                  }
                
                  return TR;
                };
                
                WalkontableTableRenderer.prototype.renderColumnHeader = function (col, TR) {
                  return this.columnHeaders[0](col, TR);
                };
                
                WalkontableTableRenderer.prototype.getColumnCount = function () {
                  if (this.wtTable.isWorkingOnClone() && (this.instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative)) {
                    return this.instance.getSetting('fixedColumnsLeft');
                  }
                  else {
                    return this.wtTable.getColumnStrategy().cellCount;
                  }
                };
                
                WalkontableTableRenderer.prototype.renderColGroups = function () {
                  for (var colIndex = 0; colIndex < this.wtTable.colgroupChildrenLength; colIndex++) {
                    if (colIndex < this.rowHeaderCount) {
                      Handsontable.Dom.addClass(this.COLGROUP.childNodes[colIndex], 'rowHeader');
                    }
                    else {
                      Handsontable.Dom.removeClass(this.COLGROUP.childNodes[colIndex], 'rowHeader');
                    }
                  }
                };
                
                WalkontableTableRenderer.prototype.adjustColumns = function (TR, desiredCount) {
                  var count = TR.childNodes.length;
                  while (count < desiredCount) {
                    var TD = document.createElement('TD');
                    TR.appendChild(TD);
                    count++;
                  }
                  while (count > desiredCount) {
                    TR.removeChild(TR.lastChild);
                    count--;
                  }
                };
                
                WalkontableTableRenderer.prototype.refreshStretching = function () {
                  if (this.wtTable.isWorkingOnClone()) {
                    return;
                  }
                
                  var instance = this.instance
                    , stretchH = instance.getSetting('stretchH')
                    , totalRows = instance.getSetting('totalRows')
                    , totalColumns = instance.getSetting('totalColumns');
                
                  var containerWidthFn = function (cacheWidth) {
                    var viewportWidth = that.instance.wtViewport.getViewportWidth(cacheWidth);
                    return viewportWidth;
                  };
                
                  var that = this;
                
                  var columnWidthFn = function (i) {
                    var source_c = that.columnFilter.visibleToSource(i);
                    if (source_c < totalColumns) {
                      return instance.getSetting('columnWidth', source_c);
                    }
                  };
                
                  var containerHeightFn = function (cacheHeight) {
                    if (that.instance.cloneOverlay instanceof WalkontableDebugOverlay || instance.wtSettings.settings.renderAllRows) {
                      return Infinity;
                    }
                    else {
                      return that.instance.wtViewport.getViewportHeight(cacheHeight);
                    }
                  };
                
                  var rowHeightFn = function (i, TD) {
                    return instance.wtSettings.settings.defaultRowHeight;
                  };
                
                  this.wtTable.columnStrategy = new WalkontableColumnStrategy(instance, containerWidthFn, columnWidthFn, stretchH);
                  this.wtTable.rowStrategy = new WalkontableRowStrategy(instance, containerHeightFn, rowHeightFn);
                };
                
                /*
                  Helper functions, which does not have any side effects
                 */
                WalkontableTableRenderer.utils = {};
                
                WalkontableTableRenderer.utils.replaceTdWithTh = function(TD, TR) {
                  var TH;
                  TH = document.createElement('TH');
                  TR.insertBefore(TH, TD);
                  TR.removeChild(TD);
                
                  return TH;
                };
                
                WalkontableTableRenderer.utils.replaceThWithTd = function(TH, TR) {
                  var TD = document.createElement('TD');
                  TR.insertBefore(TD, TH);
                  TR.removeChild(TH);
                
                  return TD;
                };
                
                
                
                function WalkontableViewport(instance) {
                  this.instance = instance;
                  this.resetSettings();
                
                  var that = this;
                  $(window).on('resize.walkontable.' + this.instance.guid, function () {
                    that.clientHeight = that.getWorkspaceHeight();
                  });
                }
                
                //used by scrollbar
                WalkontableViewport.prototype.getWorkspaceHeight = function (proposedHeight) {
                  return this.instance.wtScrollbars.vertical.windowSize;
                };
                
                WalkontableViewport.prototype.getWorkspaceWidth = function () {
                  var width = Math.min(this.getContainerFillWidth(), document.documentElement.offsetWidth - this.getWorkspaceOffset().left, document.documentElement.offsetWidth)
                    , overflow = this.instance.wtScrollbars.horizontal.scrollHandler != window ? this.instance.wtScrollbars.horizontal.scrollHandler.style.overflow : null;
                
                  if(overflow == "scroll" || overflow == "hidden" || overflow == "auto") {
                    overflow = "scroll";
                  }
                
                  if (overflow == "scroll") {
                    width = Math.max(width, this.instance.wtScrollbars.horizontal.windowSize);
                  } else {
                    width = Math.max(width, Handsontable.Dom.outerWidth(this.instance.wtTable.TABLE));
                  }
                
                  return width;
                };
                
                WalkontableViewport.prototype.getContainerFillWidth = function() {
                
                  if(this.containerWidth) {
                    return this.containerWidth;
                  }
                
                  var mainContainer = this.instance.wtTable.holder,
                      fillWidth,
                      dummyElement;
                
                  while(mainContainer.parentNode != document.body && mainContainer.parentNode != null && mainContainer.className.indexOf('handsontable') === -1) {
                    mainContainer = mainContainer.parentNode;
                  }
                
                  dummyElement = document.createElement("DIV");
                  dummyElement.style.width = "100%";
                  dummyElement.style.height = "1px";
                  mainContainer.appendChild(dummyElement);
                  fillWidth = dummyElement.offsetWidth;
                
                  this.containerWidth = fillWidth;
                
                  mainContainer.removeChild(dummyElement);
                
                  return fillWidth;
                }
                
                WalkontableViewport.prototype.getWorkspaceOffset = function () {
                  return Handsontable.Dom.offset(this.instance.wtTable.TABLE);
                };
                
                WalkontableViewport.prototype.getWorkspaceActualHeight = function () {
                  return Handsontable.Dom.outerHeight(this.instance.wtTable.TABLE);
                };
                
                WalkontableViewport.prototype.getWorkspaceActualWidth = function () {
                  return Handsontable.Dom.outerWidth(this.instance.wtTable.TABLE) || Handsontable.Dom.outerWidth(this.instance.wtTable.TBODY) || Handsontable.Dom.outerWidth(this.instance.wtTable.THEAD); //IE8 reports 0 as <table> offsetWidth;
                };
                
                WalkontableViewport.prototype.getColumnHeaderHeight = function () {
                  if (isNaN(this.columnHeaderHeight)) {
                    this.columnHeaderHeight = Handsontable.Dom.outerHeight(this.instance.wtTable.THEAD);
                  }
                  return this.columnHeaderHeight;
                };
                
                WalkontableViewport.prototype.getViewportHeight = function (proposedHeight) {
                
                  var containerHeight = this.getWorkspaceHeight(proposedHeight);
                
                  if (containerHeight === Infinity) {
                    return containerHeight;
                  }
                
                  var columnHeaderHeight = this.getColumnHeaderHeight();
                  if (columnHeaderHeight > 0) {
                    containerHeight -= columnHeaderHeight;
                  }
                
                  return containerHeight;
                
                };
                
                WalkontableViewport.prototype.getRowHeaderWidth = function () {
                  if (this.instance.cloneSource) {
                    return this.instance.cloneSource.wtViewport.getRowHeaderWidth();
                  }
                  if (isNaN(this.rowHeaderWidth)) {
                    var rowHeaders = this.instance.getSetting('rowHeaders');
                    if (rowHeaders.length) {
                      var TH = this.instance.wtTable.TABLE.querySelector('TH');
                      this.rowHeaderWidth = 0;
                      for (var i = 0, ilen = rowHeaders.length; i < ilen; i++) {
                        if (TH) {
                          this.rowHeaderWidth += Handsontable.Dom.outerWidth(TH);
                          TH = TH.nextSibling;
                        }
                        else {
                          this.rowHeaderWidth += 50; //yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring. TODO: proper fix
                        }
                      }
                    }
                    else {
                      this.rowHeaderWidth = 0;
                    }
                  }
                  return this.rowHeaderWidth;
                };
                
                // Viewport width = Workspace width - Row Headers width
                WalkontableViewport.prototype.getViewportWidth = function (proposedWidth) {
                  var containerWidth = this.getWorkspaceWidth(proposedWidth);
                
                  if (containerWidth === Infinity) {
                    return containerWidth;
                  }
                
                  var rowHeaderWidth = this.getRowHeaderWidth();
                  if (rowHeaderWidth > 0) {
                    return containerWidth - rowHeaderWidth;
                  }
                  else {
                    return containerWidth;
                  }
                };
                
                WalkontableViewport.prototype.resetSettings = function () {
                  this.rowHeaderWidth = NaN;
                  this.columnHeaderHeight = NaN;
                };
                
                })(jQuery, window, Handsontable);
                /*!
                 * numeral.js
                 * version : 1.5.3
                 * author : Adam Draper
                 * license : MIT
                 * http://adamwdraper.github.com/Numeral-js/
                 */
                
                (function () {
                
                    /************************************
                        Constants
                    ************************************/
                
                    var numeral,
                        VERSION = '1.5.3',
                        // internal storage for language config files
                        languages = {},
                        currentLanguage = 'en',
                        zeroFormat = null,
                        defaultFormat = '0,0',
                        // check for nodeJS
                        hasModule = (typeof module !== 'undefined' && module.exports);
                
                
                    /************************************
                        Constructors
                    ************************************/
                
                
                    // Numeral prototype object
                    function Numeral (number) {
                        this._value = number;
                    }
                
                    /**
                     * Implementation of toFixed() that treats floats more like decimals
                     *
                     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
                     * problems for accounting- and finance-related software.
                     */
                    function toFixed (value, precision, roundingFunction, optionals) {
                        var power = Math.pow(10, precision),
                            optionalsRegExp,
                            output;
                
                        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
                        // Multiply up by precision, round accurately, then divide and use native toFixed():
                        output = (roundingFunction(value * power) / power).toFixed(precision);
                
                        if (optionals) {
                            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
                            output = output.replace(optionalsRegExp, '');
                        }
                
                        return output;
                    }
                
                    /************************************
                        Formatting
                    ************************************/
                
                    // determine what type of formatting we need to do
                    function formatNumeral (n, format, roundingFunction) {
                        var output;
                
                        // figure out what kind of format we are dealing with
                        if (format.indexOf('$') > -1) { // currency!!!!!
                            output = formatCurrency(n, format, roundingFunction);
                        } else if (format.indexOf('%') > -1) { // percentage
                            output = formatPercentage(n, format, roundingFunction);
                        } else if (format.indexOf(':') > -1) { // time
                            output = formatTime(n, format);
                        } else { // plain ol' numbers or bytes
                            output = formatNumber(n._value, format, roundingFunction);
                        }
                
                        // return string
                        return output;
                    }
                
                    // revert to number
                    function unformatNumeral (n, string) {
                        var stringOriginal = string,
                            thousandRegExp,
                            millionRegExp,
                            billionRegExp,
                            trillionRegExp,
                            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
                            bytesMultiplier = false,
                            power;
                
                        if (string.indexOf(':') > -1) {
                            n._value = unformatTime(string);
                        } else {
                            if (string === zeroFormat) {
                                n._value = 0;
                            } else {
                                if (languages[currentLanguage].delimiters.decimal !== '.') {
                                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                                }
                
                                // see if abbreviations are there so that we can multiply to the correct number
                                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                
                                // see if bytes are there so that we can multiply to the correct number
                                for (power = 0; power <= suffixes.length; power++) {
                                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;
                
                                    if (bytesMultiplier) {
                                        break;
                                    }
                                }
                
                                // do some math to create our number
                                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));
                
                                // round if we are talking about bytes
                                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
                            }
                        }
                        return n._value;
                    }
                
                    function formatCurrency (n, format, roundingFunction) {
                        var symbolIndex = format.indexOf('$'),
                            openParenIndex = format.indexOf('('),
                            minusSignIndex = format.indexOf('-'),
                            space = '',
                            spliceIndex,
                            output;
                
                        // check for space before or after currency
                        if (format.indexOf(' $') > -1) {
                            space = ' ';
                            format = format.replace(' $', '');
                        } else if (format.indexOf('$ ') > -1) {
                            space = ' ';
                            format = format.replace('$ ', '');
                        } else {
                            format = format.replace('$', '');
                        }
                
                        // format the number
                        output = formatNumber(n._value, format, roundingFunction);
                
                        // position the symbol
                        if (symbolIndex <= 1) {
                            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                                output = output.split('');
                                spliceIndex = 1;
                                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                                    // the symbol appears before the "(" or "-"
                                    spliceIndex = 0;
                                }
                                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                                output = output.join('');
                            } else {
                                output = languages[currentLanguage].currency.symbol + space + output;
                            }
                        } else {
                            if (output.indexOf(')') > -1) {
                                output = output.split('');
                                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                                output = output.join('');
                            } else {
                                output = output + space + languages[currentLanguage].currency.symbol;
                            }
                        }
                
                        return output;
                    }
                
                    function formatPercentage (n, format, roundingFunction) {
                        var space = '',
                            output,
                            value = n._value * 100;
                
                        // check for space before %
                        if (format.indexOf(' %') > -1) {
                            space = ' ';
                            format = format.replace(' %', '');
                        } else {
                            format = format.replace('%', '');
                        }
                
                        output = formatNumber(value, format, roundingFunction);
                
                        if (output.indexOf(')') > -1 ) {
                            output = output.split('');
                            output.splice(-1, 0, space + '%');
                            output = output.join('');
                        } else {
                            output = output + space + '%';
                        }
                
                        return output;
                    }
                
                    function formatTime (n) {
                        var hours = Math.floor(n._value/60/60),
                            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
                            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
                        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
                    }
                
                    function unformatTime (string) {
                        var timeArray = string.split(':'),
                            seconds = 0;
                        // turn hours and minutes into seconds and add them all up
                        if (timeArray.length === 3) {
                            // hours
                            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
                            // minutes
                            seconds = seconds + (Number(timeArray[1]) * 60);
                            // seconds
                            seconds = seconds + Number(timeArray[2]);
                        } else if (timeArray.length === 2) {
                            // minutes
                            seconds = seconds + (Number(timeArray[0]) * 60);
                            // seconds
                            seconds = seconds + Number(timeArray[1]);
                        }
                        return Number(seconds);
                    }
                
                    function formatNumber (value, format, roundingFunction) {
                        var negP = false,
                            signed = false,
                            optDec = false,
                            abbr = '',
                            abbrK = false, // force abbreviation to thousands
                            abbrM = false, // force abbreviation to millions
                            abbrB = false, // force abbreviation to billions
                            abbrT = false, // force abbreviation to trillions
                            abbrForce = false, // force abbreviation
                            bytes = '',
                            ord = '',
                            abs = Math.abs(value),
                            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
                            min,
                            max,
                            power,
                            w,
                            precision,
                            thousands,
                            d = '',
                            neg = false;
                
                        // check if number is zero and a custom zero format has been set
                        if (value === 0 && zeroFormat !== null) {
                            return zeroFormat;
                        } else {
                            // see if we should use parentheses for negative number or if we should prefix with a sign
                            // if both are present we default to parentheses
                            if (format.indexOf('(') > -1) {
                                negP = true;
                                format = format.slice(1, -1);
                            } else if (format.indexOf('+') > -1) {
                                signed = true;
                                format = format.replace(/\+/g, '');
                            }
                
                            // see if abbreviation is wanted
                            if (format.indexOf('a') > -1) {
                                // check if abbreviation is specified
                                abbrK = format.indexOf('aK') >= 0;
                                abbrM = format.indexOf('aM') >= 0;
                                abbrB = format.indexOf('aB') >= 0;
                                abbrT = format.indexOf('aT') >= 0;
                                abbrForce = abbrK || abbrM || abbrB || abbrT;
                
                                // check for space before abbreviation
                                if (format.indexOf(' a') > -1) {
                                    abbr = ' ';
                                    format = format.replace(' a', '');
                                } else {
                                    format = format.replace('a', '');
                                }
                
                                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                                    // trillion
                                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                                    value = value / Math.pow(10, 12);
                                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                                    // billion
                                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                                    value = value / Math.pow(10, 9);
                                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                                    // million
                                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                                    value = value / Math.pow(10, 6);
                                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                                    // thousand
                                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                                    value = value / Math.pow(10, 3);
                                }
                            }
                
                            // see if we are formatting bytes
                            if (format.indexOf('b') > -1) {
                                // check for space before
                                if (format.indexOf(' b') > -1) {
                                    bytes = ' ';
                                    format = format.replace(' b', '');
                                } else {
                                    format = format.replace('b', '');
                                }
                
                                for (power = 0; power <= suffixes.length; power++) {
                                    min = Math.pow(1024, power);
                                    max = Math.pow(1024, power+1);
                
                                    if (value >= min && value < max) {
                                        bytes = bytes + suffixes[power];
                                        if (min > 0) {
                                            value = value / min;
                                        }
                                        break;
                                    }
                                }
                            }
                
                            // see if ordinal is wanted
                            if (format.indexOf('o') > -1) {
                                // check for space before
                                if (format.indexOf(' o') > -1) {
                                    ord = ' ';
                                    format = format.replace(' o', '');
                                } else {
                                    format = format.replace('o', '');
                                }
                
                                ord = ord + languages[currentLanguage].ordinal(value);
                            }
                
                            if (format.indexOf('[.]') > -1) {
                                optDec = true;
                                format = format.replace('[.]', '.');
                            }
                
                            w = value.toString().split('.')[0];
                            precision = format.split('.')[1];
                            thousands = format.indexOf(',');
                
                            if (precision) {
                                if (precision.indexOf('[') > -1) {
                                    precision = precision.replace(']', '');
                                    precision = precision.split('[');
                                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                                } else {
                                    d = toFixed(value, precision.length, roundingFunction);
                                }
                
                                w = d.split('.')[0];
                
                                if (d.split('.')[1].length) {
                                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                                } else {
                                    d = '';
                                }
                
                                if (optDec && Number(d.slice(1)) === 0) {
                                    d = '';
                                }
                            } else {
                                w = toFixed(value, null, roundingFunction);
                            }
                
                            // format number
                            if (w.indexOf('-') > -1) {
                                w = w.slice(1);
                                neg = true;
                            }
                
                            if (thousands > -1) {
                                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
                            }
                
                            if (format.indexOf('.') === 0) {
                                w = '';
                            }
                
                            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
                        }
                    }
                
                    /************************************
                        Top Level Functions
                    ************************************/
                
                    numeral = function (input) {
                        if (numeral.isNumeral(input)) {
                            input = input.value();
                        } else if (input === 0 || typeof input === 'undefined') {
                            input = 0;
                        } else if (!Number(input)) {
                            input = numeral.fn.unformat(input);
                        }
                
                        return new Numeral(Number(input));
                    };
                
                    // version number
                    numeral.version = VERSION;
                
                    // compare numeral object
                    numeral.isNumeral = function (obj) {
                        return obj instanceof Numeral;
                    };
                
                    // This function will load languages and then set the global language.  If
                    // no arguments are passed in, it will simply return the current global
                    // language key.
                    numeral.language = function (key, values) {
                        if (!key) {
                            return currentLanguage;
                        }
                
                        if (key && !values) {
                            if(!languages[key]) {
                                throw new Error('Unknown language : ' + key);
                            }
                            currentLanguage = key;
                        }
                
                        if (values || !languages[key]) {
                            loadLanguage(key, values);
                        }
                
                        return numeral;
                    };
                
                    // This function provides access to the loaded language data.  If
                    // no arguments are passed in, it will simply return the current
                    // global language object.
                    numeral.languageData = function (key) {
                        if (!key) {
                            return languages[currentLanguage];
                        }
                
                        if (!languages[key]) {
                            throw new Error('Unknown language : ' + key);
                        }
                
                        return languages[key];
                    };
                
                    numeral.language('en', {
                        delimiters: {
                            thousands: ',',
                            decimal: '.'
                        },
                        abbreviations: {
                            thousand: 'k',
                            million: 'm',
                            billion: 'b',
                            trillion: 't'
                        },
                        ordinal: function (number) {
                            var b = number % 10;
                            return (~~ (number % 100 / 10) === 1) ? 'th' :
                                (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                (b === 3) ? 'rd' : 'th';
                        },
                        currency: {
                            symbol: '$'
                        }
                    });
                
                    numeral.zeroFormat = function (format) {
                        zeroFormat = typeof(format) === 'string' ? format : null;
                    };
                
                    numeral.defaultFormat = function (format) {
                        defaultFormat = typeof(format) === 'string' ? format : '0.0';
                    };
                
                    /************************************
                        Helpers
                    ************************************/
                
                    function loadLanguage(key, values) {
                        languages[key] = values;
                    }
                
                    /************************************
                        Floating-point helpers
                    ************************************/
                
                    // The floating-point helper functions and implementation
                    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/
                
                    /**
                     * Array.prototype.reduce for browsers that don't support it
                     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
                     */
                    if ('function' !== typeof Array.prototype.reduce) {
                        Array.prototype.reduce = function (callback, opt_initialValue) {
                            
                
                            if (null === this || 'undefined' === typeof this) {
                                // At the moment all modern browsers, that support strict mode, have
                                // native implementation of Array.prototype.reduce. For instance, IE8
                                // does not support strict mode, so this check is actually useless.
                                throw new TypeError('Array.prototype.reduce called on null or undefined');
                            }
                
                            if ('function' !== typeof callback) {
                                throw new TypeError(callback + ' is not a function');
                            }
                
                            var index,
                                value,
                                length = this.length >>> 0,
                                isValueSet = false;
                
                            if (1 < arguments.length) {
                                value = opt_initialValue;
                                isValueSet = true;
                            }
                
                            for (index = 0; length > index; ++index) {
                                if (this.hasOwnProperty(index)) {
                                    if (isValueSet) {
                                        value = callback(value, this[index], index, this);
                                    } else {
                                        value = this[index];
                                        isValueSet = true;
                                    }
                                }
                            }
                
                            if (!isValueSet) {
                                throw new TypeError('Reduce of empty array with no initial value');
                            }
                
                            return value;
                        };
                    }
                
                
                    /**
                     * Computes the multiplier necessary to make x >= 1,
                     * effectively eliminating miscalculations caused by
                     * finite precision.
                     */
                    function multiplier(x) {
                        var parts = x.toString().split('.');
                        if (parts.length < 2) {
                            return 1;
                        }
                        return Math.pow(10, parts[1].length);
                    }
                
                    /**
                     * Given a variable number of arguments, returns the maximum
                     * multiplier that must be used to normalize an operation involving
                     * all of them.
                     */
                    function correctionFactor() {
                        var args = Array.prototype.slice.call(arguments);
                        return args.reduce(function (prev, next) {
                            var mp = multiplier(prev),
                                mn = multiplier(next);
                        return mp > mn ? mp : mn;
                        }, -Infinity);
                    }
                
                
                    /************************************
                        Numeral Prototype
                    ************************************/
                
                
                    numeral.fn = Numeral.prototype = {
                
                        clone : function () {
                            return numeral(this);
                        },
                
                        format : function (inputString, roundingFunction) {
                            return formatNumeral(this,
                                  inputString ? inputString : defaultFormat,
                                  (roundingFunction !== undefined) ? roundingFunction : Math.round
                              );
                        },
                
                        unformat : function (inputString) {
                            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                                return inputString;
                            }
                            return unformatNumeral(this, inputString ? inputString : defaultFormat);
                        },
                
                        value : function () {
                            return this._value;
                        },
                
                        valueOf : function () {
                            return this._value;
                        },
                
                        set : function (value) {
                            this._value = Number(value);
                            return this;
                        },
                
                        add : function (value) {
                            var corrFactor = correctionFactor.call(null, this._value, value);
                            function cback(accum, curr, currI, O) {
                                return accum + corrFactor * curr;
                            }
                            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
                            return this;
                        },
                
                        subtract : function (value) {
                            var corrFactor = correctionFactor.call(null, this._value, value);
                            function cback(accum, curr, currI, O) {
                                return accum - corrFactor * curr;
                            }
                            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
                            return this;
                        },
                
                        multiply : function (value) {
                            function cback(accum, curr, currI, O) {
                                var corrFactor = correctionFactor(accum, curr);
                                return (accum * corrFactor) * (curr * corrFactor) /
                                    (corrFactor * corrFactor);
                            }
                            this._value = [this._value, value].reduce(cback, 1);
                            return this;
                        },
                
                        divide : function (value) {
                            function cback(accum, curr, currI, O) {
                                var corrFactor = correctionFactor(accum, curr);
                                return (accum * corrFactor) / (curr * corrFactor);
                            }
                            this._value = [this._value, value].reduce(cback);
                            return this;
                        },
                
                        difference : function (value) {
                            return Math.abs(numeral(this._value).subtract(value).value());
                        }
                
                    };
                
                    /************************************
                        Exposing Numeral
                    ************************************/
                
                    // CommonJS module is defined
                    if (hasModule) {
                        module.exports = numeral;
                    }
                
                    /*global ender:false */
                    if (typeof ender === 'undefined') {
                        // here, `this` means `window` in the browser, or `global` on the server
                        // add `numeral` as a global object via a string identifier,
                        // for Closure Compiler 'advanced' mode
                        this['numeral'] = numeral;
                    }
                
                    /*global define:false */
                    if (typeof define === 'function' && define.amd) {
                        define('handsontable',[], function () {
                            return numeral;
                        });
                    }
                }).call(this);
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/handson_table',["underscore", "jquery", "handsontable", "common/collection", "common/has_properties", "common/continuum_view"], function(_, $, $$1, Collection, HasProperties, ContinuumView) {
                    var HandsonTable, HandsonTableView, HandsonTables, _ref, _ref1, _ref2;
                    HandsonTableView = (function(_super) {
                      __extends(HandsonTableView, _super);
                
                      function HandsonTableView() {
                        _ref = HandsonTableView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      HandsonTableView.prototype.initialize = function(options) {
                        var source,
                          _this = this;
                        HandsonTableView.__super__.initialize.call(this, options);
                        this.render();
                        this.listenTo(this.model, 'change', function() {
                          return _this.renderFn();
                        });
                        source = this.mget("source");
                        this.listenTo(source, 'change:data', function() {
                          return _this.renderFn();
                        });
                        return this.listenTo(source, 'change:selection', function() {
                          return _this.changeSelection();
                        });
                      };
                
                      HandsonTableView.prototype.changeSelection = function() {
                        var i, j, n, selection;
                        this.ht.deselectCell();
                        selection = this.mget("source").get("selected");
                        i = _.min(selection);
                        j = _.max(selection);
                        n = this.ht.countCols();
                        return this.ht.selectCell(i, 0, j, n - 1, true);
                      };
                
                      HandsonTableView.prototype.renderFn = function() {
                        var col_widths, column, columns, header, headers, source, width, widths, _i, _len, _ref1,
                          _this = this;
                        source = this.mget("source");
                        if (source != null) {
                          headers = [];
                          widths = [];
                          columns = [];
                          _ref1 = this.mget("columns");
                          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                            column = _ref1[_i];
                            if (column != null) {
                              header = column.get("header");
                              width = column.get("width");
                              headers.push(header != null ? header : void 0);
                              widths.push(width != null ? width : void 0);
                              columns.push({
                                data: column.get("field"),
                                type: column.get("type"),
                                format: column.get("format"),
                                source: column.get("source"),
                                strict: column.get("strict"),
                                checkedTemplate: column.get("checked"),
                                uncheckedTemplate: column.get("unchecked")
                              });
                            }
                          }
                          if (this.mget("columns_width") != null) {
                            col_widths = this.mget("columns_width");
                          } else if (_.filter(widths, function(x) {
                            return x != null;
                          }).length !== 0) {
                            col_widths = widths;
                          } else {
                            col_widths = void 0;
                          }
                          this.$el.handsontable({
                            data: source.datapoints(),
                            width: this.mget("width"),
                            height: this.mget("height"),
                            columns: columns,
                            colWidths: col_widths,
                            columnSorting: this.mget("sorting"),
                            rowHeaders: this.mget("row_headers"),
                            colHeaders: this.mget("column_headers") ? headers : false,
                            manualRowResize: this.mget("row_resize"),
                            manualColumnResize: this.mget("column_resize"),
                            afterChange: function(changes, source) {
                              if (source === "edit") {
                                return _this.editData(changes);
                              }
                            }
                          });
                        } else {
                          this.$el.handsontable();
                        }
                        return this.ht = this.$el.handsontable("getInstance");
                      };
                
                      HandsonTableView.prototype.render = function() {
                        var handler, interval,
                          _this = this;
                        handler = function() {
                          if ($.contains(document.documentElement, _this.el)) {
                            clearInterval(interval);
                            return _this.renderFn();
                          }
                        };
                        return interval = setInterval(handler, 50);
                      };
                
                      HandsonTableView.prototype.editData = function(changes) {
                        var array, change, column, data, i, index, new_val, old_val, source, _i, _j, _len, _ref1;
                        source = this.mget("source");
                        data = source.get("data");
                        for (_i = 0, _len = changes.length; _i < _len; _i++) {
                          change = changes[_i];
                          index = change[0], column = change[1], old_val = change[2], new_val = change[3];
                          array = _.clone(data[column]);
                          if (index < array.length) {
                            array[index] = new_val;
                          } else {
                            for (i = _j = 0, _ref1 = array.length - index; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                              array.push(NaN);
                            }
                            array.push(new_val);
                          }
                          data[column] = array;
                        }
                        return source.set(data);
                      };
                
                      return HandsonTableView;
                
                    })(ContinuumView);
                    HandsonTable = (function(_super) {
                      __extends(HandsonTable, _super);
                
                      function HandsonTable() {
                        _ref1 = HandsonTable.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      HandsonTable.prototype.type = 'HandsonTable';
                
                      HandsonTable.prototype.default_view = HandsonTableView;
                
                      HandsonTable.prototype.defaults = function() {
                        return _.extend({}, HandsonTable.__super__.defaults.call(this), {
                          source: null,
                          width: null,
                          height: null,
                          columns: [],
                          columns_width: null,
                          sorting: true,
                          row_headers: true,
                          column_headers: true,
                          row_resize: false,
                          column_resize: false
                        });
                      };
                
                      return HandsonTable;
                
                    })(HasProperties);
                    HandsonTables = (function(_super) {
                      __extends(HandsonTables, _super);
                
                      function HandsonTables() {
                        _ref2 = HandsonTables.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      HandsonTables.prototype.model = HandsonTable;
                
                      return HandsonTables;
                
                    })(Collection);
                    return {
                      Model: HandsonTable,
                      Collection: new HandsonTables(),
                      View: HandsonTableView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=handson_table.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/table_column',["underscore", "jquery", "common/collection", "common/has_properties"], function(_, $, Collection, HasProperties) {
                    var TableColumn, TableColumns, _ref, _ref1;
                    TableColumn = (function(_super) {
                      __extends(TableColumn, _super);
                
                      function TableColumn() {
                        _ref = TableColumn.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      TableColumn.prototype.type = 'TableColumn';
                
                      TableColumn.prototype.default_view = null;
                
                      return TableColumn;
                
                    })(HasProperties);
                    TableColumns = (function(_super) {
                      __extends(TableColumns, _super);
                
                      function TableColumns() {
                        _ref1 = TableColumns.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      TableColumns.prototype.model = TableColumn;
                
                      return TableColumns;
                
                    })(Collection);
                    return {
                      Model: TableColumn,
                      Collection: new TableColumns()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=table_column.js.map
                */;
                define('jquery_ui/core',['jquery'], function (jQuery) {
                /*!
                 * jQuery UI Core 1.10.0
                 * http://jqueryui.com
                 *
                 * Copyright 2013 jQuery Foundation and other contributors
                 * Released under the MIT license.
                 * http://jquery.org/license
                 *
                 * http://api.jqueryui.com/category/ui-core/
                 */
                (function( $, undefined ) {
                
                var uuid = 0,
                	runiqueId = /^ui-id-\d+$/;
                
                // prevent duplicate loading
                // this is only a problem because we proxy existing functions
                // and we don't want to double proxy them
                $.ui = $.ui || {};
                if ( $.ui.version ) {
                	return;
                }
                
                $.extend( $.ui, {
                	version: "1.10.0",
                
                	keyCode: {
                		BACKSPACE: 8,
                		COMMA: 188,
                		DELETE: 46,
                		DOWN: 40,
                		END: 35,
                		ENTER: 13,
                		ESCAPE: 27,
                		HOME: 36,
                		LEFT: 37,
                		NUMPAD_ADD: 107,
                		NUMPAD_DECIMAL: 110,
                		NUMPAD_DIVIDE: 111,
                		NUMPAD_ENTER: 108,
                		NUMPAD_MULTIPLY: 106,
                		NUMPAD_SUBTRACT: 109,
                		PAGE_DOWN: 34,
                		PAGE_UP: 33,
                		PERIOD: 190,
                		RIGHT: 39,
                		SPACE: 32,
                		TAB: 9,
                		UP: 38
                	}
                });
                
                // plugins
                $.fn.extend({
                	_focus: $.fn.focus,
                	focus: function( delay, fn ) {
                		return typeof delay === "number" ?
                			this.each(function() {
                				var elem = this;
                				setTimeout(function() {
                					$( elem ).focus();
                					if ( fn ) {
                						fn.call( elem );
                					}
                				}, delay );
                			}) :
                			this._focus.apply( this, arguments );
                	},
                
                	scrollParent: function() {
                		var scrollParent;
                		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
                			scrollParent = this.parents().filter(function() {
                				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
                			}).eq(0);
                		} else {
                			scrollParent = this.parents().filter(function() {
                				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
                			}).eq(0);
                		}
                
                		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
                	},
                
                	zIndex: function( zIndex ) {
                		if ( zIndex !== undefined ) {
                			return this.css( "zIndex", zIndex );
                		}
                
                		if ( this.length ) {
                			var elem = $( this[ 0 ] ), position, value;
                			while ( elem.length && elem[ 0 ] !== document ) {
                				// Ignore z-index if position is set to a value where z-index is ignored by the browser
                				// This makes behavior of this function consistent across browsers
                				// WebKit always returns auto if the element is positioned
                				position = elem.css( "position" );
                				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
                					// IE returns 0 when zIndex is not specified
                					// other browsers return a string
                					// we ignore the case of nested elements with an explicit value of 0
                					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                					value = parseInt( elem.css( "zIndex" ), 10 );
                					if ( !isNaN( value ) && value !== 0 ) {
                						return value;
                					}
                				}
                				elem = elem.parent();
                			}
                		}
                
                		return 0;
                	},
                
                	uniqueId: function() {
                		return this.each(function() {
                			if ( !this.id ) {
                				this.id = "ui-id-" + (++uuid);
                			}
                		});
                	},
                
                	removeUniqueId: function() {
                		return this.each(function() {
                			if ( runiqueId.test( this.id ) ) {
                				$( this ).removeAttr( "id" );
                			}
                		});
                	}
                });
                
                // selectors
                function focusable( element, isTabIndexNotNaN ) {
                	var map, mapName, img,
                		nodeName = element.nodeName.toLowerCase();
                	if ( "area" === nodeName ) {
                		map = element.parentNode;
                		mapName = map.name;
                		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
                			return false;
                		}
                		img = $( "img[usemap=#" + mapName + "]" )[0];
                		return !!img && visible( img );
                	}
                	return ( /input|select|textarea|button|object/.test( nodeName ) ?
                		!element.disabled :
                		"a" === nodeName ?
                			element.href || isTabIndexNotNaN :
                			isTabIndexNotNaN) &&
                		// the element and all of its ancestors must be visible
                		visible( element );
                }
                
                function visible( element ) {
                	return $.expr.filters.visible( element ) &&
                		!$( element ).parents().addBack().filter(function() {
                			return $.css( this, "visibility" ) === "hidden";
                		}).length;
                }
                
                $.extend( $.expr[ ":" ], {
                	data: $.expr.createPseudo ?
                		$.expr.createPseudo(function( dataName ) {
                			return function( elem ) {
                				return !!$.data( elem, dataName );
                			};
                		}) :
                		// support: jQuery <1.8
                		function( elem, i, match ) {
                			return !!$.data( elem, match[ 3 ] );
                		},
                
                	focusable: function( element ) {
                		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
                	},
                
                	tabbable: function( element ) {
                		var tabIndex = $.attr( element, "tabindex" ),
                			isTabIndexNaN = isNaN( tabIndex );
                		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
                	}
                });
                
                // support: jQuery <1.8
                if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
                	$.each( [ "Width", "Height" ], function( i, name ) {
                		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
                			type = name.toLowerCase(),
                			orig = {
                				innerWidth: $.fn.innerWidth,
                				innerHeight: $.fn.innerHeight,
                				outerWidth: $.fn.outerWidth,
                				outerHeight: $.fn.outerHeight
                			};
                
                		function reduce( elem, size, border, margin ) {
                			$.each( side, function() {
                				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
                				if ( border ) {
                					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
                				}
                				if ( margin ) {
                					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
                				}
                			});
                			return size;
                		}
                
                		$.fn[ "inner" + name ] = function( size ) {
                			if ( size === undefined ) {
                				return orig[ "inner" + name ].call( this );
                			}
                
                			return this.each(function() {
                				$( this ).css( type, reduce( this, size ) + "px" );
                			});
                		};
                
                		$.fn[ "outer" + name] = function( size, margin ) {
                			if ( typeof size !== "number" ) {
                				return orig[ "outer" + name ].call( this, size );
                			}
                
                			return this.each(function() {
                				$( this).css( type, reduce( this, size, true, margin ) + "px" );
                			});
                		};
                	});
                }
                
                // support: jQuery <1.8
                if ( !$.fn.addBack ) {
                	$.fn.addBack = function( selector ) {
                		return this.add( selector == null ?
                			this.prevObject : this.prevObject.filter( selector )
                		);
                	};
                }
                
                // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
                if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
                	$.fn.removeData = (function( removeData ) {
                		return function( key ) {
                			if ( arguments.length ) {
                				return removeData.call( this, $.camelCase( key ) );
                			} else {
                				return removeData.call( this );
                			}
                		};
                	})( $.fn.removeData );
                }
                
                
                
                
                
                // deprecated
                $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
                
                $.support.selectstart = "onselectstart" in document.createElement( "div" );
                $.fn.extend({
                	disableSelection: function() {
                		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
                			".ui-disableSelection", function( event ) {
                				event.preventDefault();
                			});
                	},
                
                	enableSelection: function() {
                		return this.unbind( ".ui-disableSelection" );
                	}
                });
                
                $.extend( $.ui, {
                	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
                	plugin: {
                		add: function( module, option, set ) {
                			var i,
                				proto = $.ui[ module ].prototype;
                			for ( i in set ) {
                				proto.plugins[ i ] = proto.plugins[ i ] || [];
                				proto.plugins[ i ].push( [ option, set[ i ] ] );
                			}
                		},
                		call: function( instance, name, args ) {
                			var i,
                				set = instance.plugins[ name ];
                			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
                				return;
                			}
                
                			for ( i = 0; i < set.length; i++ ) {
                				if ( instance.options[ set[ i ][ 0 ] ] ) {
                					set[ i ][ 1 ].apply( instance.element, args );
                				}
                			}
                		}
                	},
                
                	// only used by resizable
                	hasScroll: function( el, a ) {
                
                		//If overflow is hidden, the element might have extra content, but the user wants to hide it
                		if ( $( el ).css( "overflow" ) === "hidden") {
                			return false;
                		}
                
                		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
                			has = false;
                
                		if ( el[ scroll ] > 0 ) {
                			return true;
                		}
                
                		// TODO: determine which cases actually cause this to happen
                		// if the element doesn't have the scroll set, see if it's possible to
                		// set the scroll
                		el[ scroll ] = 1;
                		has = ( el[ scroll ] > 0 );
                		el[ scroll ] = 0;
                		return has;
                	}
                });
                
                })( jQuery );
                
                });
                define('jquery_ui/widget',['jquery'], function (jQuery) {
                /*!
                 * jQuery UI Widget 1.10.0
                 * http://jqueryui.com
                 *
                 * Copyright 2013 jQuery Foundation and other contributors
                 * Released under the MIT license.
                 * http://jquery.org/license
                 *
                 * http://api.jqueryui.com/jQuery.widget/
                 */
                (function( $, undefined ) {
                
                var uuid = 0,
                	slice = Array.prototype.slice,
                	_cleanData = $.cleanData;
                $.cleanData = function( elems ) {
                	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                		try {
                			$( elem ).triggerHandler( "remove" );
                		// http://bugs.jquery.com/ticket/8235
                		} catch( e ) {}
                	}
                	_cleanData( elems );
                };
                
                $.widget = function( name, base, prototype ) {
                	var fullName, existingConstructor, constructor, basePrototype,
                		// proxiedPrototype allows the provided prototype to remain unmodified
                		// so that it can be used as a mixin for multiple widgets (#8876)
                		proxiedPrototype = {},
                		namespace = name.split( "." )[ 0 ];
                
                	name = name.split( "." )[ 1 ];
                	fullName = namespace + "-" + name;
                
                	if ( !prototype ) {
                		prototype = base;
                		base = $.Widget;
                	}
                
                	// create selector for plugin
                	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
                		return !!$.data( elem, fullName );
                	};
                
                	$[ namespace ] = $[ namespace ] || {};
                	existingConstructor = $[ namespace ][ name ];
                	constructor = $[ namespace ][ name ] = function( options, element ) {
                		// allow instantiation without "new" keyword
                		if ( !this._createWidget ) {
                			return new constructor( options, element );
                		}
                
                		// allow instantiation without initializing for simple inheritance
                		// must use "new" keyword (the code above always passes args)
                		if ( arguments.length ) {
                			this._createWidget( options, element );
                		}
                	};
                	// extend with the existing constructor to carry over any static properties
                	$.extend( constructor, existingConstructor, {
                		version: prototype.version,
                		// copy the object used to create the prototype in case we need to
                		// redefine the widget later
                		_proto: $.extend( {}, prototype ),
                		// track widgets that inherit from this widget in case this widget is
                		// redefined after a widget inherits from it
                		_childConstructors: []
                	});
                
                	basePrototype = new base();
                	// we need to make the options hash a property directly on the new instance
                	// otherwise we'll modify the options hash on the prototype that we're
                	// inheriting from
                	basePrototype.options = $.widget.extend( {}, basePrototype.options );
                	$.each( prototype, function( prop, value ) {
                		if ( !$.isFunction( value ) ) {
                			proxiedPrototype[ prop ] = value;
                			return;
                		}
                		proxiedPrototype[ prop ] = (function() {
                			var _super = function() {
                					return base.prototype[ prop ].apply( this, arguments );
                				},
                				_superApply = function( args ) {
                					return base.prototype[ prop ].apply( this, args );
                				};
                			return function() {
                				var __super = this._super,
                					__superApply = this._superApply,
                					returnValue;
                
                				this._super = _super;
                				this._superApply = _superApply;
                
                				returnValue = value.apply( this, arguments );
                
                				this._super = __super;
                				this._superApply = __superApply;
                
                				return returnValue;
                			};
                		})();
                	});
                	constructor.prototype = $.widget.extend( basePrototype, {
                		// TODO: remove support for widgetEventPrefix
                		// always use the name + a colon as the prefix, e.g., draggable:start
                		// don't prefix for widgets that aren't DOM-based
                		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
                	}, proxiedPrototype, {
                		constructor: constructor,
                		namespace: namespace,
                		widgetName: name,
                		widgetFullName: fullName
                	});
                
                	// If this widget is being redefined then we need to find all widgets that
                	// are inheriting from it and redefine all of them so that they inherit from
                	// the new version of this widget. We're essentially trying to replace one
                	// level in the prototype chain.
                	if ( existingConstructor ) {
                		$.each( existingConstructor._childConstructors, function( i, child ) {
                			var childPrototype = child.prototype;
                
                			// redefine the child widget using the same prototype that was
                			// originally used, but inherit from the new version of the base
                			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
                		});
                		// remove the list of existing child constructors from the old constructor
                		// so the old child constructors can be garbage collected
                		delete existingConstructor._childConstructors;
                	} else {
                		base._childConstructors.push( constructor );
                	}
                
                	$.widget.bridge( name, constructor );
                };
                
                $.widget.extend = function( target ) {
                	var input = slice.call( arguments, 1 ),
                		inputIndex = 0,
                		inputLength = input.length,
                		key,
                		value;
                	for ( ; inputIndex < inputLength; inputIndex++ ) {
                		for ( key in input[ inputIndex ] ) {
                			value = input[ inputIndex ][ key ];
                			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
                				// Clone objects
                				if ( $.isPlainObject( value ) ) {
                					target[ key ] = $.isPlainObject( target[ key ] ) ?
                						$.widget.extend( {}, target[ key ], value ) :
                						// Don't extend strings, arrays, etc. with objects
                						$.widget.extend( {}, value );
                				// Copy everything else by reference
                				} else {
                					target[ key ] = value;
                				}
                			}
                		}
                	}
                	return target;
                };
                
                $.widget.bridge = function( name, object ) {
                	var fullName = object.prototype.widgetFullName || name;
                	$.fn[ name ] = function( options ) {
                		var isMethodCall = typeof options === "string",
                			args = slice.call( arguments, 1 ),
                			returnValue = this;
                
                		// allow multiple hashes to be passed on init
                		options = !isMethodCall && args.length ?
                			$.widget.extend.apply( null, [ options ].concat(args) ) :
                			options;
                
                		if ( isMethodCall ) {
                			this.each(function() {
                				var methodValue,
                					instance = $.data( this, fullName );
                				if ( !instance ) {
                					return $.error( "cannot call methods on " + name + " prior to initialization; " +
                						"attempted to call method '" + options + "'" );
                				}
                				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
                					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
                				}
                				methodValue = instance[ options ].apply( instance, args );
                				if ( methodValue !== instance && methodValue !== undefined ) {
                					returnValue = methodValue && methodValue.jquery ?
                						returnValue.pushStack( methodValue.get() ) :
                						methodValue;
                					return false;
                				}
                			});
                		} else {
                			this.each(function() {
                				var instance = $.data( this, fullName );
                				if ( instance ) {
                					instance.option( options || {} )._init();
                				} else {
                					$.data( this, fullName, new object( options, this ) );
                				}
                			});
                		}
                
                		return returnValue;
                	};
                };
                
                $.Widget = function( /* options, element */ ) {};
                $.Widget._childConstructors = [];
                
                $.Widget.prototype = {
                	widgetName: "widget",
                	widgetEventPrefix: "",
                	defaultElement: "<div>",
                	options: {
                		disabled: false,
                
                		// callbacks
                		create: null
                	},
                	_createWidget: function( options, element ) {
                		element = $( element || this.defaultElement || this )[ 0 ];
                		this.element = $( element );
                		this.uuid = uuid++;
                		this.eventNamespace = "." + this.widgetName + this.uuid;
                		this.options = $.widget.extend( {},
                			this.options,
                			this._getCreateOptions(),
                			options );
                
                		this.bindings = $();
                		this.hoverable = $();
                		this.focusable = $();
                
                		if ( element !== this ) {
                			$.data( element, this.widgetFullName, this );
                			this._on( true, this.element, {
                				remove: function( event ) {
                					if ( event.target === element ) {
                						this.destroy();
                					}
                				}
                			});
                			this.document = $( element.style ?
                				// element within the document
                				element.ownerDocument :
                				// element is window or document
                				element.document || element );
                			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
                		}
                
                		this._create();
                		this._trigger( "create", null, this._getCreateEventData() );
                		this._init();
                	},
                	_getCreateOptions: $.noop,
                	_getCreateEventData: $.noop,
                	_create: $.noop,
                	_init: $.noop,
                
                	destroy: function() {
                		this._destroy();
                		// we can probably remove the unbind calls in 2.0
                		// all event bindings should go through this._on()
                		this.element
                			.unbind( this.eventNamespace )
                			// 1.9 BC for #7810
                			// TODO remove dual storage
                			.removeData( this.widgetName )
                			.removeData( this.widgetFullName )
                			// support: jquery <1.6.3
                			// http://bugs.jquery.com/ticket/9413
                			.removeData( $.camelCase( this.widgetFullName ) );
                		this.widget()
                			.unbind( this.eventNamespace )
                			.removeAttr( "aria-disabled" )
                			.removeClass(
                				this.widgetFullName + "-disabled " +
                				"ui-state-disabled" );
                
                		// clean up events and states
                		this.bindings.unbind( this.eventNamespace );
                		this.hoverable.removeClass( "ui-state-hover" );
                		this.focusable.removeClass( "ui-state-focus" );
                	},
                	_destroy: $.noop,
                
                	widget: function() {
                		return this.element;
                	},
                
                	option: function( key, value ) {
                		var options = key,
                			parts,
                			curOption,
                			i;
                
                		if ( arguments.length === 0 ) {
                			// don't return a reference to the internal hash
                			return $.widget.extend( {}, this.options );
                		}
                
                		if ( typeof key === "string" ) {
                			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                			options = {};
                			parts = key.split( "." );
                			key = parts.shift();
                			if ( parts.length ) {
                				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
                				for ( i = 0; i < parts.length - 1; i++ ) {
                					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                					curOption = curOption[ parts[ i ] ];
                				}
                				key = parts.pop();
                				if ( value === undefined ) {
                					return curOption[ key ] === undefined ? null : curOption[ key ];
                				}
                				curOption[ key ] = value;
                			} else {
                				if ( value === undefined ) {
                					return this.options[ key ] === undefined ? null : this.options[ key ];
                				}
                				options[ key ] = value;
                			}
                		}
                
                		this._setOptions( options );
                
                		return this;
                	},
                	_setOptions: function( options ) {
                		var key;
                
                		for ( key in options ) {
                			this._setOption( key, options[ key ] );
                		}
                
                		return this;
                	},
                	_setOption: function( key, value ) {
                		this.options[ key ] = value;
                
                		if ( key === "disabled" ) {
                			this.widget()
                				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
                				.attr( "aria-disabled", value );
                			this.hoverable.removeClass( "ui-state-hover" );
                			this.focusable.removeClass( "ui-state-focus" );
                		}
                
                		return this;
                	},
                
                	enable: function() {
                		return this._setOption( "disabled", false );
                	},
                	disable: function() {
                		return this._setOption( "disabled", true );
                	},
                
                	_on: function( suppressDisabledCheck, element, handlers ) {
                		var delegateElement,
                			instance = this;
                
                		// no suppressDisabledCheck flag, shuffle arguments
                		if ( typeof suppressDisabledCheck !== "boolean" ) {
                			handlers = element;
                			element = suppressDisabledCheck;
                			suppressDisabledCheck = false;
                		}
                
                		// no element argument, shuffle and use this.element
                		if ( !handlers ) {
                			handlers = element;
                			element = this.element;
                			delegateElement = this.widget();
                		} else {
                			// accept selectors, DOM elements
                			element = delegateElement = $( element );
                			this.bindings = this.bindings.add( element );
                		}
                
                		$.each( handlers, function( event, handler ) {
                			function handlerProxy() {
                				// allow widgets to customize the disabled handling
                				// - disabled as an array instead of boolean
                				// - disabled class as method for disabling individual parts
                				if ( !suppressDisabledCheck &&
                						( instance.options.disabled === true ||
                							$( this ).hasClass( "ui-state-disabled" ) ) ) {
                					return;
                				}
                				return ( typeof handler === "string" ? instance[ handler ] : handler )
                					.apply( instance, arguments );
                			}
                
                			// copy the guid so direct unbinding works
                			if ( typeof handler !== "string" ) {
                				handlerProxy.guid = handler.guid =
                					handler.guid || handlerProxy.guid || $.guid++;
                			}
                
                			var match = event.match( /^(\w+)\s*(.*)$/ ),
                				eventName = match[1] + instance.eventNamespace,
                				selector = match[2];
                			if ( selector ) {
                				delegateElement.delegate( selector, eventName, handlerProxy );
                			} else {
                				element.bind( eventName, handlerProxy );
                			}
                		});
                	},
                
                	_off: function( element, eventName ) {
                		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
                		element.unbind( eventName ).undelegate( eventName );
                	},
                
                	_delay: function( handler, delay ) {
                		function handlerProxy() {
                			return ( typeof handler === "string" ? instance[ handler ] : handler )
                				.apply( instance, arguments );
                		}
                		var instance = this;
                		return setTimeout( handlerProxy, delay || 0 );
                	},
                
                	_hoverable: function( element ) {
                		this.hoverable = this.hoverable.add( element );
                		this._on( element, {
                			mouseenter: function( event ) {
                				$( event.currentTarget ).addClass( "ui-state-hover" );
                			},
                			mouseleave: function( event ) {
                				$( event.currentTarget ).removeClass( "ui-state-hover" );
                			}
                		});
                	},
                
                	_focusable: function( element ) {
                		this.focusable = this.focusable.add( element );
                		this._on( element, {
                			focusin: function( event ) {
                				$( event.currentTarget ).addClass( "ui-state-focus" );
                			},
                			focusout: function( event ) {
                				$( event.currentTarget ).removeClass( "ui-state-focus" );
                			}
                		});
                	},
                
                	_trigger: function( type, event, data ) {
                		var prop, orig,
                			callback = this.options[ type ];
                
                		data = data || {};
                		event = $.Event( event );
                		event.type = ( type === this.widgetEventPrefix ?
                			type :
                			this.widgetEventPrefix + type ).toLowerCase();
                		// the original event may come from any element
                		// so we need to reset the target on the new event
                		event.target = this.element[ 0 ];
                
                		// copy original event properties over to the new event
                		orig = event.originalEvent;
                		if ( orig ) {
                			for ( prop in orig ) {
                				if ( !( prop in event ) ) {
                					event[ prop ] = orig[ prop ];
                				}
                			}
                		}
                
                		this.element.trigger( event, data );
                		return !( $.isFunction( callback ) &&
                			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
                			event.isDefaultPrevented() );
                	}
                };
                
                $.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
                	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
                		if ( typeof options === "string" ) {
                			options = { effect: options };
                		}
                		var hasOptions,
                			effectName = !options ?
                				method :
                				options === true || typeof options === "number" ?
                					defaultEffect :
                					options.effect || defaultEffect;
                		options = options || {};
                		if ( typeof options === "number" ) {
                			options = { duration: options };
                		}
                		hasOptions = !$.isEmptyObject( options );
                		options.complete = callback;
                		if ( options.delay ) {
                			element.delay( options.delay );
                		}
                		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
                			element[ method ]( options );
                		} else if ( effectName !== method && element[ effectName ] ) {
                			element[ effectName ]( options.duration, options.easing, callback );
                		} else {
                			element.queue(function( next ) {
                				$( this )[ method ]();
                				if ( callback ) {
                					callback.call( element[ 0 ] );
                				}
                				next();
                			});
                		}
                	};
                });
                
                })( jQuery );
                
                });
                define('jquery_ui/mouse',['jquery','./widget'], function (jQuery) {
                /*!
                 * jQuery UI Mouse 1.10.0
                 * http://jqueryui.com
                 *
                 * Copyright 2013 jQuery Foundation and other contributors
                 * Released under the MIT license.
                 * http://jquery.org/license
                 *
                 * http://api.jqueryui.com/mouse/
                 *
                 * Depends:
                 *	jquery.ui.widget.js
                 */
                (function( $, undefined ) {
                
                var mouseHandled = false;
                $( document ).mouseup( function() {
                	mouseHandled = false;
                });
                
                $.widget("ui.mouse", {
                	version: "1.10.0",
                	options: {
                		cancel: "input,textarea,button,select,option",
                		distance: 1,
                		delay: 0
                	},
                	_mouseInit: function() {
                		var that = this;
                
                		this.element
                			.bind("mousedown."+this.widgetName, function(event) {
                				return that._mouseDown(event);
                			})
                			.bind("click."+this.widgetName, function(event) {
                				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                					$.removeData(event.target, that.widgetName + ".preventClickEvent");
                					event.stopImmediatePropagation();
                					return false;
                				}
                			});
                
                		this.started = false;
                	},
                
                	// TODO: make sure destroying one instance of mouse doesn't mess with
                	// other instances of mouse
                	_mouseDestroy: function() {
                		this.element.unbind("."+this.widgetName);
                		if ( this._mouseMoveDelegate ) {
                			$(document)
                				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
                				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
                		}
                	},
                
                	_mouseDown: function(event) {
                		// don't let more than one widget handle mouseStart
                		if( mouseHandled ) { return; }
                
                		// we may have missed mouseup (out of window)
                		(this._mouseStarted && this._mouseUp(event));
                
                		this._mouseDownEvent = event;
                
                		var that = this,
                			btnIsLeft = (event.which === 1),
                			// event.target.nodeName works around a bug in IE 8 with
                			// disabled inputs (#7620)
                			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
                		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                			return true;
                		}
                
                		this.mouseDelayMet = !this.options.delay;
                		if (!this.mouseDelayMet) {
                			this._mouseDelayTimer = setTimeout(function() {
                				that.mouseDelayMet = true;
                			}, this.options.delay);
                		}
                
                		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                			this._mouseStarted = (this._mouseStart(event) !== false);
                			if (!this._mouseStarted) {
                				event.preventDefault();
                				return true;
                			}
                		}
                
                		// Click event may never have fired (Gecko & Opera)
                		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                			$.removeData(event.target, this.widgetName + ".preventClickEvent");
                		}
                
                		// these delegates are required to keep context
                		this._mouseMoveDelegate = function(event) {
                			return that._mouseMove(event);
                		};
                		this._mouseUpDelegate = function(event) {
                			return that._mouseUp(event);
                		};
                		$(document)
                			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
                			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);
                
                		event.preventDefault();
                
                		mouseHandled = true;
                		return true;
                	},
                
                	_mouseMove: function(event) {
                		// IE mouseup check - mouseup happened when mouse was out of window
                		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
                			return this._mouseUp(event);
                		}
                
                		if (this._mouseStarted) {
                			this._mouseDrag(event);
                			return event.preventDefault();
                		}
                
                		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                			this._mouseStarted =
                				(this._mouseStart(this._mouseDownEvent, event) !== false);
                			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
                		}
                
                		return !this._mouseStarted;
                	},
                
                	_mouseUp: function(event) {
                		$(document)
                			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
                			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
                
                		if (this._mouseStarted) {
                			this._mouseStarted = false;
                
                			if (event.target === this._mouseDownEvent.target) {
                				$.data(event.target, this.widgetName + ".preventClickEvent", true);
                			}
                
                			this._mouseStop(event);
                		}
                
                		return false;
                	},
                
                	_mouseDistanceMet: function(event) {
                		return (Math.max(
                				Math.abs(this._mouseDownEvent.pageX - event.pageX),
                				Math.abs(this._mouseDownEvent.pageY - event.pageY)
                			) >= this.options.distance
                		);
                	},
                
                	_mouseDelayMet: function(/* event */) {
                		return this.mouseDelayMet;
                	},
                
                	// These are placeholder methods, to be overriden by extending plugin
                	_mouseStart: function(/* event */) {},
                	_mouseDrag: function(/* event */) {},
                	_mouseStop: function(/* event */) {},
                	_mouseCapture: function(/* event */) { return true; }
                });
                
                })(jQuery);
                
                });
                define('jquery_ui/sortable',['jquery','./core','./mouse','./widget'], function (jQuery) {
                /*!
                 * jQuery UI Sortable 1.10.0
                 * http://jqueryui.com
                 *
                 * Copyright 2013 jQuery Foundation and other contributors
                 * Released under the MIT license.
                 * http://jquery.org/license
                 *
                 * http://api.jqueryui.com/sortable/
                 *
                 * Depends:
                 *	jquery.ui.core.js
                 *	jquery.ui.mouse.js
                 *	jquery.ui.widget.js
                 */
                (function( $, undefined ) {
                
                /*jshint loopfunc: true */
                
                function isOverAxis( x, reference, size ) {
                	return ( x > reference ) && ( x < ( reference + size ) );
                }
                
                $.widget("ui.sortable", $.ui.mouse, {
                	version: "1.10.0",
                	widgetEventPrefix: "sort",
                	ready: false,
                	options: {
                		appendTo: "parent",
                		axis: false,
                		connectWith: false,
                		containment: false,
                		cursor: "auto",
                		cursorAt: false,
                		dropOnEmpty: true,
                		forcePlaceholderSize: false,
                		forceHelperSize: false,
                		grid: false,
                		handle: false,
                		helper: "original",
                		items: "> *",
                		opacity: false,
                		placeholder: false,
                		revert: false,
                		scroll: true,
                		scrollSensitivity: 20,
                		scrollSpeed: 20,
                		scope: "default",
                		tolerance: "intersect",
                		zIndex: 1000,
                
                		// callbacks
                		activate: null,
                		beforeStop: null,
                		change: null,
                		deactivate: null,
                		out: null,
                		over: null,
                		receive: null,
                		remove: null,
                		sort: null,
                		start: null,
                		stop: null,
                		update: null
                	},
                	_create: function() {
                
                		var o = this.options;
                		this.containerCache = {};
                		this.element.addClass("ui-sortable");
                
                		//Get the items
                		this.refresh();
                
                		//Let's determine if the items are being displayed horizontally
                		this.floating = this.items.length ? o.axis === "x" || (/left|right/).test(this.items[0].item.css("float")) || (/inline|table-cell/).test(this.items[0].item.css("display")) : false;
                
                		//Let's determine the parent's offset
                		this.offset = this.element.offset();
                
                		//Initialize mouse events for interaction
                		this._mouseInit();
                
                		//We're ready to go
                		this.ready = true;
                
                	},
                
                	_destroy: function() {
                		this.element
                			.removeClass("ui-sortable ui-sortable-disabled");
                		this._mouseDestroy();
                
                		for ( var i = this.items.length - 1; i >= 0; i-- ) {
                			this.items[i].item.removeData(this.widgetName + "-item");
                		}
                
                		return this;
                	},
                
                	_setOption: function(key, value){
                		if ( key === "disabled" ) {
                			this.options[ key ] = value;
                
                			this.widget().toggleClass( "ui-sortable-disabled", !!value );
                		} else {
                			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
                			$.Widget.prototype._setOption.apply(this, arguments);
                		}
                	},
                
                	_mouseCapture: function(event, overrideHandle) {
                		var currentItem = null,
                			validHandle = false,
                			that = this;
                
                		if (this.reverting) {
                			return false;
                		}
                
                		if(this.options.disabled || this.options.type === "static") {
                			return false;
                		}
                
                		//We have to refresh the items data once first
                		this._refreshItems(event);
                
                		//Find out if the clicked node (or one of its parents) is a actual item in this.items
                		$(event.target).parents().each(function() {
                			if($.data(this, that.widgetName + "-item") === that) {
                				currentItem = $(this);
                				return false;
                			}
                		});
                		if($.data(event.target, that.widgetName + "-item") === that) {
                			currentItem = $(event.target);
                		}
                
                		if(!currentItem) {
                			return false;
                		}
                		if(this.options.handle && !overrideHandle) {
                			$(this.options.handle, currentItem).find("*").addBack().each(function() {
                				if(this === event.target) {
                					validHandle = true;
                				}
                			});
                			if(!validHandle) {
                				return false;
                			}
                		}
                
                		this.currentItem = currentItem;
                		this._removeCurrentsFromItems();
                		return true;
                
                	},
                
                	_mouseStart: function(event, overrideHandle, noActivation) {
                
                		var i,
                			o = this.options;
                
                		this.currentContainer = this;
                
                		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
                		this.refreshPositions();
                
                		//Create and append the visible helper
                		this.helper = this._createHelper(event);
                
                		//Cache the helper size
                		this._cacheHelperProportions();
                
                		/*
                		 * - Position generation -
                		 * This block generates everything position related - it's the core of draggables.
                		 */
                
                		//Cache the margins of the original element
                		this._cacheMargins();
                
                		//Get the next scrolling parent
                		this.scrollParent = this.helper.scrollParent();
                
                		//The element's absolute position on the page minus margins
                		this.offset = this.currentItem.offset();
                		this.offset = {
                			top: this.offset.top - this.margins.top,
                			left: this.offset.left - this.margins.left
                		};
                
                		$.extend(this.offset, {
                			click: { //Where the click happened, relative to the element
                				left: event.pageX - this.offset.left,
                				top: event.pageY - this.offset.top
                			},
                			parent: this._getParentOffset(),
                			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
                		});
                
                		// Only after we got the offset, we can change the helper's position to absolute
                		// TODO: Still need to figure out a way to make relative sorting possible
                		this.helper.css("position", "absolute");
                		this.cssPosition = this.helper.css("position");
                
                		//Generate the original position
                		this.originalPosition = this._generatePosition(event);
                		this.originalPageX = event.pageX;
                		this.originalPageY = event.pageY;
                
                		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
                
                		//Cache the former DOM position
                		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
                
                		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
                		if(this.helper[0] !== this.currentItem[0]) {
                			this.currentItem.hide();
                		}
                
                		//Create the placeholder
                		this._createPlaceholder();
                
                		//Set a containment if given in the options
                		if(o.containment) {
                			this._setContainment();
                		}
                
                		if(o.cursor) { // cursor option
                			if ($("body").css("cursor")) {
                				this._storedCursor = $("body").css("cursor");
                			}
                			$("body").css("cursor", o.cursor);
                		}
                
                		if(o.opacity) { // opacity option
                			if (this.helper.css("opacity")) {
                				this._storedOpacity = this.helper.css("opacity");
                			}
                			this.helper.css("opacity", o.opacity);
                		}
                
                		if(o.zIndex) { // zIndex option
                			if (this.helper.css("zIndex")) {
                				this._storedZIndex = this.helper.css("zIndex");
                			}
                			this.helper.css("zIndex", o.zIndex);
                		}
                
                		//Prepare scrolling
                		if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                			this.overflowOffset = this.scrollParent.offset();
                		}
                
                		//Call callbacks
                		this._trigger("start", event, this._uiHash());
                
                		//Recache the helper size
                		if(!this._preserveHelperProportions) {
                			this._cacheHelperProportions();
                		}
                
                
                		//Post "activate" events to possible containers
                		if( !noActivation ) {
                			for ( i = this.containers.length - 1; i >= 0; i-- ) {
                				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
                			}
                		}
                
                		//Prepare possible droppables
                		if($.ui.ddmanager) {
                			$.ui.ddmanager.current = this;
                		}
                
                		if ($.ui.ddmanager && !o.dropBehaviour) {
                			$.ui.ddmanager.prepareOffsets(this, event);
                		}
                
                		this.dragging = true;
                
                		this.helper.addClass("ui-sortable-helper");
                		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
                		return true;
                
                	},
                
                	_mouseDrag: function(event) {
                		var i, item, itemElement, intersection,
                			o = this.options,
                			scrolled = false;
                
                		//Compute the helpers position
                		this.position = this._generatePosition(event);
                		this.positionAbs = this._convertPositionTo("absolute");
                
                		if (!this.lastPositionAbs) {
                			this.lastPositionAbs = this.positionAbs;
                		}
                
                		//Do scrolling
                		if(this.options.scroll) {
                			if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                
                				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                				}
                
                				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                				}
                
                			} else {
                
                				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                				}
                
                				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                				}
                
                			}
                
                			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                				$.ui.ddmanager.prepareOffsets(this, event);
                			}
                		}
                
                		//Regenerate the absolute position used for position checks
                		this.positionAbs = this._convertPositionTo("absolute");
                
                		//Set the helper position
                		if(!this.options.axis || this.options.axis !== "y") {
                			this.helper[0].style.left = this.position.left+"px";
                		}
                		if(!this.options.axis || this.options.axis !== "x") {
                			this.helper[0].style.top = this.position.top+"px";
                		}
                
                		//Rearrange
                		for (i = this.items.length - 1; i >= 0; i--) {
                
                			//Cache variables and intersection, continue if no intersection
                			item = this.items[i];
                			itemElement = item.item[0];
                			intersection = this._intersectsWithPointer(item);
                			if (!intersection) {
                				continue;
                			}
                
                			// Only put the placeholder inside the current Container, skip all
                			// items form other containers. This works because when moving
                			// an item from one container to another the
                			// currentContainer is switched before the placeholder is moved.
                			//
                			// Without this moving items in "sub-sortables" can cause the placeholder to jitter
                			// beetween the outer and inner container.
                			if (item.instance !== this.currentContainer) {
                				continue;
                			}
                
                			// cannot intersect with itself
                			// no useless actions that have been done before
                			// no action if the item moved is the parent of the item checked
                			if (itemElement !== this.currentItem[0] &&
                				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
                				!$.contains(this.placeholder[0], itemElement) &&
                				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
                			) {
                
                				this.direction = intersection === 1 ? "down" : "up";
                
                				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                					this._rearrange(event, item);
                				} else {
                					break;
                				}
                
                				this._trigger("change", event, this._uiHash());
                				break;
                			}
                		}
                
                		//Post events to containers
                		this._contactContainers(event);
                
                		//Interconnect with droppables
                		if($.ui.ddmanager) {
                			$.ui.ddmanager.drag(this, event);
                		}
                
                		//Call callbacks
                		this._trigger("sort", event, this._uiHash());
                
                		this.lastPositionAbs = this.positionAbs;
                		return false;
                
                	},
                
                	_mouseStop: function(event, noPropagation) {
                
                		if(!event) {
                			return;
                		}
                
                		//If we are using droppables, inform the manager about the drop
                		if ($.ui.ddmanager && !this.options.dropBehaviour) {
                			$.ui.ddmanager.drop(this, event);
                		}
                
                		if(this.options.revert) {
                			var that = this,
                				cur = this.placeholder.offset();
                
                			this.reverting = true;
                
                			$(this.helper).animate({
                				left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft),
                				top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop)
                			}, parseInt(this.options.revert, 10) || 500, function() {
                				that._clear(event);
                			});
                		} else {
                			this._clear(event, noPropagation);
                		}
                
                		return false;
                
                	},
                
                	cancel: function() {
                
                		if(this.dragging) {
                
                			this._mouseUp({ target: null });
                
                			if(this.options.helper === "original") {
                				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                			} else {
                				this.currentItem.show();
                			}
                
                			//Post deactivating events to containers
                			for (var i = this.containers.length - 1; i >= 0; i--){
                				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                				if(this.containers[i].containerCache.over) {
                					this.containers[i]._trigger("out", null, this._uiHash(this));
                					this.containers[i].containerCache.over = 0;
                				}
                			}
                
                		}
                
                		if (this.placeholder) {
                			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                			if(this.placeholder[0].parentNode) {
                				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                			}
                			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                				this.helper.remove();
                			}
                
                			$.extend(this, {
                				helper: null,
                				dragging: false,
                				reverting: false,
                				_noFinalSort: null
                			});
                
                			if(this.domPosition.prev) {
                				$(this.domPosition.prev).after(this.currentItem);
                			} else {
                				$(this.domPosition.parent).prepend(this.currentItem);
                			}
                		}
                
                		return this;
                
                	},
                
                	serialize: function(o) {
                
                		var items = this._getItemsAsjQuery(o && o.connected),
                			str = [];
                		o = o || {};
                
                		$(items).each(function() {
                			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
                			if (res) {
                				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
                			}
                		});
                
                		if(!str.length && o.key) {
                			str.push(o.key + "=");
                		}
                
                		return str.join("&");
                
                	},
                
                	toArray: function(o) {
                
                		var items = this._getItemsAsjQuery(o && o.connected),
                			ret = [];
                
                		o = o || {};
                
                		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
                		return ret;
                
                	},
                
                	/* Be careful with the following core functions */
                	_intersectsWith: function(item) {
                
                		var x1 = this.positionAbs.left,
                			x2 = x1 + this.helperProportions.width,
                			y1 = this.positionAbs.top,
                			y2 = y1 + this.helperProportions.height,
                			l = item.left,
                			r = l + item.width,
                			t = item.top,
                			b = t + item.height,
                			dyClick = this.offset.click.top,
                			dxClick = this.offset.click.left,
                			isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;
                
                		if ( this.options.tolerance === "pointer" ||
                			this.options.forcePointerForContainers ||
                			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
                		) {
                			return isOverElement;
                		} else {
                
                			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
                				x2 - (this.helperProportions.width / 2) < r && // Left Half
                				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
                				y2 - (this.helperProportions.height / 2) < b ); // Top Half
                
                		}
                	},
                
                	_intersectsWithPointer: function(item) {
                
                		var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                			isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                			isOverElement = isOverElementHeight && isOverElementWidth,
                			verticalDirection = this._getDragVerticalDirection(),
                			horizontalDirection = this._getDragHorizontalDirection();
                
                		if (!isOverElement) {
                			return false;
                		}
                
                		return this.floating ?
                			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
                			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );
                
                	},
                
                	_intersectsWithSides: function(item) {
                
                		var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
                			isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
                			verticalDirection = this._getDragVerticalDirection(),
                			horizontalDirection = this._getDragHorizontalDirection();
                
                		if (this.floating && horizontalDirection) {
                			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
                		} else {
                			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
                		}
                
                	},
                
                	_getDragVerticalDirection: function() {
                		var delta = this.positionAbs.top - this.lastPositionAbs.top;
                		return delta !== 0 && (delta > 0 ? "down" : "up");
                	},
                
                	_getDragHorizontalDirection: function() {
                		var delta = this.positionAbs.left - this.lastPositionAbs.left;
                		return delta !== 0 && (delta > 0 ? "right" : "left");
                	},
                
                	refresh: function(event) {
                		this._refreshItems(event);
                		this.refreshPositions();
                		return this;
                	},
                
                	_connectWith: function() {
                		var options = this.options;
                		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
                	},
                
                	_getItemsAsjQuery: function(connected) {
                
                		var i, j, cur, inst,
                			items = [],
                			queries = [],
                			connectWith = this._connectWith();
                
                		if(connectWith && connected) {
                			for (i = connectWith.length - 1; i >= 0; i--){
                				cur = $(connectWith[i]);
                				for ( j = cur.length - 1; j >= 0; j--){
                					inst = $.data(cur[j], this.widgetFullName);
                					if(inst && inst !== this && !inst.options.disabled) {
                						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                					}
                				}
                			}
                		}
                
                		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
                
                		for (i = queries.length - 1; i >= 0; i--){
                			queries[i][0].each(function() {
                				items.push(this);
                			});
                		}
                
                		return $(items);
                
                	},
                
                	_removeCurrentsFromItems: function() {
                
                		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
                
                		this.items = $.grep(this.items, function (item) {
                			for (var j=0; j < list.length; j++) {
                				if(list[j] === item.item[0]) {
                					return false;
                				}
                			}
                			return true;
                		});
                
                	},
                
                	_refreshItems: function(event) {
                
                		this.items = [];
                		this.containers = [this];
                
                		var i, j, cur, inst, targetData, _queries, item, queriesLength,
                			items = this.items,
                			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
                			connectWith = this._connectWith();
                
                		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
                			for (i = connectWith.length - 1; i >= 0; i--){
                				cur = $(connectWith[i]);
                				for (j = cur.length - 1; j >= 0; j--){
                					inst = $.data(cur[j], this.widgetFullName);
                					if(inst && inst !== this && !inst.options.disabled) {
                						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
                						this.containers.push(inst);
                					}
                				}
                			}
                		}
                
                		for (i = queries.length - 1; i >= 0; i--) {
                			targetData = queries[i][1];
                			_queries = queries[i][0];
                
                			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
                				item = $(_queries[j]);
                
                				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
                
                				items.push({
                					item: item,
                					instance: targetData,
                					width: 0, height: 0,
                					left: 0, top: 0
                				});
                			}
                		}
                
                	},
                
                	refreshPositions: function(fast) {
                
                		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
                		if(this.offsetParent && this.helper) {
                			this.offset.parent = this._getParentOffset();
                		}
                
                		var i, item, t, p;
                
                		for (i = this.items.length - 1; i >= 0; i--){
                			item = this.items[i];
                
                			//We ignore calculating positions of all connected containers when we're not over them
                			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                				continue;
                			}
                
                			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
                
                			if (!fast) {
                				item.width = t.outerWidth();
                				item.height = t.outerHeight();
                			}
                
                			p = t.offset();
                			item.left = p.left;
                			item.top = p.top;
                		}
                
                		if(this.options.custom && this.options.custom.refreshContainers) {
                			this.options.custom.refreshContainers.call(this);
                		} else {
                			for (i = this.containers.length - 1; i >= 0; i--){
                				p = this.containers[i].element.offset();
                				this.containers[i].containerCache.left = p.left;
                				this.containers[i].containerCache.top = p.top;
                				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
                				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                			}
                		}
                
                		return this;
                	},
                
                	_createPlaceholder: function(that) {
                		that = that || this;
                		var className,
                			o = that.options;
                
                		if(!o.placeholder || o.placeholder.constructor === String) {
                			className = o.placeholder;
                			o.placeholder = {
                				element: function() {
                
                					var el = $(document.createElement(that.currentItem[0].nodeName))
                						.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
                						.removeClass("ui-sortable-helper")[0];
                
                					if(!className) {
                						el.style.visibility = "hidden";
                					}
                
                					return el;
                				},
                				update: function(container, p) {
                
                					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
                					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
                					if(className && !o.forcePlaceholderSize) {
                						return;
                					}
                
                					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
                					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
                					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
                				}
                			};
                		}
                
                		//Create the placeholder
                		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
                
                		//Append it after the actual current item
                		that.currentItem.after(that.placeholder);
                
                		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
                		o.placeholder.update(that, that.placeholder);
                
                	},
                
                	_contactContainers: function(event) {
                		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom,
                			innermostContainer = null,
                			innermostIndex = null;
                
                		// get innermost container that intersects with item
                		for (i = this.containers.length - 1; i >= 0; i--) {
                
                			// never consider a container that's located within the item itself
                			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
                				continue;
                			}
                
                			if(this._intersectsWith(this.containers[i].containerCache)) {
                
                				// if we've already found a container and it's more "inner" than this, then continue
                				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                					continue;
                				}
                
                				innermostContainer = this.containers[i];
                				innermostIndex = i;
                
                			} else {
                				// container doesn't intersect. trigger "out" event if necessary
                				if(this.containers[i].containerCache.over) {
                					this.containers[i]._trigger("out", event, this._uiHash(this));
                					this.containers[i].containerCache.over = 0;
                				}
                			}
                
                		}
                
                		// if no intersecting containers found, return
                		if(!innermostContainer) {
                			return;
                		}
                
                		// move the item into the container if it's not there already
                		if(this.containers.length === 1) {
                			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                			this.containers[innermostIndex].containerCache.over = 1;
                		} else {
                
                			//When entering a new container, we will find the item with the least distance and append our item near it
                			dist = 10000;
                			itemWithLeastDistance = null;
                			posProperty = this.containers[innermostIndex].floating ? "left" : "top";
                			sizeProperty = this.containers[innermostIndex].floating ? "width" : "height";
                			base = this.positionAbs[posProperty] + this.offset.click[posProperty];
                			for (j = this.items.length - 1; j >= 0; j--) {
                				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                					continue;
                				}
                				if(this.items[j].item[0] === this.currentItem[0]) {
                					continue;
                				}
                				cur = this.items[j].item.offset()[posProperty];
                				nearBottom = false;
                				if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
                					nearBottom = true;
                					cur += this.items[j][sizeProperty];
                				}
                
                				if(Math.abs(cur - base) < dist) {
                					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
                					this.direction = nearBottom ? "up": "down";
                				}
                			}
                
                			//Check if dropOnEmpty is enabled
                			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
                				return;
                			}
                
                			this.currentContainer = this.containers[innermostIndex];
                			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                			this._trigger("change", event, this._uiHash());
                			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                
                			//Update the placeholder
                			this.options.placeholder.update(this.currentContainer, this.placeholder);
                
                			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                			this.containers[innermostIndex].containerCache.over = 1;
                		}
                
                
                	},
                
                	_createHelper: function(event) {
                
                		var o = this.options,
                			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
                
                		//Add the helper to the DOM if that didn't happen already
                		if(!helper.parents("body").length) {
                			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
                		}
                
                		if(helper[0] === this.currentItem[0]) {
                			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
                		}
                
                		if(!helper[0].style.width || o.forceHelperSize) {
                			helper.width(this.currentItem.width());
                		}
                		if(!helper[0].style.height || o.forceHelperSize) {
                			helper.height(this.currentItem.height());
                		}
                
                		return helper;
                
                	},
                
                	_adjustOffsetFromHelper: function(obj) {
                		if (typeof obj === "string") {
                			obj = obj.split(" ");
                		}
                		if ($.isArray(obj)) {
                			obj = {left: +obj[0], top: +obj[1] || 0};
                		}
                		if ("left" in obj) {
                			this.offset.click.left = obj.left + this.margins.left;
                		}
                		if ("right" in obj) {
                			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                		}
                		if ("top" in obj) {
                			this.offset.click.top = obj.top + this.margins.top;
                		}
                		if ("bottom" in obj) {
                			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                		}
                	},
                
                	_getParentOffset: function() {
                
                
                		//Get the offsetParent and cache its position
                		this.offsetParent = this.helper.offsetParent();
                		var po = this.offsetParent.offset();
                
                		// This is a special case where we need to modify a offset calculated on start, since the following happened:
                		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                			po.left += this.scrollParent.scrollLeft();
                			po.top += this.scrollParent.scrollTop();
                		}
                
                		// This needs to be actually done for all browsers, since pageX/pageY includes this information
                		// with an ugly IE fix
                		if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                			po = { top: 0, left: 0 };
                		}
                
                		return {
                			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
                			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
                		};
                
                	},
                
                	_getRelativeOffset: function() {
                
                		if(this.cssPosition === "relative") {
                			var p = this.currentItem.position();
                			return {
                				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
                				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
                			};
                		} else {
                			return { top: 0, left: 0 };
                		}
                
                	},
                
                	_cacheMargins: function() {
                		this.margins = {
                			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
                			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
                		};
                	},
                
                	_cacheHelperProportions: function() {
                		this.helperProportions = {
                			width: this.helper.outerWidth(),
                			height: this.helper.outerHeight()
                		};
                	},
                
                	_setContainment: function() {
                
                		var ce, co, over,
                			o = this.options;
                		if(o.containment === "parent") {
                			o.containment = this.helper[0].parentNode;
                		}
                		if(o.containment === "document" || o.containment === "window") {
                			this.containment = [
                				0 - this.offset.relative.left - this.offset.parent.left,
                				0 - this.offset.relative.top - this.offset.parent.top,
                				$(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
                				($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                			];
                		}
                
                		if(!(/^(document|window|parent)$/).test(o.containment)) {
                			ce = $(o.containment)[0];
                			co = $(o.containment).offset();
                			over = ($(ce).css("overflow") !== "hidden");
                
                			this.containment = [
                				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
                				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
                				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
                				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
                			];
                		}
                
                	},
                
                	_convertPositionTo: function(d, pos) {
                
                		if(!pos) {
                			pos = this.position;
                		}
                		var mod = d === "absolute" ? 1 : -1,
                			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
                
                		return {
                			top: (
                				pos.top	+																// The absolute mouse position
                				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
                				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
                			),
                			left: (
                				pos.left +																// The absolute mouse position
                				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
                				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
                			)
                		};
                
                	},
                
                	_generatePosition: function(event) {
                
                		var top, left,
                			o = this.options,
                			pageX = event.pageX,
                			pageY = event.pageY,
                			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
                
                		// This is another very weird special case that only happens for relative elements:
                		// 1. If the css position is relative
                		// 2. and the scroll parent is the document or similar to the offset parent
                		// we have to refresh the relative offset during the scroll so there are no jumps
                		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
                			this.offset.relative = this._getRelativeOffset();
                		}
                
                		/*
                		 * - Position constraining -
                		 * Constrain the position to a mix of grid, containment.
                		 */
                
                		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
                
                			if(this.containment) {
                				if(event.pageX - this.offset.click.left < this.containment[0]) {
                					pageX = this.containment[0] + this.offset.click.left;
                				}
                				if(event.pageY - this.offset.click.top < this.containment[1]) {
                					pageY = this.containment[1] + this.offset.click.top;
                				}
                				if(event.pageX - this.offset.click.left > this.containment[2]) {
                					pageX = this.containment[2] + this.offset.click.left;
                				}
                				if(event.pageY - this.offset.click.top > this.containment[3]) {
                					pageY = this.containment[3] + this.offset.click.top;
                				}
                			}
                
                			if(o.grid) {
                				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
                
                				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                			}
                
                		}
                
                		return {
                			top: (
                				pageY -																// The absolute mouse position
                				this.offset.click.top -													// Click offset (relative to the element)
                				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
                				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
                			),
                			left: (
                				pageX -																// The absolute mouse position
                				this.offset.click.left -												// Click offset (relative to the element)
                				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
                				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
                			)
                		};
                
                	},
                
                	_rearrange: function(event, i, a, hardRefresh) {
                
                		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
                
                		//Various things done here to improve the performance:
                		// 1. we create a setTimeout, that calls refreshPositions
                		// 2. on the instance, we have a counter variable, that get's higher after every append
                		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
                		// 4. this lets only the last addition to the timeout stack through
                		this.counter = this.counter ? ++this.counter : 1;
                		var counter = this.counter;
                
                		this._delay(function() {
                			if(counter === this.counter) {
                				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
                			}
                		});
                
                	},
                
                	_clear: function(event, noPropagation) {
                
                		this.reverting = false;
                		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
                		// everything else normalized again
                		var i,
                			delayedTriggers = [];
                
                		// We first have to update the dom position of the actual currentItem
                		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
                		if(!this._noFinalSort && this.currentItem.parent().length) {
                			this.placeholder.before(this.currentItem);
                		}
                		this._noFinalSort = null;
                
                		if(this.helper[0] === this.currentItem[0]) {
                			for(i in this._storedCSS) {
                				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                					this._storedCSS[i] = "";
                				}
                			}
                			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                		} else {
                			this.currentItem.show();
                		}
                
                		if(this.fromOutside && !noPropagation) {
                			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
                		}
                		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
                		}
                
                		// Check if the items Container has Changed and trigger appropriate
                		// events.
                		if (this !== this.currentContainer) {
                			if(!noPropagation) {
                				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
                				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
                				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
                			}
                		}
                
                
                		//Post events to containers
                		for (i = this.containers.length - 1; i >= 0; i--){
                			if(!noPropagation) {
                				delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
                			}
                			if(this.containers[i].containerCache.over) {
                				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
                				this.containers[i].containerCache.over = 0;
                			}
                		}
                
                		//Do what was originally in plugins
                		if(this._storedCursor) {
                			$("body").css("cursor", this._storedCursor);
                		}
                		if(this._storedOpacity) {
                			this.helper.css("opacity", this._storedOpacity);
                		}
                		if(this._storedZIndex) {
                			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
                		}
                
                		this.dragging = false;
                		if(this.cancelHelperRemoval) {
                			if(!noPropagation) {
                				this._trigger("beforeStop", event, this._uiHash());
                				for (i=0; i < delayedTriggers.length; i++) {
                					delayedTriggers[i].call(this, event);
                				} //Trigger all delayed events
                				this._trigger("stop", event, this._uiHash());
                			}
                
                			this.fromOutside = false;
                			return false;
                		}
                
                		if(!noPropagation) {
                			this._trigger("beforeStop", event, this._uiHash());
                		}
                
                		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                
                		if(this.helper[0] !== this.currentItem[0]) {
                			this.helper.remove();
                		}
                		this.helper = null;
                
                		if(!noPropagation) {
                			for (i=0; i < delayedTriggers.length; i++) {
                				delayedTriggers[i].call(this, event);
                			} //Trigger all delayed events
                			this._trigger("stop", event, this._uiHash());
                		}
                
                		this.fromOutside = false;
                		return true;
                
                	},
                
                	_trigger: function() {
                		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                			this.cancel();
                		}
                	},
                
                	_uiHash: function(_inst) {
                		var inst = _inst || this;
                		return {
                			helper: inst.helper,
                			placeholder: inst.placeholder || $([]),
                			position: inst.position,
                			originalPosition: inst.originalPosition,
                			offset: inst.positionAbs,
                			item: inst.currentItem,
                			sender: _inst ? _inst.element : null
                		};
                	}
                
                });
                
                })(jQuery);
                
                });
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/pivot_table',["underscore", "jquery", "jquery_ui/sortable", "bootstrap/dropdown", "common/collection", "common/has_parent", "common/has_properties", "common/continuum_view"], function(_, $, $$1, $$2, Collection, HasParent, HasProperties, ContinuumView) {
                    var PivotTable, PivotTableView, PivotTables, _ref, _ref1, _ref2;
                    PivotTableView = (function(_super) {
                      __extends(PivotTableView, _super);
                
                      function PivotTableView() {
                        this.getAggregator = __bind(this.getAggregator, this);
                        _ref = PivotTableView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PivotTableView.prototype.initialize = function(options) {
                        PivotTableView.__super__.initialize.call(this, options);
                        this.listenTo(this.model, 'destroy', this.remove);
                        this.listenTo(this.model, 'change', this.rerenderToolbox);
                        this.listenTo(this.model, 'change:data', this.rerenderPivotTable);
                        return this.render();
                      };
                
                      PivotTableView.prototype.mpush = function(attr, value) {
                        return this.mset(attr, this.mget(attr).concat([value]));
                      };
                
                      PivotTableView.prototype.mupdate = function(attr, fn) {
                        var value,
                          _this = this;
                        value = _.map(this.mget(attr), function(item) {
                          return _.clone(item);
                        });
                        fn(value);
                        return this.mset(attr, value);
                      };
                
                      PivotTableView.prototype.fieldNames = function() {
                        var field, _i, _len, _ref1, _results;
                        _ref1 = this.mget("fields");
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          field = _ref1[_i];
                          _results.push(field.name);
                        }
                        return _results;
                      };
                
                      PivotTableView.prototype.fieldDTypes = function() {
                        var field, _i, _len, _ref1, _results;
                        _ref1 = this.mget("fields");
                        _results = [];
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          field = _ref1[_i];
                          _results.push(field.dtype);
                        }
                        return _results;
                      };
                
                      PivotTableView.prototype.getDType = function(fieldName) {
                        return _.find(this.mget("fields"), function(field) {
                          return field.name === fieldName;
                        }).dtype;
                      };
                
                      PivotTableView.prototype.render = function() {
                        var html;
                        html = $('<table class="bk-pivot"></table>');
                        this.$description = $('<td class="bk-pivot-description" valign="center"></td>');
                        this.$toolbox = $('<td class="bk-pivot-toolbox" valign="top"></td>');
                        this.$pivot = $('<td class="bk-pivot-table" valign="top"></td>');
                        this.$description.html(this.renderDescription());
                        this.$toolbox.html(this.renderToolbox());
                        this.$pivot.html(this.renderWait());
                        html.append([$('<tr></tr>').append(this.$desciption), $('<tr></tr>').append([this.$toolbox, this.$pivot])]);
                        this.$el.html(html);
                        return this.delayRenderPivotTable();
                      };
                
                      PivotTableView.prototype.renderWait = function() {
                        return $('<span class="bk-wait">Rendering ...</span>');
                      };
                
                      PivotTableView.prototype.rerenderPivotTable = function() {
                        this.$pivot.html(this.renderWait());
                        return this.delayRenderPivotTable();
                      };
                
                      PivotTableView.prototype.delayRenderPivotTable = function() {
                        var _this = this;
                        return _.delay((function() {
                          return _this.$pivot.html(_this.renderPivotTable());
                        }), 50);
                      };
                
                      PivotTableView.prototype.rerenderToolbox = function() {
                        return this.$toolbox.html(this.renderToolbox());
                      };
                
                      PivotTableView.prototype.renderToolbox = function() {
                        var toolbox;
                        toolbox = $('<ul></ul>');
                        toolbox.append(this.renderRows());
                        toolbox.append(this.renderColumns());
                        toolbox.append(this.renderValues());
                        toolbox.append(this.renderFilters());
                        toolbox.append(this.renderUpdate());
                        return toolbox;
                      };
                
                      PivotTableView.prototype.renderAdd = function(exclude, handler) {
                        var button, dropdown;
                        dropdown = $('<div class="bk-bs-dropdown bk-bs-pull-right"></div>');
                        button = $('<button class="bk-bs-btn bk-bs-btn-link bk-bs-btn-xs" data-bk-bs-toggle="dropdown">Add</button>');
                        dropdown.append([button.dropdown(), this.renderFields(exclude, handler)]);
                        return dropdown;
                      };
                
                      PivotTableView.prototype.renderFields = function(exclude, handler) {
                        var fields, items, menu;
                        fields = _.difference(this.fieldNames(), exclude);
                        menu = $('<ul class="bk-bs-dropdown-menu"></ul>');
                        items = _.map(fields, function(field) {
                          var item, link;
                          link = $('<a tabindex="-1" href="javascript://"></a>');
                          link.text(field);
                          item = $('<li></li>');
                          return item.append(link);
                        });
                        menu.append(items);
                        return menu.click(function(event) {
                          return handler($(event.target).text());
                        });
                      };
                
                      PivotTableView.prototype.renderRemove = function(attr, field) {
                        var handler,
                          _this = this;
                        handler = function(event) {
                          return _this.mset(attr, _.reject(_this.mget(attr), function(item) {
                            return item.field === field;
                          }));
                        };
                        return $('<span class="bk-bs-close bk-bs-pull-right">&times;</span>').click(handler);
                      };
                
                      PivotTableView.prototype.renderOptions = function(options, value, handler) {
                        var button, dropdown, items, menu, text,
                          _this = this;
                        menu = $('<ul class="bk-bs-dropdown-menu"></ul>');
                        items = _.map(options, function(option) {
                          var item, link;
                          link = $('<a tabindex="-1" href="javascript://"></a>');
                          link.text(option);
                          item = $('<li></li>');
                          return item.append(link);
                        });
                        menu.append(items);
                        menu.click(function(event) {
                          return handler($(event.target).text());
                        });
                        dropdown = $('<span class="bk-bs-dropdown"></span>');
                        button = $('<button class="bk-bs-btn bk-bs-btn-link bk-bs-btn-xs" data-bk-bs-toggle="dropdown"></button>');
                        text = typeof value === 'number' ? options[value] : value;
                        button.text(text);
                        button.append('&nbsp;');
                        button.append($('<span class="bk-bs-caret"></span>'));
                        return dropdown.append([button.dropdown(), menu]);
                      };
                
                      PivotTableView.prototype.makeSortable = function(attr, $el) {
                        var _this = this;
                        return $el.sortable({
                          handle: ".bk-pivot-box-header",
                          axis: "y",
                          distance: 10
                        }).on('sortstop', function(ui) {
                          var child, fields;
                          fields = (function() {
                            var _i, _len, _ref1, _results;
                            _ref1 = $el.children();
                            _results = [];
                            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                              child = _ref1[_i];
                              _results.push($(child).data('bk-field'));
                            }
                            return _results;
                          })();
                          return _this.mset(attr, _.sortBy(_this.mget(attr), function(item) {
                            return fields.indexOf(item.field);
                          }));
                        });
                      };
                
                      PivotTableView.prototype.renderFieldName = function(field) {
                        return $('<span class="bk-field"></span').text(field);
                      };
                
                      PivotTableView.prototype.renderDType = function(field) {
                        return $('<span class="bk-dtype"></span').text('(' + this.getDType(field) + ')');
                      };
                
                      PivotTableView.prototype.defaultRowColumn = function(field) {
                        return {
                          field: field,
                          order: "ascending",
                          sort_by: field,
                          totals: true
                        };
                      };
                
                      PivotTableView.prototype.usedFields = function() {
                        return _.map(this.mget("rows").concat(this.mget("columns")), function(item) {
                          return item.field;
                        });
                      };
                
                      PivotTableView.prototype.renderRows = function() {
                        var $rows, add, el, header,
                          _this = this;
                        el = $("<li></li>");
                        header = $("<div>Rows</div>");
                        add = this.renderAdd(this.usedFields(), function(field) {
                          return _this.mpush("rows", _this.defaultRowColumn(field));
                        });
                        header.append(add);
                        $rows = $('<ul></ul>');
                        _.each(this.mget("rows"), function(row, index) {
                          var $dtype, $field, $remove, $row, groupBy, order, sortBy, totals;
                          groupBy = $('<li class="bk-pivot-box-header">Group by:</li>');
                          $field = _this.renderFieldName(row.field);
                          $dtype = _this.renderDType(row.field);
                          $remove = _this.renderRemove("rows", row.field);
                          groupBy.append(["&nbsp;", $field, "&nbsp;", $dtype, $remove]);
                          order = $('<li>Order:&nbsp;</li>');
                          order.append(_this.renderOptions(["ascending", "descending"], row.order, function(value) {
                            return _this.mupdate("rows", function(rows) {
                              return rows[index].order = value;
                            });
                          }));
                          sortBy = $('<li>Sort by:&nbsp;</li>');
                          sortBy.append(_this.renderOptions([row.field], row.sort_by, function(value) {
                            return _this.mupdate("rows", function(rows) {
                              return rows[index].sort_by = value;
                            });
                          }));
                          totals = $('<li>Totals:&nbsp;</li>');
                          totals.append(_this.renderOptions(["on", "off"], (row.totals ? 0 : 1), function(value) {
                            return _this.mupdate("rows", function(rows) {
                              return rows[index].totals = value === "on" ? true : false;
                            });
                          }));
                          $row = $('<ul class="bk-pivot-box"></ul>');
                          $row.data('bk-field', row.field);
                          $row.append([groupBy, order, sortBy, totals]);
                          return $rows.append($row);
                        });
                        this.makeSortable("rows", $rows);
                        return el.append([header, $rows]);
                      };
                
                      PivotTableView.prototype.renderColumns = function() {
                        var $columns, add, el, header,
                          _this = this;
                        el = $("<li></li>");
                        header = $("<div>Columns</div>");
                        add = this.renderAdd(this.usedFields(), function(field) {
                          return _this.mpush("columns", _this.defaultRowColumn(field));
                        });
                        header.append(add);
                        $columns = $('<ul></ul>');
                        _.each(this.mget("columns"), function(column, index) {
                          var $column, $dtype, $field, $remove, groupBy, order, sortBy, totals;
                          groupBy = $('<li class="bk-pivot-box-header">Group by:</li>');
                          $field = _this.renderFieldName(column.field);
                          $dtype = _this.renderDType(column.field);
                          $remove = _this.renderRemove("columns", column.field);
                          groupBy.append(["&nbsp;", $field, "&nbsp;", $dtype, $remove]);
                          order = $('<li>Order:&nbsp;</li>');
                          order.append(_this.renderOptions(["ascending", "descending"], column.order, function(value) {
                            return _this.mupdate("columns", function(columns) {
                              return columns[index].order = value;
                            });
                          }));
                          sortBy = $('<li>Sort by:&nbsp;</li>');
                          sortBy.append(_this.renderOptions([column.field], column.sort_by, function(value) {
                            return _this.mupdate("columns", function(columns) {
                              return columns[index].sort_by = value;
                            });
                          }));
                          totals = $('<li>Totals:&nbsp;</li>');
                          totals.append(_this.renderOptions(["on", "off"], (column.totals ? 0 : 1), function(value) {
                            return _this.mupdate("columns", function(columns) {
                              return columns[index].totals = value === "on" ? true : false;
                            });
                          }));
                          $column = $('<ul class="bk-pivot-box"></ul>');
                          $column.data('bk-field', column.field);
                          $column.append([groupBy, order, sortBy, totals]);
                          return $columns.append($column);
                        });
                        this.makeSortable("columns", $columns);
                        return el.append([header, $columns]);
                      };
                
                      PivotTableView.prototype.defaultValue = function(field) {
                        return {
                          field: field,
                          aggregate: "count",
                          renderer: "default",
                          formatter: "none"
                        };
                      };
                
                      PivotTableView.prototype.renderValues = function() {
                        var $values, add, el, header,
                          _this = this;
                        el = $("<li></li>");
                        header = $("<div>Values</div>");
                        add = this.renderAdd([], function(field) {
                          return _this.mpush("values", _this.defaultValue(field));
                        });
                        header.append(add);
                        $values = $('<ul></ul>');
                        _.each(this.mget("values"), function(value, index) {
                          var $dtype, $field, $remove, $value, aggregate, display, formatter, renderer;
                          display = $('<li class="bk-pivot-box-header">Display:</li>');
                          $field = _this.renderFieldName(value.field);
                          $dtype = _this.renderDType(value.field);
                          $remove = _this.renderRemove("values", value.field);
                          display.append(["&nbsp;", $field, "&nbsp;", $dtype, $remove]);
                          aggregate = $('<li>Aggregate:&nbsp;</li>');
                          aggregate.append(_this.renderOptions(_this.model.aggregates, value.aggregate, function(aggregate) {
                            return _this.mupdate("values", function(values) {
                              return values[index].aggregate = aggregate;
                            });
                          }));
                          renderer = $('<li>Renderer:&nbsp;</li>');
                          renderer.append(_this.renderOptions(_this.model.renderers, value.renderer, function(renderer) {
                            return _this.mupdate("values", function(values) {
                              return values[index].renderer = renderer;
                            });
                          }));
                          formatter = $('<li>Formatter:&nbsp;</li>');
                          formatter.append(_this.renderOptions(_this.model.formatters, value.formatter, function(formatter) {
                            return _this.mupdate("values", function(values) {
                              return values[index].formatter = formatter;
                            });
                          }));
                          $value = $('<ul class="bk-pivot-box"></ul>');
                          $value.data('bk-field', value.field);
                          $value.append([display, aggregate, renderer, formatter]);
                          return $values.append($value);
                        });
                        this.makeSortable("values", $values);
                        return el.append([header, $values]);
                      };
                
                      PivotTableView.prototype.defaultFilter = function(field) {
                        return {
                          field: field
                        };
                      };
                
                      PivotTableView.prototype.renderFilters = function() {
                        var $filters, add, el, header,
                          _this = this;
                        el = $("<li></li>");
                        header = $("<div>Filters</div>");
                        add = this.renderAdd([], function(field) {
                          return _this.mpush("filters", _this.defaultFilter(field));
                        });
                        header.append(add);
                        $filters = $('<ul></ul>');
                        _.each(this.mget("filters"), function(filter) {
                          var $dtype, $field, $filter, $remove, display;
                          display = $('<li class="bk-pivot-box-header">Filter:</li>');
                          $field = _this.renderFieldName(filter.field);
                          $dtype = _this.renderDType(filter.field);
                          $remove = _this.renderRemove("filters", filter.field);
                          display.append(["&nbsp;", $field, "&nbsp;", $dtype, $remove]);
                          $filter = $('<ul class="bk-pivot-box"></ul>');
                          $filter.data('bk-field', filter.field);
                          $filter.append([display]);
                          return $filters.append($filter);
                        });
                        this.makeSortable("filters", $filters);
                        return el.append([header, $filters]);
                      };
                
                      PivotTableView.prototype.renderUpdate = function() {
                        var button, el, manual_update, update,
                          _this = this;
                        manual_update = this.mget("manual_update");
                        el = $("<li></li>");
                        update = $('<div>Update:&nbsp;</div>');
                        update.append(this.renderOptions(["Manual", "Automatic"], (manual_update ? 0 : 1), function(value) {
                          return _this.mset("manual_update", value === "Manual" ? true : false);
                        }));
                        el.append(update);
                        if (manual_update) {
                          button = $('<button type="button" class="bk-bs-btn bk-bs-btn-primary">Update</button>');
                          button.click(function(event) {
                            return _this.model.save();
                          });
                          el.append(button);
                        }
                        return el;
                      };
                
                      PivotTableView.prototype.renderDescription = function() {
                        return $('<div></div>').text(this.mget("description"));
                      };
                
                      PivotTableView.prototype.spanSize = function(arr, i, j) {
                        var len, noDraw, stop, x, _i, _j;
                        if (i !== 0) {
                          noDraw = true;
                          for (x = _i = 0; 0 <= j ? _i <= j : _i >= j; x = 0 <= j ? ++_i : --_i) {
                            if (arr[i - 1][x] !== arr[i][x]) {
                              noDraw = false;
                            }
                          }
                          if (noDraw) {
                            return -1;
                          }
                        }
                        len = 0;
                        while (i + len < arr.length) {
                          stop = false;
                          for (x = _j = 0; 0 <= j ? _j <= j : _j >= j; x = 0 <= j ? ++_j : --_j) {
                            if (arr[i][x] !== arr[i + len][x]) {
                              stop = true;
                            }
                          }
                          if (stop) {
                            break;
                          }
                          len++;
                        }
                        return len;
                      };
                
                      PivotTableView.prototype.getAggregator = function(rowKey, colKey) {
                        var col, data, row, value;
                        data = this.mget("data");
                        row = data.rows.indexOf(rowKey);
                        col = data.cols.indexOf(colKey);
                        if (row === -1) {
                          row = data.rows.length - 1;
                        }
                        if (col === -1) {
                          col = data.cols.length - 1;
                        }
                        if (row === -1 || col === -1) {
                          value = null;
                        } else {
                          value = data.values[row][col];
                        }
                        return {
                          value: (function() {
                            return value;
                          }),
                          format: (function(value) {
                            return "" + value;
                          })
                        };
                      };
                
                      PivotTableView.prototype.renderPivotTable = function() {
                        var aggregator, c, colAttrs, colKey, colKeys, i, j, r, result, rowAttrs, rowKey, rowKeys, th, totalAggregator, tr, txt, val, x;
                        rowAttrs = this.mget("rows");
                        colAttrs = this.mget("columns");
                        rowKeys = this.mget("data").rows;
                        colKeys = this.mget("data").cols;
                        result = $("<table class='bk-pivot-table pvtTable'>");
                        for (j in colAttrs) {
                          if (!__hasProp.call(colAttrs, j)) continue;
                          c = colAttrs[j];
                          tr = $("<tr>");
                          if (parseInt(j) === 0 && rowAttrs.length !== 0) {
                            tr.append($("<th>").attr("colspan", rowAttrs.length).attr("rowspan", colAttrs.length));
                          }
                          tr.append($("<th class='pvtAxisLabel'>").text(c.field));
                          for (i in colKeys) {
                            if (!__hasProp.call(colKeys, i)) continue;
                            colKey = colKeys[i];
                            x = this.spanSize(colKeys, parseInt(i), parseInt(j));
                            if (x !== -1) {
                              th = $("<th class='pvtColLabel'>").text(colKey[j]).attr("colspan", x);
                              if (parseInt(j) === colAttrs.length - 1 && rowAttrs.length !== 0) {
                                th.attr("rowspan", 2);
                              }
                              tr.append(th);
                            }
                          }
                          if (parseInt(j) === 0) {
                            tr.append($("<th class='pvtTotalLabel'>").text("Totals").attr("rowspan", colAttrs.length + (rowAttrs.length === 0 ? 0 : 1)));
                          }
                          result.append(tr);
                        }
                        if (rowAttrs.length !== 0) {
                          tr = $("<tr>");
                          for (i in rowAttrs) {
                            if (!__hasProp.call(rowAttrs, i)) continue;
                            r = rowAttrs[i];
                            tr.append($("<th class='pvtAxisLabel'>").text(r.field));
                          }
                          th = $("<th>");
                          if (colAttrs.length === 0) {
                            th.addClass("pvtTotalLabel").text("Totals");
                          }
                          tr.append(th);
                          result.append(tr);
                        }
                        for (i in rowKeys) {
                          if (!__hasProp.call(rowKeys, i)) continue;
                          rowKey = rowKeys[i];
                          tr = $("<tr>");
                          for (j in rowKey) {
                            if (!__hasProp.call(rowKey, j)) continue;
                            txt = rowKey[j];
                            x = this.spanSize(rowKeys, parseInt(i), parseInt(j));
                            if (x !== -1) {
                              th = $("<th class='pvtRowLabel'>").text(txt).attr("rowspan", x);
                              if (parseInt(j) === rowAttrs.length - 1 && colAttrs.length !== 0) {
                                th.attr("colspan", 2);
                              }
                              tr.append(th);
                            }
                          }
                          for (j in colKeys) {
                            if (!__hasProp.call(colKeys, j)) continue;
                            colKey = colKeys[j];
                            aggregator = this.getAggregator(rowKey, colKey);
                            val = aggregator.value();
                            tr.append($("<td class='pvtVal row" + i + " col" + j + "'>").text(aggregator.format(val)).data("value", val));
                          }
                          totalAggregator = this.getAggregator(rowKey, []);
                          val = totalAggregator.value();
                          tr.append($("<td class='pvtTotal rowTotal'>").text(totalAggregator.format(val)).data("value", val).data("for", "row" + i));
                          result.append(tr);
                        }
                        tr = $("<tr>");
                        th = $("<th class='pvtTotalLabel'>").text("Totals");
                        th.attr("colspan", rowAttrs.length + (colAttrs.length === 0 ? 0 : 1));
                        tr.append(th);
                        for (j in colKeys) {
                          if (!__hasProp.call(colKeys, j)) continue;
                          colKey = colKeys[j];
                          totalAggregator = this.getAggregator([], colKey);
                          val = totalAggregator.value();
                          tr.append($("<td class='pvtTotal colTotal'>").text(totalAggregator.format(val)).data("value", val).data("for", "col" + j));
                        }
                        totalAggregator = this.getAggregator([], []);
                        val = totalAggregator.value();
                        tr.append($("<td class='pvtGrandTotal'>").text(totalAggregator.format(val)).data("value", val));
                        result.append(tr);
                        return result;
                      };
                
                      return PivotTableView;
                
                    })(ContinuumView);
                    PivotTable = (function(_super) {
                      __extends(PivotTable, _super);
                
                      function PivotTable() {
                        _ref1 = PivotTable.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      PivotTable.prototype.default_view = PivotTableView;
                
                      PivotTable.prototype.type = "PivotTable";
                
                      PivotTable.prototype.defaults = function() {
                        return _.extend({}, PivotTable.__super__.defaults.call(this), {
                          title: "Pivot Table",
                          description: "",
                          source: null,
                          data: {},
                          fields: [],
                          rows: [],
                          columns: [],
                          values: [],
                          filters: [],
                          manual_update: true
                        });
                      };
                
                      PivotTable.prototype.aggregates = ["count", "counta", "countunique", "average", "max", "min", "median", "sum", "product", "stdev", "stdevp", "var", "varp"];
                
                      PivotTable.prototype.renderers = ["default", "heatmap"];
                
                      PivotTable.prototype.formatters = ["none"];
                
                      PivotTable.prototype.mset = function() {
                        if (this.get("manual_update")) {
                          return this.set.apply(this, arguments);
                        } else {
                          return this.save.apply(this, arguments);
                        }
                      };
                
                      return PivotTable;
                
                    })(HasParent);
                    PivotTables = (function(_super) {
                      __extends(PivotTables, _super);
                
                      function PivotTables() {
                        _ref2 = PivotTables.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      PivotTables.prototype.model = PivotTable;
                
                      return PivotTables;
                
                    })(Collection);
                    return {
                      Model: PivotTable,
                      Collection: new PivotTables(),
                      View: PivotTableView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=pivot_table.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/paragraph',["common/has_parent", "common/continuum_view", "common/collection"], function(HasParent, ContinuumView, Collection) {
                    var Paragraph, ParagraphView, Paragraphs, paragraphs, _ref, _ref1, _ref2;
                    ParagraphView = (function(_super) {
                      __extends(ParagraphView, _super);
                
                      function ParagraphView() {
                        _ref = ParagraphView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ParagraphView.prototype.tagName = "p";
                
                      ParagraphView.prototype.initialize = function(options) {
                        ParagraphView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      ParagraphView.prototype.render = function() {
                        if (this.mget('height')) {
                          this.$el.height(this.mget('height'));
                        }
                        if (this.mget('width')) {
                          this.$el.width(this.mget('width'));
                        }
                        return this.$el.text(this.mget('text'));
                      };
                
                      return ParagraphView;
                
                    })(ContinuumView);
                    Paragraph = (function(_super) {
                      __extends(Paragraph, _super);
                
                      function Paragraph() {
                        _ref1 = Paragraph.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Paragraph.prototype.type = "Paragraph";
                
                      Paragraph.prototype.default_view = ParagraphView;
                
                      Paragraph.prototype.defaults = function() {
                        return _.extend({}, Paragraph.__super__.defaults.call(this), {
                          text: ''
                        });
                      };
                
                      return Paragraph;
                
                    })(HasParent);
                    Paragraphs = (function(_super) {
                      __extends(Paragraphs, _super);
                
                      function Paragraphs() {
                        _ref2 = Paragraphs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Paragraphs.prototype.model = Paragraph;
                
                      return Paragraphs;
                
                    })(Collection);
                    paragraphs = new Paragraphs();
                    return {
                      "Model": Paragraph,
                      "Collection": paragraphs,
                      "View": ParagraphView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=paragraph.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/hbox',["common/has_parent", "common/continuum_view", "common/build_views", "common/collection"], function(HasParent, ContinuumView, build_views, Collection) {
                    var HBox, HBoxView, HBoxes, hboxes, _ref, _ref1, _ref2;
                    HBoxView = (function(_super) {
                      __extends(HBoxView, _super);
                
                      function HBoxView() {
                        _ref = HBoxView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      HBoxView.prototype.tag = "div";
                
                      HBoxView.prototype.attributes = {
                        "class": "bk-hbox"
                      };
                
                      HBoxView.prototype.initialize = function(options) {
                        HBoxView.__super__.initialize.call(this, options);
                        this.views = {};
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      HBoxView.prototype.render = function() {
                        var child, children, height, key, val, width, _i, _len, _ref1, _results;
                        children = this.mget('children');
                        build_views(this.views, children);
                        _ref1 = this.views;
                        for (key in _ref1) {
                          if (!__hasProp.call(_ref1, key)) continue;
                          val = _ref1[key];
                          val.$el.detach();
                        }
                        this.$el.empty();
                        width = this.mget("width");
                        if (width != null) {
                          this.$el.css({
                            width: width + "px"
                          });
                        }
                        height = this.mget("height");
                        if (height != null) {
                          this.$el.css({
                            height: height + "px"
                          });
                        }
                        _results = [];
                        for (_i = 0, _len = children.length; _i < _len; _i++) {
                          child = children[_i];
                          _results.push(this.$el.append(this.views[child.id].$el));
                        }
                        return _results;
                      };
                
                      return HBoxView;
                
                    })(ContinuumView);
                    HBox = (function(_super) {
                      __extends(HBox, _super);
                
                      function HBox() {
                        _ref1 = HBox.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      HBox.prototype.type = "HBox";
                
                      HBox.prototype.default_view = HBoxView;
                
                      HBox.prototype.defaults = function() {
                        return _.extend({}, HBox.__super__.defaults.call(this), {
                          children: []
                        });
                      };
                
                      return HBox;
                
                    })(HasParent);
                    HBoxes = (function(_super) {
                      __extends(HBoxes, _super);
                
                      function HBoxes() {
                        _ref2 = HBoxes.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      HBoxes.prototype.model = HBox;
                
                      return HBoxes;
                
                    })(Collection);
                    hboxes = new HBoxes();
                    return {
                      "Model": HBox,
                      "Collection": hboxes,
                      "View": HBoxView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=hbox.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/vbox',["common/has_parent", "common/continuum_view", "common/build_views", "common/collection"], function(HasParent, ContinuumView, build_views, Collection) {
                    var VBox, VBoxView, VBoxes, vboxes, _ref, _ref1, _ref2;
                    VBoxView = (function(_super) {
                      __extends(VBoxView, _super);
                
                      function VBoxView() {
                        _ref = VBoxView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      VBoxView.prototype.tag = "div";
                
                      VBoxView.prototype.attributes = {
                        "class": "bk-vbox"
                      };
                
                      VBoxView.prototype.initialize = function(options) {
                        VBoxView.__super__.initialize.call(this, options);
                        this.views = {};
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      VBoxView.prototype.render = function() {
                        var child, children, height, key, val, width, _i, _len, _ref1, _results;
                        children = this.mget('children');
                        build_views(this.views, children);
                        _ref1 = this.views;
                        for (key in _ref1) {
                          if (!__hasProp.call(_ref1, key)) continue;
                          val = _ref1[key];
                          val.$el.detach();
                        }
                        this.$el.empty();
                        width = this.mget("width");
                        if (width != null) {
                          this.$el.css({
                            width: width + "px"
                          });
                        }
                        height = this.mget("height");
                        if (height != null) {
                          this.$el.css({
                            height: height + "px"
                          });
                        }
                        _results = [];
                        for (_i = 0, _len = children.length; _i < _len; _i++) {
                          child = children[_i];
                          _results.push(this.$el.append(this.views[child.id].$el));
                        }
                        return _results;
                      };
                
                      return VBoxView;
                
                    })(ContinuumView);
                    VBox = (function(_super) {
                      __extends(VBox, _super);
                
                      function VBox() {
                        _ref1 = VBox.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      VBox.prototype.type = "VBox";
                
                      VBox.prototype.default_view = VBoxView;
                
                      VBox.prototype.defaults = function() {
                        return _.extend({}, VBox.__super__.defaults.call(this), {
                          children: []
                        });
                      };
                
                      return VBox;
                
                    })(HasParent);
                    VBoxes = (function(_super) {
                      __extends(VBoxes, _super);
                
                      function VBoxes() {
                        _ref2 = VBoxes.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      VBoxes.prototype.model = VBox;
                
                      return VBoxes;
                
                    })(Collection);
                    vboxes = new VBoxes();
                    return {
                      "Model": VBox,
                      "Collection": vboxes,
                      "View": VBoxView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=vbox.js.map
                */;
                define('widget/textinputtemplate',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<label for="'));
                    
                      _print(this.id);
                    
                      _print(_safe('"> '));
                    
                      _print(this.title);
                    
                      _print(_safe(' </label>\n<input class="bk-widget-form-input" type="text" id="'));
                    
                      _print(this.id);
                    
                      _print(_safe('" name="'));
                    
                      _print(this.name);
                    
                      _print(_safe('" value="'));
                    
                      _print(this.value);
                    
                      _print(_safe('"/>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/textinput',["common/collection", "common/build_views", "common/continuum_view", "common/has_parent", "common/logging", "./textinputtemplate"], function(Collection, build_views, ContinuumView, HasParent, Logging, template) {
                    var TextInput, TextInputView, TextInputs, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    TextInputView = (function(_super) {
                      __extends(TextInputView, _super);
                
                      function TextInputView() {
                        _ref = TextInputView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      TextInputView.prototype.tagName = "div";
                
                      TextInputView.prototype.attributes = {
                        "class": "bk-widget-form-group"
                      };
                
                      TextInputView.prototype.template = template;
                
                      TextInputView.prototype.events = {
                        "change input": "change_input"
                      };
                
                      TextInputView.prototype.change_input = function() {
                        var value;
                        value = this.$('input').val();
                        logger.debug("textinput: value = " + value);
                        this.mset('value', value);
                        return this.model.save();
                      };
                
                      TextInputView.prototype.initialize = function(options) {
                        TextInputView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      TextInputView.prototype.render = function() {
                        this.$el.html(this.template(this.model.attributes));
                        return this;
                      };
                
                      return TextInputView;
                
                    })(ContinuumView);
                    TextInput = (function(_super) {
                      __extends(TextInput, _super);
                
                      function TextInput() {
                        _ref1 = TextInput.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      TextInput.prototype.type = "TextInput";
                
                      TextInput.prototype.default_view = TextInputView;
                
                      TextInput.prototype.defaults = function() {
                        return _.extend({}, TextInput.__super__.defaults.call(this), {
                          name: "",
                          value: "",
                          title: ""
                        });
                      };
                
                      return TextInput;
                
                    })(HasParent);
                    TextInputs = (function(_super) {
                      __extends(TextInputs, _super);
                
                      function TextInputs() {
                        _ref2 = TextInputs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      TextInputs.prototype.model = TextInput;
                
                      return TextInputs;
                
                    })(Collection);
                    return {
                      Model: TextInput,
                      Collection: new TextInputs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=textinput.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/vboxform',["common/has_parent", "common/continuum_view", "common/build_views", "common/collection"], function(HasParent, ContinuumView, build_views, Collection) {
                    var VBoxForm, VBoxFormView, VBoxForms, vboxforms, _ref, _ref1, _ref2;
                    VBoxFormView = (function(_super) {
                      __extends(VBoxFormView, _super);
                
                      function VBoxFormView() {
                        _ref = VBoxFormView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      VBoxFormView.prototype.tagName = "form";
                
                      VBoxFormView.prototype.attributes = {
                        "class": "bk-widget-form",
                        role: "form"
                      };
                
                      VBoxFormView.prototype.initialize = function(options) {
                        VBoxFormView.__super__.initialize.call(this, options);
                        this.views = {};
                        return this.render();
                      };
                
                      VBoxFormView.prototype.render = function() {
                        var child, children, key, val, _i, _len, _ref1, _results;
                        children = this.mget('children');
                        build_views(this.views, children);
                        _ref1 = this.views;
                        for (key in _ref1) {
                          if (!__hasProp.call(_ref1, key)) continue;
                          val = _ref1[key];
                          val.$el.detach();
                        }
                        this.$el.empty();
                        _results = [];
                        for (_i = 0, _len = children.length; _i < _len; _i++) {
                          child = children[_i];
                          this.$el.append("<br/");
                          _results.push(this.$el.append(this.views[child.id].$el));
                        }
                        return _results;
                      };
                
                      return VBoxFormView;
                
                    })(ContinuumView);
                    VBoxForm = (function(_super) {
                      __extends(VBoxForm, _super);
                
                      function VBoxForm() {
                        _ref1 = VBoxForm.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      VBoxForm.prototype.type = "VBoxForm";
                
                      VBoxForm.prototype.default_view = VBoxFormView;
                
                      VBoxForm.prototype.defaults = function() {
                        return _.extend({}, VBoxForm.__super__.defaults.call(this), {
                          children: []
                        });
                      };
                
                      return VBoxForm;
                
                    })(HasParent);
                    VBoxForms = (function(_super) {
                      __extends(VBoxForms, _super);
                
                      function VBoxForms() {
                        _ref2 = VBoxForms.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      VBoxForms.prototype.model = VBoxForm;
                
                      return VBoxForms;
                
                    })(Collection);
                    vboxforms = new VBoxForms();
                    return {
                      "Model": VBoxForm,
                      "Collection": vboxforms,
                      "View": VBoxFormView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=vboxform.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/pretext',["common/collection", "./paragraph"], function(Collection, Paragraph) {
                    var PreText, PreTextView, PreTexts, pretexts, _ref, _ref1, _ref2;
                    PreTextView = (function(_super) {
                      __extends(PreTextView, _super);
                
                      function PreTextView() {
                        _ref = PreTextView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PreTextView.prototype.tagName = "pre";
                
                      PreTextView.prototype.attributes = {
                        style: "overflow:scroll"
                      };
                
                      return PreTextView;
                
                    })(Paragraph.View);
                    PreText = (function(_super) {
                      __extends(PreText, _super);
                
                      function PreText() {
                        _ref1 = PreText.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      PreText.prototype.type = "PreText";
                
                      PreText.prototype.default_view = PreTextView;
                
                      PreText.prototype.defaults = function() {
                        return _.extend({}, PreText.__super__.defaults.call(this), {
                          text: '',
                          height: 400,
                          width: 400
                        });
                      };
                
                      return PreText;
                
                    })(Paragraph.Model);
                    PreTexts = (function(_super) {
                      __extends(PreTexts, _super);
                
                      function PreTexts() {
                        _ref2 = PreTexts.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      PreTexts.prototype.model = PreText;
                
                      return PreTexts;
                
                    })(Collection);
                    pretexts = new PreTexts();
                    return {
                      "Model": PreText,
                      "Collection": pretexts,
                      "View": PreTextView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=pretext.js.map
                */;
                define('widget/selecttemplate',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      var option, _i, _len, _ref;
                    
                      _print(_safe('<label for="'));
                    
                      _print(this.id);
                    
                      _print(_safe('"> '));
                    
                      _print(this.title);
                    
                      _print(_safe(' </label>\n<select class="bk-widget-form-input" id="'));
                    
                      _print(this.id);
                    
                      _print(_safe('" name="'));
                    
                      _print(this.name);
                    
                      _print(_safe('">\n  '));
                    
                      _ref = this.options;
                      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        option = _ref[_i];
                        _print(_safe('\n    '));
                        if (_.isString(option)) {
                          _print(_safe('\n      <option '));
                          _print(option === this.value ? _print(_safe('selected="selected"')) : void 0);
                          _print(_safe(' value="'));
                          _print(option);
                          _print(_safe('">'));
                          _print(option);
                          _print(_safe('</option>\n    '));
                        } else {
                          _print(_safe('\n      <option '));
                          _print(option.value === this.value ? _print(_safe('selected="selected"')) : void 0);
                          _print(_safe(' value="'));
                          _print(option.value);
                          _print(_safe('">'));
                          _print(option.name);
                          _print(_safe('</option>\n    '));
                        }
                        _print(_safe('\n  '));
                      }
                    
                      _print(_safe('\n</select>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/selectbox',["common/collection", "underscore", "common/continuum_view", "common/has_parent", "common/logging", "./selecttemplate"], function(Collection, build_views, ContinuumView, HasParent, Logging, template) {
                    var Select, SelectView, Selects, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    SelectView = (function(_super) {
                      __extends(SelectView, _super);
                
                      function SelectView() {
                        _ref = SelectView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SelectView.prototype.tagName = "div";
                
                      SelectView.prototype.template = template;
                
                      SelectView.prototype.events = {
                        "change select": "change_input"
                      };
                
                      SelectView.prototype.change_input = function() {
                        var value;
                        value = this.$('select').val();
                        logger.debug("selectbox: value = " + value);
                        this.mset('value', value);
                        return this.model.save();
                      };
                
                      SelectView.prototype.initialize = function(options) {
                        SelectView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      SelectView.prototype.render = function() {
                        var html;
                        this.$el.empty();
                        html = this.template(this.model.attributes);
                        this.$el.html(html);
                        return this;
                      };
                
                      return SelectView;
                
                    })(ContinuumView);
                    Select = (function(_super) {
                      __extends(Select, _super);
                
                      function Select() {
                        _ref1 = Select.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Select.prototype.type = "Select";
                
                      Select.prototype.default_view = SelectView;
                
                      Select.prototype.defaults = function() {
                        return _.extend({}, Select.__super__.defaults.call(this), {
                          title: '',
                          value: '',
                          options: []
                        });
                      };
                
                      return Select;
                
                    })(HasParent);
                    Selects = (function(_super) {
                      __extends(Selects, _super);
                
                      function Selects() {
                        _ref2 = Selects.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Selects.prototype.model = Select;
                
                      return Selects;
                
                    })(Collection);
                    return {
                      Model: Select,
                      Collection: new Selects(),
                      View: SelectView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=selectbox.js.map
                */;
                define('widget/slidertemplate',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<label for="'));
                    
                      _print(this.id);
                    
                      _print(_safe('"> '));
                    
                      _print(this.title);
                    
                      _print(_safe(': </label>\n<input type="text" id="'));
                    
                      _print(this.id);
                    
                      _print(_safe('" readonly style="border:0; color:#f6931f; font-weight:bold;">\n<div class="bk-slider-'));
                    
                      _print(this.orientation);
                    
                      _print(_safe('">\n  <div class="slider " id="'));
                    
                      _print(this.id);
                    
                      _print(_safe('">\n</div>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                define('jquery_ui/slider',['jquery','./core','./mouse','./widget'], function (jQuery) {
                /*!
                 * jQuery UI Slider 1.10.0
                 * http://jqueryui.com
                 *
                 * Copyright 2013 jQuery Foundation and other contributors
                 * Released under the MIT license.
                 * http://jquery.org/license
                 *
                 * http://api.jqueryui.com/slider/
                 *
                 * Depends:
                 *	jquery.ui.core.js
                 *	jquery.ui.mouse.js
                 *	jquery.ui.widget.js
                 */
                (function( $, undefined ) {
                
                // number of pages in a slider
                // (how many times can you page up/down to go through the whole range)
                var numPages = 5;
                
                $.widget( "ui.slider", $.ui.mouse, {
                	version: "1.10.0",
                	widgetEventPrefix: "slide",
                
                	options: {
                		animate: false,
                		distance: 0,
                		max: 100,
                		min: 0,
                		orientation: "horizontal",
                		range: false,
                		step: 1,
                		value: 0,
                		values: null,
                
                		// callbacks
                		change: null,
                		slide: null,
                		start: null,
                		stop: null
                	},
                
                	_create: function() {
                		var i, handleCount,
                			o = this.options,
                			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
                			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
                			handles = [];
                
                		this._keySliding = false;
                		this._mouseSliding = false;
                		this._animateOff = true;
                		this._handleIndex = null;
                		this._detectOrientation();
                		this._mouseInit();
                
                		this.element
                			.addClass( "ui-slider" +
                				" ui-slider-" + this.orientation +
                				" ui-widget" +
                				" ui-widget-content" +
                				" ui-corner-all");
                
                		this.range = $([]);
                
                		if ( o.range ) {
                			if ( o.range === true ) {
                				if ( !o.values ) {
                					o.values = [ this._valueMin(), this._valueMin() ];
                				} else if ( o.values.length && o.values.length !== 2 ) {
                					o.values = [ o.values[0], o.values[0] ];
                				} else if ( $.isArray( o.values ) ) {
                					o.values = o.values.slice(0);
                				}
                			}
                
                			this.range = $( "<div></div>" )
                				.appendTo( this.element )
                				.addClass( "ui-slider-range" +
                				// note: this isn't the most fittingly semantic framework class for this element,
                				// but worked best visually with a variety of themes
                				" ui-widget-header" +
                				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
                		}
                
                		handleCount = ( o.values && o.values.length ) || 1;
                
                		for ( i = existingHandles.length; i < handleCount; i++ ) {
                			handles.push( handle );
                		}
                
                		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );
                
                		this.handle = this.handles.eq( 0 );
                
                		this.handles.add( this.range ).filter( "a" )
                			.click(function( event ) {
                				event.preventDefault();
                			})
                			.mouseenter(function() {
                				if ( !o.disabled ) {
                					$( this ).addClass( "ui-state-hover" );
                				}
                			})
                			.mouseleave(function() {
                				$( this ).removeClass( "ui-state-hover" );
                			})
                			.focus(function() {
                				if ( !o.disabled ) {
                					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
                					$( this ).addClass( "ui-state-focus" );
                				} else {
                					$( this ).blur();
                				}
                			})
                			.blur(function() {
                				$( this ).removeClass( "ui-state-focus" );
                			});
                
                		this.handles.each(function( i ) {
                			$( this ).data( "ui-slider-handle-index", i );
                		});
                
                		this._setOption( "disabled", o.disabled );
                
                		this._on( this.handles, this._handleEvents );
                
                		this._refreshValue();
                
                		this._animateOff = false;
                	},
                
                	_destroy: function() {
                		this.handles.remove();
                		this.range.remove();
                
                		this.element
                			.removeClass( "ui-slider" +
                				" ui-slider-horizontal" +
                				" ui-slider-vertical" +
                				" ui-widget" +
                				" ui-widget-content" +
                				" ui-corner-all" );
                
                		this._mouseDestroy();
                	},
                
                	_mouseCapture: function( event ) {
                		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                			that = this,
                			o = this.options;
                
                		if ( o.disabled ) {
                			return false;
                		}
                
                		this.elementSize = {
                			width: this.element.outerWidth(),
                			height: this.element.outerHeight()
                		};
                		this.elementOffset = this.element.offset();
                
                		position = { x: event.pageX, y: event.pageY };
                		normValue = this._normValueFromMouse( position );
                		distance = this._valueMax() - this._valueMin() + 1;
                		this.handles.each(function( i ) {
                			var thisDistance = Math.abs( normValue - that.values(i) );
                			if (( distance > thisDistance ) ||
                				( distance === thisDistance &&
                					(i === that._lastChangedValue || that.values(i) === o.min ))) {
                				distance = thisDistance;
                				closestHandle = $( this );
                				index = i;
                			}
                		});
                
                		allowed = this._start( event, index );
                		if ( allowed === false ) {
                			return false;
                		}
                		this._mouseSliding = true;
                
                		this._handleIndex = index;
                
                		closestHandle
                			.addClass( "ui-state-active" )
                			.focus();
                
                		offset = closestHandle.offset();
                		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
                		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
                			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
                			top: event.pageY - offset.top -
                				( closestHandle.height() / 2 ) -
                				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
                				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
                				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
                		};
                
                		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
                			this._slide( event, index, normValue );
                		}
                		this._animateOff = true;
                		return true;
                	},
                
                	_mouseStart: function() {
                		return true;
                	},
                
                	_mouseDrag: function( event ) {
                		var position = { x: event.pageX, y: event.pageY },
                			normValue = this._normValueFromMouse( position );
                
                		this._slide( event, this._handleIndex, normValue );
                
                		return false;
                	},
                
                	_mouseStop: function( event ) {
                		this.handles.removeClass( "ui-state-active" );
                		this._mouseSliding = false;
                
                		this._stop( event, this._handleIndex );
                		this._change( event, this._handleIndex );
                
                		this._handleIndex = null;
                		this._clickOffset = null;
                		this._animateOff = false;
                
                		return false;
                	},
                
                	_detectOrientation: function() {
                		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
                	},
                
                	_normValueFromMouse: function( position ) {
                		var pixelTotal,
                			pixelMouse,
                			percentMouse,
                			valueTotal,
                			valueMouse;
                
                		if ( this.orientation === "horizontal" ) {
                			pixelTotal = this.elementSize.width;
                			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
                		} else {
                			pixelTotal = this.elementSize.height;
                			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
                		}
                
                		percentMouse = ( pixelMouse / pixelTotal );
                		if ( percentMouse > 1 ) {
                			percentMouse = 1;
                		}
                		if ( percentMouse < 0 ) {
                			percentMouse = 0;
                		}
                		if ( this.orientation === "vertical" ) {
                			percentMouse = 1 - percentMouse;
                		}
                
                		valueTotal = this._valueMax() - this._valueMin();
                		valueMouse = this._valueMin() + percentMouse * valueTotal;
                
                		return this._trimAlignValue( valueMouse );
                	},
                
                	_start: function( event, index ) {
                		var uiHash = {
                			handle: this.handles[ index ],
                			value: this.value()
                		};
                		if ( this.options.values && this.options.values.length ) {
                			uiHash.value = this.values( index );
                			uiHash.values = this.values();
                		}
                		return this._trigger( "start", event, uiHash );
                	},
                
                	_slide: function( event, index, newVal ) {
                		var otherVal,
                			newValues,
                			allowed;
                
                		if ( this.options.values && this.options.values.length ) {
                			otherVal = this.values( index ? 0 : 1 );
                
                			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
                					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
                				) {
                				newVal = otherVal;
                			}
                
                			if ( newVal !== this.values( index ) ) {
                				newValues = this.values();
                				newValues[ index ] = newVal;
                				// A slide can be canceled by returning false from the slide callback
                				allowed = this._trigger( "slide", event, {
                					handle: this.handles[ index ],
                					value: newVal,
                					values: newValues
                				} );
                				otherVal = this.values( index ? 0 : 1 );
                				if ( allowed !== false ) {
                					this.values( index, newVal, true );
                				}
                			}
                		} else {
                			if ( newVal !== this.value() ) {
                				// A slide can be canceled by returning false from the slide callback
                				allowed = this._trigger( "slide", event, {
                					handle: this.handles[ index ],
                					value: newVal
                				} );
                				if ( allowed !== false ) {
                					this.value( newVal );
                				}
                			}
                		}
                	},
                
                	_stop: function( event, index ) {
                		var uiHash = {
                			handle: this.handles[ index ],
                			value: this.value()
                		};
                		if ( this.options.values && this.options.values.length ) {
                			uiHash.value = this.values( index );
                			uiHash.values = this.values();
                		}
                
                		this._trigger( "stop", event, uiHash );
                	},
                
                	_change: function( event, index ) {
                		if ( !this._keySliding && !this._mouseSliding ) {
                			var uiHash = {
                				handle: this.handles[ index ],
                				value: this.value()
                			};
                			if ( this.options.values && this.options.values.length ) {
                				uiHash.value = this.values( index );
                				uiHash.values = this.values();
                			}
                
                			//store the last changed value index for reference when handles overlap
                			this._lastChangedValue = index;
                
                			this._trigger( "change", event, uiHash );
                		}
                	},
                
                	value: function( newValue ) {
                		if ( arguments.length ) {
                			this.options.value = this._trimAlignValue( newValue );
                			this._refreshValue();
                			this._change( null, 0 );
                			return;
                		}
                
                		return this._value();
                	},
                
                	values: function( index, newValue ) {
                		var vals,
                			newValues,
                			i;
                
                		if ( arguments.length > 1 ) {
                			this.options.values[ index ] = this._trimAlignValue( newValue );
                			this._refreshValue();
                			this._change( null, index );
                			return;
                		}
                
                		if ( arguments.length ) {
                			if ( $.isArray( arguments[ 0 ] ) ) {
                				vals = this.options.values;
                				newValues = arguments[ 0 ];
                				for ( i = 0; i < vals.length; i += 1 ) {
                					vals[ i ] = this._trimAlignValue( newValues[ i ] );
                					this._change( null, i );
                				}
                				this._refreshValue();
                			} else {
                				if ( this.options.values && this.options.values.length ) {
                					return this._values( index );
                				} else {
                					return this.value();
                				}
                			}
                		} else {
                			return this._values();
                		}
                	},
                
                	_setOption: function( key, value ) {
                		var i,
                			valsLength = 0;
                
                		if ( $.isArray( this.options.values ) ) {
                			valsLength = this.options.values.length;
                		}
                
                		$.Widget.prototype._setOption.apply( this, arguments );
                
                		switch ( key ) {
                			case "disabled":
                				if ( value ) {
                					this.handles.filter( ".ui-state-focus" ).blur();
                					this.handles.removeClass( "ui-state-hover" );
                					this.handles.prop( "disabled", true );
                				} else {
                					this.handles.prop( "disabled", false );
                				}
                				break;
                			case "orientation":
                				this._detectOrientation();
                				this.element
                					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
                					.addClass( "ui-slider-" + this.orientation );
                				this._refreshValue();
                				break;
                			case "value":
                				this._animateOff = true;
                				this._refreshValue();
                				this._change( null, 0 );
                				this._animateOff = false;
                				break;
                			case "values":
                				this._animateOff = true;
                				this._refreshValue();
                				for ( i = 0; i < valsLength; i += 1 ) {
                					this._change( null, i );
                				}
                				this._animateOff = false;
                				break;
                			case "min":
                			case "max":
                				this._animateOff = true;
                				this._refreshValue();
                				this._animateOff = false;
                				break;
                		}
                	},
                
                	//internal value getter
                	// _value() returns value trimmed by min and max, aligned by step
                	_value: function() {
                		var val = this.options.value;
                		val = this._trimAlignValue( val );
                
                		return val;
                	},
                
                	//internal values getter
                	// _values() returns array of values trimmed by min and max, aligned by step
                	// _values( index ) returns single value trimmed by min and max, aligned by step
                	_values: function( index ) {
                		var val,
                			vals,
                			i;
                
                		if ( arguments.length ) {
                			val = this.options.values[ index ];
                			val = this._trimAlignValue( val );
                
                			return val;
                		} else {
                			// .slice() creates a copy of the array
                			// this copy gets trimmed by min and max and then returned
                			vals = this.options.values.slice();
                			for ( i = 0; i < vals.length; i+= 1) {
                				vals[ i ] = this._trimAlignValue( vals[ i ] );
                			}
                
                			return vals;
                		}
                	},
                
                	// returns the step-aligned value that val is closest to, between (inclusive) min and max
                	_trimAlignValue: function( val ) {
                		if ( val <= this._valueMin() ) {
                			return this._valueMin();
                		}
                		if ( val >= this._valueMax() ) {
                			return this._valueMax();
                		}
                		var step = ( this.options.step > 0 ) ? this.options.step : 1,
                			valModStep = (val - this._valueMin()) % step,
                			alignValue = val - valModStep;
                
                		if ( Math.abs(valModStep) * 2 >= step ) {
                			alignValue += ( valModStep > 0 ) ? step : ( -step );
                		}
                
                		// Since JavaScript has problems with large floats, round
                		// the final value to 5 digits after the decimal point (see #4124)
                		return parseFloat( alignValue.toFixed(5) );
                	},
                
                	_valueMin: function() {
                		return this.options.min;
                	},
                
                	_valueMax: function() {
                		return this.options.max;
                	},
                
                	_refreshValue: function() {
                		var lastValPercent, valPercent, value, valueMin, valueMax,
                			oRange = this.options.range,
                			o = this.options,
                			that = this,
                			animate = ( !this._animateOff ) ? o.animate : false,
                			_set = {};
                
                		if ( this.options.values && this.options.values.length ) {
                			this.handles.each(function( i ) {
                				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
                				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
                				if ( that.options.range === true ) {
                					if ( that.orientation === "horizontal" ) {
                						if ( i === 0 ) {
                							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
                						}
                						if ( i === 1 ) {
                							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
                						}
                					} else {
                						if ( i === 0 ) {
                							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
                						}
                						if ( i === 1 ) {
                							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
                						}
                					}
                				}
                				lastValPercent = valPercent;
                			});
                		} else {
                			value = this.value();
                			valueMin = this._valueMin();
                			valueMax = this._valueMax();
                			valPercent = ( valueMax !== valueMin ) ?
                					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
                					0;
                			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
                
                			if ( oRange === "min" && this.orientation === "horizontal" ) {
                				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
                			}
                			if ( oRange === "max" && this.orientation === "horizontal" ) {
                				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
                			}
                			if ( oRange === "min" && this.orientation === "vertical" ) {
                				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
                			}
                			if ( oRange === "max" && this.orientation === "vertical" ) {
                				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
                			}
                		}
                	},
                
                	_handleEvents: {
                		keydown: function( event ) {
                			/*jshint maxcomplexity:25*/
                			var allowed, curVal, newVal, step,
                				index = $( event.target ).data( "ui-slider-handle-index" );
                
                			switch ( event.keyCode ) {
                				case $.ui.keyCode.HOME:
                				case $.ui.keyCode.END:
                				case $.ui.keyCode.PAGE_UP:
                				case $.ui.keyCode.PAGE_DOWN:
                				case $.ui.keyCode.UP:
                				case $.ui.keyCode.RIGHT:
                				case $.ui.keyCode.DOWN:
                				case $.ui.keyCode.LEFT:
                					event.preventDefault();
                					if ( !this._keySliding ) {
                						this._keySliding = true;
                						$( event.target ).addClass( "ui-state-active" );
                						allowed = this._start( event, index );
                						if ( allowed === false ) {
                							return;
                						}
                					}
                					break;
                			}
                
                			step = this.options.step;
                			if ( this.options.values && this.options.values.length ) {
                				curVal = newVal = this.values( index );
                			} else {
                				curVal = newVal = this.value();
                			}
                
                			switch ( event.keyCode ) {
                				case $.ui.keyCode.HOME:
                					newVal = this._valueMin();
                					break;
                				case $.ui.keyCode.END:
                					newVal = this._valueMax();
                					break;
                				case $.ui.keyCode.PAGE_UP:
                					newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
                					break;
                				case $.ui.keyCode.PAGE_DOWN:
                					newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
                					break;
                				case $.ui.keyCode.UP:
                				case $.ui.keyCode.RIGHT:
                					if ( curVal === this._valueMax() ) {
                						return;
                					}
                					newVal = this._trimAlignValue( curVal + step );
                					break;
                				case $.ui.keyCode.DOWN:
                				case $.ui.keyCode.LEFT:
                					if ( curVal === this._valueMin() ) {
                						return;
                					}
                					newVal = this._trimAlignValue( curVal - step );
                					break;
                			}
                
                			this._slide( event, index, newVal );
                		},
                		keyup: function( event ) {
                			var index = $( event.target ).data( "ui-slider-handle-index" );
                
                			if ( this._keySliding ) {
                				this._keySliding = false;
                				this._stop( event, index );
                				this._change( event, index );
                				$( event.target ).removeClass( "ui-state-active" );
                			}
                		}
                	}
                
                });
                
                }(jQuery));
                
                });
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/slider',["common/collection", "underscore", "common/continuum_view", "common/has_parent", "common/logging", "./slidertemplate", "jquery_ui/slider"], function(Collection, _, ContinuumView, HasParent, Logging, slidertemplate) {
                    var Slider, SliderView, Sliders, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    SliderView = (function(_super) {
                      __extends(SliderView, _super);
                
                      function SliderView() {
                        this.slide = __bind(this.slide, this);
                        _ref = SliderView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SliderView.prototype.tagName = "div";
                
                      SliderView.prototype.template = slidertemplate;
                
                      SliderView.prototype.initialize = function(options) {
                        SliderView.__super__.initialize.call(this, options);
                        return this.render();
                      };
                
                      SliderView.prototype.render = function() {
                        var html, max, min, step;
                        this.$el.empty();
                        html = this.template(this.model.attributes);
                        this.$el.html(html);
                        max = this.mget('end');
                        min = this.mget('start');
                        step = this.mget('step') || ((max - min) / 50);
                        logger.debug("slider render: min, max, step = (" + min + ", " + max + ", " + step + ")");
                        this.$('.slider').slider({
                          orientation: this.mget('orientation'),
                          animate: "fast",
                          slide: _.throttle(this.slide, 200),
                          value: this.mget('value'),
                          min: min,
                          max: max,
                          step: step
                        });
                        return this.$("#" + (this.mget('id'))).val(this.$('.slider').slider('value'));
                      };
                
                      SliderView.prototype.slide = function(event, ui) {
                        var value;
                        value = ui.value;
                        logger.debug("slide value = " + value);
                        this.$("#" + (this.mget('id'))).val(ui.value);
                        this.mset('value', value);
                        return this.model.save();
                      };
                
                      return SliderView;
                
                    })(ContinuumView);
                    Slider = (function(_super) {
                      __extends(Slider, _super);
                
                      function Slider() {
                        _ref1 = Slider.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Slider.prototype.type = "Slider";
                
                      Slider.prototype.default_view = SliderView;
                
                      Slider.prototype.defaults = function() {
                        return _.extend({}, Slider.__super__.defaults.call(this), {
                          title: '',
                          value: 0.5,
                          start: 0,
                          end: 1,
                          step: 0,
                          orientation: "horizontal"
                        });
                      };
                
                      return Slider;
                
                    })(HasParent);
                    Sliders = (function(_super) {
                      __extends(Sliders, _super);
                
                      function Sliders() {
                        _ref2 = Sliders.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Sliders.prototype.model = Slider;
                
                      return Sliders;
                
                    })(Collection);
                    return {
                      Model: Slider,
                      Collection: new Sliders(),
                      View: SliderView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=slider.js.map
                */;
                define('jquery_ui/draggable',['jquery','./core','./mouse','./widget'], function (jQuery) {
                /*!
                 * jQuery UI Draggable 1.10.0
                 * http://jqueryui.com
                 *
                 * Copyright 2013 jQuery Foundation and other contributors
                 * Released under the MIT license.
                 * http://jquery.org/license
                 *
                 * http://api.jqueryui.com/draggable/
                 *
                 * Depends:
                 *	jquery.ui.core.js
                 *	jquery.ui.mouse.js
                 *	jquery.ui.widget.js
                 */
                (function( $, undefined ) {
                
                $.widget("ui.draggable", $.ui.mouse, {
                	version: "1.10.0",
                	widgetEventPrefix: "drag",
                	options: {
                		addClasses: true,
                		appendTo: "parent",
                		axis: false,
                		connectToSortable: false,
                		containment: false,
                		cursor: "auto",
                		cursorAt: false,
                		grid: false,
                		handle: false,
                		helper: "original",
                		iframeFix: false,
                		opacity: false,
                		refreshPositions: false,
                		revert: false,
                		revertDuration: 500,
                		scope: "default",
                		scroll: true,
                		scrollSensitivity: 20,
                		scrollSpeed: 20,
                		snap: false,
                		snapMode: "both",
                		snapTolerance: 20,
                		stack: false,
                		zIndex: false,
                
                		// callbacks
                		drag: null,
                		start: null,
                		stop: null
                	},
                	_create: function() {
                
                		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
                			this.element[0].style.position = "relative";
                		}
                		if (this.options.addClasses){
                			this.element.addClass("ui-draggable");
                		}
                		if (this.options.disabled){
                			this.element.addClass("ui-draggable-disabled");
                		}
                
                		this._mouseInit();
                
                	},
                
                	_destroy: function() {
                		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
                		this._mouseDestroy();
                	},
                
                	_mouseCapture: function(event) {
                
                		var o = this.options;
                
                		// among others, prevent a drag on a resizable-handle
                		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                			return false;
                		}
                
                		//Quit if we're not on a valid handle
                		this.handle = this._getHandle(event);
                		if (!this.handle) {
                			return false;
                		}
                
                		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
                			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
                			.css({
                				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
                				position: "absolute", opacity: "0.001", zIndex: 1000
                			})
                			.css($(this).offset())
                			.appendTo("body");
                		});
                
                		return true;
                
                	},
                
                	_mouseStart: function(event) {
                
                		var o = this.options;
                
                		//Create and append the visible helper
                		this.helper = this._createHelper(event);
                
                		this.helper.addClass("ui-draggable-dragging");
                
                		//Cache the helper size
                		this._cacheHelperProportions();
                
                		//If ddmanager is used for droppables, set the global draggable
                		if($.ui.ddmanager) {
                			$.ui.ddmanager.current = this;
                		}
                
                		/*
                		 * - Position generation -
                		 * This block generates everything position related - it's the core of draggables.
                		 */
                
                		//Cache the margins of the original element
                		this._cacheMargins();
                
                		//Store the helper's css position
                		this.cssPosition = this.helper.css("position");
                		this.scrollParent = this.helper.scrollParent();
                
                		//The element's absolute position on the page minus margins
                		this.offset = this.positionAbs = this.element.offset();
                		this.offset = {
                			top: this.offset.top - this.margins.top,
                			left: this.offset.left - this.margins.left
                		};
                
                		$.extend(this.offset, {
                			click: { //Where the click happened, relative to the element
                				left: event.pageX - this.offset.left,
                				top: event.pageY - this.offset.top
                			},
                			parent: this._getParentOffset(),
                			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
                		});
                
                		//Generate the original position
                		this.originalPosition = this.position = this._generatePosition(event);
                		this.originalPageX = event.pageX;
                		this.originalPageY = event.pageY;
                
                		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
                		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
                
                		//Set a containment if given in the options
                		if(o.containment) {
                			this._setContainment();
                		}
                
                		//Trigger event + callbacks
                		if(this._trigger("start", event) === false) {
                			this._clear();
                			return false;
                		}
                
                		//Recache the helper size
                		this._cacheHelperProportions();
                
                		//Prepare the droppable offsets
                		if ($.ui.ddmanager && !o.dropBehaviour) {
                			$.ui.ddmanager.prepareOffsets(this, event);
                		}
                
                
                		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
                
                		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
                		if ( $.ui.ddmanager ) {
                			$.ui.ddmanager.dragStart(this, event);
                		}
                
                		return true;
                	},
                
                	_mouseDrag: function(event, noPropagation) {
                
                		//Compute the helpers position
                		this.position = this._generatePosition(event);
                		this.positionAbs = this._convertPositionTo("absolute");
                
                		//Call plugins and callbacks and use the resulting position if something is returned
                		if (!noPropagation) {
                			var ui = this._uiHash();
                			if(this._trigger("drag", event, ui) === false) {
                				this._mouseUp({});
                				return false;
                			}
                			this.position = ui.position;
                		}
                
                		if(!this.options.axis || this.options.axis !== "y") {
                			this.helper[0].style.left = this.position.left+"px";
                		}
                		if(!this.options.axis || this.options.axis !== "x") {
                			this.helper[0].style.top = this.position.top+"px";
                		}
                		if($.ui.ddmanager) {
                			$.ui.ddmanager.drag(this, event);
                		}
                
                		return false;
                	},
                
                	_mouseStop: function(event) {
                
                		//If we are using droppables, inform the manager about the drop
                		var element,
                			that = this,
                			elementInDom = false,
                			dropped = false;
                		if ($.ui.ddmanager && !this.options.dropBehaviour) {
                			dropped = $.ui.ddmanager.drop(this, event);
                		}
                
                		//if a drop comes from outside (a sortable)
                		if(this.dropped) {
                			dropped = this.dropped;
                			this.dropped = false;
                		}
                
                		//if the original element is no longer in the DOM don't bother to continue (see #8269)
                		element = this.element[0];
                		while ( element && (element = element.parentNode) ) {
                			if (element === document ) {
                				elementInDom = true;
                			}
                		}
                		if ( !elementInDom && this.options.helper === "original" ) {
                			return false;
                		}
                
                		if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
                			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                				if(that._trigger("stop", event) !== false) {
                					that._clear();
                				}
                			});
                		} else {
                			if(this._trigger("stop", event) !== false) {
                				this._clear();
                			}
                		}
                
                		return false;
                	},
                
                	_mouseUp: function(event) {
                		//Remove frame helpers
                		$("div.ui-draggable-iframeFix").each(function() {
                			this.parentNode.removeChild(this);
                		});
                
                		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
                		if( $.ui.ddmanager ) {
                			$.ui.ddmanager.dragStop(this, event);
                		}
                
                		return $.ui.mouse.prototype._mouseUp.call(this, event);
                	},
                
                	cancel: function() {
                
                		if(this.helper.is(".ui-draggable-dragging")) {
                			this._mouseUp({});
                		} else {
                			this._clear();
                		}
                
                		return this;
                
                	},
                
                	_getHandle: function(event) {
                
                		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
                		$(this.options.handle, this.element)
                			.find("*")
                			.addBack()
                			.each(function() {
                				if(this === event.target) {
                					handle = true;
                				}
                			});
                
                		return handle;
                
                	},
                
                	_createHelper: function(event) {
                
                		var o = this.options,
                			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);
                
                		if(!helper.parents("body").length) {
                			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
                		}
                
                		if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
                			helper.css("position", "absolute");
                		}
                
                		return helper;
                
                	},
                
                	_adjustOffsetFromHelper: function(obj) {
                		if (typeof obj === "string") {
                			obj = obj.split(" ");
                		}
                		if ($.isArray(obj)) {
                			obj = {left: +obj[0], top: +obj[1] || 0};
                		}
                		if ("left" in obj) {
                			this.offset.click.left = obj.left + this.margins.left;
                		}
                		if ("right" in obj) {
                			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
                		}
                		if ("top" in obj) {
                			this.offset.click.top = obj.top + this.margins.top;
                		}
                		if ("bottom" in obj) {
                			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
                		}
                	},
                
                	_getParentOffset: function() {
                
                		//Get the offsetParent and cache its position
                		this.offsetParent = this.helper.offsetParent();
                		var po = this.offsetParent.offset();
                
                		// This is a special case where we need to modify a offset calculated on start, since the following happened:
                		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
                		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
                		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
                		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                			po.left += this.scrollParent.scrollLeft();
                			po.top += this.scrollParent.scrollTop();
                		}
                
                		//This needs to be actually done for all browsers, since pageX/pageY includes this information
                		//Ugly IE fix
                		if((this.offsetParent[0] === document.body) ||
                			(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                			po = { top: 0, left: 0 };
                		}
                
                		return {
                			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
                			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
                		};
                
                	},
                
                	_getRelativeOffset: function() {
                
                		if(this.cssPosition === "relative") {
                			var p = this.element.position();
                			return {
                				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
                				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
                			};
                		} else {
                			return { top: 0, left: 0 };
                		}
                
                	},
                
                	_cacheMargins: function() {
                		this.margins = {
                			left: (parseInt(this.element.css("marginLeft"),10) || 0),
                			top: (parseInt(this.element.css("marginTop"),10) || 0),
                			right: (parseInt(this.element.css("marginRight"),10) || 0),
                			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
                		};
                	},
                
                	_cacheHelperProportions: function() {
                		this.helperProportions = {
                			width: this.helper.outerWidth(),
                			height: this.helper.outerHeight()
                		};
                	},
                
                	_setContainment: function() {
                
                		var over, c, ce,
                			o = this.options;
                
                		if(o.containment === "parent") {
                			o.containment = this.helper[0].parentNode;
                		}
                		if(o.containment === "document" || o.containment === "window") {
                			this.containment = [
                				o.containment === "document" ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                				o.containment === "document" ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                				(o.containment === "document" ? 0 : $(window).scrollLeft()) + $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
                				(o.containment === "document" ? 0 : $(window).scrollTop()) + ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                			];
                		}
                
                		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor !== Array) {
                			c = $(o.containment);
                			ce = c[0];
                
                			if(!ce) {
                				return;
                			}
                
                			over = ($(ce).css("overflow") !== "hidden");
                
                			this.containment = [
                				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
                				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
                				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
                				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
                			];
                			this.relative_container = c;
                
                		} else if(o.containment.constructor === Array) {
                			this.containment = o.containment;
                		}
                
                	},
                
                	_convertPositionTo: function(d, pos) {
                
                		if(!pos) {
                			pos = this.position;
                		}
                
                		var mod = d === "absolute" ? 1 : -1,
                			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
                
                		return {
                			top: (
                				pos.top	+																// The absolute mouse position
                				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
                				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
                			),
                			left: (
                				pos.left +																// The absolute mouse position
                				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
                				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
                			)
                		};
                
                	},
                
                	_generatePosition: function(event) {
                
                		var containment, co, top, left,
                			o = this.options,
                			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName),
                			pageX = event.pageX,
                			pageY = event.pageY;
                
                		/*
                		 * - Position constraining -
                		 * Constrain the position to a mix of grid, containment.
                		 */
                
                		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
                			if(this.containment) {
                			if (this.relative_container){
                				co = this.relative_container.offset();
                				containment = [ this.containment[0] + co.left,
                					this.containment[1] + co.top,
                					this.containment[2] + co.left,
                					this.containment[3] + co.top ];
                			}
                			else {
                				containment = this.containment;
                			}
                
                				if(event.pageX - this.offset.click.left < containment[0]) {
                					pageX = containment[0] + this.offset.click.left;
                				}
                				if(event.pageY - this.offset.click.top < containment[1]) {
                					pageY = containment[1] + this.offset.click.top;
                				}
                				if(event.pageX - this.offset.click.left > containment[2]) {
                					pageX = containment[2] + this.offset.click.left;
                				}
                				if(event.pageY - this.offset.click.top > containment[3]) {
                					pageY = containment[3] + this.offset.click.top;
                				}
                			}
                
                			if(o.grid) {
                				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
                
                				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                			}
                
                		}
                
                		return {
                			top: (
                				pageY -																	// The absolute mouse position
                				this.offset.click.top	-												// Click offset (relative to the element)
                				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
                				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
                			),
                			left: (
                				pageX -																	// The absolute mouse position
                				this.offset.click.left -												// Click offset (relative to the element)
                				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
                				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
                			)
                		};
                
                	},
                
                	_clear: function() {
                		this.helper.removeClass("ui-draggable-dragging");
                		if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                			this.helper.remove();
                		}
                		this.helper = null;
                		this.cancelHelperRemoval = false;
                	},
                
                	// From now on bulk stuff - mainly helpers
                
                	_trigger: function(type, event, ui) {
                		ui = ui || this._uiHash();
                		$.ui.plugin.call(this, type, [event, ui]);
                		//The absolute position has to be recalculated after plugins
                		if(type === "drag") {
                			this.positionAbs = this._convertPositionTo("absolute");
                		}
                		return $.Widget.prototype._trigger.call(this, type, event, ui);
                	},
                
                	plugins: {},
                
                	_uiHash: function() {
                		return {
                			helper: this.helper,
                			position: this.position,
                			originalPosition: this.originalPosition,
                			offset: this.positionAbs
                		};
                	}
                
                });
                
                $.ui.plugin.add("draggable", "connectToSortable", {
                	start: function(event, ui) {
                
                		var inst = $(this).data("ui-draggable"), o = inst.options,
                			uiSortable = $.extend({}, ui, { item: inst.element });
                		inst.sortables = [];
                		$(o.connectToSortable).each(function() {
                			var sortable = $.data(this, "ui-sortable");
                			if (sortable && !sortable.options.disabled) {
                				inst.sortables.push({
                					instance: sortable,
                					shouldRevert: sortable.options.revert
                				});
                				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
                				sortable._trigger("activate", event, uiSortable);
                			}
                		});
                
                	},
                	stop: function(event, ui) {
                
                		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
                		var inst = $(this).data("ui-draggable"),
                			uiSortable = $.extend({}, ui, { item: inst.element });
                
                		$.each(inst.sortables, function() {
                			if(this.instance.isOver) {
                
                				this.instance.isOver = 0;
                
                				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
                				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)
                
                				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
                				if(this.shouldRevert) {
                					this.instance.options.revert = true;
                				}
                
                				//Trigger the stop of the sortable
                				this.instance._mouseStop(event);
                
                				this.instance.options.helper = this.instance.options._helper;
                
                				//If the helper has been the original item, restore properties in the sortable
                				if(inst.options.helper === "original") {
                					this.instance.currentItem.css({ top: "auto", left: "auto" });
                				}
                
                			} else {
                				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
                				this.instance._trigger("deactivate", event, uiSortable);
                			}
                
                		});
                
                	},
                	drag: function(event, ui) {
                
                		var inst = $(this).data("ui-draggable"), that = this;
                
                		$.each(inst.sortables, function() {
                
                			var innermostIntersecting = false,
                				thisSortable = this;
                
                			//Copy over some variables to allow calling the sortable's native _intersectsWith
                			this.instance.positionAbs = inst.positionAbs;
                			this.instance.helperProportions = inst.helperProportions;
                			this.instance.offset.click = inst.offset.click;
                
                			if(this.instance._intersectsWith(this.instance.containerCache)) {
                				innermostIntersecting = true;
                				$.each(inst.sortables, function () {
                					this.instance.positionAbs = inst.positionAbs;
                					this.instance.helperProportions = inst.helperProportions;
                					this.instance.offset.click = inst.offset.click;
                					if (this !== thisSortable &&
                						this.instance._intersectsWith(this.instance.containerCache) &&
                						$.ui.contains(thisSortable.instance.element[0], this.instance.element[0])
                					) {
                						innermostIntersecting = false;
                					}
                					return innermostIntersecting;
                				});
                			}
                
                
                			if(innermostIntersecting) {
                				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
                				if(!this.instance.isOver) {
                
                					this.instance.isOver = 1;
                					//Now we fake the start of dragging for the sortable instance,
                					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
                					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
                					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
                					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
                					this.instance.options.helper = function() { return ui.helper[0]; };
                
                					event.target = this.instance.currentItem[0];
                					this.instance._mouseCapture(event, true);
                					this.instance._mouseStart(event, true, true);
                
                					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
                					this.instance.offset.click.top = inst.offset.click.top;
                					this.instance.offset.click.left = inst.offset.click.left;
                					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
                					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;
                
                					inst._trigger("toSortable", event);
                					inst.dropped = this.instance.element; //draggable revert needs that
                					//hack so receive/update callbacks work (mostly)
                					inst.currentItem = inst.element;
                					this.instance.fromOutside = inst;
                
                				}
                
                				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
                				if(this.instance.currentItem) {
                					this.instance._mouseDrag(event);
                				}
                
                			} else {
                
                				//If it doesn't intersect with the sortable, and it intersected before,
                				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
                				if(this.instance.isOver) {
                
                					this.instance.isOver = 0;
                					this.instance.cancelHelperRemoval = true;
                
                					//Prevent reverting on this forced stop
                					this.instance.options.revert = false;
                
                					// The out event needs to be triggered independently
                					this.instance._trigger("out", event, this.instance._uiHash(this.instance));
                
                					this.instance._mouseStop(event, true);
                					this.instance.options.helper = this.instance.options._helper;
                
                					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
                					this.instance.currentItem.remove();
                					if(this.instance.placeholder) {
                						this.instance.placeholder.remove();
                					}
                
                					inst._trigger("fromSortable", event);
                					inst.dropped = false; //draggable revert needs that
                				}
                
                			}
                
                		});
                
                	}
                });
                
                $.ui.plugin.add("draggable", "cursor", {
                	start: function() {
                		var t = $("body"), o = $(this).data("ui-draggable").options;
                		if (t.css("cursor")) {
                			o._cursor = t.css("cursor");
                		}
                		t.css("cursor", o.cursor);
                	},
                	stop: function() {
                		var o = $(this).data("ui-draggable").options;
                		if (o._cursor) {
                			$("body").css("cursor", o._cursor);
                		}
                	}
                });
                
                $.ui.plugin.add("draggable", "opacity", {
                	start: function(event, ui) {
                		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
                		if(t.css("opacity")) {
                			o._opacity = t.css("opacity");
                		}
                		t.css("opacity", o.opacity);
                	},
                	stop: function(event, ui) {
                		var o = $(this).data("ui-draggable").options;
                		if(o._opacity) {
                			$(ui.helper).css("opacity", o._opacity);
                		}
                	}
                });
                
                $.ui.plugin.add("draggable", "scroll", {
                	start: function() {
                		var i = $(this).data("ui-draggable");
                		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                			i.overflowOffset = i.scrollParent.offset();
                		}
                	},
                	drag: function( event ) {
                
                		var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;
                
                		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
                
                			if(!o.axis || o.axis !== "x") {
                				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
                				} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
                				}
                			}
                
                			if(!o.axis || o.axis !== "y") {
                				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
                				} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
                				}
                			}
                
                		} else {
                
                			if(!o.axis || o.axis !== "x") {
                				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                				}
                			}
                
                			if(!o.axis || o.axis !== "y") {
                				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                				}
                			}
                
                		}
                
                		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                			$.ui.ddmanager.prepareOffsets(i, event);
                		}
                
                	}
                });
                
                $.ui.plugin.add("draggable", "snap", {
                	start: function() {
                
                		var i = $(this).data("ui-draggable"),
                			o = i.options;
                
                		i.snapElements = [];
                
                		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
                			var $t = $(this),
                				$o = $t.offset();
                			if(this !== i.element[0]) {
                				i.snapElements.push({
                					item: this,
                					width: $t.outerWidth(), height: $t.outerHeight(),
                					top: $o.top, left: $o.left
                				});
                			}
                		});
                
                	},
                	drag: function(event, ui) {
                
                		var ts, bs, ls, rs, l, r, t, b, i, first,
                			inst = $(this).data("ui-draggable"),
                			o = inst.options,
                			d = o.snapTolerance,
                			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
                			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
                
                		for (i = inst.snapElements.length - 1; i >= 0; i--){
                
                			l = inst.snapElements[i].left;
                			r = l + inst.snapElements[i].width;
                			t = inst.snapElements[i].top;
                			b = t + inst.snapElements[i].height;
                
                			//Yes, I know, this is insane ;)
                			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
                				if(inst.snapElements[i].snapping) {
                					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                				}
                				inst.snapElements[i].snapping = false;
                				continue;
                			}
                
                			if(o.snapMode !== "inner") {
                				ts = Math.abs(t - y2) <= d;
                				bs = Math.abs(b - y1) <= d;
                				ls = Math.abs(l - x2) <= d;
                				rs = Math.abs(r - x1) <= d;
                				if(ts) {
                					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
                				}
                				if(bs) {
                					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
                				}
                				if(ls) {
                					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
                				}
                				if(rs) {
                					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
                				}
                			}
                
                			first = (ts || bs || ls || rs);
                
                			if(o.snapMode !== "outer") {
                				ts = Math.abs(t - y1) <= d;
                				bs = Math.abs(b - y2) <= d;
                				ls = Math.abs(l - x1) <= d;
                				rs = Math.abs(r - x2) <= d;
                				if(ts) {
                					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
                				}
                				if(bs) {
                					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
                				}
                				if(ls) {
                					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
                				}
                				if(rs) {
                					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
                				}
                			}
                
                			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                			}
                			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);
                
                		}
                
                	}
                });
                
                $.ui.plugin.add("draggable", "stack", {
                	start: function() {
                
                		var min,
                			o = $(this).data("ui-draggable").options,
                			group = $.makeArray($(o.stack)).sort(function(a,b) {
                				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
                			});
                
                		if (!group.length) { return; }
                
                		min = parseInt(group[0].style.zIndex, 10) || 0;
                		$(group).each(function(i) {
                			this.style.zIndex = min + i;
                		});
                
                		this[0].style.zIndex = min + group.length;
                
                	}
                });
                
                $.ui.plugin.add("draggable", "zIndex", {
                	start: function(event, ui) {
                		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
                		if(t.css("zIndex")) {
                			o._zIndex = t.css("zIndex");
                		}
                		t.css("zIndex", o.zIndex);
                	},
                	stop: function(event, ui) {
                		var o = $(this).data("ui-draggable").options;
                		if(o._zIndex) {
                			$(ui.helper).css("zIndex", o._zIndex);
                		}
                	}
                });
                
                })(jQuery);
                
                });
                define('jquery_ui/droppable',['jquery','./core','./widget','./mouse','./draggable'], function (jQuery) {
                /*!
                 * jQuery UI Droppable 1.10.0
                 * http://jqueryui.com
                 *
                 * Copyright 2013 jQuery Foundation and other contributors
                 * Released under the MIT license.
                 * http://jquery.org/license
                 *
                 * http://api.jqueryui.com/droppable/
                 *
                 * Depends:
                 *	jquery.ui.core.js
                 *	jquery.ui.widget.js
                 *	jquery.ui.mouse.js
                 *	jquery.ui.draggable.js
                 */
                (function( $, undefined ) {
                
                function isOverAxis( x, reference, size ) {
                	return ( x > reference ) && ( x < ( reference + size ) );
                }
                
                $.widget("ui.droppable", {
                	version: "1.10.0",
                	widgetEventPrefix: "drop",
                	options: {
                		accept: "*",
                		activeClass: false,
                		addClasses: true,
                		greedy: false,
                		hoverClass: false,
                		scope: "default",
                		tolerance: "intersect",
                
                		// callbacks
                		activate: null,
                		deactivate: null,
                		drop: null,
                		out: null,
                		over: null
                	},
                	_create: function() {
                
                		var o = this.options,
                			accept = o.accept;
                
                		this.isover = false;
                		this.isout = true;
                
                		this.accept = $.isFunction(accept) ? accept : function(d) {
                			return d.is(accept);
                		};
                
                		//Store the droppable's proportions
                		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };
                
                		// Add the reference and positions to the manager
                		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
                		$.ui.ddmanager.droppables[o.scope].push(this);
                
                		(o.addClasses && this.element.addClass("ui-droppable"));
                
                	},
                
                	_destroy: function() {
                		var i = 0,
                			drop = $.ui.ddmanager.droppables[this.options.scope];
                
                		for ( ; i < drop.length; i++ ) {
                			if ( drop[i] === this ) {
                				drop.splice(i, 1);
                			}
                		}
                
                		this.element.removeClass("ui-droppable ui-droppable-disabled");
                	},
                
                	_setOption: function(key, value) {
                
                		if(key === "accept") {
                			this.accept = $.isFunction(value) ? value : function(d) {
                				return d.is(value);
                			};
                		}
                		$.Widget.prototype._setOption.apply(this, arguments);
                	},
                
                	_activate: function(event) {
                		var draggable = $.ui.ddmanager.current;
                		if(this.options.activeClass) {
                			this.element.addClass(this.options.activeClass);
                		}
                		if(draggable){
                			this._trigger("activate", event, this.ui(draggable));
                		}
                	},
                
                	_deactivate: function(event) {
                		var draggable = $.ui.ddmanager.current;
                		if(this.options.activeClass) {
                			this.element.removeClass(this.options.activeClass);
                		}
                		if(draggable){
                			this._trigger("deactivate", event, this.ui(draggable));
                		}
                	},
                
                	_over: function(event) {
                
                		var draggable = $.ui.ddmanager.current;
                
                		// Bail if draggable and droppable are same element
                		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                			return;
                		}
                
                		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                			if(this.options.hoverClass) {
                				this.element.addClass(this.options.hoverClass);
                			}
                			this._trigger("over", event, this.ui(draggable));
                		}
                
                	},
                
                	_out: function(event) {
                
                		var draggable = $.ui.ddmanager.current;
                
                		// Bail if draggable and droppable are same element
                		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                			return;
                		}
                
                		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                			if(this.options.hoverClass) {
                				this.element.removeClass(this.options.hoverClass);
                			}
                			this._trigger("out", event, this.ui(draggable));
                		}
                
                	},
                
                	_drop: function(event,custom) {
                
                		var draggable = custom || $.ui.ddmanager.current,
                			childrenIntersection = false;
                
                		// Bail if draggable and droppable are same element
                		if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                			return false;
                		}
                
                		this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                			var inst = $.data(this, "ui-droppable");
                			if(
                				inst.options.greedy &&
                				!inst.options.disabled &&
                				inst.options.scope === draggable.options.scope &&
                				inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
                				$.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
                			) { childrenIntersection = true; return false; }
                		});
                		if(childrenIntersection) {
                			return false;
                		}
                
                		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                			if(this.options.activeClass) {
                				this.element.removeClass(this.options.activeClass);
                			}
                			if(this.options.hoverClass) {
                				this.element.removeClass(this.options.hoverClass);
                			}
                			this._trigger("drop", event, this.ui(draggable));
                			return this.element;
                		}
                
                		return false;
                
                	},
                
                	ui: function(c) {
                		return {
                			draggable: (c.currentItem || c.element),
                			helper: c.helper,
                			position: c.position,
                			offset: c.positionAbs
                		};
                	}
                
                });
                
                $.ui.intersect = function(draggable, droppable, toleranceMode) {
                
                	if (!droppable.offset) {
                		return false;
                	}
                
                	var draggableLeft, draggableTop,
                		x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
                		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height,
                		l = droppable.offset.left, r = l + droppable.proportions.width,
                		t = droppable.offset.top, b = t + droppable.proportions.height;
                
                	switch (toleranceMode) {
                		case "fit":
                			return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
                		case "intersect":
                			return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
                				x2 - (draggable.helperProportions.width / 2) < r && // Left Half
                				t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
                				y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
                		case "pointer":
                			draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
                			draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
                			return isOverAxis( draggableTop, t, droppable.proportions.height ) && isOverAxis( draggableLeft, l, droppable.proportions.width );
                		case "touch":
                			return (
                				(y1 >= t && y1 <= b) ||	// Top edge touching
                				(y2 >= t && y2 <= b) ||	// Bottom edge touching
                				(y1 < t && y2 > b)		// Surrounded vertically
                			) && (
                				(x1 >= l && x1 <= r) ||	// Left edge touching
                				(x2 >= l && x2 <= r) ||	// Right edge touching
                				(x1 < l && x2 > r)		// Surrounded horizontally
                			);
                		default:
                			return false;
                		}
                
                };
                
                /*
                	This manager tracks offsets of draggables and droppables
                */
                $.ui.ddmanager = {
                	current: null,
                	droppables: { "default": [] },
                	prepareOffsets: function(t, event) {
                
                		var i, j,
                			m = $.ui.ddmanager.droppables[t.options.scope] || [],
                			type = event ? event.type : null, // workaround for #2317
                			list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
                
                		droppablesLoop: for (i = 0; i < m.length; i++) {
                
                			//No disabled and non-accepted
                			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {
                				continue;
                			}
                
                			// Filter out elements in the current dragged item
                			for (j=0; j < list.length; j++) {
                				if(list[j] === m[i].element[0]) {
                					m[i].proportions.height = 0;
                					continue droppablesLoop;
                				}
                			}
                
                			m[i].visible = m[i].element.css("display") !== "none";
                			if(!m[i].visible) {
                				continue;
                			}
                
                			//Activate the droppable if used directly from draggables
                			if(type === "mousedown") {
                				m[i]._activate.call(m[i], event);
                			}
                
                			m[i].offset = m[i].element.offset();
                			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };
                
                		}
                
                	},
                	drop: function(draggable, event) {
                
                		var dropped = false;
                		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                
                			if(!this.options) {
                				return;
                			}
                			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
                				dropped = this._drop.call(this, event) || dropped;
                			}
                
                			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                				this.isout = true;
                				this.isover = false;
                				this._deactivate.call(this, event);
                			}
                
                		});
                		return dropped;
                
                	},
                	dragStart: function( draggable, event ) {
                		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
                		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
                			if( !draggable.options.refreshPositions ) {
                				$.ui.ddmanager.prepareOffsets( draggable, event );
                			}
                		});
                	},
                	drag: function(draggable, event) {
                
                		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
                		if(draggable.options.refreshPositions) {
                			$.ui.ddmanager.prepareOffsets(draggable, event);
                		}
                
                		//Run through all droppables and check their positions based on specific tolerance options
                		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                
                			if(this.options.disabled || this.greedyChild || !this.visible) {
                				return;
                			}
                
                			var parentInstance, scope, parent,
                				intersects = $.ui.intersect(draggable, this, this.options.tolerance),
                				c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
                			if(!c) {
                				return;
                			}
                
                			if (this.options.greedy) {
                				// find droppable parents with same scope
                				scope = this.options.scope;
                				parent = this.element.parents(":data(ui-droppable)").filter(function () {
                					return $.data(this, "ui-droppable").options.scope === scope;
                				});
                
                				if (parent.length) {
                					parentInstance = $.data(parent[0], "ui-droppable");
                					parentInstance.greedyChild = (c === "isover");
                				}
                			}
                
                			// we just moved into a greedy child
                			if (parentInstance && c === "isover") {
                				parentInstance.isover = false;
                				parentInstance.isout = true;
                				parentInstance._out.call(parentInstance, event);
                			}
                
                			this[c] = true;
                			this[c === "isout" ? "isover" : "isout"] = false;
                			this[c === "isover" ? "_over" : "_out"].call(this, event);
                
                			// we just moved out of a greedy child
                			if (parentInstance && c === "isout") {
                				parentInstance.isout = false;
                				parentInstance.isover = true;
                				parentInstance._over.call(parentInstance, event);
                			}
                		});
                
                	},
                	dragStop: function( draggable, event ) {
                		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
                		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
                		if( !draggable.options.refreshPositions ) {
                			$.ui.ddmanager.prepareOffsets( draggable, event );
                		}
                	}
                };
                
                })(jQuery);
                
                });
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('common/close_wrapper',["underscore", "./continuum_view"], function(_, ContinuumView) {
                    var CloseWrapper, _ref;
                    CloseWrapper = (function(_super) {
                      __extends(CloseWrapper, _super);
                
                      function CloseWrapper() {
                        _ref = CloseWrapper.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CloseWrapper.prototype.attributes = {
                        "class": "bk-closewrapper"
                      };
                
                      CloseWrapper.prototype.delegateEvents = function(events) {
                        return CloseWrapper.__super__.delegateEvents.call(this, events);
                      };
                
                      CloseWrapper.prototype.events = {
                        "click .bk-close": "close"
                      };
                
                      CloseWrapper.prototype.close = function(options) {
                        this.view.remove();
                        return this.remove();
                      };
                
                      CloseWrapper.prototype.initialize = function(options) {
                        CloseWrapper.__super__.initialize.call(this, options);
                        this.view = options.view;
                        return this.render();
                      };
                
                      CloseWrapper.prototype.render = function() {
                        this.view.$el.detach();
                        this.$el.empty();
                        this.$el.html("<a href='#' class='bk-close'>[x]</a>");
                        return this.$el.append(this.view.$el);
                      };
                
                      return CloseWrapper;
                
                    })(ContinuumView);
                    return {
                      View: CloseWrapper
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=close_wrapper.js.map
                */;
                define('widget/crossfilter_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<div class="bk-crossfilter-container">\n\n  <table>\n\n    <tr>\n\n      <td class="aligntable">\n\n        <div class="bk-crossfilter-configuration bk-bs-container">\n\n          <div class="bk-crossfilter-row">\n\n            <div class="col-md-5 bk-column-list" />\n\n            <div class="col-md-7 bk-filters-facets">\n\n              <div class="bk-bs-panel bk-bs-panel-primary bk-filters">\n                <div class="bk-bs-panel-heading bk-crossfilter-panel-heading"> Filter </div>\n                <div class="bk-bs-panel-body bk-filters-selections" />\n              </div>\n\n              <div class="bk-bs-panel bk-bs-panel-primary bk-facet bk-facet-x">\n                <div class="bk-bs-panel-heading bk-crossfilter-panel-heading"> Facet X </div>\n                <div class="bk-facets-selections " />\n              </div>\n\n              <div class="bk-bs-panel bk-bs-panel-primary bk-facet bk-facet-y">\n                <div class="bk-bs-panel-heading bk-crossfilter-panel-heading"> Facet Y </div>\n                <div class="bk-facets-selections " />\n              </div>\n\n              <div class="bk-bs-panel bk-bs-panel-primary bk-facet bk-facet-tab">\n                <div class="bk-bs-panel-heading bk-crossfilter-panel-heading"> Facet Tab (Coming Soon) </div>\n                <div class="bk-facets-selections " />\n              </div>\n\n            </div>\n\n          </div>\n\n        </div>\n\n      </td>\n\n      <td class="aligntable">\n\n        <div class="bk-plot-selection">\n\n          <form class="bk-widget-form">\n            <ul class="bk-crossfilter-selector">\n              <li class="bk-plot-selector col-md-3"> </li>\n              <li class="bk-x-selector col-md-3"> </li>\n              <li class="bk-y-selector col-md-3"> </li>\n              <li class="bk-agg-selector col-md-3"> </li>\n            </ul>\n          </form>\n\n        </div>\n\n        <div class="bk-plot" />\n      </td>\n\n    </tr>\n\n  </table>\n\n</div>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                define('widget/crossfilter_column_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      var field, _i, _len, _ref;
                    
                      if (this.label === "Continuous") {
                        _print(_safe('\n<div class="bk-bs-panel-heading bk-crossfilter-panel-heading bk-crossfilter-panel-continuous-heading">\n'));
                      } else {
                        _print(_safe('\n<div class="bk-bs-panel-heading bk-crossfilter-panel-heading bk-crossfilter-panel-factor-heading">\n'));
                      }
                    
                      _print(_safe('\n  '));
                    
                      _print(this.name);
                    
                      _print(_safe(' <span style="font-size:x-small;">('));
                    
                      _print(this.label);
                    
                      _print(_safe(')</span>\n</div>\n\n\n<div class="bk-bs-panel-body">\n\n  <table class="bk-table">\n\n    <tbody>\n\n      '));
                    
                      _ref = this.fields;
                      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        field = _ref[_i];
                        _print(_safe('\n      <tr> <td> '));
                        _print(field);
                        _print(_safe('  </td> <td> '));
                        _print(this[field]);
                        _print(_safe('  </td> </tr>\n      '));
                      }
                    
                      _print(_safe('\n\n    </tbody>\n\n  </table>\n\n</div>'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                define('widget/crossfilter_facet_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(this.name);
                    
                      _print(_safe(' &nbsp; [x]'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
                    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
                
                  define('widget/crossfilter',["common/collection", "underscore", "jquery_ui/draggable", "jquery_ui/droppable", "common/has_parent", "common/has_properties", "common/continuum_view", "common/close_wrapper", "common/build_views", "./crossfilter_template", "./crossfilter_column_template", "./crossfilter_facet_template"], function(Collection, _, draggable, droppable, HasParent, HasProperties, ContinuumView, CloseWrapper, build_views, crossfilter_template, crossfilter_column_template, crossfilter_facet_template) {
                    var ColumnCollection, ColumnView, ColumnsView, ContinuousColumn, ContinuousColumnView, CrossFilter, CrossFilterView, CrossFilters, DiscreteColumn, DiscreteColumnView, FacetView, FacetsView, FilterView, PlotAttributeSelector, TimeColumn, TimeColumnView, column_types, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
                    CrossFilterView = (function(_super) {
                      __extends(CrossFilterView, _super);
                
                      function CrossFilterView() {
                        _ref = CrossFilterView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CrossFilterView.prototype.tag = "div";
                
                      CrossFilterView.prototype.attributes = {
                        "class": "bk-crossfilter"
                      };
                
                      CrossFilterView.prototype.initialize = function(options) {
                        CrossFilterView.__super__.initialize.call(this, options);
                        this.views = {};
                        this.listenTo(this.model, 'change:plot', this.render_plot);
                        this.render();
                        this.render_plot();
                        return this;
                      };
                
                      CrossFilterView.prototype.render_plot = function() {
                        var plot, plot_view;
                        plot = this.mget('plot');
                        plot_view = new plot.default_view({
                          model: plot
                        });
                        this.$el.find('.bk-plot').empty();
                        return this.$el.find('.bk-plot').append(plot_view.$el);
                      };
                
                      CrossFilterView.prototype.render = function() {
                        var html;
                        if (this.columnview != null) {
                          this.columnview.$el.detach();
                        }
                        this.$el.empty();
                        html = crossfilter_template();
                        this.$el.html(html);
                        this.filterview = new FilterView({
                          el: this.$('.bk-filters'),
                          collection: this.model.columns,
                          model: this.model
                        });
                        this.facetsview = new FacetsView({
                          el: this.$el,
                          model: this.model
                        });
                        this.plotattributeview = new PlotAttributeSelector({
                          el: this.$el,
                          model: this.model
                        });
                        this.columnview = new ColumnsView({
                          collection: this.model.columns
                        });
                        this.$('.bk-column-list').append(this.columnview.el);
                        this.$('.bk-crossfilter-configuration').height(this.mget('height'));
                        this.$('.bk-crossfilter-configuration').width(400);
                        return this;
                      };
                
                      return CrossFilterView;
                
                    })(ContinuumView);
                    CrossFilter = (function(_super) {
                      __extends(CrossFilter, _super);
                
                      function CrossFilter() {
                        this._set_columns = __bind(this._set_columns, this);
                        _ref1 = CrossFilter.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CrossFilter.prototype.default_view = CrossFilterView;
                
                      CrossFilter.prototype.type = "CrossFilter";
                
                      CrossFilter.prototype.initialize = function(attrs, options) {
                        CrossFilter.__super__.initialize.call(this, attrs, options);
                        this.columns = new ColumnCollection();
                        this._set_columns();
                        return this.listenTo(this, 'change:columns', this._set_columns);
                      };
                
                      CrossFilter.prototype._set_columns = function() {
                        return this.columns.reset(this.get('columns'));
                      };
                
                      CrossFilter.prototype.defaults = function() {
                        return _.extend({}, CrossFilter.__super__.defaults.call(this), {
                          height: 700,
                          width: 1300
                        });
                      };
                
                      return CrossFilter;
                
                    })(HasParent);
                    CrossFilters = (function(_super) {
                      __extends(CrossFilters, _super);
                
                      function CrossFilters() {
                        _ref2 = CrossFilters.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      CrossFilters.prototype.model = CrossFilter;
                
                      return CrossFilters;
                
                    })(Collection);
                    PlotAttributeSelector = (function(_super) {
                      __extends(PlotAttributeSelector, _super);
                
                      function PlotAttributeSelector() {
                        _ref3 = PlotAttributeSelector.__super__.constructor.apply(this, arguments);
                        return _ref3;
                      }
                
                      PlotAttributeSelector.prototype.initialize = function(options) {
                        PlotAttributeSelector.__super__.initialize.call(this, options);
                        this.listenTo(this.model, "change:plot_selector", _.bind(this.render_selector, 'plot'));
                        this.listenTo(this.model, "change:x_selector", _.bind(this.render_selector, 'x'));
                        this.listenTo(this.model, "change:y_selector", _.bind(this.render_selector, 'y'));
                        this.listenTo(this.model, "change:agg_selector", _.bind(this.render_selector, 'agg'));
                        this.render_selector('plot');
                        this.render_selector('x');
                        this.render_selector('y');
                        return this.render_selector('agg');
                      };
                
                      PlotAttributeSelector.prototype.render_selector = function(selector) {
                        var model, node;
                        node = this.$(".bk-" + selector + "-selector").empty();
                        model = this.mget("" + selector + "_selector");
                        this.plot_selector_view = new model.default_view({
                          model: model
                        });
                        return node.append(this.plot_selector_view.$el);
                      };
                
                      return PlotAttributeSelector;
                
                    })(ContinuumView);
                    ColumnsView = (function(_super) {
                      __extends(ColumnsView, _super);
                
                      function ColumnsView() {
                        _ref4 = ColumnsView.__super__.constructor.apply(this, arguments);
                        return _ref4;
                      }
                
                      ColumnsView.prototype.initialize = function(options) {
                        ColumnsView.__super__.initialize.call(this, options);
                        this.views = {};
                        this.listenTo(this.collection, 'all', this.render);
                        this.render();
                        return this;
                      };
                
                      ColumnsView.prototype.render = function() {
                        var _this = this;
                        _.map(this.views, function(view) {
                          return view.$el.detach();
                        });
                        build_views(this.views, this.collection.models);
                        _.map(this.collection.models, function(model) {
                          return _this.$el.append(_this.views[model.id].$el);
                        });
                        return this;
                      };
                
                      return ColumnsView;
                
                    })(ContinuumView);
                    FacetView = (function(_super) {
                      __extends(FacetView, _super);
                
                      function FacetView() {
                        _ref5 = FacetView.__super__.constructor.apply(this, arguments);
                        return _ref5;
                      }
                
                      FacetView.prototype.events = {
                        "click": "remove"
                      };
                
                      FacetView.prototype.tagName = "span";
                
                      FacetView.prototype.attributes = {
                        "class": "bk-facet-label"
                      };
                
                      FacetView.prototype.initialize = function(options) {
                        FacetView.__super__.initialize.call(this, options);
                        this.name = options.name;
                        return this.render();
                      };
                
                      FacetView.prototype.render = function() {
                        return this.$el.html(crossfilter_facet_template({
                          name: this.name
                        }));
                      };
                
                      return FacetView;
                
                    })(ContinuumView);
                    FacetsView = (function(_super) {
                      __extends(FacetsView, _super);
                
                      function FacetsView() {
                        this.drop_tab = __bind(this.drop_tab, this);
                        this.drop_y = __bind(this.drop_y, this);
                        this.drop_x = __bind(this.drop_x, this);
                        this.drop = __bind(this.drop, this);
                        this.add_facet = __bind(this.add_facet, this);
                        this.remove_facet = __bind(this.remove_facet, this);
                        _ref6 = FacetsView.__super__.constructor.apply(this, arguments);
                        return _ref6;
                      }
                
                      FacetsView.prototype.initialize = function(options) {
                        FacetsView.__super__.initialize.call(this, options);
                        this.render_init();
                        this.render_all_facets();
                        this.listenTo(this.model, 'change:facet_x', this.render_all_facets);
                        this.listenTo(this.model, 'change:facet_y', this.render_all_facets);
                        return this.listenTo(this.model, 'change:facet_tab', this.render_all_facets);
                      };
                
                      FacetsView.prototype.render_init = function() {
                        this.facet_x_node = this.$('.bk-facet-x');
                        this.facet_y_node = this.$('.bk-facet-y');
                        this.facet_tab_node = this.$('.bk-facet-tab');
                        this.facet_x_node.droppable({
                          drop: this.drop_x,
                          tolerance: 'pointer',
                          hoverClass: 'bk-droppable-hover'
                        });
                        this.facet_y_node.droppable({
                          drop: this.drop_y,
                          tolerance: 'pointer',
                          hoverClass: 'bk-droppable-hover'
                        });
                        return this.facet_tab_node.droppable({
                          drop: this.drop_tab,
                          tolerance: 'pointer',
                          hoverClass: 'bk-droppable-hover'
                        });
                      };
                
                      FacetsView.prototype.render_all_facets = function() {
                        this.render_facets(this.facet_x_node, 'facet_x', this.model.get('facet_x'));
                        this.render_facets(this.facet_y_node, 'facet_y', this.model.get('facet_y'));
                        this.render_facets(this.facet_tab_node, 'facet_tab', this.model.get('facet_tab'));
                      };
                
                      FacetsView.prototype.render_facets = function(node, type, facets) {
                        var facet, view, _i, _len, _results;
                        node = node.find('.bk-facets-selections');
                        node.empty();
                        _results = [];
                        for (_i = 0, _len = facets.length; _i < _len; _i++) {
                          facet = facets[_i];
                          view = new FacetView({
                            name: facet
                          });
                          this.listenTo(view, 'remove', function() {
                            var save;
                            return this.remove_facet(facet, save = true);
                          });
                          _results.push(node.append(view.$el));
                        }
                        return _results;
                      };
                
                      FacetsView.prototype.remove_facet = function(facet, save) {
                        var facets, type, x, _i, _len, _ref7;
                        if (save == null) {
                          save = true;
                        }
                        _ref7 = ['facet_x', 'facet_y', 'facet_tab'];
                        for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
                          type = _ref7[_i];
                          facets = _.clone(this.model.get(type));
                          facets = (function() {
                            var _j, _len1, _results;
                            _results = [];
                            for (_j = 0, _len1 = facets.length; _j < _len1; _j++) {
                              x = facets[_j];
                              if (x !== facet) {
                                _results.push(x);
                              }
                            }
                            return _results;
                          })();
                          this.model.set(type, facets);
                        }
                        if (save) {
                          return this.model.save();
                        }
                      };
                
                      FacetsView.prototype.add_facet = function(type, facet) {
                        var facets, save;
                        this.remove_facet(facet, save = false);
                        facets = _.clone(this.model.get(type));
                        if (facets.indexOf(facet) < 0) {
                          facets.push(facet);
                          this.model.set(type, facets);
                        }
                        return this.model.save();
                      };
                
                      FacetsView.prototype.drop = function(type, e, ui) {
                        var column_model, name;
                        column_model = ui.helper.data('model');
                        name = column_model.get('name');
                        return this.add_facet(type, name);
                      };
                
                      FacetsView.prototype.drop_x = function(e, ui) {
                        return this.drop('facet_x', e, ui);
                      };
                
                      FacetsView.prototype.drop_y = function(e, ui) {
                        return this.drop('facet_y', e, ui);
                      };
                
                      FacetsView.prototype.drop_tab = function(e, ui) {
                        return this.drop('facet_tab', e, ui);
                      };
                
                      return FacetsView;
                
                    })(ContinuumView);
                    FilterView = (function(_super) {
                      __extends(FilterView, _super);
                
                      function FilterView() {
                        this.drop = __bind(this.drop, this);
                        _ref7 = FilterView.__super__.constructor.apply(this, arguments);
                        return _ref7;
                      }
                
                      FilterView.prototype.initialize = function(options) {
                        FilterView.__super__.initialize.call(this, options);
                        this.views = {};
                        this.render();
                        this.render_columns_selectors;
                        return this.listenTo(this.model, 'change:filter_widgets', this.render_column_selectors);
                      };
                
                      FilterView.prototype.drop = function(e, ui) {
                        var column_model, filtering_columns;
                        column_model = ui.helper.data('model');
                        filtering_columns = _.clone(this.model.get('filtering_columns'));
                        filtering_columns.push(column_model.get('name'));
                        this.model.set('filtering_columns', filtering_columns);
                        return this.model.save();
                      };
                
                      FilterView.prototype.render = function() {
                        return this.$el.droppable({
                          drop: this.drop,
                          tolerance: 'pointer',
                          hoverClass: 'bk-droppable-hover'
                        });
                      };
                
                      FilterView.prototype.render_column_selectors = function() {
                        var col, filter_widget_dict, filter_widgets, filtering_columns, key, newviews, val, _ref8,
                          _this = this;
                        _.map(this.views, function(view) {
                          return view.$el.detach();
                        });
                        this.$el.find('.bk-filters-selections').empty();
                        filter_widget_dict = {};
                        _ref8 = this.mget('filter_widgets');
                        for (key in _ref8) {
                          if (!__hasProp.call(_ref8, key)) continue;
                          val = _ref8[key];
                          filter_widget_dict[key] = this.model.resolve_ref(val);
                        }
                        filtering_columns = this.mget('filtering_columns');
                        filter_widgets = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = filtering_columns.length; _i < _len; _i++) {
                            col = filtering_columns[_i];
                            if (filter_widget_dict[col] != null) {
                              _results.push(filter_widget_dict[col]);
                            }
                          }
                          return _results;
                        })();
                        newviews = build_views(this.views, filter_widgets);
                        _.map(newviews, function(view) {
                          return _this.listenTo(view, 'remove', _this.child_remove);
                        });
                        return _.map(filter_widgets, function(model) {
                          var wrapper;
                          wrapper = new CloseWrapper.View({
                            view: _this.views[model.id]
                          });
                          return _this.$el.find('.bk-filters-selections').append(wrapper.$el);
                        });
                      };
                
                      FilterView.prototype.child_remove = function(view) {
                        var key, model, newcolumns, to_remove, val, _ref8;
                        _ref8 = this.mget('filter_widgets');
                        for (key in _ref8) {
                          if (!__hasProp.call(_ref8, key)) continue;
                          val = _ref8[key];
                          model = this.model.resolve_ref(val);
                          if (model === view.model) {
                            to_remove = key;
                            break;
                          }
                        }
                        newcolumns = _.filter(this.mget('filtering_columns'), function(x) {
                          return x !== to_remove;
                        });
                        this.mset('filtering_columns', newcolumns);
                        return this.model.save();
                      };
                
                      return FilterView;
                
                    })(ContinuumView);
                    ColumnView = (function(_super) {
                      __extends(ColumnView, _super);
                
                      function ColumnView() {
                        _ref8 = ColumnView.__super__.constructor.apply(this, arguments);
                        return _ref8;
                      }
                
                      ColumnView.prototype.template = crossfilter_column_template;
                
                      ColumnView.prototype.attributes = {
                        "class": "bk-crossfilter-column-entry bk-bs-panel bk-bs-panel-primary"
                      };
                
                      ColumnView.prototype.initialize = function(options) {
                        ColumnView.__super__.initialize.call(this, options);
                        return this.render();
                      };
                
                      ColumnView.prototype.render = function() {
                        var _this = this;
                        this.$el.html(this.template(this.model.attributes));
                        this.$el.draggable({
                          appendTo: 'body',
                          containment: 'document',
                          helper: 'clone',
                          start: function(e, ui) {
                            return ui.helper.data('model', _this.model);
                          }
                        });
                        return this;
                      };
                
                      return ColumnView;
                
                    })(ContinuumView);
                    TimeColumnView = (function(_super) {
                      __extends(TimeColumnView, _super);
                
                      function TimeColumnView() {
                        _ref9 = TimeColumnView.__super__.constructor.apply(this, arguments);
                        return _ref9;
                      }
                
                      return TimeColumnView;
                
                    })(ColumnView);
                    TimeColumn = (function(_super) {
                      __extends(TimeColumn, _super);
                
                      function TimeColumn() {
                        _ref10 = TimeColumn.__super__.constructor.apply(this, arguments);
                        return _ref10;
                      }
                
                      TimeColumn.prototype.default_view = TimeColumnView;
                
                      TimeColumn.prototype.defaults = function() {
                        return _.extend({}, TimeColumn.__super__.defaults.call(this), {
                          type: "TimeColumn",
                          label: "Time",
                          name: "",
                          fields: ['count', 'unique', 'first', 'last'],
                          count: 0,
                          unique: 0,
                          first: 0,
                          last: 0
                        });
                      };
                
                      return TimeColumn;
                
                    })(HasProperties);
                    DiscreteColumnView = (function(_super) {
                      __extends(DiscreteColumnView, _super);
                
                      function DiscreteColumnView() {
                        _ref11 = DiscreteColumnView.__super__.constructor.apply(this, arguments);
                        return _ref11;
                      }
                
                      return DiscreteColumnView;
                
                    })(ColumnView);
                    DiscreteColumn = (function(_super) {
                      __extends(DiscreteColumn, _super);
                
                      function DiscreteColumn() {
                        _ref12 = DiscreteColumn.__super__.constructor.apply(this, arguments);
                        return _ref12;
                      }
                
                      DiscreteColumn.prototype.default_view = DiscreteColumnView;
                
                      DiscreteColumn.prototype.defaults = function() {
                        return _.extend({}, DiscreteColumn.__super__.defaults.call(this), {
                          type: "DiscreteColumn",
                          label: "Factor",
                          name: "",
                          fields: ['count', 'unique', 'top', 'freq'],
                          count: 0,
                          unique: 0,
                          top: 0,
                          freq: 0
                        });
                      };
                
                      return DiscreteColumn;
                
                    })(HasProperties);
                    ContinuousColumnView = (function(_super) {
                      __extends(ContinuousColumnView, _super);
                
                      function ContinuousColumnView() {
                        _ref13 = ContinuousColumnView.__super__.constructor.apply(this, arguments);
                        return _ref13;
                      }
                
                      return ContinuousColumnView;
                
                    })(ColumnView);
                    ContinuousColumn = (function(_super) {
                      __extends(ContinuousColumn, _super);
                
                      function ContinuousColumn() {
                        _ref14 = ContinuousColumn.__super__.constructor.apply(this, arguments);
                        return _ref14;
                      }
                
                      ContinuousColumn.prototype.default_view = ContinuousColumnView;
                
                      ContinuousColumn.prototype.defaults = function() {
                        return _.extend({}, ContinuousColumn.__super__.defaults.call(this), {
                          type: "ContinuousColumn",
                          label: "Continuous",
                          name: "",
                          fields: ['count', 'mean', 'std', 'min', 'max'],
                          count: 0,
                          mean: 0,
                          std: 0,
                          min: 0,
                          max: 0
                        });
                      };
                
                      return ContinuousColumn;
                
                    })(HasProperties);
                    column_types = {
                      'DiscreteColumn': DiscreteColumn,
                      'TimeColumn': TimeColumn,
                      'ContinuousColumn': ContinuousColumn
                    };
                    ColumnCollection = (function(_super) {
                      __extends(ColumnCollection, _super);
                
                      function ColumnCollection() {
                        _ref15 = ColumnCollection.__super__.constructor.apply(this, arguments);
                        return _ref15;
                      }
                
                      ColumnCollection.prototype.model = function(attrs, options) {
                        if (attrs.type in column_types) {
                          return new column_types[attrs.type](attrs);
                        }
                        console.log("Unknown column type: '" + attrs.type + "'");
                        return null;
                      };
                
                      return ColumnCollection;
                
                    })(Collection);
                    return {
                      Model: CrossFilter,
                      Collection: new CrossFilters(),
                      View: CrossFilterView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=crossfilter.js.map
                */;
                define('widget/multiselecttemplate',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      var option, _i, _len, _ref;
                    
                      _print(_safe('<label for="'));
                    
                      _print(this.id);
                    
                      _print(_safe('"> '));
                    
                      _print(this.title);
                    
                      _print(_safe(' </label>\n<select multiple class="bk-widget-form-input" id="'));
                    
                      _print(this.id);
                    
                      _print(_safe('" name="'));
                    
                      _print(this.name);
                    
                      _print(_safe('">\n  '));
                    
                      _ref = this.options;
                      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        option = _ref[_i];
                        _print(_safe('\n  '));
                        if (option.value === this.value) {
                          _print(_safe('\n  <option selected="selected" value="'));
                          _print(option.value);
                          _print(_safe('">'));
                          _print(option.name);
                          _print(_safe('</option>\n  '));
                        } else {
                          _print(_safe('\n  <option value="'));
                          _print(option.value);
                          _print(_safe('">'));
                          _print(option.name);
                          _print(_safe('</option> \n  '));
                        }
                        _print(_safe('\n\n  '));
                      }
                    
                      _print(_safe('\n</select>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/multiselect',["common/has_parent", "common/continuum_view", "common/collection", "underscore", "./multiselecttemplate"], function(HasParent, ContinuumView, Collection, _, multiselecttemplate) {
                    var MultiSelect, MultiSelectView, MultiSelects, multiselectboxes, _ref, _ref1, _ref2;
                    MultiSelectView = (function(_super) {
                      __extends(MultiSelectView, _super);
                
                      function MultiSelectView() {
                        _ref = MultiSelectView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      MultiSelectView.prototype.events = {
                        "change select": "change_input"
                      };
                
                      MultiSelectView.prototype.change_input = function() {
                        this.mset('value', this.$('select').val(), {
                          'silent': true
                        });
                        return this.model.save();
                      };
                
                      MultiSelectView.prototype.tagName = "div";
                
                      MultiSelectView.prototype.template = multiselecttemplate;
                
                      MultiSelectView.prototype.initialize = function(options) {
                        MultiSelectView.__super__.initialize.call(this, options);
                        this.render();
                        this.listenTo(this.model, 'change:value', this.render_selection);
                        this.listenTo(this.model, 'change:options', this.render);
                        this.listenTo(this.model, 'change:name', this.render);
                        return this.listenTo(this.model, 'change:title', this.render);
                      };
                
                      MultiSelectView.prototype.render = function() {
                        var html;
                        this.$el.empty();
                        html = this.template(this.model.attributes);
                        this.$el.html(html);
                        this.render_selection();
                        return this;
                      };
                
                      MultiSelectView.prototype.render_selection = function() {
                        var values;
                        values = {};
                        _.map(this.mget('value'), function(x) {
                          return values[x] = true;
                        });
                        return this.$('option').each(function(el) {
                          el = $(el);
                          if (values[el.attr('value')]) {
                            return el.attr('selected', 'selected');
                          }
                        });
                      };
                
                      return MultiSelectView;
                
                    })(ContinuumView);
                    MultiSelect = (function(_super) {
                      __extends(MultiSelect, _super);
                
                      function MultiSelect() {
                        _ref1 = MultiSelect.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      MultiSelect.prototype.type = "MultiSelect";
                
                      MultiSelect.prototype.default_view = MultiSelectView;
                
                      MultiSelect.prototype.defaults = function() {
                        return _.extend({}, MultiSelect.__super__.defaults.call(this), {
                          title: '',
                          value: [],
                          options: []
                        });
                      };
                
                      return MultiSelect;
                
                    })(HasParent);
                    MultiSelects = (function(_super) {
                      __extends(MultiSelects, _super);
                
                      function MultiSelects() {
                        _ref2 = MultiSelects.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      MultiSelects.prototype.model = MultiSelect;
                
                      return MultiSelects;
                
                    })(Collection);
                    multiselectboxes = new MultiSelects();
                    return {
                      "Model": MultiSelect,
                      "Collection": multiselectboxes,
                      "View": MultiSelectView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=multiselect.js.map
                */;
                (function(root) {
                define("jqrangeslider", ["jquery_ui/core","jquery_ui/widget","jquery_ui/mouse","jquery_mousewheel"], function() {
                  return (function() {
                /*! jQRangeSlider 5.7.0 - 2014-03-18 - Copyright (C) Guillaume Gautreau 2012 - MIT and GPLv3 licenses.*/!function(a){a.widget("ui.rangeSliderMouseTouch",a.ui.mouse,{enabled:!0,_mouseInit:function(){var b=this;a.ui.mouse.prototype._mouseInit.apply(this),this._mouseDownEvent=!1,this.element.bind("touchstart."+this.widgetName,function(a){return b._touchStart(a)})},_mouseDestroy:function(){a(document).unbind("touchmove."+this.widgetName,this._touchMoveDelegate).unbind("touchend."+this.widgetName,this._touchEndDelegate),a.ui.mouse.prototype._mouseDestroy.apply(this)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},destroy:function(){this._mouseDestroy(),a.ui.mouse.prototype.destroy.apply(this),this._mouseInit=null},_touchStart:function(b){if(!this.enabled)return!1;b.which=1,b.preventDefault(),this._fillTouchEvent(b);var c=this,d=this._mouseDownEvent;this._mouseDown(b),d!==this._mouseDownEvent&&(this._touchEndDelegate=function(a){c._touchEnd(a)},this._touchMoveDelegate=function(a){c._touchMove(a)},a(document).bind("touchmove."+this.widgetName,this._touchMoveDelegate).bind("touchend."+this.widgetName,this._touchEndDelegate))},_mouseDown:function(b){return this.enabled?a.ui.mouse.prototype._mouseDown.apply(this,[b]):!1},_touchEnd:function(b){this._fillTouchEvent(b),this._mouseUp(b),a(document).unbind("touchmove."+this.widgetName,this._touchMoveDelegate).unbind("touchend."+this.widgetName,this._touchEndDelegate),this._mouseDownEvent=!1,a(document).trigger("mouseup")},_touchMove:function(a){return a.preventDefault(),this._fillTouchEvent(a),this._mouseMove(a)},_fillTouchEvent:function(a){var b;b="undefined"==typeof a.targetTouches&&"undefined"==typeof a.changedTouches?a.originalEvent.targetTouches[0]||a.originalEvent.changedTouches[0]:a.targetTouches[0]||a.changedTouches[0],a.pageX=b.pageX,a.pageY=b.pageY}})}(jQuery),function(a){a.widget("ui.rangeSliderDraggable",a.ui.rangeSliderMouseTouch,{cache:null,options:{containment:null},_create:function(){a.ui.rangeSliderMouseTouch.prototype._create.apply(this),setTimeout(a.proxy(this._initElementIfNotDestroyed,this),10)},destroy:function(){this.cache=null,a.ui.rangeSliderMouseTouch.prototype.destroy.apply(this)},_initElementIfNotDestroyed:function(){this._mouseInit&&this._initElement()},_initElement:function(){this._mouseInit(),this._cache()},_setOption:function(b,c){"containment"===b&&(this.options.containment=null===c||0===a(c).length?null:a(c))},_mouseStart:function(a){return this._cache(),this.cache.click={left:a.pageX,top:a.pageY},this.cache.initialOffset=this.element.offset(),this._triggerMouseEvent("mousestart"),!0},_mouseDrag:function(a){var b=a.pageX-this.cache.click.left;return b=this._constraintPosition(b+this.cache.initialOffset.left),this._applyPosition(b),this._triggerMouseEvent("sliderDrag"),!1},_mouseStop:function(){this._triggerMouseEvent("stop")},_constraintPosition:function(a){return 0!==this.element.parent().length&&null!==this.cache.parent.offset&&(a=Math.min(a,this.cache.parent.offset.left+this.cache.parent.width-this.cache.width.outer),a=Math.max(a,this.cache.parent.offset.left)),a},_applyPosition:function(a){var b={top:this.cache.offset.top,left:a};this.element.offset({left:a}),this.cache.offset=b},_cacheIfNecessary:function(){null===this.cache&&this._cache()},_cache:function(){this.cache={},this._cacheMargins(),this._cacheParent(),this._cacheDimensions(),this.cache.offset=this.element.offset()},_cacheMargins:function(){this.cache.margin={left:this._parsePixels(this.element,"marginLeft"),right:this._parsePixels(this.element,"marginRight"),top:this._parsePixels(this.element,"marginTop"),bottom:this._parsePixels(this.element,"marginBottom")}},_cacheParent:function(){if(null!==this.options.parent){var a=this.element.parent();this.cache.parent={offset:a.offset(),width:a.width()}}else this.cache.parent=null},_cacheDimensions:function(){this.cache.width={outer:this.element.outerWidth(),inner:this.element.width()}},_parsePixels:function(a,b){return parseInt(a.css(b),10)||0},_triggerMouseEvent:function(a){var b=this._prepareEventData();this.element.trigger(a,b)},_prepareEventData:function(){return{element:this.element,offset:this.cache.offset||null}}})}(jQuery),function(a,b){a.widget("ui.rangeSlider",{options:{bounds:{min:0,max:100},defaultValues:{min:20,max:50},wheelMode:null,wheelSpeed:4,arrows:!0,valueLabels:"show",formatter:null,durationIn:0,durationOut:400,delayOut:200,range:{min:!1,max:!1},step:!1,scales:!1,enabled:!0,symmetricPositionning:!1},_values:null,_valuesChanged:!1,_initialized:!1,bar:null,leftHandle:null,rightHandle:null,innerBar:null,container:null,arrows:null,labels:null,changing:{min:!1,max:!1},changed:{min:!1,max:!1},ruler:null,_create:function(){this._setDefaultValues(),this.labels={left:null,right:null,leftDisplayed:!0,rightDisplayed:!0},this.arrows={left:null,right:null},this.changing={min:!1,max:!1},this.changed={min:!1,max:!1},this._createElements(),this._bindResize(),setTimeout(a.proxy(this.resize,this),1),setTimeout(a.proxy(this._initValues,this),1)},_setDefaultValues:function(){this._values={min:this.options.defaultValues.min,max:this.options.defaultValues.max}},_bindResize:function(){var b=this;this._resizeProxy=function(a){b.resize(a)},a(window).resize(this._resizeProxy)},_initWidth:function(){this.container.css("width",this.element.width()-this.container.outerWidth(!0)+this.container.width()),this.innerBar.css("width",this.container.width()-this.innerBar.outerWidth(!0)+this.innerBar.width())},_initValues:function(){this._initialized=!0,this.values(this._values.min,this._values.max)},_setOption:function(a,b){this._setWheelOption(a,b),this._setArrowsOption(a,b),this._setLabelsOption(a,b),this._setLabelsDurations(a,b),this._setFormatterOption(a,b),this._setBoundsOption(a,b),this._setRangeOption(a,b),this._setStepOption(a,b),this._setScalesOption(a,b),this._setEnabledOption(a,b),this._setPositionningOption(a,b)},_validProperty:function(a,b,c){return null===a||"undefined"==typeof a[b]?c:a[b]},_setStepOption:function(a,b){"step"===a&&(this.options.step=b,this._leftHandle("option","step",b),this._rightHandle("option","step",b),this._changed(!0))},_setScalesOption:function(a,b){"scales"===a&&(b===!1||null===b?(this.options.scales=!1,this._destroyRuler()):b instanceof Array&&(this.options.scales=b,this._updateRuler()))},_setRangeOption:function(a,b){"range"===a&&(this._bar("option","range",b),this.options.range=this._bar("option","range"),this._changed(!0))},_setBoundsOption:function(a,b){"bounds"===a&&"undefined"!=typeof b.min&&"undefined"!=typeof b.max&&this.bounds(b.min,b.max)},_setWheelOption:function(a,b){("wheelMode"===a||"wheelSpeed"===a)&&(this._bar("option",a,b),this.options[a]=this._bar("option",a))},_setLabelsOption:function(a,b){if("valueLabels"===a){if("hide"!==b&&"show"!==b&&"change"!==b)return;this.options.valueLabels=b,"hide"!==b?(this._createLabels(),this._leftLabel("update"),this._rightLabel("update")):this._destroyLabels()}},_setFormatterOption:function(a,b){"formatter"===a&&null!==b&&"function"==typeof b&&"hide"!==this.options.valueLabels&&(this._leftLabel("option","formatter",b),this.options.formatter=this._rightLabel("option","formatter",b))},_setArrowsOption:function(a,b){"arrows"!==a||b!==!0&&b!==!1||b===this.options.arrows||(b===!0?(this.element.removeClass("ui-rangeSlider-noArrow").addClass("ui-rangeSlider-withArrows"),this.arrows.left.css("display","block"),this.arrows.right.css("display","block"),this.options.arrows=!0):b===!1&&(this.element.addClass("ui-rangeSlider-noArrow").removeClass("ui-rangeSlider-withArrows"),this.arrows.left.css("display","none"),this.arrows.right.css("display","none"),this.options.arrows=!1),this._initWidth())},_setLabelsDurations:function(a,b){if("durationIn"===a||"durationOut"===a||"delayOut"===a){if(parseInt(b,10)!==b)return;null!==this.labels.left&&this._leftLabel("option",a,b),null!==this.labels.right&&this._rightLabel("option",a,b),this.options[a]=b}},_setEnabledOption:function(a,b){"enabled"===a&&this.toggle(b)},_setPositionningOption:function(a,b){"symmetricPositionning"===a&&(this._rightHandle("option",a,b),this.options[a]=this._leftHandle("option",a,b))},_createElements:function(){"absolute"!==this.element.css("position")&&this.element.css("position","relative"),this.element.addClass("ui-rangeSlider"),this.container=a("<div class='ui-rangeSlider-container' />").css("position","absolute").appendTo(this.element),this.innerBar=a("<div class='ui-rangeSlider-innerBar' />").css("position","absolute").css("top",0).css("left",0),this._createHandles(),this._createBar(),this.container.prepend(this.innerBar),this._createArrows(),"hide"!==this.options.valueLabels?this._createLabels():this._destroyLabels(),this._updateRuler(),this.options.enabled||this._toggle(this.options.enabled)},_createHandle:function(b){return a("<div />")[this._handleType()](b).bind("sliderDrag",a.proxy(this._changing,this)).bind("stop",a.proxy(this._changed,this))},_createHandles:function(){this.leftHandle=this._createHandle({isLeft:!0,bounds:this.options.bounds,value:this._values.min,step:this.options.step,symmetricPositionning:this.options.symmetricPositionning}).appendTo(this.container),this.rightHandle=this._createHandle({isLeft:!1,bounds:this.options.bounds,value:this._values.max,step:this.options.step,symmetricPositionning:this.options.symmetricPositionning}).appendTo(this.container)},_createBar:function(){this.bar=a("<div />").prependTo(this.container).bind("sliderDrag scroll zoom",a.proxy(this._changing,this)).bind("stop",a.proxy(this._changed,this)),this._bar({leftHandle:this.leftHandle,rightHandle:this.rightHandle,values:{min:this._values.min,max:this._values.max},type:this._handleType(),range:this.options.range,wheelMode:this.options.wheelMode,wheelSpeed:this.options.wheelSpeed}),this.options.range=this._bar("option","range"),this.options.wheelMode=this._bar("option","wheelMode"),this.options.wheelSpeed=this._bar("option","wheelSpeed")},_createArrows:function(){this.arrows.left=this._createArrow("left"),this.arrows.right=this._createArrow("right"),this.options.arrows?this.element.addClass("ui-rangeSlider-withArrows"):(this.arrows.left.css("display","none"),this.arrows.right.css("display","none"),this.element.addClass("ui-rangeSlider-noArrow"))},_createArrow:function(b){var c,d=a("<div class='ui-rangeSlider-arrow' />").append("<div class='ui-rangeSlider-arrow-inner' />").addClass("ui-rangeSlider-"+b+"Arrow").css("position","absolute").css(b,0).appendTo(this.element);return c="right"===b?a.proxy(this._scrollRightClick,this):a.proxy(this._scrollLeftClick,this),d.bind("mousedown touchstart",c),d},_proxy:function(a,b,c){var d=Array.prototype.slice.call(c);return a&&a[b]?a[b].apply(a,d):null},_handleType:function(){return"rangeSliderHandle"},_barType:function(){return"rangeSliderBar"},_bar:function(){return this._proxy(this.bar,this._barType(),arguments)},_labelType:function(){return"rangeSliderLabel"},_leftLabel:function(){return this._proxy(this.labels.left,this._labelType(),arguments)},_rightLabel:function(){return this._proxy(this.labels.right,this._labelType(),arguments)},_leftHandle:function(){return this._proxy(this.leftHandle,this._handleType(),arguments)},_rightHandle:function(){return this._proxy(this.rightHandle,this._handleType(),arguments)},_getValue:function(a,b){return b===this.rightHandle&&(a-=b.outerWidth()),a*(this.options.bounds.max-this.options.bounds.min)/(this.container.innerWidth()-b.outerWidth(!0))+this.options.bounds.min},_trigger:function(a){var b=this;setTimeout(function(){b.element.trigger(a,{label:b.element,values:b.values()})},1)},_changing:function(){this._updateValues()&&(this._trigger("valuesChanging"),this._valuesChanged=!0)},_deactivateLabels:function(){"change"===this.options.valueLabels&&(this._leftLabel("option","show","hide"),this._rightLabel("option","show","hide"))},_reactivateLabels:function(){"change"===this.options.valueLabels&&(this._leftLabel("option","show","change"),this._rightLabel("option","show","change"))},_changed:function(a){a===!0&&this._deactivateLabels(),(this._updateValues()||this._valuesChanged)&&(this._trigger("valuesChanged"),a!==!0&&this._trigger("userValuesChanged"),this._valuesChanged=!1),a===!0&&this._reactivateLabels()},_updateValues:function(){var a=this._leftHandle("value"),b=this._rightHandle("value"),c=this._min(a,b),d=this._max(a,b),e=c!==this._values.min||d!==this._values.max;return this._values.min=this._min(a,b),this._values.max=this._max(a,b),e},_min:function(a,b){return Math.min(a,b)},_max:function(a,b){return Math.max(a,b)},_createLabel:function(b,c){var d;return null===b?(d=this._getLabelConstructorParameters(b,c),b=a("<div />").appendTo(this.element)[this._labelType()](d)):(d=this._getLabelRefreshParameters(b,c),b[this._labelType()](d)),b},_getLabelConstructorParameters:function(a,b){return{handle:b,handleType:this._handleType(),formatter:this._getFormatter(),show:this.options.valueLabels,durationIn:this.options.durationIn,durationOut:this.options.durationOut,delayOut:this.options.delayOut}},_getLabelRefreshParameters:function(){return{formatter:this._getFormatter(),show:this.options.valueLabels,durationIn:this.options.durationIn,durationOut:this.options.durationOut,delayOut:this.options.delayOut}},_getFormatter:function(){return this.options.formatter===!1||null===this.options.formatter?this._defaultFormatter:this.options.formatter},_defaultFormatter:function(a){return Math.round(a)},_destroyLabel:function(a){return null!==a&&(a[this._labelType()]("destroy"),a.remove(),a=null),a},_createLabels:function(){this.labels.left=this._createLabel(this.labels.left,this.leftHandle),this.labels.right=this._createLabel(this.labels.right,this.rightHandle),this._leftLabel("pair",this.labels.right)},_destroyLabels:function(){this.labels.left=this._destroyLabel(this.labels.left),this.labels.right=this._destroyLabel(this.labels.right)},_stepRatio:function(){return this._leftHandle("stepRatio")},_scrollRightClick:function(a){return this.options.enabled?(a.preventDefault(),this._bar("startScroll"),this._bindStopScroll(),this._continueScrolling("scrollRight",4*this._stepRatio(),1),void 0):!1},_continueScrolling:function(a,b,c,d){if(!this.options.enabled)return!1;this._bar(a,c),d=d||5,d--;var e=this,f=16,g=Math.max(1,4/this._stepRatio());this._scrollTimeout=setTimeout(function(){0===d&&(b>f?b=Math.max(f,b/1.5):c=Math.min(g,2*c),d=5),e._continueScrolling(a,b,c,d)},b)},_scrollLeftClick:function(a){return this.options.enabled?(a.preventDefault(),this._bar("startScroll"),this._bindStopScroll(),this._continueScrolling("scrollLeft",4*this._stepRatio(),1),void 0):!1},_bindStopScroll:function(){var b=this;this._stopScrollHandle=function(a){a.preventDefault(),b._stopScroll()},a(document).bind("mouseup touchend",this._stopScrollHandle)},_stopScroll:function(){a(document).unbind("mouseup touchend",this._stopScrollHandle),this._stopScrollHandle=null,this._bar("stopScroll"),clearTimeout(this._scrollTimeout)},_createRuler:function(){this.ruler=a("<div class='ui-rangeSlider-ruler' />").appendTo(this.innerBar)},_setRulerParameters:function(){this.ruler.ruler({min:this.options.bounds.min,max:this.options.bounds.max,scales:this.options.scales})},_destroyRuler:function(){null!==this.ruler&&a.fn.ruler&&(this.ruler.ruler("destroy"),this.ruler.remove(),this.ruler=null)},_updateRuler:function(){this._destroyRuler(),this.options.scales!==!1&&a.fn.ruler&&(this._createRuler(),this._setRulerParameters())},values:function(a,b){var c;if("undefined"!=typeof a&&"undefined"!=typeof b){if(!this._initialized)return this._values.min=a,this._values.max=b,this._values;this._deactivateLabels(),c=this._bar("values",a,b),this._changed(!0),this._reactivateLabels()}else c=this._bar("values",a,b);return c},min:function(a){return this._values.min=this.values(a,this._values.max).min,this._values.min},max:function(a){return this._values.max=this.values(this._values.min,a).max,this._values.max},bounds:function(a,b){return this._isValidValue(a)&&this._isValidValue(b)&&b>a&&(this._setBounds(a,b),this._updateRuler(),this._changed(!0)),this.options.bounds},_isValidValue:function(a){return"undefined"!=typeof a&&parseFloat(a)===a},_setBounds:function(a,b){this.options.bounds={min:a,max:b},this._leftHandle("option","bounds",this.options.bounds),this._rightHandle("option","bounds",this.options.bounds),this._bar("option","bounds",this.options.bounds)},zoomIn:function(a){this._bar("zoomIn",a)},zoomOut:function(a){this._bar("zoomOut",a)},scrollLeft:function(a){this._bar("startScroll"),this._bar("scrollLeft",a),this._bar("stopScroll")},scrollRight:function(a){this._bar("startScroll"),this._bar("scrollRight",a),this._bar("stopScroll")},resize:function(){this._initWidth(),this._leftHandle("update"),this._rightHandle("update"),this._bar("update")},enable:function(){this.toggle(!0)},disable:function(){this.toggle(!1)},toggle:function(a){a===b&&(a=!this.options.enabled),this.options.enabled!==a&&this._toggle(a)},_toggle:function(a){this.options.enabled=a,this.element.toggleClass("ui-rangeSlider-disabled",!a);var b=a?"enable":"disable";this._bar(b),this._leftHandle(b),this._rightHandle(b),this._leftLabel(b),this._rightLabel(b)},destroy:function(){this.element.removeClass("ui-rangeSlider-withArrows ui-rangeSlider-noArrow ui-rangeSlider-disabled"),this._destroyWidgets(),this._destroyElements(),this.element.removeClass("ui-rangeSlider"),this.options=null,a(window).unbind("resize",this._resizeProxy),this._resizeProxy=null,this._bindResize=null,a.Widget.prototype.destroy.apply(this,arguments)},_destroyWidget:function(a){this["_"+a]("destroy"),this[a].remove(),this[a]=null},_destroyWidgets:function(){this._destroyWidget("bar"),this._destroyWidget("leftHandle"),this._destroyWidget("rightHandle"),this._destroyRuler(),this._destroyLabels()},_destroyElements:function(){this.container.remove(),this.container=null,this.innerBar.remove(),this.innerBar=null,this.arrows.left.remove(),this.arrows.right.remove(),this.arrows=null}})}(jQuery),function(a){a.widget("ui.rangeSliderHandle",a.ui.rangeSliderDraggable,{currentMove:null,margin:0,parentElement:null,options:{isLeft:!0,bounds:{min:0,max:100},range:!1,value:0,step:!1},_value:0,_left:0,_create:function(){a.ui.rangeSliderDraggable.prototype._create.apply(this),this.element.css("position","absolute").css("top",0).addClass("ui-rangeSlider-handle").toggleClass("ui-rangeSlider-leftHandle",this.options.isLeft).toggleClass("ui-rangeSlider-rightHandle",!this.options.isLeft),this.element.append("<div class='ui-rangeSlider-handle-inner' />"),this._value=this._constraintValue(this.options.value)},destroy:function(){this.element.empty(),a.ui.rangeSliderDraggable.prototype.destroy.apply(this)},_setOption:function(b,c){"isLeft"!==b||c!==!0&&c!==!1||c===this.options.isLeft?"step"===b&&this._checkStep(c)?(this.options.step=c,this.update()):"bounds"===b?(this.options.bounds=c,this.update()):"range"===b&&this._checkRange(c)?(this.options.range=c,this.update()):"symmetricPositionning"===b&&(this.options.symmetricPositionning=c===!0,this.update()):(this.options.isLeft=c,this.element.toggleClass("ui-rangeSlider-leftHandle",this.options.isLeft).toggleClass("ui-rangeSlider-rightHandle",!this.options.isLeft),this._position(this._value),this.element.trigger("switch",this.options.isLeft)),a.ui.rangeSliderDraggable.prototype._setOption.apply(this,[b,c])},_checkRange:function(a){return a===!1||!this._isValidValue(a.min)&&!this._isValidValue(a.max)},_isValidValue:function(a){return"undefined"!=typeof a&&a!==!1&&parseFloat(a)!==a},_checkStep:function(a){return a===!1||parseFloat(a)===a},_initElement:function(){a.ui.rangeSliderDraggable.prototype._initElement.apply(this),0===this.cache.parent.width||null===this.cache.parent.width?setTimeout(a.proxy(this._initElementIfNotDestroyed,this),500):(this._position(this._value),this._triggerMouseEvent("initialize"))},_bounds:function(){return this.options.bounds},_cache:function(){a.ui.rangeSliderDraggable.prototype._cache.apply(this),this._cacheParent()},_cacheParent:function(){var a=this.element.parent();this.cache.parent={element:a,offset:a.offset(),padding:{left:this._parsePixels(a,"paddingLeft")},width:a.width()}},_position:function(a){var b=this._getPositionForValue(a);this._applyPosition(b)},_constraintPosition:function(a){var b=this._getValueForPosition(a);return this._getPositionForValue(b)},_applyPosition:function(b){a.ui.rangeSliderDraggable.prototype._applyPosition.apply(this,[b]),this._left=b,this._setValue(this._getValueForPosition(b)),this._triggerMouseEvent("moving")},_prepareEventData:function(){var b=a.ui.rangeSliderDraggable.prototype._prepareEventData.apply(this);return b.value=this._value,b},_setValue:function(a){a!==this._value&&(this._value=a)},_constraintValue:function(a){if(a=Math.min(a,this._bounds().max),a=Math.max(a,this._bounds().min),a=this._round(a),this.options.range!==!1){var b=this.options.range.min||!1,c=this.options.range.max||!1;b!==!1&&(a=Math.max(a,this._round(b))),c!==!1&&(a=Math.min(a,this._round(c))),a=Math.min(a,this._bounds().max),a=Math.max(a,this._bounds().min)}return a},_round:function(a){return this.options.step!==!1&&this.options.step>0?Math.round(a/this.options.step)*this.options.step:a},_getPositionForValue:function(a){if(!this.cache||!this.cache.parent||null===this.cache.parent.offset)return 0;a=this._constraintValue(a);var b=(a-this.options.bounds.min)/(this.options.bounds.max-this.options.bounds.min),c=this.cache.parent.width,d=this.cache.parent.offset.left,e=this.options.isLeft?0:this.cache.width.outer;return this.options.symmetricPositionning?b*(c-2*this.cache.width.outer)+d+e:b*c+d-e},_getValueForPosition:function(a){var b=this._getRawValueForPositionAndBounds(a,this.options.bounds.min,this.options.bounds.max);return this._constraintValue(b)},_getRawValueForPositionAndBounds:function(a,b,c){var d,e,f=null===this.cache.parent.offset?0:this.cache.parent.offset.left;return this.options.symmetricPositionning?(a-=this.options.isLeft?0:this.cache.width.outer,d=this.cache.parent.width-2*this.cache.width.outer):(a+=this.options.isLeft?0:this.cache.width.outer,d=this.cache.parent.width),0===d?this._value:(e=(a-f)/d,e*(c-b)+b)},value:function(a){return"undefined"!=typeof a&&(this._cache(),a=this._constraintValue(a),this._position(a)),this._value},update:function(){this._cache();var a=this._constraintValue(this._value),b=this._getPositionForValue(a);a!==this._value?(this._triggerMouseEvent("updating"),this._position(a),this._triggerMouseEvent("update")):b!==this.cache.offset.left&&(this._triggerMouseEvent("updating"),this._position(a),this._triggerMouseEvent("update"))},position:function(a){return"undefined"!=typeof a&&(this._cache(),a=this._constraintPosition(a),this._applyPosition(a)),this._left},add:function(a,b){return a+b},substract:function(a,b){return a-b},stepsBetween:function(a,b){return this.options.step===!1?b-a:(b-a)/this.options.step},multiplyStep:function(a,b){return a*b},moveRight:function(a){var b;return this.options.step===!1?(b=this._left,this.position(this._left+a),this._left-b):(b=this._value,this.value(this.add(b,this.multiplyStep(this.options.step,a))),this.stepsBetween(b,this._value))},moveLeft:function(a){return-this.moveRight(-a)},stepRatio:function(){if(this.options.step===!1)return 1;var a=(this.options.bounds.max-this.options.bounds.min)/this.options.step;return this.cache.parent.width/a}})}(jQuery),function(a){function b(a,b){return"undefined"==typeof a?b||!1:a}a.widget("ui.rangeSliderBar",a.ui.rangeSliderDraggable,{options:{leftHandle:null,rightHandle:null,bounds:{min:0,max:100},type:"rangeSliderHandle",range:!1,drag:function(){},stop:function(){},values:{min:0,max:20},wheelSpeed:4,wheelMode:null},_values:{min:0,max:20},_waitingToInit:2,_wheelTimeout:!1,_create:function(){a.ui.rangeSliderDraggable.prototype._create.apply(this),this.element.css("position","absolute").css("top",0).addClass("ui-rangeSlider-bar"),this.options.leftHandle.bind("initialize",a.proxy(this._onInitialized,this)).bind("mousestart",a.proxy(this._cache,this)).bind("stop",a.proxy(this._onHandleStop,this)),this.options.rightHandle.bind("initialize",a.proxy(this._onInitialized,this)).bind("mousestart",a.proxy(this._cache,this)).bind("stop",a.proxy(this._onHandleStop,this)),this._bindHandles(),this._values=this.options.values,this._setWheelModeOption(this.options.wheelMode)},destroy:function(){this.options.leftHandle.unbind(".bar"),this.options.rightHandle.unbind(".bar"),this.options=null,a.ui.rangeSliderDraggable.prototype.destroy.apply(this)},_setOption:function(a,b){"range"===a?this._setRangeOption(b):"wheelSpeed"===a?this._setWheelSpeedOption(b):"wheelMode"===a&&this._setWheelModeOption(b)},_setRangeOption:function(a){if(("object"!=typeof a||null===a)&&(a=!1),a!==!1||this.options.range!==!1){if(a!==!1){var c=b(a.min,this.options.range.min),d=b(a.max,this.options.range.max);this.options.range={min:c,max:d}}else this.options.range=!1;this._setLeftRange(),this._setRightRange()}},_setWheelSpeedOption:function(a){"number"==typeof a&&a>0&&(this.options.wheelSpeed=a)},_setWheelModeOption:function(a){(null===a||a===!1||"zoom"===a||"scroll"===a)&&(this.options.wheelMode!==a&&this.element.parent().unbind("mousewheel.bar"),this._bindMouseWheel(a),this.options.wheelMode=a)},_bindMouseWheel:function(b){"zoom"===b?this.element.parent().bind("mousewheel.bar",a.proxy(this._mouseWheelZoom,this)):"scroll"===b&&this.element.parent().bind("mousewheel.bar",a.proxy(this._mouseWheelScroll,this))},_setLeftRange:function(){if(this.options.range===!1)return!1;var a=this._values.max,b={min:!1,max:!1};b.max="undefined"!=typeof this.options.range.min&&this.options.range.min!==!1?this._leftHandle("substract",a,this.options.range.min):!1,b.min="undefined"!=typeof this.options.range.max&&this.options.range.max!==!1?this._leftHandle("substract",a,this.options.range.max):!1,this._leftHandle("option","range",b)},_setRightRange:function(){var a=this._values.min,b={min:!1,max:!1};b.min="undefined"!=typeof this.options.range.min&&this.options.range.min!==!1?this._rightHandle("add",a,this.options.range.min):!1,b.max="undefined"!=typeof this.options.range.max&&this.options.range.max!==!1?this._rightHandle("add",a,this.options.range.max):!1,this._rightHandle("option","range",b)},_deactivateRange:function(){this._leftHandle("option","range",!1),this._rightHandle("option","range",!1)},_reactivateRange:function(){this._setRangeOption(this.options.range)},_onInitialized:function(){this._waitingToInit--,0===this._waitingToInit&&this._initMe()},_initMe:function(){this._cache(),this.min(this._values.min),this.max(this._values.max);var a=this._leftHandle("position"),b=this._rightHandle("position")+this.options.rightHandle.width();this.element.offset({left:a}),this.element.css("width",b-a)},_leftHandle:function(){return this._handleProxy(this.options.leftHandle,arguments)},_rightHandle:function(){return this._handleProxy(this.options.rightHandle,arguments)},_handleProxy:function(a,b){var c=Array.prototype.slice.call(b);return a[this.options.type].apply(a,c)},_cache:function(){a.ui.rangeSliderDraggable.prototype._cache.apply(this),this._cacheHandles()},_cacheHandles:function(){this.cache.rightHandle={},this.cache.rightHandle.width=this.options.rightHandle.width(),this.cache.rightHandle.offset=this.options.rightHandle.offset(),this.cache.leftHandle={},this.cache.leftHandle.offset=this.options.leftHandle.offset()},_mouseStart:function(b){a.ui.rangeSliderDraggable.prototype._mouseStart.apply(this,[b]),this._deactivateRange()},_mouseStop:function(b){a.ui.rangeSliderDraggable.prototype._mouseStop.apply(this,[b]),this._cacheHandles(),this._values.min=this._leftHandle("value"),this._values.max=this._rightHandle("value"),this._reactivateRange(),this._leftHandle().trigger("stop"),this._rightHandle().trigger("stop")},_onDragLeftHandle:function(a,b){if(this._cacheIfNecessary(),b.element[0]===this.options.leftHandle[0]){if(this._switchedValues())return this._switchHandles(),this._onDragRightHandle(a,b),void 0;this._values.min=b.value,this.cache.offset.left=b.offset.left,this.cache.leftHandle.offset=b.offset,this._positionBar()}},_onDragRightHandle:function(a,b){if(this._cacheIfNecessary(),b.element[0]===this.options.rightHandle[0]){if(this._switchedValues())return this._switchHandles(),this._onDragLeftHandle(a,b),void 0;this._values.max=b.value,this.cache.rightHandle.offset=b.offset,this._positionBar()}},_positionBar:function(){var a=this.cache.rightHandle.offset.left+this.cache.rightHandle.width-this.cache.leftHandle.offset.left;this.cache.width.inner=a,this.element.css("width",a).offset({left:this.cache.leftHandle.offset.left})},_onHandleStop:function(){this._setLeftRange(),this._setRightRange()},_switchedValues:function(){if(this.min()>this.max()){var a=this._values.min;return this._values.min=this._values.max,this._values.max=a,!0}return!1},_switchHandles:function(){var a=this.options.leftHandle;this.options.leftHandle=this.options.rightHandle,this.options.rightHandle=a,this._leftHandle("option","isLeft",!0),this._rightHandle("option","isLeft",!1),this._bindHandles(),this._cacheHandles()},_bindHandles:function(){this.options.leftHandle.unbind(".bar").bind("sliderDrag.bar update.bar moving.bar",a.proxy(this._onDragLeftHandle,this)),this.options.rightHandle.unbind(".bar").bind("sliderDrag.bar update.bar moving.bar",a.proxy(this._onDragRightHandle,this))},_constraintPosition:function(b){var c,d={};return d.left=a.ui.rangeSliderDraggable.prototype._constraintPosition.apply(this,[b]),d.left=this._leftHandle("position",d.left),c=this._rightHandle("position",d.left+this.cache.width.outer-this.cache.rightHandle.width),d.width=c-d.left+this.cache.rightHandle.width,d},_applyPosition:function(b){a.ui.rangeSliderDraggable.prototype._applyPosition.apply(this,[b.left]),this.element.width(b.width)},_mouseWheelZoom:function(b,c,d,e){if(!this.enabled)return!1;var f=this._values.min+(this._values.max-this._values.min)/2,g={},h={};return this.options.range===!1||this.options.range.min===!1?(g.max=f,h.min=f):(g.max=f-this.options.range.min/2,h.min=f+this.options.range.min/2),this.options.range!==!1&&this.options.range.max!==!1&&(g.min=f-this.options.range.max/2,h.max=f+this.options.range.max/2),this._leftHandle("option","range",g),this._rightHandle("option","range",h),clearTimeout(this._wheelTimeout),this._wheelTimeout=setTimeout(a.proxy(this._wheelStop,this),200),this.zoomIn(e*this.options.wheelSpeed),!1},_mouseWheelScroll:function(b,c,d,e){return this.enabled?(this._wheelTimeout===!1?this.startScroll():clearTimeout(this._wheelTimeout),this._wheelTimeout=setTimeout(a.proxy(this._wheelStop,this),200),this.scrollLeft(e*this.options.wheelSpeed),!1):!1},_wheelStop:function(){this.stopScroll(),this._wheelTimeout=!1},min:function(a){return this._leftHandle("value",a)},max:function(a){return this._rightHandle("value",a)},startScroll:function(){this._deactivateRange()},stopScroll:function(){this._reactivateRange(),this._triggerMouseEvent("stop"),this._leftHandle().trigger("stop"),this._rightHandle().trigger("stop")},scrollLeft:function(a){return a=a||1,0>a?this.scrollRight(-a):(a=this._leftHandle("moveLeft",a),this._rightHandle("moveLeft",a),this.update(),this._triggerMouseEvent("scroll"),void 0)},scrollRight:function(a){return a=a||1,0>a?this.scrollLeft(-a):(a=this._rightHandle("moveRight",a),this._leftHandle("moveRight",a),this.update(),this._triggerMouseEvent("scroll"),void 0)},zoomIn:function(a){if(a=a||1,0>a)return this.zoomOut(-a);var b=this._rightHandle("moveLeft",a);a>b&&(b/=2,this._rightHandle("moveRight",b)),this._leftHandle("moveRight",b),this.update(),this._triggerMouseEvent("zoom")},zoomOut:function(a){if(a=a||1,0>a)return this.zoomIn(-a);var b=this._rightHandle("moveRight",a);a>b&&(b/=2,this._rightHandle("moveLeft",b)),this._leftHandle("moveLeft",b),this.update(),this._triggerMouseEvent("zoom")},values:function(a,b){if("undefined"!=typeof a&&"undefined"!=typeof b){var c=Math.min(a,b),d=Math.max(a,b);this._deactivateRange(),this.options.leftHandle.unbind(".bar"),this.options.rightHandle.unbind(".bar"),this._values.min=this._leftHandle("value",c),this._values.max=this._rightHandle("value",d),this._bindHandles(),this._reactivateRange(),this.update()
                }return{min:this._values.min,max:this._values.max}},update:function(){this._values.min=this.min(),this._values.max=this.max(),this._cache(),this._positionBar()}})}(jQuery),function(a){function b(b,c,d,e){this.label1=b,this.label2=c,this.type=d,this.options=e,this.handle1=this.label1[this.type]("option","handle"),this.handle2=this.label2[this.type]("option","handle"),this.cache=null,this.left=b,this.right=c,this.moving=!1,this.initialized=!1,this.updating=!1,this.Init=function(){this.BindHandle(this.handle1),this.BindHandle(this.handle2),"show"===this.options.show?(setTimeout(a.proxy(this.PositionLabels,this),1),this.initialized=!0):setTimeout(a.proxy(this.AfterInit,this),1e3),this._resizeProxy=a.proxy(this.onWindowResize,this),a(window).resize(this._resizeProxy)},this.Destroy=function(){this._resizeProxy&&(a(window).unbind("resize",this._resizeProxy),this._resizeProxy=null,this.handle1.unbind(".positionner"),this.handle1=null,this.handle2.unbind(".positionner"),this.handle2=null,this.label1=null,this.label2=null,this.left=null,this.right=null),this.cache=null},this.AfterInit=function(){this.initialized=!0},this.Cache=function(){"none"!==this.label1.css("display")&&(this.cache={},this.cache.label1={},this.cache.label2={},this.cache.handle1={},this.cache.handle2={},this.cache.offsetParent={},this.CacheElement(this.label1,this.cache.label1),this.CacheElement(this.label2,this.cache.label2),this.CacheElement(this.handle1,this.cache.handle1),this.CacheElement(this.handle2,this.cache.handle2),this.CacheElement(this.label1.offsetParent(),this.cache.offsetParent))},this.CacheIfNecessary=function(){null===this.cache?this.Cache():(this.CacheWidth(this.label1,this.cache.label1),this.CacheWidth(this.label2,this.cache.label2),this.CacheHeight(this.label1,this.cache.label1),this.CacheHeight(this.label2,this.cache.label2),this.CacheWidth(this.label1.offsetParent(),this.cache.offsetParent))},this.CacheElement=function(a,b){this.CacheWidth(a,b),this.CacheHeight(a,b),b.offset=a.offset(),b.margin={left:this.ParsePixels("marginLeft",a),right:this.ParsePixels("marginRight",a)},b.border={left:this.ParsePixels("borderLeftWidth",a),right:this.ParsePixels("borderRightWidth",a)}},this.CacheWidth=function(a,b){b.width=a.width(),b.outerWidth=a.outerWidth()},this.CacheHeight=function(a,b){b.outerHeightMargin=a.outerHeight(!0)},this.ParsePixels=function(a,b){return parseInt(b.css(a),10)||0},this.BindHandle=function(b){b.bind("updating.positionner",a.proxy(this.onHandleUpdating,this)),b.bind("update.positionner",a.proxy(this.onHandleUpdated,this)),b.bind("moving.positionner",a.proxy(this.onHandleMoving,this)),b.bind("stop.positionner",a.proxy(this.onHandleStop,this))},this.PositionLabels=function(){if(this.CacheIfNecessary(),null!==this.cache){var a=this.GetRawPosition(this.cache.label1,this.cache.handle1),b=this.GetRawPosition(this.cache.label2,this.cache.handle2);this.label1[d]("option","isLeft")?this.ConstraintPositions(a,b):this.ConstraintPositions(b,a),this.PositionLabel(this.label1,a.left,this.cache.label1),this.PositionLabel(this.label2,b.left,this.cache.label2)}},this.PositionLabel=function(a,b,c){var d,e,f,g=this.cache.offsetParent.offset.left+this.cache.offsetParent.border.left;g-b>=0?(a.css("right",""),a.offset({left:b})):(d=g+this.cache.offsetParent.width,e=b+c.margin.left+c.outerWidth+c.margin.right,f=d-e,a.css("left",""),a.css("right",f))},this.ConstraintPositions=function(a,b){(a.center<b.center&&a.outerRight>b.outerLeft||a.center>b.center&&b.outerRight>a.outerLeft)&&(a=this.getLeftPosition(a,b),b=this.getRightPosition(a,b))},this.getLeftPosition=function(a,b){var c=(b.center+a.center)/2,d=c-a.cache.outerWidth-a.cache.margin.right+a.cache.border.left;return a.left=d,a},this.getRightPosition=function(a,b){var c=(b.center+a.center)/2;return b.left=c+b.cache.margin.left+b.cache.border.left,b},this.ShowIfNecessary=function(){"show"===this.options.show||this.moving||!this.initialized||this.updating||(this.label1.stop(!0,!0).fadeIn(this.options.durationIn||0),this.label2.stop(!0,!0).fadeIn(this.options.durationIn||0),this.moving=!0)},this.HideIfNeeded=function(){this.moving===!0&&(this.label1.stop(!0,!0).delay(this.options.delayOut||0).fadeOut(this.options.durationOut||0),this.label2.stop(!0,!0).delay(this.options.delayOut||0).fadeOut(this.options.durationOut||0),this.moving=!1)},this.onHandleMoving=function(a,b){this.ShowIfNecessary(),this.CacheIfNecessary(),this.UpdateHandlePosition(b),this.PositionLabels()},this.onHandleUpdating=function(){this.updating=!0},this.onHandleUpdated=function(){this.updating=!1,this.cache=null},this.onHandleStop=function(){this.HideIfNeeded()},this.onWindowResize=function(){this.cache=null},this.UpdateHandlePosition=function(a){null!==this.cache&&(a.element[0]===this.handle1[0]?this.UpdatePosition(a,this.cache.handle1):this.UpdatePosition(a,this.cache.handle2))},this.UpdatePosition=function(a,b){b.offset=a.offset,b.value=a.value},this.GetRawPosition=function(a,b){var c=b.offset.left+b.outerWidth/2,d=c-a.outerWidth/2,e=d+a.outerWidth-a.border.left-a.border.right,f=d-a.margin.left-a.border.left,g=b.offset.top-a.outerHeightMargin;return{left:d,outerLeft:f,top:g,right:e,outerRight:f+a.outerWidth+a.margin.left+a.margin.right,cache:a,center:c}},this.Init()}a.widget("ui.rangeSliderLabel",a.ui.rangeSliderMouseTouch,{options:{handle:null,formatter:!1,handleType:"rangeSliderHandle",show:"show",durationIn:0,durationOut:500,delayOut:500,isLeft:!1},cache:null,_positionner:null,_valueContainer:null,_innerElement:null,_value:null,_create:function(){this.options.isLeft=this._handle("option","isLeft"),this.element.addClass("ui-rangeSlider-label").css("position","absolute").css("display","block"),this._createElements(),this._toggleClass(),this.options.handle.bind("moving.label",a.proxy(this._onMoving,this)).bind("update.label",a.proxy(this._onUpdate,this)).bind("switch.label",a.proxy(this._onSwitch,this)),"show"!==this.options.show&&this.element.hide(),this._mouseInit()},destroy:function(){this.options.handle.unbind(".label"),this.options.handle=null,this._valueContainer=null,this._innerElement=null,this.element.empty(),this._positionner&&(this._positionner.Destroy(),this._positionner=null),a.ui.rangeSliderMouseTouch.prototype.destroy.apply(this)},_createElements:function(){this._valueContainer=a("<div class='ui-rangeSlider-label-value' />").appendTo(this.element),this._innerElement=a("<div class='ui-rangeSlider-label-inner' />").appendTo(this.element)},_handle:function(){var a=Array.prototype.slice.apply(arguments);return this.options.handle[this.options.handleType].apply(this.options.handle,a)},_setOption:function(a,b){"show"===a?this._updateShowOption(b):("durationIn"===a||"durationOut"===a||"delayOut"===a)&&this._updateDurations(a,b),this._setFormatterOption(a,b)},_setFormatterOption:function(a,b){"formatter"===a&&("function"==typeof b||b===!1)&&(this.options.formatter=b,this._display(this._value))},_updateShowOption:function(a){this.options.show=a,"show"!==this.options.show?(this.element.hide(),this._positionner.moving=!1):(this.element.show(),this._display(this.options.handle[this.options.handleType]("value")),this._positionner.PositionLabels()),this._positionner.options.show=this.options.show},_updateDurations:function(a,b){parseInt(b,10)===b&&(this._positionner.options[a]=b,this.options[a]=b)},_display:function(a){this.options.formatter===!1?this._displayText(Math.round(a)):this._displayText(this.options.formatter(a)),this._value=a},_displayText:function(a){this._valueContainer.text(a)},_toggleClass:function(){this.element.toggleClass("ui-rangeSlider-leftLabel",this.options.isLeft).toggleClass("ui-rangeSlider-rightLabel",!this.options.isLeft)},_positionLabels:function(){this._positionner.PositionLabels()},_mouseDown:function(a){this.options.handle.trigger(a)},_mouseUp:function(a){this.options.handle.trigger(a)},_mouseMove:function(a){this.options.handle.trigger(a)},_onMoving:function(a,b){this._display(b.value)},_onUpdate:function(){"show"===this.options.show&&this.update()},_onSwitch:function(a,b){this.options.isLeft=b,this._toggleClass(),this._positionLabels()},pair:function(a){null===this._positionner&&(this._positionner=new b(this.element,a,this.widgetName,{show:this.options.show,durationIn:this.options.durationIn,durationOut:this.options.durationOut,delayOut:this.options.delayOut}),a[this.widgetName]("positionner",this._positionner))},positionner:function(a){return"undefined"!=typeof a&&(this._positionner=a),this._positionner},update:function(){this._positionner.cache=null,this._display(this._handle("value")),"show"===this.options.show&&this._positionLabels()}})}(jQuery),function(a){a.widget("ui.dateRangeSlider",a.ui.rangeSlider,{options:{bounds:{min:new Date(2010,0,1).valueOf(),max:new Date(2012,0,1).valueOf()},defaultValues:{min:new Date(2010,1,11).valueOf(),max:new Date(2011,1,11).valueOf()}},_create:function(){a.ui.rangeSlider.prototype._create.apply(this),this.element.addClass("ui-dateRangeSlider")},destroy:function(){this.element.removeClass("ui-dateRangeSlider"),a.ui.rangeSlider.prototype.destroy.apply(this)},_setDefaultValues:function(){this._values={min:this.options.defaultValues.min.valueOf(),max:this.options.defaultValues.max.valueOf()}},_setRulerParameters:function(){this.ruler.ruler({min:new Date(this.options.bounds.min),max:new Date(this.options.bounds.max),scales:this.options.scales})},_setOption:function(b,c){("defaultValues"===b||"bounds"===b)&&"undefined"!=typeof c&&null!==c&&this._isValidDate(c.min)&&this._isValidDate(c.max)?a.ui.rangeSlider.prototype._setOption.apply(this,[b,{min:c.min.valueOf(),max:c.max.valueOf()}]):a.ui.rangeSlider.prototype._setOption.apply(this,this._toArray(arguments))},_handleType:function(){return"dateRangeSliderHandle"},option:function(b){if("bounds"===b||"defaultValues"===b){var c=a.ui.rangeSlider.prototype.option.apply(this,arguments);return{min:new Date(c.min),max:new Date(c.max)}}return a.ui.rangeSlider.prototype.option.apply(this,this._toArray(arguments))},_defaultFormatter:function(a){var b=a.getMonth()+1,c=a.getDate();return""+a.getFullYear()+"-"+(10>b?"0"+b:b)+"-"+(10>c?"0"+c:c)},_getFormatter:function(){var a=this.options.formatter;return(this.options.formatter===!1||null===this.options.formatter)&&(a=this._defaultFormatter),function(a){return function(b){return a(new Date(b))}}(a)},values:function(b,c){var d=null;return d=this._isValidDate(b)&&this._isValidDate(c)?a.ui.rangeSlider.prototype.values.apply(this,[b.valueOf(),c.valueOf()]):a.ui.rangeSlider.prototype.values.apply(this,this._toArray(arguments)),{min:new Date(d.min),max:new Date(d.max)}},min:function(b){return this._isValidDate(b)?new Date(a.ui.rangeSlider.prototype.min.apply(this,[b.valueOf()])):new Date(a.ui.rangeSlider.prototype.min.apply(this))},max:function(b){return this._isValidDate(b)?new Date(a.ui.rangeSlider.prototype.max.apply(this,[b.valueOf()])):new Date(a.ui.rangeSlider.prototype.max.apply(this))},bounds:function(b,c){var d;return d=this._isValidDate(b)&&this._isValidDate(c)?a.ui.rangeSlider.prototype.bounds.apply(this,[b.valueOf(),c.valueOf()]):a.ui.rangeSlider.prototype.bounds.apply(this,this._toArray(arguments)),{min:new Date(d.min),max:new Date(d.max)}},_isValidDate:function(a){return"undefined"!=typeof a&&a instanceof Date},_toArray:function(a){return Array.prototype.slice.call(a)}})}(jQuery),function(a){a.widget("ui.dateRangeSliderHandle",a.ui.rangeSliderHandle,{_steps:!1,_boundsValues:{},_create:function(){this._createBoundsValues(),a.ui.rangeSliderHandle.prototype._create.apply(this)},_getValueForPosition:function(a){var b=this._getRawValueForPositionAndBounds(a,this.options.bounds.min.valueOf(),this.options.bounds.max.valueOf());return this._constraintValue(new Date(b))},_setOption:function(b,c){return"step"===b?(this.options.step=c,this._createSteps(),this.update(),void 0):(a.ui.rangeSliderHandle.prototype._setOption.apply(this,[b,c]),"bounds"===b&&this._createBoundsValues(),void 0)},_createBoundsValues:function(){this._boundsValues={min:this.options.bounds.min.valueOf(),max:this.options.bounds.max.valueOf()}},_bounds:function(){return this._boundsValues},_createSteps:function(){if(this.options.step===!1||!this._isValidStep())return this._steps=!1,void 0;var a=new Date(this.options.bounds.min),b=new Date(this.options.bounds.max),c=a,d=0,e=new Date;for(this._steps=[];b>=c&&(1===d||e.valueOf()!==c.valueOf());)e=c,this._steps.push(c.valueOf()),c=this._addStep(a,d,this.options.step),d++;e.valueOf()===c.valueOf()&&(this._steps=!1)},_isValidStep:function(){return"object"==typeof this.options.step},_addStep:function(a,b,c){var d=new Date(a.valueOf());return d=this._addThing(d,"FullYear",b,c.years),d=this._addThing(d,"Month",b,c.months),d=this._addThing(d,"Date",b,7*c.weeks),d=this._addThing(d,"Date",b,c.days),d=this._addThing(d,"Hours",b,c.hours),d=this._addThing(d,"Minutes",b,c.minutes),d=this._addThing(d,"Seconds",b,c.seconds)},_addThing:function(a,b,c,d){return 0===c||0===(d||0)?a:(a["set"+b](a["get"+b]()+c*(d||0)),a)},_round:function(a){if(this._steps===!1)return a;for(var b,c,d=this.options.bounds.max.valueOf(),e=this.options.bounds.min.valueOf(),f=Math.max(0,(a-e)/(d-e)),g=Math.floor(this._steps.length*f);this._steps[g]>a;)g--;for(;g+1<this._steps.length&&this._steps[g+1]<=a;)g++;return g>=this._steps.length-1?this._steps[this._steps.length-1]:0===g?this._steps[0]:(b=this._steps[g],c=this._steps[g+1],c-a>a-b?b:c)},update:function(){this._createBoundsValues(),this._createSteps(),a.ui.rangeSliderHandle.prototype.update.apply(this)},add:function(a,b){return this._addStep(new Date(a),1,b).valueOf()},substract:function(a,b){return this._addStep(new Date(a),-1,b).valueOf()},stepsBetween:function(a,b){if(this.options.step===!1)return b-a;var c=Math.min(a,b),d=Math.max(a,b),e=0,f=!1,g=a>b;for(this.add(c,this.options.step)-c<0&&(f=!0);d>c;)f?d=this.add(d,this.options.step):c=this.add(c,this.options.step),e++;return g?-e:e},multiplyStep:function(a,b){var c={};for(var d in a)a.hasOwnProperty(d)&&(c[d]=a[d]*b);return c},stepRatio:function(){if(this.options.step===!1)return 1;var a=this._steps.length;return this.cache.parent.width/a}})}(jQuery),function(a){a.widget("ui.editRangeSlider",a.ui.rangeSlider,{options:{type:"text",round:1},_create:function(){a.ui.rangeSlider.prototype._create.apply(this),this.element.addClass("ui-editRangeSlider")},destroy:function(){this.element.removeClass("ui-editRangeSlider"),a.ui.rangeSlider.prototype.destroy.apply(this)},_setOption:function(b,c){("type"===b||"step"===b)&&this._setLabelOption(b,c),"type"===b&&(this.options[b]=null===this.labels.left?c:this._leftLabel("option",b)),a.ui.rangeSlider.prototype._setOption.apply(this,[b,c])},_setLabelOption:function(a,b){null!==this.labels.left&&(this._leftLabel("option",a,b),this._rightLabel("option",a,b))},_labelType:function(){return"editRangeSliderLabel"},_createLabel:function(b,c){var d=a.ui.rangeSlider.prototype._createLabel.apply(this,[b,c]);return null===b&&d.bind("valueChange",a.proxy(this._onValueChange,this)),d},_addPropertiesToParameter:function(a){return a.type=this.options.type,a.step=this.options.step,a.id=this.element.attr("id"),a},_getLabelConstructorParameters:function(b,c){var d=a.ui.rangeSlider.prototype._getLabelConstructorParameters.apply(this,[b,c]);return this._addPropertiesToParameter(d)},_getLabelRefreshParameters:function(b,c){var d=a.ui.rangeSlider.prototype._getLabelRefreshParameters.apply(this,[b,c]);return this._addPropertiesToParameter(d)},_onValueChange:function(a,b){var c=!1;c=b.isLeft?this._values.min!==this.min(b.value):this._values.max!==this.max(b.value),c&&this._trigger("userValuesChanged")}})}(jQuery),function(a){a.widget("ui.editRangeSliderLabel",a.ui.rangeSliderLabel,{options:{type:"text",step:!1,id:""},_input:null,_text:"",_create:function(){a.ui.rangeSliderLabel.prototype._create.apply(this),this._createInput()},_setOption:function(b,c){"type"===b?this._setTypeOption(c):"step"===b&&this._setStepOption(c),a.ui.rangeSliderLabel.prototype._setOption.apply(this,[b,c])},_createInput:function(){this._input=a("<input type='"+this.options.type+"' />").addClass("ui-editRangeSlider-inputValue").appendTo(this._valueContainer),this._setInputName(),this._input.bind("keyup",a.proxy(this._onKeyUp,this)),this._input.blur(a.proxy(this._onChange,this)),"number"===this.options.type&&(this.options.step!==!1&&this._input.attr("step",this.options.step),this._input.click(a.proxy(this._onChange,this))),this._input.val(this._text)},_setInputName:function(){var a=this.options.isLeft?"left":"right";this._input.attr("name",this.options.id+a)},_onSwitch:function(b,c){a.ui.rangeSliderLabel.prototype._onSwitch.apply(this,[b,c]),this._setInputName()},_destroyInput:function(){this._input.remove(),this._input=null},_onKeyUp:function(a){return 13===a.which?(this._onChange(a),!1):void 0},_onChange:function(){var a=this._returnCheckedValue(this._input.val());a!==!1&&this._triggerValue(a)},_triggerValue:function(a){var b=this.options.handle[this.options.handleType]("option","isLeft");this.element.trigger("valueChange",[{isLeft:b,value:a}])},_returnCheckedValue:function(a){var b=parseFloat(a);return isNaN(b)||isNaN(Number(a))?!1:b},_setTypeOption:function(a){"text"!==a&&"number"!==a||this.options.type===a||(this._destroyInput(),this.options.type=a,this._createInput())},_setStepOption:function(a){this.options.step=a,"number"===this.options.type&&this._input.attr("step",a!==!1?a:"any")},_displayText:function(a){this._input.val(a),this._text=a},enable:function(){a.ui.rangeSliderLabel.prototype.enable.apply(this),this._input.attr("disabled",null)},disable:function(){a.ui.rangeSliderLabel.prototype.disable.apply(this),this._input.attr("disabled","disabled")}})}(jQuery),function(a){var b={first:function(a){return a},next:function(a){return a+1},format:function(){},label:function(a){return Math.round(a)},stop:function(){return!1}};a.widget("ui.ruler",{options:{min:0,max:100,scales:[]},_create:function(){this.element.addClass("ui-ruler"),this._createScales()},destroy:function(){this.element.removeClass("ui-ruler"),this.element.empty()},_regenerate:function(){this.element.empty(),this._createScales()},_setOption:function(a,b){return"min"===a||"max"===a&&b!==this.options[a]?(this.options[a]=b,this._regenerate(),void 0):"scales"===a&&b instanceof Array?(this.options.scales=b,this._regenerate(),void 0):void 0},_createScales:function(){if(this.options.max!==this.options.min)for(var a=0;a<this.options.scales.length;a++)this._createScale(this.options.scales[a],a)},_createScale:function(c,d){var e=a.extend({},b,c),f=a("<div class='ui-ruler-scale' />").appendTo(this.element);f.addClass("ui-ruler-scale"+d),this._createTicks(f,e)},_createTicks:function(a,b){var c,d,e,f=b.first(this.options.min,this.options.max),g=this.options.max-this.options.min,h=!0;do c=f,f=b.next(c),d=(Math.min(f,this.options.max)-Math.max(c,this.options.min))/g,e=this._createTick(c,f,b),a.append(e),e.css("width",100*d+"%"),h&&c>this.options.min&&e.css("margin-left",100*(c-this.options.min)/g+"%"),h=!1;while(!this._stop(b,f))},_stop:function(a,b){return a.stop(b)||b>=this.options.max},_createTick:function(b,c,d){var e=a("<div class='ui-ruler-tick' style='display:inline-block' />"),f=a("<div class='ui-ruler-tick-inner' />").appendTo(e),g=a("<span class='ui-ruler-tick-label' />").appendTo(f);return g.text(d.label(b,c)),d.format(e,b,c),e}})}(jQuery);
                return $.fn.rangeSlider;
                  }).apply(root, arguments);
                });
                }(this));
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/date_range_slider',["underscore", "jquery", "jqrangeslider", "common/collection", "common/continuum_view", "common/has_properties"], function(_, $, $1, Collection, ContinuumView, HasProperties) {
                    var DateRangeSlider, DateRangeSliderView, DateRangeSliders, _ref, _ref1, _ref2;
                    DateRangeSliderView = (function(_super) {
                      __extends(DateRangeSliderView, _super);
                
                      function DateRangeSliderView() {
                        _ref = DateRangeSliderView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DateRangeSliderView.prototype.initialize = function(options) {
                        var _this = this;
                        DateRangeSliderView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', function() {
                          return _this.render;
                        });
                      };
                
                      DateRangeSliderView.prototype.render = function() {
                        var bounds_max, bounds_min, range_max, range_min, value_max, value_min, _ref1, _ref2, _ref3,
                          _this = this;
                        this.$el.empty();
                        _ref1 = this.mget("value"), value_min = _ref1[0], value_max = _ref1[1];
                        _ref2 = this.mget("range"), range_min = _ref2[0], range_max = _ref2[1];
                        _ref3 = this.mget("bounds"), bounds_min = _ref3[0], bounds_max = _ref3[1];
                        this.$el.dateRangeSlider({
                          defaultValues: {
                            min: new Date(value_min),
                            max: new Date(value_max)
                          },
                          bounds: {
                            min: new Date(bounds_min),
                            max: new Date(bounds_max)
                          },
                          range: {
                            min: _.isObject(range_min) ? range_min : false,
                            max: _.isObject(range_max) ? range_max : false
                          },
                          step: this.mget("step") || {},
                          enabled: this.mget("enabled"),
                          arrows: this.mget("arrows"),
                          valueLabels: this.mget("value_labels"),
                          wheelMode: this.mget("wheel_mode")
                        });
                        return this.$el.on("userValuesChanged", function(event, data) {
                          _this.mset('value', [data.values.min, data.values.max]);
                          return _this.model.save();
                        });
                      };
                
                      return DateRangeSliderView;
                
                    })(ContinuumView);
                    DateRangeSlider = (function(_super) {
                      __extends(DateRangeSlider, _super);
                
                      function DateRangeSlider() {
                        _ref1 = DateRangeSlider.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DateRangeSlider.prototype.type = "DateRangeSlider";
                
                      DateRangeSlider.prototype.default_view = DateRangeSliderView;
                
                      DateRangeSlider.prototype.defaults = function() {
                        return _.extend({}, DateRangeSlider.__super__.defaults.call(this), {
                          /*
                          value
                          range
                          bounds
                          step
                          formatter
                          scales
                          enabled
                          arrows
                          value_labels
                          wheel_mode
                          */
                
                        });
                      };
                
                      return DateRangeSlider;
                
                    })(HasProperties);
                    DateRangeSliders = (function(_super) {
                      __extends(DateRangeSliders, _super);
                
                      function DateRangeSliders() {
                        _ref2 = DateRangeSliders.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      DateRangeSliders.prototype.model = DateRangeSlider;
                
                      return DateRangeSliders;
                
                    })(Collection);
                    return {
                      Model: DateRangeSlider,
                      Collection: new DateRangeSliders(),
                      View: DateRangeSliderView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=date_range_slider.js.map
                */;
                define('jquery_ui/datepicker',['jquery','./core'], function (jQuery) {
                /*!
                 * jQuery UI Datepicker 1.10.0
                 * http://jqueryui.com
                 *
                 * Copyright 2013 jQuery Foundation and other contributors
                 * Released under the MIT license.
                 * http://jquery.org/license
                 *
                 * http://api.jqueryui.com/datepicker/
                 *
                 * Depends:
                 *	jquery.ui.core.js
                 */
                (function( $, undefined ) {
                
                $.extend($.ui, { datepicker: { version: "1.10.0" } });
                
                var PROP_NAME = "datepicker",
                	dpuuid = new Date().getTime(),
                	instActive;
                
                /* Date picker manager.
                   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
                   Settings for (groups of) date pickers are maintained in an instance object,
                   allowing multiple different settings on the same page. */
                
                function Datepicker() {
                	this._curInst = null; // The current instance in use
                	this._keyEvent = false; // If the last event was a key event
                	this._disabledInputs = []; // List of date picker inputs that have been disabled
                	this._datepickerShowing = false; // True if the popup picker is showing , false if not
                	this._inDialog = false; // True if showing within a "dialog", false if not
                	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
                	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
                	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
                	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
                	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
                	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
                	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
                	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
                	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
                	this.regional = []; // Available regional settings, indexed by language code
                	this.regional[""] = { // Default regional settings
                		closeText: "Done", // Display text for close link
                		prevText: "Prev", // Display text for previous month link
                		nextText: "Next", // Display text for next month link
                		currentText: "Today", // Display text for current month link
                		monthNames: ["January","February","March","April","May","June",
                			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
                		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
                		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
                		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
                		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
                		weekHeader: "Wk", // Column header for week of the year
                		dateFormat: "mm/dd/yy", // See format options on parseDate
                		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
                		isRTL: false, // True if right-to-left language, false if left-to-right
                		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
                		yearSuffix: "" // Additional text to append to the year in the month headers
                	};
                	this._defaults = { // Global defaults for all the date picker instances
                		showOn: "focus", // "focus" for popup on focus,
                			// "button" for trigger button, or "both" for either
                		showAnim: "fadeIn", // Name of jQuery animation for popup
                		showOptions: {}, // Options for enhanced animations
                		defaultDate: null, // Used when field is blank: actual date,
                			// +/-number for offset from today, null for today
                		appendText: "", // Display text following the input box, e.g. showing the format
                		buttonText: "...", // Text for trigger button
                		buttonImage: "", // URL for trigger button image
                		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
                		hideIfNoPrevNext: false, // True to hide next/previous month links
                			// if not applicable, false to just disable them
                		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
                		gotoCurrent: false, // True if today link goes back to current selection instead
                		changeMonth: false, // True if month can be selected directly, false if only prev/next
                		changeYear: false, // True if year can be selected directly, false if only prev/next
                		yearRange: "c-10:c+10", // Range of years to display in drop-down,
                			// either relative to today's year (-nn:+nn), relative to currently displayed year
                			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
                		showOtherMonths: false, // True to show dates in other months, false to leave blank
                		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
                		showWeek: false, // True to show week of the year, false to not show it
                		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
                			// takes a Date and returns the number of the week for it
                		shortYearCutoff: "+10", // Short year values < this are in the current century,
                			// > this are in the previous century,
                			// string value starting with "+" for current year + value
                		minDate: null, // The earliest selectable date, or null for no limit
                		maxDate: null, // The latest selectable date, or null for no limit
                		duration: "fast", // Duration of display/closure
                		beforeShowDay: null, // Function that takes a date and returns an array with
                			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
                			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
                		beforeShow: null, // Function that takes an input field and
                			// returns a set of custom settings for the date picker
                		onSelect: null, // Define a callback function when a date is selected
                		onChangeMonthYear: null, // Define a callback function when the month or year is changed
                		onClose: null, // Define a callback function when the datepicker is closed
                		numberOfMonths: 1, // Number of months to show at a time
                		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
                		stepMonths: 1, // Number of months to step back/forward
                		stepBigMonths: 12, // Number of months to step back/forward for the big links
                		altField: "", // Selector for an alternate field to store selected dates into
                		altFormat: "", // The date format to use for the alternate field
                		constrainInput: true, // The input is constrained by the current date format
                		showButtonPanel: false, // True to show button panel, false to not show it
                		autoSize: false, // True to size the input for the date format, false to leave as is
                		disabled: false // The initial disabled state
                	};
                	$.extend(this._defaults, this.regional[""]);
                	this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
                }
                
                $.extend(Datepicker.prototype, {
                	/* Class name added to elements to indicate already configured with a date picker. */
                	markerClassName: "hasDatepicker",
                
                	//Keep track of the maximum number of rows displayed (see #7043)
                	maxRows: 4,
                
                	// TODO rename to "widget" when switching to widget factory
                	_widgetDatepicker: function() {
                		return this.dpDiv;
                	},
                
                	/* Override the default settings for all instances of the date picker.
                	 * @param  settings  object - the new settings to use as defaults (anonymous object)
                	 * @return the manager object
                	 */
                	setDefaults: function(settings) {
                		extendRemove(this._defaults, settings || {});
                		return this;
                	},
                
                	/* Attach the date picker to a jQuery selection.
                	 * @param  target	element - the target input field or division or span
                	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
                	 */
                	_attachDatepicker: function(target, settings) {
                		var nodeName, inline, inst;
                		nodeName = target.nodeName.toLowerCase();
                		inline = (nodeName === "div" || nodeName === "span");
                		if (!target.id) {
                			this.uuid += 1;
                			target.id = "dp" + this.uuid;
                		}
                		inst = this._newInst($(target), inline);
                		inst.settings = $.extend({}, settings || {});
                		if (nodeName === "input") {
                			this._connectDatepicker(target, inst);
                		} else if (inline) {
                			this._inlineDatepicker(target, inst);
                		}
                	},
                
                	/* Create a new instance object. */
                	_newInst: function(target, inline) {
                		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
                		return {id: id, input: target, // associated target
                			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
                			drawMonth: 0, drawYear: 0, // month being drawn
                			inline: inline, // is datepicker inline or not
                			dpDiv: (!inline ? this.dpDiv : // presentation div
                			bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
                	},
                
                	/* Attach the date picker to an input field. */
                	_connectDatepicker: function(target, inst) {
                		var input = $(target);
                		inst.append = $([]);
                		inst.trigger = $([]);
                		if (input.hasClass(this.markerClassName)) {
                			return;
                		}
                		this._attachments(input, inst);
                		input.addClass(this.markerClassName).keydown(this._doKeyDown).
                			keypress(this._doKeyPress).keyup(this._doKeyUp);
                		this._autoSize(inst);
                		$.data(target, PROP_NAME, inst);
                		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
                		if( inst.settings.disabled ) {
                			this._disableDatepicker( target );
                		}
                	},
                
                	/* Make attachments based on settings. */
                	_attachments: function(input, inst) {
                		var showOn, buttonText, buttonImage,
                			appendText = this._get(inst, "appendText"),
                			isRTL = this._get(inst, "isRTL");
                
                		if (inst.append) {
                			inst.append.remove();
                		}
                		if (appendText) {
                			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                			input[isRTL ? "before" : "after"](inst.append);
                		}
                
                		input.unbind("focus", this._showDatepicker);
                
                		if (inst.trigger) {
                			inst.trigger.remove();
                		}
                
                		showOn = this._get(inst, "showOn");
                		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
                			input.focus(this._showDatepicker);
                		}
                		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
                			buttonText = this._get(inst, "buttonText");
                			buttonImage = this._get(inst, "buttonImage");
                			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
                				$("<img/>").addClass(this._triggerClass).
                					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
                				$("<button type='button'></button>").addClass(this._triggerClass).
                					html(!buttonImage ? buttonText : $("<img/>").attr(
                					{ src:buttonImage, alt:buttonText, title:buttonText })));
                			input[isRTL ? "before" : "after"](inst.trigger);
                			inst.trigger.click(function() {
                				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                					$.datepicker._hideDatepicker();
                				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                					$.datepicker._hideDatepicker();
                					$.datepicker._showDatepicker(input[0]);
                				} else {
                					$.datepicker._showDatepicker(input[0]);
                				}
                				return false;
                			});
                		}
                	},
                
                	/* Apply the maximum length for the date format. */
                	_autoSize: function(inst) {
                		if (this._get(inst, "autoSize") && !inst.inline) {
                			var findMax, max, maxI, i,
                				date = new Date(2009, 12 - 1, 20), // Ensure double digits
                				dateFormat = this._get(inst, "dateFormat");
                
                			if (dateFormat.match(/[DM]/)) {
                				findMax = function(names) {
                					max = 0;
                					maxI = 0;
                					for (i = 0; i < names.length; i++) {
                						if (names[i].length > max) {
                							max = names[i].length;
                							maxI = i;
                						}
                					}
                					return maxI;
                				};
                				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                					"monthNames" : "monthNamesShort"))));
                				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
                			}
                			inst.input.attr("size", this._formatDate(inst, date).length);
                		}
                	},
                
                	/* Attach an inline date picker to a div. */
                	_inlineDatepicker: function(target, inst) {
                		var divSpan = $(target);
                		if (divSpan.hasClass(this.markerClassName)) {
                			return;
                		}
                		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
                		$.data(target, PROP_NAME, inst);
                		this._setDate(inst, this._getDefaultDate(inst), true);
                		this._updateDatepicker(inst);
                		this._updateAlternate(inst);
                		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
                		if( inst.settings.disabled ) {
                			this._disableDatepicker( target );
                		}
                		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
                		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
                		inst.dpDiv.css( "display", "block" );
                	},
                
                	/* Pop-up the date picker in a "dialog" box.
                	 * @param  input element - ignored
                	 * @param  date	string or Date - the initial date to display
                	 * @param  onSelect  function - the function to call when a date is selected
                	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
                	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
                	 *					event - with x/y coordinates or
                	 *					leave empty for default (screen centre)
                	 * @return the manager object
                	 */
                	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
                		var id, browserWidth, browserHeight, scrollX, scrollY,
                			inst = this._dialogInst; // internal instance
                
                		if (!inst) {
                			this.uuid += 1;
                			id = "dp" + this.uuid;
                			this._dialogInput = $("<input type='text' id='" + id +
                				"' style='position: absolute; top: -100px; width: 0px;'/>");
                			this._dialogInput.keydown(this._doKeyDown);
                			$("body").append(this._dialogInput);
                			inst = this._dialogInst = this._newInst(this._dialogInput, false);
                			inst.settings = {};
                			$.data(this._dialogInput[0], PROP_NAME, inst);
                		}
                		extendRemove(inst.settings, settings || {});
                		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
                		this._dialogInput.val(date);
                
                		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
                		if (!this._pos) {
                			browserWidth = document.documentElement.clientWidth;
                			browserHeight = document.documentElement.clientHeight;
                			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                			this._pos = // should use actual width/height below
                				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
                		}
                
                		// move input on screen for focus, but hidden behind dialog
                		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
                		inst.settings.onSelect = onSelect;
                		this._inDialog = true;
                		this.dpDiv.addClass(this._dialogClass);
                		this._showDatepicker(this._dialogInput[0]);
                		if ($.blockUI) {
                			$.blockUI(this.dpDiv);
                		}
                		$.data(this._dialogInput[0], PROP_NAME, inst);
                		return this;
                	},
                
                	/* Detach a datepicker from its control.
                	 * @param  target	element - the target input field or division or span
                	 */
                	_destroyDatepicker: function(target) {
                		var nodeName,
                			$target = $(target),
                			inst = $.data(target, PROP_NAME);
                
                		if (!$target.hasClass(this.markerClassName)) {
                			return;
                		}
                
                		nodeName = target.nodeName.toLowerCase();
                		$.removeData(target, PROP_NAME);
                		if (nodeName === "input") {
                			inst.append.remove();
                			inst.trigger.remove();
                			$target.removeClass(this.markerClassName).
                				unbind("focus", this._showDatepicker).
                				unbind("keydown", this._doKeyDown).
                				unbind("keypress", this._doKeyPress).
                				unbind("keyup", this._doKeyUp);
                		} else if (nodeName === "div" || nodeName === "span") {
                			$target.removeClass(this.markerClassName).empty();
                		}
                	},
                
                	/* Enable the date picker to a jQuery selection.
                	 * @param  target	element - the target input field or division or span
                	 */
                	_enableDatepicker: function(target) {
                		var nodeName, inline,
                			$target = $(target),
                			inst = $.data(target, PROP_NAME);
                
                		if (!$target.hasClass(this.markerClassName)) {
                			return;
                		}
                
                		nodeName = target.nodeName.toLowerCase();
                		if (nodeName === "input") {
                			target.disabled = false;
                			inst.trigger.filter("button").
                				each(function() { this.disabled = false; }).end().
                				filter("img").css({opacity: "1.0", cursor: ""});
                		} else if (nodeName === "div" || nodeName === "span") {
                			inline = $target.children("." + this._inlineClass);
                			inline.children().removeClass("ui-state-disabled");
                			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                				prop("disabled", false);
                		}
                		this._disabledInputs = $.map(this._disabledInputs,
                			function(value) { return (value === target ? null : value); }); // delete entry
                	},
                
                	/* Disable the date picker to a jQuery selection.
                	 * @param  target	element - the target input field or division or span
                	 */
                	_disableDatepicker: function(target) {
                		var nodeName, inline,
                			$target = $(target),
                			inst = $.data(target, PROP_NAME);
                
                		if (!$target.hasClass(this.markerClassName)) {
                			return;
                		}
                
                		nodeName = target.nodeName.toLowerCase();
                		if (nodeName === "input") {
                			target.disabled = true;
                			inst.trigger.filter("button").
                				each(function() { this.disabled = true; }).end().
                				filter("img").css({opacity: "0.5", cursor: "default"});
                		} else if (nodeName === "div" || nodeName === "span") {
                			inline = $target.children("." + this._inlineClass);
                			inline.children().addClass("ui-state-disabled");
                			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                				prop("disabled", true);
                		}
                		this._disabledInputs = $.map(this._disabledInputs,
                			function(value) { return (value === target ? null : value); }); // delete entry
                		this._disabledInputs[this._disabledInputs.length] = target;
                	},
                
                	/* Is the first field in a jQuery collection disabled as a datepicker?
                	 * @param  target	element - the target input field or division or span
                	 * @return boolean - true if disabled, false if enabled
                	 */
                	_isDisabledDatepicker: function(target) {
                		if (!target) {
                			return false;
                		}
                		for (var i = 0; i < this._disabledInputs.length; i++) {
                			if (this._disabledInputs[i] === target) {
                				return true;
                			}
                		}
                		return false;
                	},
                
                	/* Retrieve the instance data for the target control.
                	 * @param  target  element - the target input field or division or span
                	 * @return  object - the associated instance data
                	 * @throws  error if a jQuery problem getting data
                	 */
                	_getInst: function(target) {
                		try {
                			return $.data(target, PROP_NAME);
                		}
                		catch (err) {
                			throw "Missing instance data for this datepicker";
                		}
                	},
                
                	/* Update or retrieve the settings for a date picker attached to an input field or division.
                	 * @param  target  element - the target input field or division or span
                	 * @param  name	object - the new settings to update or
                	 *				string - the name of the setting to change or retrieve,
                	 *				when retrieving also "all" for all instance settings or
                	 *				"defaults" for all global defaults
                	 * @param  value   any - the new value for the setting
                	 *				(omit if above is an object or to retrieve a value)
                	 */
                	_optionDatepicker: function(target, name, value) {
                		var settings, date, minDate, maxDate,
                			inst = this._getInst(target);
                
                		if (arguments.length === 2 && typeof name === "string") {
                			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
                				(inst ? (name === "all" ? $.extend({}, inst.settings) :
                				this._get(inst, name)) : null));
                		}
                
                		settings = name || {};
                		if (typeof name === "string") {
                			settings = {};
                			settings[name] = value;
                		}
                
                		if (inst) {
                			if (this._curInst === inst) {
                				this._hideDatepicker();
                			}
                
                			date = this._getDateDatepicker(target, true);
                			minDate = this._getMinMaxDate(inst, "min");
                			maxDate = this._getMinMaxDate(inst, "max");
                			extendRemove(inst.settings, settings);
                			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                				inst.settings.minDate = this._formatDate(inst, minDate);
                			}
                			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                				inst.settings.maxDate = this._formatDate(inst, maxDate);
                			}
                			if ( "disabled" in settings ) {
                				if ( settings.disabled ) {
                					this._disableDatepicker(target);
                				} else {
                					this._enableDatepicker(target);
                				}
                			}
                			this._attachments($(target), inst);
                			this._autoSize(inst);
                			this._setDate(inst, date);
                			this._updateAlternate(inst);
                			this._updateDatepicker(inst);
                		}
                	},
                
                	// change method deprecated
                	_changeDatepicker: function(target, name, value) {
                		this._optionDatepicker(target, name, value);
                	},
                
                	/* Redraw the date picker attached to an input field or division.
                	 * @param  target  element - the target input field or division or span
                	 */
                	_refreshDatepicker: function(target) {
                		var inst = this._getInst(target);
                		if (inst) {
                			this._updateDatepicker(inst);
                		}
                	},
                
                	/* Set the dates for a jQuery selection.
                	 * @param  target element - the target input field or division or span
                	 * @param  date	Date - the new date
                	 */
                	_setDateDatepicker: function(target, date) {
                		var inst = this._getInst(target);
                		if (inst) {
                			this._setDate(inst, date);
                			this._updateDatepicker(inst);
                			this._updateAlternate(inst);
                		}
                	},
                
                	/* Get the date(s) for the first entry in a jQuery selection.
                	 * @param  target element - the target input field or division or span
                	 * @param  noDefault boolean - true if no default date is to be used
                	 * @return Date - the current date
                	 */
                	_getDateDatepicker: function(target, noDefault) {
                		var inst = this._getInst(target);
                		if (inst && !inst.inline) {
                			this._setDateFromField(inst, noDefault);
                		}
                		return (inst ? this._getDate(inst) : null);
                	},
                
                	/* Handle keystrokes. */
                	_doKeyDown: function(event) {
                		var onSelect, dateStr, sel,
                			inst = $.datepicker._getInst(event.target),
                			handled = true,
                			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
                
                		inst._keyEvent = true;
                		if ($.datepicker._datepickerShowing) {
                			switch (event.keyCode) {
                				case 9: $.datepicker._hideDatepicker();
                						handled = false;
                						break; // hide on tab out
                				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                									$.datepicker._currentClass + ")", inst.dpDiv);
                						if (sel[0]) {
                							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                						}
                
                						onSelect = $.datepicker._get(inst, "onSelect");
                						if (onSelect) {
                							dateStr = $.datepicker._formatDate(inst);
                
                							// trigger custom callback
                							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                						} else {
                							$.datepicker._hideDatepicker();
                						}
                
                						return false; // don't submit the form
                				case 27: $.datepicker._hideDatepicker();
                						break; // hide on escape
                				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                							-$.datepicker._get(inst, "stepBigMonths") :
                							-$.datepicker._get(inst, "stepMonths")), "M");
                						break; // previous month/year on page up/+ ctrl
                				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                							+$.datepicker._get(inst, "stepBigMonths") :
                							+$.datepicker._get(inst, "stepMonths")), "M");
                						break; // next month/year on page down/+ ctrl
                				case 35: if (event.ctrlKey || event.metaKey) {
                							$.datepicker._clearDate(event.target);
                						}
                						handled = event.ctrlKey || event.metaKey;
                						break; // clear on ctrl or command +end
                				case 36: if (event.ctrlKey || event.metaKey) {
                							$.datepicker._gotoToday(event.target);
                						}
                						handled = event.ctrlKey || event.metaKey;
                						break; // current on ctrl or command +home
                				case 37: if (event.ctrlKey || event.metaKey) {
                							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                						}
                						handled = event.ctrlKey || event.metaKey;
                						// -1 day on ctrl or command +left
                						if (event.originalEvent.altKey) {
                							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
                								-$.datepicker._get(inst, "stepBigMonths") :
                								-$.datepicker._get(inst, "stepMonths")), "M");
                						}
                						// next month/year on alt +left on Mac
                						break;
                				case 38: if (event.ctrlKey || event.metaKey) {
                							$.datepicker._adjustDate(event.target, -7, "D");
                						}
                						handled = event.ctrlKey || event.metaKey;
                						break; // -1 week on ctrl or command +up
                				case 39: if (event.ctrlKey || event.metaKey) {
                							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                						}
                						handled = event.ctrlKey || event.metaKey;
                						// +1 day on ctrl or command +right
                						if (event.originalEvent.altKey) {
                							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
                								+$.datepicker._get(inst, "stepBigMonths") :
                								+$.datepicker._get(inst, "stepMonths")), "M");
                						}
                						// next month/year on alt +right
                						break;
                				case 40: if (event.ctrlKey || event.metaKey) {
                							$.datepicker._adjustDate(event.target, +7, "D");
                						}
                						handled = event.ctrlKey || event.metaKey;
                						break; // +1 week on ctrl or command +down
                				default: handled = false;
                			}
                		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
                			$.datepicker._showDatepicker(this);
                		} else {
                			handled = false;
                		}
                
                		if (handled) {
                			event.preventDefault();
                			event.stopPropagation();
                		}
                	},
                
                	/* Filter entered characters - based on date format. */
                	_doKeyPress: function(event) {
                		var chars, chr,
                			inst = $.datepicker._getInst(event.target);
                
                		if ($.datepicker._get(inst, "constrainInput")) {
                			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
                		}
                	},
                
                	/* Synchronise manual entry and field/alternate field. */
                	_doKeyUp: function(event) {
                		var date,
                			inst = $.datepicker._getInst(event.target);
                
                		if (inst.input.val() !== inst.lastVal) {
                			try {
                				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                					(inst.input ? inst.input.val() : null),
                					$.datepicker._getFormatConfig(inst));
                
                				if (date) { // only if valid
                					$.datepicker._setDateFromField(inst);
                					$.datepicker._updateAlternate(inst);
                					$.datepicker._updateDatepicker(inst);
                				}
                			}
                			catch (err) {
                			}
                		}
                		return true;
                	},
                
                	/* Pop-up the date picker for a given input field.
                	 * If false returned from beforeShow event handler do not show.
                	 * @param  input  element - the input field attached to the date picker or
                	 *					event - if triggered by focus
                	 */
                	_showDatepicker: function(input) {
                		input = input.target || input;
                		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
                			input = $("input", input.parentNode)[0];
                		}
                
                		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
                			return;
                		}
                
                		var inst, beforeShow, beforeShowSettings, isFixed,
                			offset, showAnim, duration;
                
                		inst = $.datepicker._getInst(input);
                		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                			$.datepicker._curInst.dpDiv.stop(true, true);
                			if ( inst && $.datepicker._datepickerShowing ) {
                				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
                			}
                		}
                
                		beforeShow = $.datepicker._get(inst, "beforeShow");
                		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
                		if(beforeShowSettings === false){
                			return;
                		}
                		extendRemove(inst.settings, beforeShowSettings);
                
                		inst.lastVal = null;
                		$.datepicker._lastInput = input;
                		$.datepicker._setDateFromField(inst);
                
                		if ($.datepicker._inDialog) { // hide cursor
                			input.value = "";
                		}
                		if (!$.datepicker._pos) { // position below input
                			$.datepicker._pos = $.datepicker._findPos(input);
                			$.datepicker._pos[1] += input.offsetHeight; // add the height
                		}
                
                		isFixed = false;
                		$(input).parents().each(function() {
                			isFixed |= $(this).css("position") === "fixed";
                			return !isFixed;
                		});
                
                		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
                		$.datepicker._pos = null;
                		//to avoid flashes on Firefox
                		inst.dpDiv.empty();
                		// determine sizing offscreen
                		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
                		$.datepicker._updateDatepicker(inst);
                		// fix width for dynamic number of date pickers
                		// and adjust position before showing
                		offset = $.datepicker._checkOffset(inst, offset, isFixed);
                		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
                			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
                			left: offset.left + "px", top: offset.top + "px"});
                
                		if (!inst.inline) {
                			showAnim = $.datepicker._get(inst, "showAnim");
                			duration = $.datepicker._get(inst, "duration");
                			inst.dpDiv.zIndex($(input).zIndex()+1);
                			$.datepicker._datepickerShowing = true;
                
                			if ( $.effects && $.effects.effect[ showAnim ] ) {
                				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                			} else {
                				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                			}
                
                			if (inst.input.is(":visible") && !inst.input.is(":disabled")) {
                				inst.input.focus();
                			}
                			$.datepicker._curInst = inst;
                		}
                	},
                
                	/* Generate the date picker content. */
                	_updateDatepicker: function(inst) {
                		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
                		instActive = inst; // for delegate hover events
                		inst.dpDiv.empty().append(this._generateHTML(inst));
                		this._attachHandlers(inst);
                		inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();
                
                		var origyearshtml,
                			numMonths = this._getNumberOfMonths(inst),
                			cols = numMonths[1],
                			width = 17;
                
                		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
                		if (cols > 1) {
                			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
                		}
                		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
                			"Class"]("ui-datepicker-multi");
                		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
                			"Class"]("ui-datepicker-rtl");
                
                		// #6694 - don't focus the input if it's already focused
                		// this breaks the change event in IE
                		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
                			inst.input.is(":visible") && !inst.input.is(":disabled") && inst.input[0] !== document.activeElement) {
                			inst.input.focus();
                		}
                
                		// deffered render of the years select (to avoid flashes on Firefox)
                		if( inst.yearshtml ){
                			origyearshtml = inst.yearshtml;
                			setTimeout(function(){
                				//assure that inst.yearshtml didn't change.
                				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
                					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                				}
                				origyearshtml = inst.yearshtml = null;
                			}, 0);
                		}
                	},
                
                	/* Retrieve the size of left and top borders for an element.
                	 * @param  elem  (jQuery object) the element of interest
                	 * @return  (number[2]) the left and top borders
                	 */
                	_getBorders: function(elem) {
                		var convert = function(value) {
                			return {thin: 1, medium: 2, thick: 3}[value] || value;
                		};
                		return [parseFloat(convert(elem.css("border-left-width"))),
                			parseFloat(convert(elem.css("border-top-width")))];
                	},
                
                	/* Check positioning to remain on screen. */
                	_checkOffset: function(inst, offset, isFixed) {
                		var dpWidth = inst.dpDiv.outerWidth(),
                			dpHeight = inst.dpDiv.outerHeight(),
                			inputWidth = inst.input ? inst.input.outerWidth() : 0,
                			inputHeight = inst.input ? inst.input.outerHeight() : 0,
                			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
                			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
                
                		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
                		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
                		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;
                
                		// now check if datepicker is showing outside window viewport - move to a better place if so.
                		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
                			Math.abs(offset.left + dpWidth - viewWidth) : 0);
                		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                			Math.abs(dpHeight + inputHeight) : 0);
                
                		return offset;
                	},
                
                	/* Find an object's position on the screen. */
                	_findPos: function(obj) {
                		var position,
                			inst = this._getInst(obj),
                			isRTL = this._get(inst, "isRTL");
                
                		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
                		}
                
                		position = $(obj).offset();
                		return [position.left, position.top];
                	},
                
                	/* Hide the date picker from view.
                	 * @param  input  element - the input field attached to the date picker
                	 */
                	_hideDatepicker: function(input) {
                		var showAnim, duration, postProcess, onClose,
                			inst = this._curInst;
                
                		if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
                			return;
                		}
                
                		if (this._datepickerShowing) {
                			showAnim = this._get(inst, "showAnim");
                			duration = this._get(inst, "duration");
                			postProcess = function() {
                				$.datepicker._tidyDialog(inst);
                			};
                
                			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
                				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                			} else {
                				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
                					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
                			}
                
                			if (!showAnim) {
                				postProcess();
                			}
                			this._datepickerShowing = false;
                
                			onClose = this._get(inst, "onClose");
                			if (onClose) {
                				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
                			}
                
                			this._lastInput = null;
                			if (this._inDialog) {
                				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
                				if ($.blockUI) {
                					$.unblockUI();
                					$("body").append(this.dpDiv);
                				}
                			}
                			this._inDialog = false;
                		}
                	},
                
                	/* Tidy up after a dialog display. */
                	_tidyDialog: function(inst) {
                		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
                	},
                
                	/* Close date picker if clicked elsewhere. */
                	_checkExternalClick: function(event) {
                		if (!$.datepicker._curInst) {
                			return;
                		}
                
                		var $target = $(event.target),
                			inst = $.datepicker._getInst($target[0]);
                
                		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
                				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
                				!$target.hasClass($.datepicker.markerClassName) &&
                				!$target.closest("." + $.datepicker._triggerClass).length &&
                				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
                			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
                				$.datepicker._hideDatepicker();
                		}
                	},
                
                	/* Adjust one of the date sub-fields. */
                	_adjustDate: function(id, offset, period) {
                		var target = $(id),
                			inst = this._getInst(target[0]);
                
                		if (this._isDisabledDatepicker(target[0])) {
                			return;
                		}
                		this._adjustInstDate(inst, offset +
                			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
                			period);
                		this._updateDatepicker(inst);
                	},
                
                	/* Action for current link. */
                	_gotoToday: function(id) {
                		var date,
                			target = $(id),
                			inst = this._getInst(target[0]);
                
                		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                			inst.selectedDay = inst.currentDay;
                			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                			inst.drawYear = inst.selectedYear = inst.currentYear;
                		} else {
                			date = new Date();
                			inst.selectedDay = date.getDate();
                			inst.drawMonth = inst.selectedMonth = date.getMonth();
                			inst.drawYear = inst.selectedYear = date.getFullYear();
                		}
                		this._notifyChange(inst);
                		this._adjustDate(target);
                	},
                
                	/* Action for selecting a new month/year. */
                	_selectMonthYear: function(id, select, period) {
                		var target = $(id),
                			inst = this._getInst(target[0]);
                
                		inst["selected" + (period === "M" ? "Month" : "Year")] =
                		inst["draw" + (period === "M" ? "Month" : "Year")] =
                			parseInt(select.options[select.selectedIndex].value,10);
                
                		this._notifyChange(inst);
                		this._adjustDate(target);
                	},
                
                	/* Action for selecting a day. */
                	_selectDay: function(id, month, year, td) {
                		var inst,
                			target = $(id);
                
                		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                			return;
                		}
                
                		inst = this._getInst(target[0]);
                		inst.selectedDay = inst.currentDay = $("a", td).html();
                		inst.selectedMonth = inst.currentMonth = month;
                		inst.selectedYear = inst.currentYear = year;
                		this._selectDate(id, this._formatDate(inst,
                			inst.currentDay, inst.currentMonth, inst.currentYear));
                	},
                
                	/* Erase the input field and hide the date picker. */
                	_clearDate: function(id) {
                		var target = $(id);
                		this._selectDate(target, "");
                	},
                
                	/* Update the input field with the selected date. */
                	_selectDate: function(id, dateStr) {
                		var onSelect,
                			target = $(id),
                			inst = this._getInst(target[0]);
                
                		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
                		if (inst.input) {
                			inst.input.val(dateStr);
                		}
                		this._updateAlternate(inst);
                
                		onSelect = this._get(inst, "onSelect");
                		if (onSelect) {
                			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
                		} else if (inst.input) {
                			inst.input.trigger("change"); // fire the change event
                		}
                
                		if (inst.inline){
                			this._updateDatepicker(inst);
                		} else {
                			this._hideDatepicker();
                			this._lastInput = inst.input[0];
                			if (typeof(inst.input[0]) !== "object") {
                				inst.input.focus(); // restore focus
                			}
                			this._lastInput = null;
                		}
                	},
                
                	/* Update any alternate field to synchronise with the main field. */
                	_updateAlternate: function(inst) {
                		var altFormat, date, dateStr,
                			altField = this._get(inst, "altField");
                
                		if (altField) { // update alternate field too
                			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                			date = this._getDate(inst);
                			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                			$(altField).each(function() { $(this).val(dateStr); });
                		}
                	},
                
                	/* Set as beforeShowDay function to prevent selection of weekends.
                	 * @param  date  Date - the date to customise
                	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
                	 */
                	noWeekends: function(date) {
                		var day = date.getDay();
                		return [(day > 0 && day < 6), ""];
                	},
                
                	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
                	 * @param  date  Date - the date to get the week for
                	 * @return  number - the number of the week within the year that contains this date
                	 */
                	iso8601Week: function(date) {
                		var time,
                			checkDate = new Date(date.getTime());
                
                		// Find Thursday of this week starting on Monday
                		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                
                		time = checkDate.getTime();
                		checkDate.setMonth(0); // Compare with Jan 1
                		checkDate.setDate(1);
                		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
                	},
                
                	/* Parse a string value into a date object.
                	 * See formatDate below for the possible formats.
                	 *
                	 * @param  format string - the expected format of the date
                	 * @param  value string - the date in the above format
                	 * @param  settings Object - attributes include:
                	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
                	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
                	 *					dayNames		string[7] - names of the days from Sunday (optional)
                	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
                	 *					monthNames		string[12] - names of the months (optional)
                	 * @return  Date - the extracted date value or null if value is blank
                	 */
                	parseDate: function (format, value, settings) {
                		if (format == null || value == null) {
                			throw "Invalid arguments";
                		}
                
                		value = (typeof value === "object" ? value.toString() : value + "");
                		if (value === "") {
                			return null;
                		}
                
                		var iFormat, dim, extra,
                			iValue = 0,
                			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
                			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                			year = -1,
                			month = -1,
                			day = -1,
                			doy = -1,
                			literal = false,
                			date,
                			// Check whether a format character is doubled
                			lookAhead = function(match) {
                				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                				if (matches) {
                					iFormat++;
                				}
                				return matches;
                			},
                			// Extract a number from the string value
                			getNumber = function(match) {
                				var isDoubled = lookAhead(match),
                					size = (match === "@" ? 14 : (match === "!" ? 20 :
                					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                					digits = new RegExp("^\\d{1," + size + "}"),
                					num = value.substring(iValue).match(digits);
                				if (!num) {
                					throw "Missing number at position " + iValue;
                				}
                				iValue += num[0].length;
                				return parseInt(num[0], 10);
                			},
                			// Extract a name from the string value and convert to an index
                			getName = function(match, shortNames, longNames) {
                				var index = -1,
                					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                						return [ [k, v] ];
                					}).sort(function (a, b) {
                						return -(a[1].length - b[1].length);
                					});
                
                				$.each(names, function (i, pair) {
                					var name = pair[1];
                					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                						index = pair[0];
                						iValue += name.length;
                						return false;
                					}
                				});
                				if (index !== -1) {
                					return index + 1;
                				} else {
                					throw "Unknown name at position " + iValue;
                				}
                			},
                			// Confirm that a literal character matches the string value
                			checkLiteral = function() {
                				if (value.charAt(iValue) !== format.charAt(iFormat)) {
                					throw "Unexpected literal at position " + iValue;
                				}
                				iValue++;
                			};
                
                		for (iFormat = 0; iFormat < format.length; iFormat++) {
                			if (literal) {
                				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                					literal = false;
                				} else {
                					checkLiteral();
                				}
                			} else {
                				switch (format.charAt(iFormat)) {
                					case "d":
                						day = getNumber("d");
                						break;
                					case "D":
                						getName("D", dayNamesShort, dayNames);
                						break;
                					case "o":
                						doy = getNumber("o");
                						break;
                					case "m":
                						month = getNumber("m");
                						break;
                					case "M":
                						month = getName("M", monthNamesShort, monthNames);
                						break;
                					case "y":
                						year = getNumber("y");
                						break;
                					case "@":
                						date = new Date(getNumber("@"));
                						year = date.getFullYear();
                						month = date.getMonth() + 1;
                						day = date.getDate();
                						break;
                					case "!":
                						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                						year = date.getFullYear();
                						month = date.getMonth() + 1;
                						day = date.getDate();
                						break;
                					case "'":
                						if (lookAhead("'")){
                							checkLiteral();
                						} else {
                							literal = true;
                						}
                						break;
                					default:
                						checkLiteral();
                				}
                			}
                		}
                
                		if (iValue < value.length){
                			extra = value.substr(iValue);
                			if (!/^\s+/.test(extra)) {
                				throw "Extra/unparsed characters found in date: " + extra;
                			}
                		}
                
                		if (year === -1) {
                			year = new Date().getFullYear();
                		} else if (year < 100) {
                			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                				(year <= shortYearCutoff ? 0 : -100);
                		}
                
                		if (doy > -1) {
                			month = 1;
                			day = doy;
                			do {
                				dim = this._getDaysInMonth(year, month - 1);
                				if (day <= dim) {
                					break;
                				}
                				month++;
                				day -= dim;
                			} while (true);
                		}
                
                		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
                		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                			throw "Invalid date"; // E.g. 31/02/00
                		}
                		return date;
                	},
                
                	/* Standard date formats. */
                	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
                	COOKIE: "D, dd M yy",
                	ISO_8601: "yy-mm-dd",
                	RFC_822: "D, d M y",
                	RFC_850: "DD, dd-M-y",
                	RFC_1036: "D, d M y",
                	RFC_1123: "D, d M yy",
                	RFC_2822: "D, d M yy",
                	RSS: "D, d M y", // RFC 822
                	TICKS: "!",
                	TIMESTAMP: "@",
                	W3C: "yy-mm-dd", // ISO 8601
                
                	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
                		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),
                
                	/* Format a date object into a string value.
                	 * The format can be combinations of the following:
                	 * d  - day of month (no leading zero)
                	 * dd - day of month (two digit)
                	 * o  - day of year (no leading zeros)
                	 * oo - day of year (three digit)
                	 * D  - day name short
                	 * DD - day name long
                	 * m  - month of year (no leading zero)
                	 * mm - month of year (two digit)
                	 * M  - month name short
                	 * MM - month name long
                	 * y  - year (two digit)
                	 * yy - year (four digit)
                	 * @ - Unix timestamp (ms since 01/01/1970)
                	 * ! - Windows ticks (100ns since 01/01/0001)
                	 * "..." - literal text
                	 * '' - single quote
                	 *
                	 * @param  format string - the desired format of the date
                	 * @param  date Date - the date value to format
                	 * @param  settings Object - attributes include:
                	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
                	 *					dayNames		string[7] - names of the days from Sunday (optional)
                	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
                	 *					monthNames		string[12] - names of the months (optional)
                	 * @return  string - the date in the above format
                	 */
                	formatDate: function (format, date, settings) {
                		if (!date) {
                			return "";
                		}
                
                		var iFormat,
                			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                			// Check whether a format character is doubled
                			lookAhead = function(match) {
                				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                				if (matches) {
                					iFormat++;
                				}
                				return matches;
                			},
                			// Format a number, with leading zero if necessary
                			formatNumber = function(match, value, len) {
                				var num = "" + value;
                				if (lookAhead(match)) {
                					while (num.length < len) {
                						num = "0" + num;
                					}
                				}
                				return num;
                			},
                			// Format a name, short or long as requested
                			formatName = function(match, value, shortNames, longNames) {
                				return (lookAhead(match) ? longNames[value] : shortNames[value]);
                			},
                			output = "",
                			literal = false;
                
                		if (date) {
                			for (iFormat = 0; iFormat < format.length; iFormat++) {
                				if (literal) {
                					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                						literal = false;
                					} else {
                						output += format.charAt(iFormat);
                					}
                				} else {
                					switch (format.charAt(iFormat)) {
                						case "d":
                							output += formatNumber("d", date.getDate(), 2);
                							break;
                						case "D":
                							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                							break;
                						case "o":
                							output += formatNumber("o",
                								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                							break;
                						case "m":
                							output += formatNumber("m", date.getMonth() + 1, 2);
                							break;
                						case "M":
                							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                							break;
                						case "y":
                							output += (lookAhead("y") ? date.getFullYear() :
                								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                							break;
                						case "@":
                							output += date.getTime();
                							break;
                						case "!":
                							output += date.getTime() * 10000 + this._ticksTo1970;
                							break;
                						case "'":
                							if (lookAhead("'")) {
                								output += "'";
                							} else {
                								literal = true;
                							}
                							break;
                						default:
                							output += format.charAt(iFormat);
                					}
                				}
                			}
                		}
                		return output;
                	},
                
                	/* Extract all possible characters from the date format. */
                	_possibleChars: function (format) {
                		var iFormat,
                			chars = "",
                			literal = false,
                			// Check whether a format character is doubled
                			lookAhead = function(match) {
                				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                				if (matches) {
                					iFormat++;
                				}
                				return matches;
                			};
                
                		for (iFormat = 0; iFormat < format.length; iFormat++) {
                			if (literal) {
                				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                					literal = false;
                				} else {
                					chars += format.charAt(iFormat);
                				}
                			} else {
                				switch (format.charAt(iFormat)) {
                					case "d": case "m": case "y": case "@":
                						chars += "0123456789";
                						break;
                					case "D": case "M":
                						return null; // Accept anything
                					case "'":
                						if (lookAhead("'")) {
                							chars += "'";
                						} else {
                							literal = true;
                						}
                						break;
                					default:
                						chars += format.charAt(iFormat);
                				}
                			}
                		}
                		return chars;
                	},
                
                	/* Get a setting value, defaulting if necessary. */
                	_get: function(inst, name) {
                		return inst.settings[name] !== undefined ?
                			inst.settings[name] : this._defaults[name];
                	},
                
                	/* Parse existing date and initialise date picker. */
                	_setDateFromField: function(inst, noDefault) {
                		if (inst.input.val() === inst.lastVal) {
                			return;
                		}
                
                		var dateFormat = this._get(inst, "dateFormat"),
                			dates = inst.lastVal = inst.input ? inst.input.val() : null,
                			defaultDate = this._getDefaultDate(inst),
                			date = defaultDate,
                			settings = this._getFormatConfig(inst);
                
                		try {
                			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
                		} catch (event) {
                			dates = (noDefault ? "" : dates);
                		}
                		inst.selectedDay = date.getDate();
                		inst.drawMonth = inst.selectedMonth = date.getMonth();
                		inst.drawYear = inst.selectedYear = date.getFullYear();
                		inst.currentDay = (dates ? date.getDate() : 0);
                		inst.currentMonth = (dates ? date.getMonth() : 0);
                		inst.currentYear = (dates ? date.getFullYear() : 0);
                		this._adjustInstDate(inst);
                	},
                
                	/* Retrieve the default date shown on opening. */
                	_getDefaultDate: function(inst) {
                		return this._restrictMinMax(inst,
                			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
                	},
                
                	/* A date may be specified as an exact value or a relative one. */
                	_determineDate: function(inst, date, defaultDate) {
                		var offsetNumeric = function(offset) {
                				var date = new Date();
                				date.setDate(date.getDate() + offset);
                				return date;
                			},
                			offsetString = function(offset) {
                				try {
                					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                						offset, $.datepicker._getFormatConfig(inst));
                				}
                				catch (e) {
                					// Ignore
                				}
                
                				var date = (offset.toLowerCase().match(/^c/) ?
                					$.datepicker._getDate(inst) : null) || new Date(),
                					year = date.getFullYear(),
                					month = date.getMonth(),
                					day = date.getDate(),
                					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                					matches = pattern.exec(offset);
                
                				while (matches) {
                					switch (matches[2] || "d") {
                						case "d" : case "D" :
                							day += parseInt(matches[1],10); break;
                						case "w" : case "W" :
                							day += parseInt(matches[1],10) * 7; break;
                						case "m" : case "M" :
                							month += parseInt(matches[1],10);
                							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                							break;
                						case "y": case "Y" :
                							year += parseInt(matches[1],10);
                							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                							break;
                					}
                					matches = pattern.exec(offset);
                				}
                				return new Date(year, month, day);
                			},
                			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
                				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
                
                		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
                		if (newDate) {
                			newDate.setHours(0);
                			newDate.setMinutes(0);
                			newDate.setSeconds(0);
                			newDate.setMilliseconds(0);
                		}
                		return this._daylightSavingAdjust(newDate);
                	},
                
                	/* Handle switch to/from daylight saving.
                	 * Hours may be non-zero on daylight saving cut-over:
                	 * > 12 when midnight changeover, but then cannot generate
                	 * midnight datetime, so jump to 1AM, otherwise reset.
                	 * @param  date  (Date) the date to check
                	 * @return  (Date) the corrected date
                	 */
                	_daylightSavingAdjust: function(date) {
                		if (!date) {
                			return null;
                		}
                		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
                		return date;
                	},
                
                	/* Set the date(s) directly. */
                	_setDate: function(inst, date, noChange) {
                		var clear = !date,
                			origMonth = inst.selectedMonth,
                			origYear = inst.selectedYear,
                			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
                
                		inst.selectedDay = inst.currentDay = newDate.getDate();
                		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
                		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
                		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                			this._notifyChange(inst);
                		}
                		this._adjustInstDate(inst);
                		if (inst.input) {
                			inst.input.val(clear ? "" : this._formatDate(inst));
                		}
                	},
                
                	/* Retrieve the date(s) directly. */
                	_getDate: function(inst) {
                		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
                			this._daylightSavingAdjust(new Date(
                			inst.currentYear, inst.currentMonth, inst.currentDay)));
                			return startDate;
                	},
                
                	/* Attach the onxxx handlers.  These are declared statically so
                	 * they work with static code transformers like Caja.
                	 */
                	_attachHandlers: function(inst) {
                		var stepMonths = this._get(inst, "stepMonths"),
                			id = "#" + inst.id.replace( /\\\\/g, "\\" );
                		inst.dpDiv.find("[data-handler]").map(function () {
                			var handler = {
                				prev: function () {
                					window["DP_jQuery_" + dpuuid].datepicker._adjustDate(id, -stepMonths, "M");
                				},
                				next: function () {
                					window["DP_jQuery_" + dpuuid].datepicker._adjustDate(id, +stepMonths, "M");
                				},
                				hide: function () {
                					window["DP_jQuery_" + dpuuid].datepicker._hideDatepicker();
                				},
                				today: function () {
                					window["DP_jQuery_" + dpuuid].datepicker._gotoToday(id);
                				},
                				selectDay: function () {
                					window["DP_jQuery_" + dpuuid].datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                					return false;
                				},
                				selectMonth: function () {
                					window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(id, this, "M");
                					return false;
                				},
                				selectYear: function () {
                					window["DP_jQuery_" + dpuuid].datepicker._selectMonthYear(id, this, "Y");
                					return false;
                				}
                			};
                			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
                		});
                	},
                
                	/* Generate the HTML for the current state of the date picker. */
                	_generateHTML: function(inst) {
                		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                			tempDate = new Date(),
                			today = this._daylightSavingAdjust(
                				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
                			isRTL = this._get(inst, "isRTL"),
                			showButtonPanel = this._get(inst, "showButtonPanel"),
                			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
                			numMonths = this._getNumberOfMonths(inst),
                			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                			stepMonths = this._get(inst, "stepMonths"),
                			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
                			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
                			minDate = this._getMinMaxDate(inst, "min"),
                			maxDate = this._getMinMaxDate(inst, "max"),
                			drawMonth = inst.drawMonth - showCurrentAtPos,
                			drawYear = inst.drawYear;
                
                		if (drawMonth < 0) {
                			drawMonth += 12;
                			drawYear--;
                		}
                		if (maxDate) {
                			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
                			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                				drawMonth--;
                				if (drawMonth < 0) {
                					drawMonth = 11;
                					drawYear--;
                				}
                			}
                		}
                		inst.drawMonth = drawMonth;
                		inst.drawYear = drawYear;
                
                		prevText = this._get(inst, "prevText");
                		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
                			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
                			this._getFormatConfig(inst)));
                
                		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
                			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
                			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));
                
                		nextText = this._get(inst, "nextText");
                		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
                			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
                			this._getFormatConfig(inst)));
                
                		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
                			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
                			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));
                
                		currentText = this._get(inst, "currentText");
                		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
                		currentText = (!navigationAsDateFormat ? currentText :
                			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
                
                		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                			this._get(inst, "closeText") + "</button>" : "");
                
                		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
                			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
                
                		firstDay = parseInt(this._get(inst, "firstDay"),10);
                		firstDay = (isNaN(firstDay) ? 0 : firstDay);
                
                		showWeek = this._get(inst, "showWeek");
                		dayNames = this._get(inst, "dayNames");
                		dayNamesMin = this._get(inst, "dayNamesMin");
                		monthNames = this._get(inst, "monthNames");
                		monthNamesShort = this._get(inst, "monthNamesShort");
                		beforeShowDay = this._get(inst, "beforeShowDay");
                		showOtherMonths = this._get(inst, "showOtherMonths");
                		selectOtherMonths = this._get(inst, "selectOtherMonths");
                		defaultDate = this._getDefaultDate(inst);
                		html = "";
                		dow;
                		for (row = 0; row < numMonths[0]; row++) {
                			group = "";
                			this.maxRows = 4;
                			for (col = 0; col < numMonths[1]; col++) {
                				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                				cornerClass = " ui-corner-all";
                				calender = "";
                				if (isMultiMonth) {
                					calender += "<div class='ui-datepicker-group";
                					if (numMonths[1] > 1) {
                						switch (col) {
                							case 0: calender += " ui-datepicker-group-first";
                								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
                							case numMonths[1]-1: calender += " ui-datepicker-group-last";
                								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
                							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
                						}
                					}
                					calender += "'>";
                				}
                				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
                					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
                					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                					"</div><table class='ui-datepicker-calendar'><thead>" +
                					"<tr>";
                				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
                				for (dow = 0; dow < 7; dow++) { // days of the week
                					day = (dow + firstDay) % 7;
                					thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
                						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                				}
                				calender += thead + "</tr></thead><tbody>";
                				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                				}
                				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                				this.maxRows = numRows;
                				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                					calender += "<tr>";
                					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                						this._get(inst, "calculateWeek")(printDate) + "</td>");
                					for (dow = 0; dow < 7; dow++) { // create date picker days
                						daySettings = (beforeShowDay ?
                							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                						otherMonth = (printDate.getMonth() !== drawMonth);
                						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                						tbody += "<td class='" +
                							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
                							// or defaultDate is current printedDate and defaultDate is selectedDate
                							" " + this._dayOverClass : "") + // highlight selected day
                							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
                							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2] + "'" : "") + // cell title
                							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
                						printDate.setDate(printDate.getDate() + 1);
                						printDate = this._daylightSavingAdjust(printDate);
                					}
                					calender += tbody + "</tr>";
                				}
                				drawMonth++;
                				if (drawMonth > 11) {
                					drawMonth = 0;
                					drawYear++;
                				}
                				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                				group += calender;
                			}
                			html += group;
                		}
                		html += buttonPanel;
                		inst._keyEvent = false;
                		return html;
                	},
                
                	/* Generate the month and year header. */
                	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
                			secondary, monthNames, monthNamesShort) {
                
                		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                			changeMonth = this._get(inst, "changeMonth"),
                			changeYear = this._get(inst, "changeYear"),
                			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                			html = "<div class='ui-datepicker-title'>",
                			monthHtml = "";
                
                		// month selection
                		if (secondary || !changeMonth) {
                			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
                		} else {
                			inMinYear = (minDate && minDate.getFullYear() === drawYear);
                			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
                			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                			for ( month = 0; month < 12; month++) {
                				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                					monthHtml += "<option value='" + month + "'" +
                						(month === drawMonth ? " selected='selected'" : "") +
                						">" + monthNamesShort[month] + "</option>";
                				}
                			}
                			monthHtml += "</select>";
                		}
                
                		if (!showMonthAfterYear) {
                			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
                		}
                
                		// year selection
                		if ( !inst.yearshtml ) {
                			inst.yearshtml = "";
                			if (secondary || !changeYear) {
                				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                			} else {
                				// determine range of years to display
                				years = this._get(inst, "yearRange").split(":");
                				thisYear = new Date().getFullYear();
                				determineYear = function(value) {
                					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
                						parseInt(value, 10)));
                					return (isNaN(year) ? thisYear : year);
                				};
                				year = determineYear(years[0]);
                				endYear = Math.max(year, determineYear(years[1] || ""));
                				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                				for (; year <= endYear; year++) {
                					inst.yearshtml += "<option value='" + year + "'" +
                						(year === drawYear ? " selected='selected'" : "") +
                						">" + year + "</option>";
                				}
                				inst.yearshtml += "</select>";
                
                				html += inst.yearshtml;
                				inst.yearshtml = null;
                			}
                		}
                
                		html += this._get(inst, "yearSuffix");
                		if (showMonthAfterYear) {
                			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
                		}
                		html += "</div>"; // Close datepicker_header
                		return html;
                	},
                
                	/* Adjust one of the date sub-fields. */
                	_adjustInstDate: function(inst, offset, period) {
                		var year = inst.drawYear + (period === "Y" ? offset : 0),
                			month = inst.drawMonth + (period === "M" ? offset : 0),
                			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
                			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
                
                		inst.selectedDay = date.getDate();
                		inst.drawMonth = inst.selectedMonth = date.getMonth();
                		inst.drawYear = inst.selectedYear = date.getFullYear();
                		if (period === "M" || period === "Y") {
                			this._notifyChange(inst);
                		}
                	},
                
                	/* Ensure a date is within any min/max bounds. */
                	_restrictMinMax: function(inst, date) {
                		var minDate = this._getMinMaxDate(inst, "min"),
                			maxDate = this._getMinMaxDate(inst, "max"),
                			newDate = (minDate && date < minDate ? minDate : date);
                		return (maxDate && newDate > maxDate ? maxDate : newDate);
                	},
                
                	/* Notify change of month/year. */
                	_notifyChange: function(inst) {
                		var onChange = this._get(inst, "onChangeMonthYear");
                		if (onChange) {
                			onChange.apply((inst.input ? inst.input[0] : null),
                				[inst.selectedYear, inst.selectedMonth + 1, inst]);
                		}
                	},
                
                	/* Determine the number of months to show. */
                	_getNumberOfMonths: function(inst) {
                		var numMonths = this._get(inst, "numberOfMonths");
                		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
                	},
                
                	/* Determine the current maximum date - ensure no time components are set. */
                	_getMinMaxDate: function(inst, minMax) {
                		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
                	},
                
                	/* Find the number of days in a given month. */
                	_getDaysInMonth: function(year, month) {
                		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
                	},
                
                	/* Find the day of the week of the first of a month. */
                	_getFirstDayOfMonth: function(year, month) {
                		return new Date(year, month, 1).getDay();
                	},
                
                	/* Determines if we should allow a "next/prev" month display change. */
                	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
                		var numMonths = this._getNumberOfMonths(inst),
                			date = this._daylightSavingAdjust(new Date(curYear,
                			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
                
                		if (offset < 0) {
                			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
                		}
                		return this._isInRange(inst, date);
                	},
                
                	/* Is the given date in the accepted range? */
                	_isInRange: function(inst, date) {
                		var yearSplit, currentYear,
                			minDate = this._getMinMaxDate(inst, "min"),
                			maxDate = this._getMinMaxDate(inst, "max"),
                			minYear = null,
                			maxYear = null,
                			years = this._get(inst, "yearRange");
                			if (years){
                				yearSplit = years.split(":");
                				currentYear = new Date().getFullYear();
                				minYear = parseInt(yearSplit[0], 10) + currentYear;
                				maxYear = parseInt(yearSplit[1], 10) + currentYear;
                			}
                
                		return ((!minDate || date.getTime() >= minDate.getTime()) &&
                			(!maxDate || date.getTime() <= maxDate.getTime()) &&
                			(!minYear || date.getFullYear() >= minYear) &&
                			(!maxYear || date.getFullYear() <= maxYear));
                	},
                
                	/* Provide the configuration settings for formatting/parsing. */
                	_getFormatConfig: function(inst) {
                		var shortYearCutoff = this._get(inst, "shortYearCutoff");
                		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
                			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
                		return {shortYearCutoff: shortYearCutoff,
                			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
                			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
                	},
                
                	/* Format the given date for display. */
                	_formatDate: function(inst, day, month, year) {
                		if (!day) {
                			inst.currentDay = inst.selectedDay;
                			inst.currentMonth = inst.selectedMonth;
                			inst.currentYear = inst.selectedYear;
                		}
                		var date = (day ? (typeof day === "object" ? day :
                			this._daylightSavingAdjust(new Date(year, month, day))) :
                			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
                		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
                	}
                });
                
                /*
                 * Bind hover events for datepicker elements.
                 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
                 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
                 */
                function bindHover(dpDiv) {
                	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
                	return dpDiv.delegate(selector, "mouseout", function() {
                			$(this).removeClass("ui-state-hover");
                			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                				$(this).removeClass("ui-datepicker-prev-hover");
                			}
                			if (this.className.indexOf("ui-datepicker-next") !== -1) {
                				$(this).removeClass("ui-datepicker-next-hover");
                			}
                		})
                		.delegate(selector, "mouseover", function(){
                			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
                				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                				$(this).addClass("ui-state-hover");
                				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                					$(this).addClass("ui-datepicker-prev-hover");
                				}
                				if (this.className.indexOf("ui-datepicker-next") !== -1) {
                					$(this).addClass("ui-datepicker-next-hover");
                				}
                			}
                		});
                }
                
                /* jQuery extend now ignores nulls! */
                function extendRemove(target, props) {
                	$.extend(target, props);
                	for (var name in props) {
                		if (props[name] == null) {
                			target[name] = props[name];
                		}
                	}
                	return target;
                }
                
                /* Invoke the datepicker functionality.
                   @param  options  string - a command, optionally followed by additional parameters or
                					Object - settings for attaching new datepicker functionality
                   @return  jQuery object */
                $.fn.datepicker = function(options){
                
                	/* Verify an empty collection wasn't passed - Fixes #6976 */
                	if ( !this.length ) {
                		return this;
                	}
                
                	/* Initialise the date picker. */
                	if (!$.datepicker.initialized) {
                		$(document).mousedown($.datepicker._checkExternalClick);
                		$.datepicker.initialized = true;
                	}
                
                	/* Append datepicker main container to body if not exist. */
                	if ($("#"+$.datepicker._mainDivId).length === 0) {
                		$("body").append($.datepicker.dpDiv);
                	}
                
                	var otherArgs = Array.prototype.slice.call(arguments, 1);
                	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
                		return $.datepicker["_" + options + "Datepicker"].
                			apply($.datepicker, [this[0]].concat(otherArgs));
                	}
                	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
                		return $.datepicker["_" + options + "Datepicker"].
                			apply($.datepicker, [this[0]].concat(otherArgs));
                	}
                	return this.each(function() {
                		typeof options === "string" ?
                			$.datepicker["_" + options + "Datepicker"].
                				apply($.datepicker, [this].concat(otherArgs)) :
                			$.datepicker._attachDatepicker(this, options);
                	});
                };
                
                $.datepicker = new Datepicker(); // singleton instance
                $.datepicker.initialized = false;
                $.datepicker.uuid = new Date().getTime();
                $.datepicker.version = "1.10.0";
                
                // Workaround for #4055
                // Add another global to avoid noConflict issues with inline event handlers
                window["DP_jQuery_" + dpuuid] = $;
                
                })(jQuery);
                
                });
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/date_picker',["underscore", "jquery", "jquery_ui/datepicker", "common/collection", "common/continuum_view", "common/has_properties"], function(_, $, $1, Collection, ContinuumView, HasProperties) {
                    var DatePicker, DatePickerView, DatePickers, _ref, _ref1, _ref2;
                    DatePickerView = (function(_super) {
                      __extends(DatePickerView, _super);
                
                      function DatePickerView() {
                        this.onSelect = __bind(this.onSelect, this);
                        _ref = DatePickerView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DatePickerView.prototype.initialize = function(options) {
                        DatePickerView.__super__.initialize.call(this, options);
                        return this.render();
                      };
                
                      DatePickerView.prototype.render = function() {
                        var $datepicker, $label;
                        this.$el.empty();
                        $label = $('<label>').text(this.mget("title"));
                        $datepicker = $("<div>").datepicker({
                          defaultDate: new Date(this.mget('value')),
                          minDate: this.mget('min_date') != null ? new Date(this.mget('min_date')) : null,
                          maxDate: this.mget('max_date') != null ? new Date(this.mget('max_date')) : null,
                          onSelect: this.onSelect
                        });
                        return this.$el.append([$label, $datepicker]);
                      };
                
                      DatePickerView.prototype.onSelect = function(dateText, ui) {
                        this.mset('value', new Date(dateText));
                        return this.model.save();
                      };
                
                      return DatePickerView;
                
                    })(ContinuumView);
                    DatePicker = (function(_super) {
                      __extends(DatePicker, _super);
                
                      function DatePicker() {
                        _ref1 = DatePicker.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      DatePicker.prototype.type = "DatePicker";
                
                      DatePicker.prototype.default_view = DatePickerView;
                
                      DatePicker.prototype.defaults = function() {
                        return _.extend({}, DatePicker.__super__.defaults.call(this), {
                          value: Date.now()
                        });
                      };
                
                      return DatePicker;
                
                    })(HasProperties);
                    DatePickers = (function(_super) {
                      __extends(DatePickers, _super);
                
                      function DatePickers() {
                        _ref2 = DatePickers.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      DatePickers.prototype.model = DatePicker;
                
                      return DatePickers;
                
                    })(Collection);
                    return {
                      Model: DatePicker,
                      Collection: new DatePickers(),
                      View: DatePickerView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=date_picker.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/panel',["underscore", "jquery", "common/collection", "common/continuum_view", "common/has_properties"], function(_, $, Collection, ContinuumView, HasProperties) {
                    var Panel, PanelView, Panels, _ref, _ref1, _ref2;
                    PanelView = (function(_super) {
                      __extends(PanelView, _super);
                
                      function PanelView() {
                        _ref = PanelView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PanelView.prototype.initialize = function(options) {
                        PanelView.__super__.initialize.call(this, options);
                        return this.render();
                      };
                
                      PanelView.prototype.render = function() {
                        return this.$el.empty();
                      };
                
                      return PanelView;
                
                    })(ContinuumView);
                    Panel = (function(_super) {
                      __extends(Panel, _super);
                
                      function Panel() {
                        _ref1 = Panel.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Panel.prototype.type = "Panel";
                
                      Panel.prototype.default_view = PanelView;
                
                      Panel.prototype.defaults = function() {
                        return _.extend({}, Panel.__super__.defaults.call(this), {
                          title: "",
                          child: null,
                          closable: false
                        });
                      };
                
                      return Panel;
                
                    })(HasProperties);
                    Panels = (function(_super) {
                      __extends(Panels, _super);
                
                      function Panels() {
                        _ref2 = Panels.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Panels.prototype.model = Panel;
                
                      return Panels;
                
                    })(Collection);
                    return {
                      Model: Panel,
                      Collection: new Panels(),
                      View: PanelView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=panel.js.map
                */;
                define('bootstrap/tab',["jquery"], function(jQuery) {
                
                /* ========================================================================
                 * Bootstrap: tab.js v3.1.1
                 * http://getbootstrap.com/javascript/#tabs
                 * ========================================================================
                 * Copyright 2011-2014 Twitter, Inc.
                 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
                 * ======================================================================== */
                
                
                +function ($) {
                  
                
                  // TAB CLASS DEFINITION
                  // ====================
                
                  var Tab = function (element) {
                    this.element = $(element)
                  }
                
                  Tab.prototype.show = function () {
                    var $this    = this.element
                    var $ul      = $this.closest('ul:not(.bk-bs-dropdown-menu)')
                    var selector = $this.data('bk-bs-target')
                
                    if (!selector) {
                      selector = $this.attr('href')
                      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
                    }
                
                    if ($this.parent('li').hasClass('bk-bs-active')) return
                
                    var previous = $ul.find('.bk-bs-active:last a')[0]
                    var e        = $.Event('show.bk-bs.tab', {
                      relatedTarget: previous
                    })
                
                    $this.trigger(e)
                
                    if (e.isDefaultPrevented()) return
                
                    var $target = $(selector)
                
                    this.activate($this.parent('li'), $ul)
                    this.activate($target, $target.parent(), function () {
                      $this.trigger({
                        type: 'shown.bk-bs.tab',
                        relatedTarget: previous
                      })
                    })
                  }
                
                  Tab.prototype.activate = function (element, container, callback) {
                    var $active    = container.find('> .bk-bs-active')
                    var transition = callback
                      && $.support.transition
                      && $active.hasClass('bk-bs-fade')
                
                    function next() {
                      $active
                        .removeClass('bk-bs-active')
                        .find('> .bk-bs-dropdown-menu > .bk-bs-active')
                        .removeClass('bk-bs-active')
                
                      element.addClass('bk-bs-active')
                
                      if (transition) {
                        element[0].offsetWidth // reflow for transition
                        element.addClass('bk-bs-in')
                      } else {
                        element.removeClass('bk-bs-fade')
                      }
                
                      if (element.parent('.bk-bs-dropdown-menu')) {
                        element.closest('li.bk-bs-dropdown').addClass('bk-bs-active')
                      }
                
                      callback && callback()
                    }
                
                    transition ?
                      $active
                        .one($.support.transition.end, next)
                        .emulateTransitionEnd(150) :
                      next()
                
                    $active.removeClass('bk-bs-in')
                  }
                
                
                  // TAB PLUGIN DEFINITION
                  // =====================
                
                  var old = $.fn.tab
                
                  $.fn.tab = function ( option ) {
                    return this.each(function () {
                      var $this = $(this)
                      var data  = $this.data('bk-bs.tab')
                
                      if (!data) $this.data('bk-bs.tab', (data = new Tab(this)))
                      if (typeof option == 'string') data[option]()
                    })
                  }
                
                  $.fn.tab.Constructor = Tab
                
                
                  // TAB NO CONFLICT
                  // ===============
                
                  $.fn.tab.noConflict = function () {
                    $.fn.tab = old
                    return this
                  }
                
                
                  // TAB DATA-API
                  // ============
                
                  $(document).on('click.bk-bs.tab.data-api', '[data-bk-bs-toggle="tab"], [data-bk-bs-toggle="pill"]', function (e) {
                    e.preventDefault()
                    $(this).tab('show')
                  })
                
                }(jQuery);
                
                });
                
                define('widget/tabs_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      var i, tab, _i, _j, _len, _len1, _ref, _ref1;
                    
                      _print(_safe('<ul class="bk-bs-nav bk-bs-nav-tabs">\n  '));
                    
                      _ref = this.tabs;
                      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                        tab = _ref[i];
                        _print(_safe('\n    <li class="'));
                        _print(this.active(i));
                        _print(_safe('">\n      <a href="#tab-'));
                        _print(tab.get('id'));
                        _print(_safe('">'));
                        _print(tab.get('title'));
                        _print(_safe('</a>\n    </li>\n  '));
                      }
                    
                      _print(_safe('\n</ul>\n<div class="bk-bs-tab-content">\n  '));
                    
                      _ref1 = this.tabs;
                      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                        tab = _ref1[i];
                        _print(_safe('\n    <div class="bk-bs-tab-pane '));
                        _print(this.active(i));
                        _print(_safe('" id="tab-'));
                        _print(tab.get('id'));
                        _print(_safe('"></div>\n  '));
                      }
                    
                      _print(_safe('\n</div>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/tabs',["underscore", "jquery", "bootstrap/tab", "common/collection", "common/continuum_view", "common/has_properties", "common/build_views", "./tabs_template"], function(_, $, $1, Collection, ContinuumView, HasProperties, build_views, tabs_template) {
                    var Tabs, TabsView, Tabses, _ref, _ref1, _ref2;
                    TabsView = (function(_super) {
                      __extends(TabsView, _super);
                
                      function TabsView() {
                        _ref = TabsView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      TabsView.prototype.initialize = function(options) {
                        TabsView.__super__.initialize.call(this, options);
                        this.views = {};
                        return this.render();
                      };
                
                      TabsView.prototype.render = function() {
                        var $panels, active, child, children, html, key, panel, tab, tabs, val, _i, _len, _ref1, _ref2, _ref3;
                        _ref1 = this.views;
                        for (key in _ref1) {
                          if (!__hasProp.call(_ref1, key)) continue;
                          val = _ref1[key];
                          val.$el.detach();
                        }
                        this.$el.empty();
                        tabs = this.mget('tabs');
                        active = this.mget("active");
                        children = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = tabs.length; _i < _len; _i++) {
                            tab = tabs[_i];
                            _results.push(tab.get("child"));
                          }
                          return _results;
                        })();
                        build_views(this.views, children);
                        html = $(tabs_template({
                          tabs: tabs,
                          active: function(i) {
                            if (i === active) {
                              return 'bk-bs-active';
                            } else {
                              return '';
                            }
                          }
                        }));
                        html.find("> li > a").click(function(event) {
                          event.preventDefault();
                          return $(this).tab('show');
                        });
                        $panels = html.children(".bk-bs-tab-pane");
                        _ref2 = _.zip(children, $panels);
                        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                          _ref3 = _ref2[_i], child = _ref3[0], panel = _ref3[1];
                          $(panel).html(this.views[child.id].$el);
                        }
                        this.$el.append(html);
                        return this.$el.tabs;
                      };
                
                      return TabsView;
                
                    })(ContinuumView);
                    Tabs = (function(_super) {
                      __extends(Tabs, _super);
                
                      function Tabs() {
                        _ref1 = Tabs.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Tabs.prototype.type = "Tabs";
                
                      Tabs.prototype.default_view = TabsView;
                
                      Tabs.prototype.defaults = function() {
                        return _.extend({}, Tabs.__super__.defaults.call(this), {
                          tabs: [],
                          active: 0
                        });
                      };
                
                      return Tabs;
                
                    })(HasProperties);
                    Tabses = (function(_super) {
                      __extends(Tabses, _super);
                
                      function Tabses() {
                        _ref2 = Tabses.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Tabses.prototype.model = Tabs;
                
                      return Tabses;
                
                    })(Collection);
                    return {
                      Model: Tabs,
                      Collection: new Tabses(),
                      View: TabsView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=tabs.js.map
                */;
                define('widget/dialog_template',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      var button, i, _i, _len, _ref;
                    
                      _print(_safe('<div class="bk-bs-modal" tabindex="-1">\n  <div class="bk-bs-modal-dialog">\n    <div class="bk-bs-modal-content">\n      <div class="bk-bs-modal-header">\n        '));
                    
                      if (this.closable) {
                        _print(_safe('\n          <button type="button" class="bk-bs-close" data-bk-bs-dismiss="modal">&times;</button>\n        '));
                      }
                    
                      _print(_safe('\n        <h4 class="bk-bs-modal-title">'));
                    
                      _print(this.title);
                    
                      _print(_safe('</h4>\n      </div>\n      <div class="bk-bs-modal-body">\n        '));
                    
                      _print(this.content);
                    
                      _print(_safe('\n      </div>\n      <div class="bk-bs-modal-footer">\n        '));
                    
                      _ref = this.buttons;
                      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                        button = _ref[i];
                        _print(_safe('\n          '));
                        if (i === 0) {
                          _print(_safe('\n            <button type="button" class="bk-bs-btn bk-bs-btn-primary" data-bk-bs-dismiss="modal">'));
                          _print(button);
                          _print(_safe('</button>\n          '));
                        } else {
                          _print(_safe('\n            <button type="button" class="bk-bs-btn bk-bs-btn-default">'));
                          _print(button);
                          _print(_safe('</button>\n          '));
                        }
                        _print(_safe('\n        '));
                      }
                    
                      _print(_safe('\n      </div>\n    </div>\n  </div>\n</div>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
                    __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/dialog',["underscore", "common/collection", "jquery", "bootstrap/modal", "common/has_properties", "common/continuum_view", "./dialog_template"], function(_, Collection, $, $1, HasProperties, ContinuumView, dialog_template) {
                    var Dialog, DialogView, Dialogs, _ref, _ref1, _ref2;
                    DialogView = (function(_super) {
                      __extends(DialogView, _super);
                
                      function DialogView() {
                        this.changeContent = __bind(this.changeContent, this);
                        this.changeVisibility = __bind(this.changeVisibility, this);
                        this.onHide = __bind(this.onHide, this);
                        _ref = DialogView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DialogView.prototype.initialize = function(options) {
                        DialogView.__super__.initialize.call(this, options);
                        this.render();
                        this.listenTo(this.model, 'destroy', this.remove);
                        this.listenTo(this.model, 'change:visible', this.changeVisibility);
                        return this.listenTo(this.model, 'change:content', this.changeContent);
                      };
                
                      DialogView.prototype.render = function() {
                        this.$modal = $(dialog_template(this.model.attributes));
                        this.$modal.modal({
                          show: this.mget("visible")
                        });
                        this.$modal.on('hidden.bk-bs.modal', this.onHide);
                        return this.$el.html(this.$modal);
                      };
                
                      DialogView.prototype.onHide = function(event) {
                        return this.mset("visible", false, {
                          silent: true
                        });
                      };
                
                      DialogView.prototype.changeVisibility = function() {
                        return this.$modal.modal(this.mget("visible") ? "show" : "hide");
                      };
                
                      DialogView.prototype.changeContent = function() {
                        return this.$modal.find(".bk-bs-modal-body").text(this.mget("content"));
                      };
                
                      return DialogView;
                
                    })(ContinuumView);
                    Dialog = (function(_super) {
                      __extends(Dialog, _super);
                
                      function Dialog() {
                        _ref1 = Dialog.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Dialog.prototype.type = "Dialog";
                
                      Dialog.prototype.default_view = DialogView;
                
                      Dialog.prototype.defaults = function() {
                        return _.extend({}, Dialog.__super__.defaults.call(this), {
                          visible: false,
                          closable: true,
                          title: "",
                          content: "",
                          buttons: []
                        });
                      };
                
                      return Dialog;
                
                    })(HasProperties);
                    Dialogs = (function(_super) {
                      __extends(Dialogs, _super);
                
                      function Dialogs() {
                        _ref2 = Dialogs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Dialogs.prototype.model = Dialog;
                
                      return Dialogs;
                
                    })(Collection);
                    return {
                      Model: Dialog,
                      Collection: new Dialogs(),
                      View: DialogView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=dialog.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/icon',["underscore", "common/collection", "common/continuum_view", "common/has_parent", "common/logging"], function(_, Collection, ContinuumView, HasParent, Logging) {
                    var Icon, IconView, Icons, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    IconView = (function(_super) {
                      __extends(IconView, _super);
                
                      function IconView() {
                        _ref = IconView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      IconView.prototype.tagName = "i";
                
                      IconView.prototype.initialize = function(options) {
                        IconView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      IconView.prototype.render = function() {
                        var flip, size;
                        this.$el.empty();
                        this.$el.addClass("bk-fa");
                        this.$el.addClass("bk-fa-" + this.mget("name"));
                        size = this.mget("size");
                        if (size != null) {
                          this.$el.css({
                            "font-size": size + "em"
                          });
                        }
                        flip = this.mget("flip");
                        if (flip != null) {
                          this.$el.addClass("bk-fa-flip-" + flip);
                        }
                        if (this.mget("spin")) {
                          this.$el.addClass("bk-fa-spin");
                        }
                        return this;
                      };
                
                      return IconView;
                
                    })(ContinuumView);
                    Icon = (function(_super) {
                      __extends(Icon, _super);
                
                      function Icon() {
                        _ref1 = Icon.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Icon.prototype.type = "Icon";
                
                      Icon.prototype.default_view = IconView;
                
                      Icon.prototype.defaults = function() {
                        return _.extend({}, Icon.__super__.defaults.call(this), {
                          name: "",
                          size: null,
                          flip: null,
                          spin: false
                        });
                      };
                
                      return Icon;
                
                    })(HasParent);
                    Icons = (function(_super) {
                      __extends(Icons, _super);
                
                      function Icons() {
                        _ref2 = Icons.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Icons.prototype.model = Icon;
                
                      return Icons;
                
                    })(Collection);
                    return {
                      Model: Icon,
                      Collection: new Icons(),
                      View: IconView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=icon.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/button',["underscore", "common/collection", "common/continuum_view", "common/has_parent", "common/build_views", "common/logging"], function(_, Collection, ContinuumView, HasParent, build_views, Logging) {
                    var Button, ButtonView, Buttons, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    ButtonView = (function(_super) {
                      __extends(ButtonView, _super);
                
                      function ButtonView() {
                        _ref = ButtonView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ButtonView.prototype.tagName = "button";
                
                      ButtonView.prototype.events = {
                        "click": "change_input"
                      };
                
                      ButtonView.prototype.change_input = function() {
                        this.mset('clicks', this.mget('clicks') + 1);
                        return this.model.save();
                      };
                
                      ButtonView.prototype.initialize = function(options) {
                        ButtonView.__super__.initialize.call(this, options);
                        this.views = {};
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      ButtonView.prototype.render = function() {
                        var icon, key, label, val, _ref1;
                        icon = this.mget('icon');
                        if (icon != null) {
                          build_views(this.views, [icon]);
                          _ref1 = this.views;
                          for (key in _ref1) {
                            if (!__hasProp.call(_ref1, key)) continue;
                            val = _ref1[key];
                            val.$el.detach();
                          }
                        }
                        this.$el.empty();
                        this.$el.addClass("bk-bs-btn");
                        this.$el.addClass("bk-bs-btn-" + this.mget("type"));
                        if (this.mget("disabled")) {
                          this.$el.attr("disabled", "disabled");
                        }
                        label = this.mget("label");
                        if (icon != null) {
                          this.$el.append(this.views[icon.id].$el);
                          label = " " + label;
                        }
                        this.$el.append(document.createTextNode(label));
                        return this;
                      };
                
                      return ButtonView;
                
                    })(ContinuumView);
                    Button = (function(_super) {
                      __extends(Button, _super);
                
                      function Button() {
                        _ref1 = Button.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Button.prototype.type = "Button";
                
                      Button.prototype.default_view = ButtonView;
                
                      Button.prototype.defaults = function() {
                        return _.extend({}, Button.__super__.defaults.call(this), {
                          clicks: 0,
                          label: "Button",
                          icon: null,
                          type: "default",
                          disabled: false
                        });
                      };
                
                      return Button;
                
                    })(HasParent);
                    Buttons = (function(_super) {
                      __extends(Buttons, _super);
                
                      function Buttons() {
                        _ref2 = Buttons.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Buttons.prototype.model = Button;
                
                      return Buttons;
                
                    })(Collection);
                    return {
                      Model: Button,
                      Collection: new Buttons(),
                      View: ButtonView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=button.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/toggle',["underscore", "common/collection", "common/continuum_view", "common/has_parent", "common/logging"], function(_, Collection, ContinuumView, HasParent, Logging) {
                    var Toggle, ToggleView, Toggles, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    ToggleView = (function(_super) {
                      __extends(ToggleView, _super);
                
                      function ToggleView() {
                        _ref = ToggleView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ToggleView.prototype.tagName = "button";
                
                      ToggleView.prototype.events = {
                        "click": "change_input"
                      };
                
                      ToggleView.prototype.change_input = function() {
                        this.mset('active', this.$el.hasClass("bk-bs-active"));
                        return this.model.save();
                      };
                
                      ToggleView.prototype.initialize = function(options) {
                        ToggleView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      ToggleView.prototype.render = function() {
                        var icon, key, label, val, _ref1;
                        icon = this.mget('icon');
                        if (icon != null) {
                          build_views(this.views, [icon]);
                          _ref1 = this.views;
                          for (key in _ref1) {
                            if (!__hasProp.call(_ref1, key)) continue;
                            val = _ref1[key];
                            val.$el.detach();
                          }
                        }
                        this.$el.empty();
                        this.$el.addClass("bk-bs-btn");
                        this.$el.addClass("bk-bs-btn-" + this.mget("type"));
                        if (this.mget("disabled")) {
                          this.$el.attr("disabled", "disabled");
                        }
                        label = this.mget("label");
                        if (icon != null) {
                          this.$el.append(this.views[icon.id].$el);
                          label = " " + label;
                        }
                        this.$el.append(document.createTextNode(label));
                        if (this.mget("active")) {
                          this.$el.addClass("bk-bs-active");
                        }
                        this.$el.attr("data-bk-bs-toggle", "button");
                        return this;
                      };
                
                      return ToggleView;
                
                    })(ContinuumView);
                    Toggle = (function(_super) {
                      __extends(Toggle, _super);
                
                      function Toggle() {
                        _ref1 = Toggle.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Toggle.prototype.type = "Toggle";
                
                      Toggle.prototype.default_view = ToggleView;
                
                      Toggle.prototype.defaults = function() {
                        return _.extend({}, Toggle.__super__.defaults.call(this), {
                          active: false,
                          label: "Toggle",
                          icon: null,
                          type: "default",
                          disabled: false
                        });
                      };
                
                      return Toggle;
                
                    })(HasParent);
                    Toggles = (function(_super) {
                      __extends(Toggles, _super);
                
                      function Toggles() {
                        _ref2 = Toggles.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Toggles.prototype.model = Toggle;
                
                      return Toggles;
                
                    })(Collection);
                    return {
                      Model: Toggle,
                      Collection: new Toggles(),
                      View: ToggleView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=toggle.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/dropdown',["underscore", "common/collection", "common/continuum_view", "common/has_parent", "common/logging"], function(_, Collection, ContinuumView, HasParent, Logging) {
                    var Dropdown, DropdownView, Dropdowns, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    DropdownView = (function(_super) {
                      __extends(DropdownView, _super);
                
                      function DropdownView() {
                        _ref = DropdownView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DropdownView.prototype.tagName = "div";
                
                      DropdownView.prototype.change_input = function(action) {
                        this.mset('action', action);
                        return this.model.save();
                      };
                
                      DropdownView.prototype.initialize = function(options) {
                        DropdownView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      DropdownView.prototype.render = function() {
                        var $a, $button, $caret, $divider, $item, $menu, $toggle, action, item, label, split, _i, _len, _ref1,
                          _this = this;
                        this.$el.empty();
                        split = this.mget("default_action") != null;
                        $button = $('<button></button>');
                        $button.addClass("bk-bs-btn");
                        $button.addClass("bk-bs-btn-" + this.mget("type"));
                        $button.text(this.mget("label"));
                        $caret = $('<span class="bk-bs-caret"></span>');
                        if (!split) {
                          $button.addClass("bk-bs-dropdown-toggle");
                          $button.attr("data-bk-bs-toggle", "dropdown");
                          $button.append(document.createTextNode(" "));
                          $button.append($caret);
                          $toggle = $('');
                        } else {
                          $button.click(function() {
                            return _this.change_input(_this.mget("default_action"));
                          });
                          $toggle = $('<button></button>');
                          $toggle.addClass("bk-bs-btn");
                          $toggle.addClass("bk-bs-btn-" + this.mget("type"));
                          $toggle.addClass("bk-bs-dropdown-toggle");
                          $toggle.attr("data-bk-bs-toggle", "dropdown");
                          $toggle.append($caret);
                        }
                        $menu = $('<ul class="bk-bs-dropdown-menu"></ul>');
                        $divider = $('<li class="bk-bs-divider"></li>');
                        _ref1 = this.mget("menu");
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          item = _ref1[_i];
                          $item = item != null ? ((label = item[0], action = item[1], item), $a = $('<a></a>').text(label), $a.click(function() {
                            return _this.change_input(action);
                          }), $('<li></li>').append($a)) : $divider;
                          $menu.append($item);
                        }
                        this.$el.addClass("bk-bs-btn-group");
                        this.$el.append([$button, $toggle, $menu]);
                        return this;
                      };
                
                      return DropdownView;
                
                    })(ContinuumView);
                    Dropdown = (function(_super) {
                      __extends(Dropdown, _super);
                
                      function Dropdown() {
                        _ref1 = Dropdown.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Dropdown.prototype.type = "Dropdown";
                
                      Dropdown.prototype.default_view = DropdownView;
                
                      Dropdown.prototype.defaults = function() {
                        return _.extend({}, Dropdown.__super__.defaults.call(this), {
                          action: null,
                          default_action: null,
                          label: "Dropdown",
                          icon: null,
                          type: "default",
                          menu: [],
                          disabled: false
                        });
                      };
                
                      return Dropdown;
                
                    })(HasParent);
                    Dropdowns = (function(_super) {
                      __extends(Dropdowns, _super);
                
                      function Dropdowns() {
                        _ref2 = Dropdowns.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Dropdowns.prototype.model = Dropdown;
                
                      return Dropdowns;
                
                    })(Collection);
                    return {
                      Model: Dropdown,
                      Collection: new Dropdowns(),
                      View: DropdownView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=dropdown.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
                    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
                
                  define('widget/checkbox_group',["underscore", "common/collection", "common/continuum_view", "common/has_parent", "common/logging"], function(_, Collection, ContinuumView, HasParent, Logging) {
                    var CheckboxGroup, CheckboxGroupView, CheckboxGroups, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    CheckboxGroupView = (function(_super) {
                      __extends(CheckboxGroupView, _super);
                
                      function CheckboxGroupView() {
                        _ref = CheckboxGroupView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CheckboxGroupView.prototype.tagName = "div";
                
                      CheckboxGroupView.prototype.events = {
                        "change input": "change_input"
                      };
                
                      CheckboxGroupView.prototype.change_input = function() {
                        var active, checkbox, i;
                        active = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.$("input");
                          _results = [];
                          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                            checkbox = _ref1[i];
                            if (checkbox.checked) {
                              _results.push(i);
                            }
                          }
                          return _results;
                        }).call(this);
                        this.mset('active', active);
                        return this.model.save();
                      };
                
                      CheckboxGroupView.prototype.initialize = function(options) {
                        CheckboxGroupView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      CheckboxGroupView.prototype.render = function() {
                        var $div, $input, $label, active, i, label, _i, _len, _ref1;
                        this.$el.empty();
                        active = this.mget("active");
                        _ref1 = this.mget("labels");
                        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                          label = _ref1[i];
                          $input = $('<input type="checkbox">').attr({
                            value: "" + i
                          });
                          if (this.mget("disabled")) {
                            $input.prop("disabled", true);
                          }
                          if (__indexOf.call(active, i) >= 0) {
                            $input.prop("checked", true);
                          }
                          $label = $('<label></label>').text(label).prepend($input);
                          if (this.mget("inline")) {
                            $label.addClass("bk-bs-checkbox-inline");
                            this.$el.append($label);
                          } else {
                            $div = $('<div class="bk-bs-checkbox"></div>').append($label);
                            this.$el.append($div);
                          }
                        }
                        return this;
                      };
                
                      return CheckboxGroupView;
                
                    })(ContinuumView);
                    CheckboxGroup = (function(_super) {
                      __extends(CheckboxGroup, _super);
                
                      function CheckboxGroup() {
                        _ref1 = CheckboxGroup.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CheckboxGroup.prototype.type = "CheckboxGroup";
                
                      CheckboxGroup.prototype.default_view = CheckboxGroupView;
                
                      CheckboxGroup.prototype.defaults = function() {
                        return _.extend({}, CheckboxGroup.__super__.defaults.call(this), {
                          active: [],
                          labels: [],
                          inline: false,
                          disabled: false
                        });
                      };
                
                      return CheckboxGroup;
                
                    })(HasParent);
                    CheckboxGroups = (function(_super) {
                      __extends(CheckboxGroups, _super);
                
                      function CheckboxGroups() {
                        _ref2 = CheckboxGroups.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      CheckboxGroups.prototype.model = CheckboxGroup;
                
                      return CheckboxGroups;
                
                    })(Collection);
                    return {
                      Model: CheckboxGroup,
                      Collection: new CheckboxGroups(),
                      View: CheckboxGroupView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=checkbox_group.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/radio_group',["underscore", "common/collection", "common/continuum_view", "common/has_parent", "common/logging"], function(_, Collection, ContinuumView, HasParent, Logging) {
                    var RadioGroup, RadioGroupView, RadioGroups, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    RadioGroupView = (function(_super) {
                      __extends(RadioGroupView, _super);
                
                      function RadioGroupView() {
                        _ref = RadioGroupView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      RadioGroupView.prototype.tagName = "div";
                
                      RadioGroupView.prototype.events = {
                        "change input": "change_input"
                      };
                
                      RadioGroupView.prototype.change_input = function() {
                        var active, i, radio;
                        active = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.$("input");
                          _results = [];
                          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                            radio = _ref1[i];
                            if (radio.checked) {
                              _results.push(i);
                            }
                          }
                          return _results;
                        }).call(this);
                        this.mset('active', active[0]);
                        return this.model.save();
                      };
                
                      RadioGroupView.prototype.initialize = function(options) {
                        RadioGroupView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      RadioGroupView.prototype.render = function() {
                        var $div, $input, $label, active, i, label, name, _i, _len, _ref1;
                        this.$el.empty();
                        name = _.uniqueId("RadioGroup");
                        active = this.mget("active");
                        _ref1 = this.mget("labels");
                        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                          label = _ref1[i];
                          $input = $('<input type="radio">').attr({
                            name: name,
                            value: "" + i
                          });
                          if (this.mget("disabled")) {
                            $input.prop("disabled", true);
                          }
                          if (i === active) {
                            $input.prop("checked", true);
                          }
                          $label = $('<label></label>').text(label).prepend($input);
                          if (this.mget("inline")) {
                            $label.addClass("bk-bs-radio-inline");
                            this.$el.append($label);
                          } else {
                            $div = $('<div class="bk-bs-radio"></div>').append($label);
                            this.$el.append($div);
                          }
                        }
                        return this;
                      };
                
                      return RadioGroupView;
                
                    })(ContinuumView);
                    RadioGroup = (function(_super) {
                      __extends(RadioGroup, _super);
                
                      function RadioGroup() {
                        _ref1 = RadioGroup.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      RadioGroup.prototype.type = "RadioGroup";
                
                      RadioGroup.prototype.default_view = RadioGroupView;
                
                      RadioGroup.prototype.defaults = function() {
                        return _.extend({}, RadioGroup.__super__.defaults.call(this), {
                          active: null,
                          labels: [],
                          inline: false,
                          disabled: false
                        });
                      };
                
                      return RadioGroup;
                
                    })(HasParent);
                    RadioGroups = (function(_super) {
                      __extends(RadioGroups, _super);
                
                      function RadioGroups() {
                        _ref2 = RadioGroups.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      RadioGroups.prototype.model = RadioGroup;
                
                      return RadioGroups;
                
                    })(Collection);
                    return {
                      Model: RadioGroup,
                      Collection: new RadioGroups(),
                      View: RadioGroupView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=radio_group.js.map
                */;
                define('bootstrap/button',["jquery"], function(jQuery) {
                
                /* ========================================================================
                 * Bootstrap: button.js v3.1.1
                 * http://getbootstrap.com/javascript/#buttons
                 * ========================================================================
                 * Copyright 2011-2014 Twitter, Inc.
                 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
                 * ======================================================================== */
                
                
                +function ($) {
                  
                
                  // BUTTON PUBLIC CLASS DEFINITION
                  // ==============================
                
                  var Button = function (element, options) {
                    this.$element  = $(element)
                    this.options   = $.extend({}, Button.DEFAULTS, options)
                    this.isLoading = false
                  }
                
                  Button.DEFAULTS = {
                    loadingText: 'loading...'
                  }
                
                  Button.prototype.setState = function (state) {
                    var d    = 'bk-bs-disabled'
                    var $el  = this.$element
                    var val  = $el.is('input') ? 'val' : 'html'
                    var data = $el.data()
                
                    state = state + 'Text'
                
                    if (!data.resetText) $el.data('resetText', $el[val]())
                
                    $el[val](data[state] || this.options[state])
                
                    // push to event loop to allow forms to submit
                    setTimeout($.proxy(function () {
                      if (state == 'loadingText') {
                        this.isLoading = true
                        $el.addClass(d).attr(d, d)
                      } else if (this.isLoading) {
                        this.isLoading = false
                        $el.removeClass(d).removeAttr(d)
                      }
                    }, this), 0)
                  }
                
                  Button.prototype.toggle = function () {
                    var changed = true
                    var $parent = this.$element.closest('[data-bk-bs-toggle="buttons"]')
                
                    if ($parent.length) {
                      var $input = this.$element.find('input')
                      if ($input.prop('type') == 'radio') {
                        if ($input.prop('checked') && this.$element.hasClass('bk-bs-active')) changed = false
                        else $parent.find('.bk-bs-active').removeClass('bk-bs-active')
                      }
                      if (changed) $input.prop('checked', !this.$element.hasClass('bk-bs-active')).trigger('change')
                    }
                
                    if (changed) this.$element.toggleClass('bk-bs-active')
                  }
                
                
                  // BUTTON PLUGIN DEFINITION
                  // ========================
                
                  var old = $.fn.button
                
                  $.fn.button = function (option) {
                    return this.each(function () {
                      var $this   = $(this)
                      var data    = $this.data('bk-bs.button')
                      var options = typeof option == 'object' && option
                
                      if (!data) $this.data('bk-bs.button', (data = new Button(this, options)))
                
                      if (option == 'toggle') data.toggle()
                      else if (option) data.setState(option)
                    })
                  }
                
                  $.fn.button.Constructor = Button
                
                
                  // BUTTON NO CONFLICT
                  // ==================
                
                  $.fn.button.noConflict = function () {
                    $.fn.button = old
                    return this
                  }
                
                
                  // BUTTON DATA-API
                  // ===============
                
                  $(document).on('click.bk-bs.button.data-api', '[data-bk-bs-toggle^=button]', function (e) {
                    var $btn = $(e.target)
                    if (!$btn.hasClass('bk-bs-btn')) $btn = $btn.closest('.bk-bs-btn')
                    $btn.button('toggle')
                    e.preventDefault()
                  })
                
                }(jQuery);
                
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
                    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
                
                  define('widget/checkbox_button_group',["underscore", "common/collection", "jquery", "bootstrap/button", "common/continuum_view", "common/has_parent", "common/logging"], function(_, Collection, $, $1, ContinuumView, HasParent, Logging) {
                    var CheckboxButtonGroup, CheckboxButtonGroupView, CheckboxButtonGroups, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    CheckboxButtonGroupView = (function(_super) {
                      __extends(CheckboxButtonGroupView, _super);
                
                      function CheckboxButtonGroupView() {
                        _ref = CheckboxButtonGroupView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CheckboxButtonGroupView.prototype.tagName = "div";
                
                      CheckboxButtonGroupView.prototype.events = {
                        "change input": "change_input"
                      };
                
                      CheckboxButtonGroupView.prototype.change_input = function() {
                        var active, checkbox, i;
                        active = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.$("input");
                          _results = [];
                          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                            checkbox = _ref1[i];
                            if (checkbox.checked) {
                              _results.push(i);
                            }
                          }
                          return _results;
                        }).call(this);
                        this.mset('active', active);
                        return this.model.save();
                      };
                
                      CheckboxButtonGroupView.prototype.initialize = function(options) {
                        CheckboxButtonGroupView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      CheckboxButtonGroupView.prototype.render = function() {
                        this.$el.empty();
                        return this;
                      };
                
                      CheckboxButtonGroupView.prototype.render = function() {
                        var $input, $label, active, i, label, _i, _len, _ref1;
                        this.$el.empty();
                        this.$el.addClass("bk-bs-btn-group");
                        this.$el.attr("data-bk-bs-toggle", "buttons");
                        active = this.mget("active");
                        _ref1 = this.mget("labels");
                        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                          label = _ref1[i];
                          $input = $('<input type="checkbox">').attr({
                            value: "" + i
                          });
                          if (__indexOf.call(active, i) >= 0) {
                            $input.prop("checked", true);
                          }
                          $label = $('<label class="bk-bs-btn"></label>');
                          $label.text(label).prepend($input);
                          $label.addClass("bk-bs-btn-" + this.mget("type"));
                          if (__indexOf.call(active, i) >= 0) {
                            $label.addClass("bk-bs-active");
                          }
                          this.$el.append($label);
                        }
                        return this;
                      };
                
                      return CheckboxButtonGroupView;
                
                    })(ContinuumView);
                    CheckboxButtonGroup = (function(_super) {
                      __extends(CheckboxButtonGroup, _super);
                
                      function CheckboxButtonGroup() {
                        _ref1 = CheckboxButtonGroup.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CheckboxButtonGroup.prototype.type = "CheckboxButtonGroup";
                
                      CheckboxButtonGroup.prototype.default_view = CheckboxButtonGroupView;
                
                      CheckboxButtonGroup.prototype.defaults = function() {
                        return _.extend({}, CheckboxButtonGroup.__super__.defaults.call(this), {
                          active: [],
                          labels: [],
                          type: "default",
                          disabled: false
                        });
                      };
                
                      return CheckboxButtonGroup;
                
                    })(HasParent);
                    CheckboxButtonGroups = (function(_super) {
                      __extends(CheckboxButtonGroups, _super);
                
                      function CheckboxButtonGroups() {
                        _ref2 = CheckboxButtonGroups.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      CheckboxButtonGroups.prototype.model = CheckboxButtonGroup;
                
                      return CheckboxButtonGroups;
                
                    })(Collection);
                    return {
                      Model: CheckboxButtonGroup,
                      Collection: new CheckboxButtonGroups(),
                      View: CheckboxButtonGroupView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=checkbox_button_group.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('widget/radio_button_group',["underscore", "common/collection", "jquery", "bootstrap/button", "common/continuum_view", "common/has_parent", "common/logging", "bootstrap/button"], function(_, Collection, $, $1, ContinuumView, HasParent, Logging) {
                    var RadioButtonGroup, RadioButtonGroupView, RadioButtonGroups, logger, _ref, _ref1, _ref2;
                    logger = Logging.logger;
                    RadioButtonGroupView = (function(_super) {
                      __extends(RadioButtonGroupView, _super);
                
                      function RadioButtonGroupView() {
                        _ref = RadioButtonGroupView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      RadioButtonGroupView.prototype.tagName = "div";
                
                      RadioButtonGroupView.prototype.events = {
                        "change input": "change_input"
                      };
                
                      RadioButtonGroupView.prototype.change_input = function() {
                        var active, i, radio;
                        active = (function() {
                          var _i, _len, _ref1, _results;
                          _ref1 = this.$("input");
                          _results = [];
                          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                            radio = _ref1[i];
                            if (radio.checked) {
                              _results.push(i);
                            }
                          }
                          return _results;
                        }).call(this);
                        this.mset('active', active[0]);
                        return this.model.save();
                      };
                
                      RadioButtonGroupView.prototype.initialize = function(options) {
                        RadioButtonGroupView.__super__.initialize.call(this, options);
                        this.render();
                        return this.listenTo(this.model, 'change', this.render);
                      };
                
                      RadioButtonGroupView.prototype.render = function() {
                        var $input, $label, active, i, label, name, _i, _len, _ref1;
                        this.$el.empty();
                        this.$el.addClass("bk-bs-btn-group");
                        this.$el.attr("data-bk-bs-toggle", "buttons");
                        name = _.uniqueId("RadioButtonGroup");
                        active = this.mget("active");
                        _ref1 = this.mget("labels");
                        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                          label = _ref1[i];
                          $input = $('<input type="radio">').attr({
                            name: name,
                            value: "" + i
                          });
                          if (i === active) {
                            $input.prop("checked", true);
                          }
                          $label = $('<label class="bk-bs-btn"></label>');
                          $label.text(label).prepend($input);
                          $label.addClass("bk-bs-btn-" + this.mget("type"));
                          if (i === active) {
                            $label.addClass("bk-bs-active");
                          }
                          this.$el.append($label);
                        }
                        return this;
                      };
                
                      return RadioButtonGroupView;
                
                    })(ContinuumView);
                    RadioButtonGroup = (function(_super) {
                      __extends(RadioButtonGroup, _super);
                
                      function RadioButtonGroup() {
                        _ref1 = RadioButtonGroup.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      RadioButtonGroup.prototype.type = "RadioButtonGroup";
                
                      RadioButtonGroup.prototype.default_view = RadioButtonGroupView;
                
                      RadioButtonGroup.prototype.defaults = function() {
                        return _.extend({}, RadioButtonGroup.__super__.defaults.call(this), {
                          active: null,
                          labels: [],
                          type: "default",
                          disabled: false
                        });
                      };
                
                      return RadioButtonGroup;
                
                    })(HasParent);
                    RadioButtonGroups = (function(_super) {
                      __extends(RadioButtonGroups, _super);
                
                      function RadioButtonGroups() {
                        _ref2 = RadioButtonGroups.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      RadioButtonGroups.prototype.model = RadioButtonGroup;
                
                      return RadioButtonGroups;
                
                    })(Collection);
                    return {
                      Model: RadioButtonGroup,
                      Collection: new RadioButtonGroups(),
                      View: RadioButtonGroupView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=radio_button_group.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/autoencode',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var AutoEncode, AutoEncodeView, AutoEncodes, _ref, _ref1, _ref2;
                    AutoEncodeView = (function(_super) {
                      __extends(AutoEncodeView, _super);
                
                      function AutoEncodeView() {
                        _ref = AutoEncodeView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      AutoEncodeView.prototype.attributes = {
                        "class": "AutoEncodeView"
                      };
                
                      AutoEncodeView.prototype.initialize = function(options) {
                        AutoEncodeView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      AutoEncodeView.prototype.delegateEvents = function(events) {
                        AutoEncodeView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      AutoEncodeView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return AutoEncodeView;
                
                    })(ContinuumView);
                    AutoEncode = (function(_super) {
                      __extends(AutoEncode, _super);
                
                      function AutoEncode() {
                        _ref1 = AutoEncode.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      AutoEncode.prototype.type = "AutoEncode";
                
                      AutoEncode.prototype.default_view = AutoEncodeView;
                
                      return AutoEncode;
                
                    })(HasParent);
                    AutoEncodes = (function(_super) {
                      __extends(AutoEncodes, _super);
                
                      function AutoEncodes() {
                        _ref2 = AutoEncodes.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      AutoEncodes.prototype.model = AutoEncode;
                
                      return AutoEncodes;
                
                    })(Collection);
                    return {
                      "Model": AutoEncode,
                      "Collection": new AutoEncodes()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=autoencode.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/binarysegment',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var BinarySegment, BinarySegmentView, BinarySegments, _ref, _ref1, _ref2;
                    BinarySegmentView = (function(_super) {
                      __extends(BinarySegmentView, _super);
                
                      function BinarySegmentView() {
                        _ref = BinarySegmentView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      BinarySegmentView.prototype.attributes = {
                        "class": "BinarySegmentView"
                      };
                
                      BinarySegmentView.prototype.initialize = function(options) {
                        BinarySegmentView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      BinarySegmentView.prototype.delegateEvents = function(events) {
                        BinarySegmentView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      BinarySegmentView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return BinarySegmentView;
                
                    })(ContinuumView);
                    BinarySegment = (function(_super) {
                      __extends(BinarySegment, _super);
                
                      function BinarySegment() {
                        _ref1 = BinarySegment.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      BinarySegment.prototype.type = "BinarySegment";
                
                      BinarySegment.prototype.default_view = BinarySegmentView;
                
                      return BinarySegment;
                
                    })(HasParent);
                    BinarySegments = (function(_super) {
                      __extends(BinarySegments, _super);
                
                      function BinarySegments() {
                        _ref2 = BinarySegments.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      BinarySegments.prototype.model = BinarySegment;
                
                      return BinarySegments;
                
                    })(Collection);
                    return {
                      "Model": BinarySegment,
                      "Collection": new BinarySegments()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=binarysegment.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/const',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Const, ConstView, Consts, _ref, _ref1, _ref2;
                    ConstView = (function(_super) {
                      __extends(ConstView, _super);
                
                      function ConstView() {
                        _ref = ConstView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ConstView.prototype.attributes = {
                        "class": "ConstView"
                      };
                
                      ConstView.prototype.initialize = function(options) {
                        ConstView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      ConstView.prototype.delegateEvents = function(events) {
                        ConstView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      ConstView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return ConstView;
                
                    })(ContinuumView);
                    Const = (function(_super) {
                      __extends(Const, _super);
                
                      function Const() {
                        _ref1 = Const.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Const.prototype.type = "Const";
                
                      Const.prototype.default_view = ConstView;
                
                      return Const;
                
                    })(HasParent);
                    Consts = (function(_super) {
                      __extends(Consts, _super);
                
                      function Consts() {
                        _ref2 = Consts.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Consts.prototype.model = Const;
                
                      return Consts;
                
                    })(Collection);
                    return {
                      "Model": Const,
                      "Collection": new Consts()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=const.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/contour',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Contour, ContourView, Contours, _ref, _ref1, _ref2;
                    ContourView = (function(_super) {
                      __extends(ContourView, _super);
                
                      function ContourView() {
                        _ref = ContourView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ContourView.prototype.attributes = {
                        "class": "ContourView"
                      };
                
                      ContourView.prototype.initialize = function(options) {
                        ContourView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      ContourView.prototype.delegateEvents = function(events) {
                        ContourView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      ContourView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return ContourView;
                
                    })(ContinuumView);
                    Contour = (function(_super) {
                      __extends(Contour, _super);
                
                      function Contour() {
                        _ref1 = Contour.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Contour.prototype.type = "Contour";
                
                      Contour.prototype.default_view = ContourView;
                
                      return Contour;
                
                    })(HasParent);
                    Contours = (function(_super) {
                      __extends(Contours, _super);
                
                      function Contours() {
                        _ref2 = Contours.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Contours.prototype.model = Contour;
                
                      return Contours;
                
                    })(Collection);
                    return {
                      "Model": Contour,
                      "Collection": new Contours()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=contour.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/count',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Count, CountView, Counts, _ref, _ref1, _ref2;
                    CountView = (function(_super) {
                      __extends(CountView, _super);
                
                      function CountView() {
                        _ref = CountView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CountView.prototype.attributes = {
                        "class": "CountView"
                      };
                
                      CountView.prototype.initialize = function(options) {
                        CountView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      CountView.prototype.delegateEvents = function(events) {
                        CountView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      CountView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return CountView;
                
                    })(ContinuumView);
                    Count = (function(_super) {
                      __extends(Count, _super);
                
                      function Count() {
                        _ref1 = Count.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Count.prototype.type = "Count";
                
                      Count.prototype.default_view = CountView;
                
                      return Count;
                
                    })(HasParent);
                    Counts = (function(_super) {
                      __extends(Counts, _super);
                
                      function Counts() {
                        _ref2 = Counts.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Counts.prototype.model = Count;
                
                      return Counts;
                
                    })(Collection);
                    return {
                      "Model": Count,
                      "Collection": new Counts()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=count.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/countcategories',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var CountCategories, CountCategoriesView, CountCategoriess, _ref, _ref1, _ref2;
                    CountCategoriesView = (function(_super) {
                      __extends(CountCategoriesView, _super);
                
                      function CountCategoriesView() {
                        _ref = CountCategoriesView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CountCategoriesView.prototype.attributes = {
                        "class": "CountCategoriesView"
                      };
                
                      CountCategoriesView.prototype.initialize = function(options) {
                        CountCategoriesView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      CountCategoriesView.prototype.delegateEvents = function(events) {
                        CountCategoriesView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      CountCategoriesView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return CountCategoriesView;
                
                    })(ContinuumView);
                    CountCategories = (function(_super) {
                      __extends(CountCategories, _super);
                
                      function CountCategories() {
                        _ref1 = CountCategories.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      CountCategories.prototype.type = "CountCategories";
                
                      CountCategories.prototype.default_view = CountCategoriesView;
                
                      return CountCategories;
                
                    })(HasParent);
                    CountCategoriess = (function(_super) {
                      __extends(CountCategoriess, _super);
                
                      function CountCategoriess() {
                        _ref2 = CountCategoriess.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      CountCategoriess.prototype.model = CountCategories;
                
                      return CountCategoriess;
                
                    })(Collection);
                    return {
                      "Model": CountCategories,
                      "Collection": new CountCategoriess()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=countcategories.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/encode',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Encode, EncodeView, Encodes, _ref, _ref1, _ref2;
                    EncodeView = (function(_super) {
                      __extends(EncodeView, _super);
                
                      function EncodeView() {
                        _ref = EncodeView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      EncodeView.prototype.attributes = {
                        "class": "EncodeView"
                      };
                
                      EncodeView.prototype.initialize = function(options) {
                        EncodeView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      EncodeView.prototype.delegateEvents = function(events) {
                        EncodeView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      EncodeView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return EncodeView;
                
                    })(ContinuumView);
                    Encode = (function(_super) {
                      __extends(Encode, _super);
                
                      function Encode() {
                        _ref1 = Encode.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Encode.prototype.type = "Encode";
                
                      Encode.prototype.default_view = EncodeView;
                
                      return Encode;
                
                    })(HasParent);
                    Encodes = (function(_super) {
                      __extends(Encodes, _super);
                
                      function Encodes() {
                        _ref2 = Encodes.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Encodes.prototype.model = Encode;
                
                      return Encodes;
                
                    })(Collection);
                    return {
                      "Model": Encode,
                      "Collection": new Encodes()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=encode.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/cuberoot',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Cuberoot, CuberootView, Cuberoots, _ref, _ref1, _ref2;
                    CuberootView = (function(_super) {
                      __extends(CuberootView, _super);
                
                      function CuberootView() {
                        _ref = CuberootView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      CuberootView.prototype.attributes = {
                        "class": "CuberootView"
                      };
                
                      CuberootView.prototype.initialize = function(options) {
                        CuberootView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      CuberootView.prototype.delegateEvents = function(events) {
                        CuberootView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      CuberootView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return CuberootView;
                
                    })(ContinuumView);
                    Cuberoot = (function(_super) {
                      __extends(Cuberoot, _super);
                
                      function Cuberoot() {
                        _ref1 = Cuberoot.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Cuberoot.prototype.type = "Cuberoot";
                
                      Cuberoot.prototype.default_view = CuberootView;
                
                      return Cuberoot;
                
                    })(HasParent);
                    Cuberoots = (function(_super) {
                      __extends(Cuberoots, _super);
                
                      function Cuberoots() {
                        _ref2 = Cuberoots.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Cuberoots.prototype.model = Cuberoot;
                
                      return Cuberoots;
                
                    })(Collection);
                    return {
                      "Model": Cuberoot,
                      "Collection": new Cuberoots()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=cuberoot.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/hdalpha',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var HDAlpha, HDAlphaView, HDAlphas, _ref, _ref1, _ref2;
                    HDAlphaView = (function(_super) {
                      __extends(HDAlphaView, _super);
                
                      function HDAlphaView() {
                        _ref = HDAlphaView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      HDAlphaView.prototype.attributes = {
                        "class": "HDAlphaView"
                      };
                
                      HDAlphaView.prototype.initialize = function(options) {
                        HDAlphaView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      HDAlphaView.prototype.delegateEvents = function(events) {
                        HDAlphaView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      HDAlphaView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return HDAlphaView;
                
                    })(ContinuumView);
                    HDAlpha = (function(_super) {
                      __extends(HDAlpha, _super);
                
                      function HDAlpha() {
                        _ref1 = HDAlpha.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      HDAlpha.prototype.type = "HDAlpha";
                
                      HDAlpha.prototype.default_view = HDAlphaView;
                
                      return HDAlpha;
                
                    })(HasParent);
                    HDAlphas = (function(_super) {
                      __extends(HDAlphas, _super);
                
                      function HDAlphas() {
                        _ref2 = HDAlphas.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      HDAlphas.prototype.model = HDAlpha;
                
                      return HDAlphas;
                
                    })(Collection);
                    return {
                      "Model": HDAlpha,
                      "Collection": new HDAlphas()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=hdalpha.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/id',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Id, IdView, Ids, _ref, _ref1, _ref2;
                    IdView = (function(_super) {
                      __extends(IdView, _super);
                
                      function IdView() {
                        _ref = IdView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      IdView.prototype.attributes = {
                        "class": "IdView"
                      };
                
                      IdView.prototype.initialize = function(options) {
                        IdView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      IdView.prototype.delegateEvents = function(events) {
                        IdView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      IdView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return IdView;
                
                    })(ContinuumView);
                    Id = (function(_super) {
                      __extends(Id, _super);
                
                      function Id() {
                        _ref1 = Id.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Id.prototype.type = "Id";
                
                      Id.prototype.default_view = IdView;
                
                      return Id;
                
                    })(HasParent);
                    Ids = (function(_super) {
                      __extends(Ids, _super);
                
                      function Ids() {
                        _ref2 = Ids.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Ids.prototype.model = Id;
                
                      return Ids;
                
                    })(Collection);
                    return {
                      "Model": Id,
                      "Collection": new Ids()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=id.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/interpolate',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Interpolate, InterpolateView, Interpolates, _ref, _ref1, _ref2;
                    InterpolateView = (function(_super) {
                      __extends(InterpolateView, _super);
                
                      function InterpolateView() {
                        _ref = InterpolateView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      InterpolateView.prototype.attributes = {
                        "class": "InterpolateView"
                      };
                
                      InterpolateView.prototype.initialize = function(options) {
                        InterpolateView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      InterpolateView.prototype.delegateEvents = function(events) {
                        InterpolateView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      InterpolateView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return InterpolateView;
                
                    })(ContinuumView);
                    Interpolate = (function(_super) {
                      __extends(Interpolate, _super);
                
                      function Interpolate() {
                        _ref1 = Interpolate.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Interpolate.prototype.type = "Interpolate";
                
                      Interpolate.prototype.default_view = InterpolateView;
                
                      return Interpolate;
                
                    })(HasParent);
                    Interpolates = (function(_super) {
                      __extends(Interpolates, _super);
                
                      function Interpolates() {
                        _ref2 = Interpolates.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Interpolates.prototype.model = Interpolate;
                
                      return Interpolates;
                
                    })(Collection);
                    return {
                      "Model": Interpolate,
                      "Collection": new Interpolates()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=interpolate.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/interpolatecolor',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var InterpolateColor, InterpolateColorView, InterpolateColors, _ref, _ref1, _ref2;
                    InterpolateColorView = (function(_super) {
                      __extends(InterpolateColorView, _super);
                
                      function InterpolateColorView() {
                        _ref = InterpolateColorView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      InterpolateColorView.prototype.attributes = {
                        "class": "InterpolateColorView"
                      };
                
                      InterpolateColorView.prototype.initialize = function(options) {
                        InterpolateColorView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      InterpolateColorView.prototype.delegateEvents = function(events) {
                        InterpolateColorView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      InterpolateColorView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return InterpolateColorView;
                
                    })(ContinuumView);
                    InterpolateColor = (function(_super) {
                      __extends(InterpolateColor, _super);
                
                      function InterpolateColor() {
                        _ref1 = InterpolateColor.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      InterpolateColor.prototype.type = "InterpolateColor";
                
                      InterpolateColor.prototype.default_view = InterpolateColorView;
                
                      return InterpolateColor;
                
                    })(HasParent);
                    InterpolateColors = (function(_super) {
                      __extends(InterpolateColors, _super);
                
                      function InterpolateColors() {
                        _ref2 = InterpolateColors.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      InterpolateColors.prototype.model = InterpolateColor;
                
                      return InterpolateColors;
                
                    })(Collection);
                    return {
                      "Model": InterpolateColor,
                      "Collection": new InterpolateColors()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=interpolatecolor.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/log',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Log, LogView, Logs, _ref, _ref1, _ref2;
                    LogView = (function(_super) {
                      __extends(LogView, _super);
                
                      function LogView() {
                        _ref = LogView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      LogView.prototype.attributes = {
                        "class": "LogView"
                      };
                
                      LogView.prototype.initialize = function(options) {
                        LogView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      LogView.prototype.delegateEvents = function(events) {
                        LogView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      LogView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return LogView;
                
                    })(ContinuumView);
                    Log = (function(_super) {
                      __extends(Log, _super);
                
                      function Log() {
                        _ref1 = Log.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Log.prototype.type = "Log";
                
                      Log.prototype.default_view = LogView;
                
                      return Log;
                
                    })(HasParent);
                    Logs = (function(_super) {
                      __extends(Logs, _super);
                
                      function Logs() {
                        _ref2 = Logs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Logs.prototype.model = Log;
                
                      return Logs;
                
                    })(Collection);
                    return {
                      "Model": Log,
                      "Collection": new Logs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=log.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/nonzero',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var NonZero, NonZeroView, NonZeros, _ref, _ref1, _ref2;
                    NonZeroView = (function(_super) {
                      __extends(NonZeroView, _super);
                
                      function NonZeroView() {
                        _ref = NonZeroView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      NonZeroView.prototype.attributes = {
                        "class": "NonZeroView"
                      };
                
                      NonZeroView.prototype.initialize = function(options) {
                        NonZeroView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      NonZeroView.prototype.delegateEvents = function(events) {
                        NonZeroView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      NonZeroView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return NonZeroView;
                
                    })(ContinuumView);
                    NonZero = (function(_super) {
                      __extends(NonZero, _super);
                
                      function NonZero() {
                        _ref1 = NonZero.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      NonZero.prototype.type = "NonZero";
                
                      NonZero.prototype.default_view = NonZeroView;
                
                      return NonZero;
                
                    })(HasParent);
                    NonZeros = (function(_super) {
                      __extends(NonZeros, _super);
                
                      function NonZeros() {
                        _ref2 = NonZeros.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      NonZeros.prototype.model = NonZero;
                
                      return NonZeros;
                
                    })(Collection);
                    return {
                      "Model": NonZero,
                      "Collection": new NonZeros()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=nonzero.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/ratio',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Ratio, RatioView, Ratios, _ref, _ref1, _ref2;
                    RatioView = (function(_super) {
                      __extends(RatioView, _super);
                
                      function RatioView() {
                        _ref = RatioView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      RatioView.prototype.attributes = {
                        "class": "RatioView"
                      };
                
                      RatioView.prototype.initialize = function(options) {
                        RatioView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      RatioView.prototype.delegateEvents = function(events) {
                        RatioView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      RatioView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return RatioView;
                
                    })(ContinuumView);
                    Ratio = (function(_super) {
                      __extends(Ratio, _super);
                
                      function Ratio() {
                        _ref1 = Ratio.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Ratio.prototype.type = "Ratio";
                
                      Ratio.prototype.default_view = RatioView;
                
                      return Ratio;
                
                    })(HasParent);
                    Ratios = (function(_super) {
                      __extends(Ratios, _super);
                
                      function Ratios() {
                        _ref2 = Ratios.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Ratios.prototype.model = Ratio;
                
                      return Ratios;
                
                    })(Collection);
                    return {
                      "Model": Ratio,
                      "Collection": new Ratios()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=ratio.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/seq',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Seq, SeqView, Seqs, _ref, _ref1, _ref2;
                    SeqView = (function(_super) {
                      __extends(SeqView, _super);
                
                      function SeqView() {
                        _ref = SeqView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SeqView.prototype.attributes = {
                        "class": "SeqView"
                      };
                
                      SeqView.prototype.initialize = function(options) {
                        SeqView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      SeqView.prototype.delegateEvents = function(events) {
                        SeqView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      SeqView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return SeqView;
                
                    })(ContinuumView);
                    Seq = (function(_super) {
                      __extends(Seq, _super);
                
                      function Seq() {
                        _ref1 = Seq.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Seq.prototype.type = "Seq";
                
                      Seq.prototype.default_view = SeqView;
                
                      return Seq;
                
                    })(HasParent);
                    Seqs = (function(_super) {
                      __extends(Seqs, _super);
                
                      function Seqs() {
                        _ref2 = Seqs.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Seqs.prototype.model = Seq;
                
                      return Seqs;
                
                    })(Collection);
                    return {
                      "Model": Seq,
                      "Collection": new Seqs()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=seq.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/spread',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var Spread, SpreadView, Spreads, _ref, _ref1, _ref2;
                    SpreadView = (function(_super) {
                      __extends(SpreadView, _super);
                
                      function SpreadView() {
                        _ref = SpreadView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      SpreadView.prototype.attributes = {
                        "class": "SpreadView"
                      };
                
                      SpreadView.prototype.initialize = function(options) {
                        SpreadView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      SpreadView.prototype.delegateEvents = function(events) {
                        SpreadView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      SpreadView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return SpreadView;
                
                    })(ContinuumView);
                    Spread = (function(_super) {
                      __extends(Spread, _super);
                
                      function Spread() {
                        _ref1 = Spread.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      Spread.prototype.type = "Spread";
                
                      Spread.prototype.default_view = SpreadView;
                
                      return Spread;
                
                    })(HasParent);
                    Spreads = (function(_super) {
                      __extends(Spreads, _super);
                
                      function Spreads() {
                        _ref2 = Spreads.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Spreads.prototype.model = Spread;
                
                      return Spreads;
                
                    })(Collection);
                    return {
                      "Model": Spread,
                      "Collection": new Spreads()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=spread.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('transforms/tocounts',["common/continuum_view", "common/collection", "common/has_parent"], function(ContinuumView, Collection, HasParent) {
                    var ToCounts, ToCountsView, ToCountss, _ref, _ref1, _ref2;
                    ToCountsView = (function(_super) {
                      __extends(ToCountsView, _super);
                
                      function ToCountsView() {
                        _ref = ToCountsView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      ToCountsView.prototype.attributes = {
                        "class": "ToCountsView"
                      };
                
                      ToCountsView.prototype.initialize = function(options) {
                        ToCountsView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      ToCountsView.prototype.delegateEvents = function(events) {
                        ToCountsView.__super__.delegateEvents.call(this, events);
                        return "pass";
                      };
                
                      ToCountsView.prototype.render_init = function() {
                        return this.$el.html("");
                      };
                
                      return ToCountsView;
                
                    })(ContinuumView);
                    ToCounts = (function(_super) {
                      __extends(ToCounts, _super);
                
                      function ToCounts() {
                        _ref1 = ToCounts.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      ToCounts.prototype.type = "ToCounts";
                
                      ToCounts.prototype.default_view = ToCountsView;
                
                      return ToCounts;
                
                    })(HasParent);
                    ToCountss = (function(_super) {
                      __extends(ToCountss, _super);
                
                      function ToCountss() {
                        _ref2 = ToCountss.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      ToCountss.prototype.model = ToCounts;
                
                      return ToCountss;
                
                    })(Collection);
                    return {
                      "Model": ToCounts,
                      "Collection": new ToCountss()
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=tocounts.js.map
                */;
                (function() {
                  define('common/base',["underscore", "require", "common/custom", "common/canvas", "common/cartesian_frame", "common/gmap_plot", "common/geojs_plot", "common/grid_plot", "common/layout_box", "common/plot", "common/plot_context", "common/selection_manager", "common/selector", "common/tool_events", "mapper/categorical_mapper", "mapper/linear_mapper", "mapper/log_mapper", "mapper/grid_mapper", "mapper/linear_color_mapper", "range/data_factor_range", "range/data_range1d", "range/factor_range", "range/range1d", "renderer/annotation/legend", "renderer/annotation/span", "renderer/annotation/tooltip", "renderer/glyph/glyph_renderer", "renderer/glyph/annular_wedge", "renderer/glyph/annulus", "renderer/glyph/arc", "renderer/glyph/bezier", "renderer/glyph/circle", "renderer/glyph/gear", "renderer/glyph/image", "renderer/glyph/image_rgba", "renderer/glyph/image_url", "renderer/glyph/line", "renderer/glyph/multi_line", "renderer/glyph/oval", "renderer/glyph/patch", "renderer/glyph/patches", "renderer/glyph/quad", "renderer/glyph/quadratic", "renderer/glyph/ray", "renderer/glyph/rect", "renderer/glyph/segment", "renderer/glyph/text", "renderer/glyph/wedge", "renderer/glyph/marker/asterisk", "renderer/glyph/marker/circle_cross", "renderer/glyph/marker/circle_x", "renderer/glyph/marker/cross", "renderer/glyph/marker/diamond", "renderer/glyph/marker/diamond_cross", "renderer/glyph/marker/inverted_triangle", "renderer/glyph/marker/square", "renderer/glyph/marker/square_cross", "renderer/glyph/marker/square_x", "renderer/glyph/marker/triangle", "renderer/glyph/marker/x", "renderer/guide/categorical_axis", "renderer/guide/datetime_axis", "renderer/guide/grid", "renderer/guide/linear_axis", "renderer/guide/log_axis", "renderer/overlay/box_selection", "renderer/overlay/poly_selection", "source/column_data_source", "source/server_data_source", "ticking/abstract_ticker", "ticking/adaptive_ticker", "ticking/basic_tick_formatter", "ticking/basic_ticker", "ticking/log_ticker", "ticking/log_tick_formatter", "ticking/categorical_tick_formatter", "ticking/categorical_ticker", "ticking/composite_ticker", "ticking/datetime_tick_formatter", "ticking/datetime_ticker", "ticking/days_ticker", "ticking/months_ticker", "ticking/single_interval_ticker", "ticking/years_ticker", "tool/button_tool", "tool/actions/action_tool", "tool/actions/preview_save_tool", "tool/actions/reset_tool", "tool/gestures/box_select_tool", "tool/gestures/box_zoom_tool", "tool/gestures/gesture_tool", "tool/gestures/lasso_select_tool", "tool/gestures/pan_tool", "tool/gestures/resize_tool", "tool/gestures/select_tool", "tool/gestures/tap_tool", "tool/gestures/wheel_zoom_tool", "tool/inspectors/crosshair_tool", "tool/inspectors/hover_tool", "tool/inspectors/inspect_tool", "widget/data_table", "widget/handson_table", "widget/table_column", "widget/pivot_table", 'widget/paragraph', 'widget/hbox', 'widget/vbox', 'widget/textinput', 'widget/vboxform', 'widget/pretext', 'widget/selectbox', 'widget/slider', 'widget/crossfilter', 'widget/multiselect', 'widget/date_range_slider', 'widget/date_picker', 'widget/panel', 'widget/tabs', 'widget/dialog', 'widget/icon', 'widget/button', 'widget/toggle', 'widget/dropdown', 'widget/checkbox_group', 'widget/radio_group', 'widget/checkbox_button_group', 'widget/radio_button_group', 'transforms/autoencode', 'transforms/binarysegment', 'transforms/const', 'transforms/contour', 'transforms/count', 'transforms/countcategories', 'transforms/encode', 'transforms/cuberoot', 'transforms/hdalpha', 'transforms/id', 'transforms/interpolate', 'transforms/interpolatecolor', 'transforms/log', 'transforms/nonzero', 'transforms/ratio', 'transforms/seq', 'transforms/spread', 'transforms/tocounts'], function(_, require) {
                    var Collections, Config, collection_overrides, index, locations, mod_cache, url;
                    require("common/custom").monkey_patch();
                    Config = {};
                    url = window.location.href;
                    if (url.indexOf('/bokeh') > 0) {
                      Config.prefix = url.slice(0, url.indexOf('/bokeh')) + "/";
                    } else {
                      Config.prefix = '/';
                    }
                    console.log('Bokeh: setting prefix to', Config.prefix);
                    locations = {
                      Plot: 'common/plot',
                      GMapPlot: 'common/gmap_plot',
                      GeoJSPlot: 'common/geojs_plot',
                      GridPlot: 'common/grid_plot',
                      PlotContext: 'common/plot_context',
                      PlotList: 'common/plot_context',
                      Canvas: 'common/canvas',
                      LayoutBox: 'common/layout_box',
                      CartesianFrame: 'common/cartesian_frame',
                      SelectionManager: 'common/selection_manager',
                      Selector: 'common/selector',
                      ToolEvents: 'common/tool_events',
                      LinearColorMapper: 'mapper/linear_color_mapper',
                      DataFactorRange: 'range/data_factor_range',
                      DataRange1d: 'range/data_range1d',
                      FactorRange: 'range/factor_range',
                      Range1d: 'range/range1d',
                      Legend: 'renderer/annotation/legend',
                      Span: 'renderer/annotation/span',
                      Tooltip: 'renderer/annotation/tooltip',
                      GlyphRenderer: 'renderer/glyph/glyph_renderer',
                      AnnularWedge: 'renderer/glyph/annular_wedge',
                      Annulus: 'renderer/glyph/annulus',
                      Arc: 'renderer/glyph/arc',
                      Bezier: 'renderer/glyph/bezier',
                      Circle: 'renderer/glyph/circle',
                      Gear: 'renderer/glyph/gear',
                      Image: 'renderer/glyph/image',
                      ImageRGBA: 'renderer/glyph/image_rgba',
                      ImageURL: 'renderer/glyph/image_url',
                      Line: 'renderer/glyph/line',
                      MultiLine: 'renderer/glyph/multi_line',
                      Oval: 'renderer/glyph/oval',
                      Patch: 'renderer/glyph/patch',
                      Patches: 'renderer/glyph/patches',
                      Quad: 'renderer/glyph/quad',
                      Quadratic: 'renderer/glyph/quadratic',
                      Ray: 'renderer/glyph/ray',
                      Rect: 'renderer/glyph/rect',
                      Segment: 'renderer/glyph/segment',
                      Text: 'renderer/glyph/text',
                      Wedge: 'renderer/glyph/wedge',
                      Asterisk: 'renderer/glyph/marker/asterisk',
                      CircleCross: 'renderer/glyph/marker/circle_cross',
                      CircleX: 'renderer/glyph/marker/circle_x',
                      Cross: 'renderer/glyph/marker/cross',
                      Diamond: 'renderer/glyph/marker/diamond',
                      DiamondCross: 'renderer/glyph/marker/diamond_cross',
                      InvertedTriangle: 'renderer/glyph/marker/inverted_triangle',
                      Square: 'renderer/glyph/marker/square',
                      SquareCross: 'renderer/glyph/marker/square_cross',
                      SquareX: 'renderer/glyph/marker/square_x',
                      Triangle: 'renderer/glyph/marker/triangle',
                      X: 'renderer/glyph/marker/x',
                      LinearAxis: 'renderer/guide/linear_axis',
                      LogAxis: 'renderer/guide/log_axis',
                      CategoricalAxis: 'renderer/guide/categorical_axis',
                      DatetimeAxis: 'renderer/guide/datetime_axis',
                      Grid: 'renderer/guide/grid',
                      BoxSelection: 'renderer/overlay/box_selection',
                      PolySelection: 'renderer/overlay/poly_selection',
                      ColumnDataSource: 'source/column_data_source',
                      ServerDataSource: 'source/server_data_source',
                      AbstractTicker: 'ticking/abstract_ticker',
                      AdaptiveTicker: 'ticking/adaptive_ticker',
                      BasicTicker: 'ticking/basic_ticker',
                      BasicTickFormatter: 'ticking/basic_tick_formatter',
                      LogTicker: 'ticking/log_ticker',
                      LogTickFormatter: 'ticking/log_tick_formatter',
                      CategoricalTicker: 'ticking/categorical_ticker',
                      CategoricalTickFormatter: 'ticking/categorical_tick_formatter',
                      CompositeTicker: 'ticking/composite_ticker',
                      DatetimeTicker: 'ticking/datetime_ticker',
                      DatetimeTickFormatter: 'ticking/datetime_tick_formatter',
                      DaysTicker: 'ticking/days_ticker',
                      MonthsTicker: 'ticking/months_ticker',
                      SingleIntervalTicker: 'ticking/single_interval_ticker',
                      YearsTicker: 'ticking/years_ticker',
                      ButtonTool: 'tool/button_tool',
                      ActionTool: 'tool/actions/action_tool',
                      PreviewSaveTool: 'tool/actions/preview_save_tool',
                      ResetTool: 'tool/actions/reset_tool',
                      BoxSelectTool: 'tool/gestures/box_select_tool',
                      BoxZoomTool: 'tool/gestures/box_zoom_tool',
                      GestureTool: 'tool/gestures/gesture_tool',
                      LassoSelectTool: 'tool/gestures/lasso_select_tool',
                      PanTool: 'tool/gestures/pan_tool',
                      PolySelectTool: 'tool/gestures/poly_select_tool',
                      SelectTool: 'tool/gestures/select_tool',
                      ResizeTool: 'tool/gestures/resize_tool',
                      TapTool: 'tool/gestures/tap_tool',
                      WheelZoomTool: 'tool/gestures/wheel_zoom_tool',
                      CrosshairTool: 'tool/inspectors/crosshair_tool',
                      HoverTool: 'tool/inspectors/hover_tool',
                      InspectTool: 'tool/inspectors/inspect_tool',
                      DataTable: 'widget/data_table',
                      HandsonTable: 'widget/handson_table',
                      TableColumn: 'widget/table_column',
                      PivotTable: 'widget/pivot_table',
                      Paragraph: 'widget/paragraph',
                      HBox: 'widget/hbox',
                      VBox: 'widget/vbox',
                      VBoxForm: 'widget/vboxform',
                      TextInput: 'widget/textinput',
                      PreText: 'widget/pretext',
                      Select: 'widget/selectbox',
                      Slider: 'widget/slider',
                      CrossFilter: 'widget/crossfilter',
                      MultiSelect: 'widget/multiselect',
                      DateRangeSlider: 'widget/date_range_slider',
                      DatePicker: 'widget/date_picker',
                      Panel: 'widget/panel',
                      Tabs: 'widget/tabs',
                      Dialog: 'widget/dialog',
                      Icon: 'widget/icon',
                      Button: 'widget/button',
                      Toggle: 'widget/toggle',
                      Dropdown: 'widget/dropdown',
                      CheckboxGroup: 'widget/checkbox_group',
                      RadioGroup: 'widget/radio_group',
                      CheckboxButtonGroup: 'widget/checkbox_button_group',
                      RadioButtonGroup: 'widget/radio_button_group',
                      AutoEncode: 'transforms/autoencode',
                      BinarySegment: 'transforms/binarysegment',
                      Const: 'transforms/const',
                      Contour: 'transforms/contour',
                      Count: 'transforms/count',
                      CountCategories: 'transforms/countcategories',
                      Cuberoot: 'transforms/cuberoot',
                      HDAlpha: 'transforms/hdalpha',
                      Encode: 'transforms/encode',
                      Id: 'transforms/id',
                      Interpolate: 'transforms/interpolate',
                      InterpolateColor: 'transforms/interpolatecolor',
                      Log: 'transforms/log',
                      NonZero: 'transforms/nonzero',
                      Ratio: 'transforms/ratio',
                      Seq: 'transforms/seq',
                      Spread: 'transforms/spread',
                      ToCounts: 'transforms/tocounts'
                    };
                    mod_cache = {};
                    collection_overrides = {};
                    Collections = function(typename) {
                      var mod, modulename;
                      if (collection_overrides[typename]) {
                        return collection_overrides[typename];
                      }
                      if (!locations[typename]) {
                        throw "./base: Unknown Collection " + typename;
                      }
                      modulename = locations[typename];
                      if (mod_cache[modulename] == null) {
                        mod = require(modulename);
                        if (mod != null) {
                          mod_cache[modulename] = mod;
                        } else {
                          throw Error("improperly implemented collection: " + modulename);
                        }
                      }
                      return mod_cache[modulename].Collection;
                    };
                    Collections.register = function(name, collection) {
                      return collection_overrides[name] = collection;
                    };
                    index = {};
                    return {
                      "collection_overrides": collection_overrides,
                      "mod_cache": mod_cache,
                      "locations": locations,
                      "index": index,
                      "Collections": Collections,
                      "Config": Config
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=base.js.map
                */;
                (function() {
                  define('common/plotting',["underscore", "jquery", "./logging", "./plot", "range/data_range1d", "range/factor_range", "range/range1d", "renderer/annotation/legend", "renderer/glyph/glyph_renderer", "renderer/guide/categorical_axis", "renderer/guide/linear_axis", "renderer/guide/grid", "renderer/overlay/box_selection", "source/column_data_source", "tool/gestures/box_select_tool", "tool/gestures/box_zoom_tool", "tool/inspectors/hover_tool", "tool/gestures/pan_tool", "tool/actions/preview_save_tool", "tool/gestures/resize_tool", "tool/gestures/wheel_zoom_tool", "tool/actions/reset_tool", "renderer/guide/datetime_axis"], function(_, $, Logging, Plot, DataRange1d, FactorRange, Range1d, Legend, GlyphRenderer, CategoricalAxis, LinearAxis, Grid, BoxSelection, ColumnDataSource, BoxSelectTool, BoxZoomTool, HoverTool, PanTool, PreviewSaveTool, ResizeTool, WheelZoomTool, ResetTool, DatetimeAxis) {
                    var add_axes, add_grids, add_legend, add_tools, create_glyphs, create_range, create_sources, logger, make_plot, show;
                    logger = Logging.logger;
                    create_sources = function(data) {
                      var d, sources, _i, _len;
                      if (!_.isArray(data)) {
                        data = [data];
                      }
                      sources = [];
                      for (_i = 0, _len = data.length; _i < _len; _i++) {
                        d = data[_i];
                        if (d instanceof ColumnDataSource.Model) {
                          sources.push(d);
                        } else {
                          sources.push(ColumnDataSource.Collection.create({
                            data: d
                          }));
                        }
                      }
                      return sources;
                    };
                    create_range = function(range, sources, columns) {
                      var s;
                      if (range === 'auto') {
                        return DataRange1d.Collection.create({
                          sources: (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = sources.length; _i < _len; _i++) {
                              s = sources[_i];
                              _results.push({
                                source: s,
                                columns: columns
                              });
                            }
                            return _results;
                          })()
                        });
                      } else if ((range instanceof Range1d.Model) || (range instanceof FactorRange.Model)) {
                        return range;
                      } else {
                        if (typeof range[0] === "string") {
                          return FactorRange.Collection.create({
                            factors: range
                          });
                        } else {
                          return Range1d.Collection.create({
                            start: range[0],
                            end: range[1]
                          });
                        }
                      }
                    };
                    create_glyphs = function(plot, glyphspecs, sources, nonselection_glyphspecs) {
                      var glyph, glyphs, non_spec, source, spec, val, x, _i, _len, _ref;
                      glyphs = [];
                      if (!_.isArray(glyphspecs)) {
                        glyphspecs = [glyphspecs];
                      }
                      if (sources.length === 1) {
                        sources = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = glyphspecs.length; _i < _len; _i++) {
                            x = glyphspecs[_i];
                            _results.push(sources[0]);
                          }
                          return _results;
                        })();
                      }
                      if (nonselection_glyphspecs == null) {
                        nonselection_glyphspecs = {
                          fill_alpha: 0.1,
                          line_alpha: 0.1
                        };
                      }
                      if (!_.isArray(nonselection_glyphspecs)) {
                        nonselection_glyphspecs = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = glyphspecs.length; _i < _len; _i++) {
                            x = glyphspecs[_i];
                            _results.push(nonselection_glyphspecs);
                          }
                          return _results;
                        })();
                      }
                      _ref = _.zip(glyphspecs, nonselection_glyphspecs, sources);
                      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        val = _ref[_i];
                        spec = val[0], non_spec = val[1], source = val[2];
                        glyph = GlyphRenderer.Collection.create({
                          data_source: source,
                          glyph: spec,
                          nonselection_glyph: non_spec
                        });
                        glyphs.push(glyph);
                      }
                      return glyphs;
                    };
                    add_axes = function(plot, xaxes_spec, yaxes_spec, xdr, ydr) {
                      var a, above, axis, below, left, loc, right, xax, xaxes, yax, yaxes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n;
                      xaxes = [];
                      if (xaxes_spec) {
                        if (xaxes_spec === true) {
                          xaxes_spec = ['below', 'above'];
                        }
                        if (!_.isArray(xaxes_spec)) {
                          xaxes_spec = [xaxes_spec];
                        }
                        if (xaxes_spec[0] === "datetime") {
                          axis = DatetimeAxis.Collection.create({
                            axis_label: 'x',
                            location: 'below',
                            plot: plot
                          });
                          xaxes.push(axis);
                        } else if (xdr.type === "FactorRange") {
                          for (_i = 0, _len = xaxes_spec.length; _i < _len; _i++) {
                            loc = xaxes_spec[_i];
                            axis = CategoricalAxis.Collection.create({
                              axis_label: 'x',
                              location: loc,
                              plot: plot
                            });
                            xaxes.push(axis);
                          }
                        } else {
                          for (_j = 0, _len1 = xaxes_spec.length; _j < _len1; _j++) {
                            loc = xaxes_spec[_j];
                            axis = LinearAxis.Collection.create({
                              axis_label: 'x',
                              location: loc,
                              plot: plot
                            });
                            xaxes.push(axis);
                          }
                        }
                        for (_k = 0, _len2 = xaxes.length; _k < _len2; _k++) {
                          xax = xaxes[_k];
                          if (xax.get('location') === "below") {
                            below = plot.get('below');
                            below.push(xax);
                            plot.set('below', below);
                          } else if (xax.get('location') === "above") {
                            above = plot.get('above');
                            above.push(xax);
                            plot.set('above', above);
                          }
                        }
                      }
                      yaxes = [];
                      if (yaxes_spec) {
                        if (yaxes_spec === true) {
                          yaxes_spec = ['left', 'right'];
                        }
                        if (!_.isArray(yaxes_spec)) {
                          yaxes_spec = [yaxes_spec];
                        }
                        if (yaxes_spec[0] === "datetime") {
                          axis = DatetimeAxis.Collection.create({
                            axis_label: 'y',
                            location: 'left',
                            plot: plot
                          });
                          yaxes.push(axis);
                        } else if (ydr.type === "FactorRange") {
                          for (_l = 0, _len3 = yaxes_spec.length; _l < _len3; _l++) {
                            loc = yaxes_spec[_l];
                            axis = CategoricalAxis.Collection.create({
                              axis_label: 'y',
                              location: loc,
                              plot: plot
                            });
                            yaxes.push(axis);
                          }
                        } else {
                          for (_m = 0, _len4 = yaxes_spec.length; _m < _len4; _m++) {
                            loc = yaxes_spec[_m];
                            axis = LinearAxis.Collection.create({
                              axis_label: 'y',
                              location: loc,
                              plot: plot
                            });
                            yaxes.push(axis);
                          }
                        }
                        for (_n = 0, _len5 = yaxes.length; _n < _len5; _n++) {
                          yax = yaxes[_n];
                          if (yax.get('location') === "left") {
                            left = plot.get('left');
                            left.push(yax);
                            plot.set('left', left);
                          } else if (yax.get('location') === "right") {
                            right = plot.get('right');
                            right.push(yax);
                            plot.set('right', right);
                          }
                        }
                      }
                      plot.add_renderers((function() {
                        var _len6, _o, _results;
                        _results = [];
                        for (_o = 0, _len6 = xaxes.length; _o < _len6; _o++) {
                          a = xaxes[_o];
                          _results.push(a);
                        }
                        return _results;
                      })());
                      plot.add_renderers((function() {
                        var _len6, _o, _results;
                        _results = [];
                        for (_o = 0, _len6 = yaxes.length; _o < _len6; _o++) {
                          a = yaxes[_o];
                          _results.push(a);
                        }
                        return _results;
                      })());
                      return [xaxes, yaxes];
                    };
                    add_grids = function(plot, xgrid, ygrid, xaxes, yaxes) {
                      var g, grid, grids;
                      grids = [];
                      if (xgrid && xaxes.length > 0) {
                        grid = Grid.Collection.create({
                          dimension: 0,
                          plot: plot,
                          ticker: xaxes[0].get('ticker')
                        });
                        grids.push(grid);
                      }
                      if (ygrid && yaxes.length > 0) {
                        grid = Grid.Collection.create({
                          dimension: 1,
                          plot: plot,
                          ticker: yaxes[0].get('ticker')
                        });
                        grids.push(grid);
                        return plot.add_renderers((function() {
                          var _i, _len, _results;
                          _results = [];
                          for (_i = 0, _len = grids.length; _i < _len; _i++) {
                            g = grids[_i];
                            _results.push(g);
                          }
                          return _results;
                        })());
                      }
                    };
                    add_tools = function(plot, tools, glyphs, xdr, ydr) {
                      var added_tools, box_zoom_overlay, box_zoom_tool, g, hover_tool, pan_tool, preview_tool, reset_tool, resize_tool, select_overlay, select_tool, wheel_zoom_tool;
                      if (tools === false) {
                        return;
                      }
                      if (tools === true) {
                        tools = "pan,wheel_zoom,select,resize,preview,reset,box_zoom";
                      }
                      added_tools = [];
                      if (tools.indexOf("pan") > -1) {
                        pan_tool = PanTool.Collection.create({
                          dataranges: [xdr, ydr],
                          dimensions: ['width', 'height']
                        });
                        added_tools.push(pan_tool);
                      }
                      if (tools.indexOf("wheel_zoom") > -1) {
                        wheel_zoom_tool = WheelZoomTool.Collection.create({
                          dataranges: [xdr, ydr],
                          dimensions: ['width', 'height']
                        });
                        added_tools.push(wheel_zoom_tool);
                      }
                      if (tools.indexOf("hover") > -1) {
                        hover_tool = HoverTool.Collection.create({
                          plot: plot
                        });
                        added_tools.push(hover_tool);
                      }
                      if (tools.indexOf("select") > -1) {
                        select_tool = BoxSelectTool.Collection.create({
                          renderers: (function() {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = glyphs.length; _i < _len; _i++) {
                              g = glyphs[_i];
                              _results.push(g);
                            }
                            return _results;
                          })()
                        });
                        select_overlay = BoxSelection.Collection.create({
                          tool: select_tool
                        });
                        added_tools.push(select_tool);
                        plot.add_renderers([select_overlay]);
                      }
                      if (tools.indexOf("resize") > -1) {
                        resize_tool = ResizeTool.Collection.create();
                        added_tools.push(resize_tool);
                      }
                      if (tools.indexOf("preview") > -1) {
                        preview_tool = PreviewSaveTool.Collection.create();
                        added_tools.push(preview_tool);
                      }
                      if (tools.indexOf("reset") > -1) {
                        reset_tool = ResetTool.Collection.create();
                        added_tools.push(reset_tool);
                      }
                      if (tools.indexOf("box_zoom") > -1) {
                        box_zoom_tool = BoxZoomTool.Collection.create();
                        box_zoom_overlay = BoxSelection.Collection.create({
                          tool: box_zoom_tool
                        });
                        added_tools.push(box_zoom_tool);
                        plot.add_renderers([box_zoom_overlay]);
                      }
                      return plot.set_obj('tools', added_tools);
                    };
                    add_legend = function(plot, legend, glyphs) {
                      var glyph, idx, legend_renderer, legends;
                      if (legend) {
                        legends = (function() {
                          var _i, _len, _results;
                          _results = [];
                          for (idx = _i = 0, _len = glyphs.length; _i < _len; idx = ++_i) {
                            glyph = glyphs[idx];
                            _results.push([legend + String(idx), [glyph]]);
                          }
                          return _results;
                        })();
                        legend_renderer = Legend.Collection.create({
                          plot: plot,
                          orientation: "top_right",
                          legends: legends
                        });
                        return plot.add_renderers([legend_renderer]);
                      }
                    };
                    make_plot = function(glyphspecs, data, _arg) {
                      var dims, g, glyphs, legend, nonselected, plot, sources, title, tools, xaxes, xdr, xgrid, xrange, yaxes, ydr, ygrid, yrange, _ref;
                      nonselected = _arg.nonselected, title = _arg.title, dims = _arg.dims, xrange = _arg.xrange, yrange = _arg.yrange, xaxes = _arg.xaxes, yaxes = _arg.yaxes, xgrid = _arg.xgrid, ygrid = _arg.ygrid, xdr = _arg.xdr, ydr = _arg.ydr, tools = _arg.tools, legend = _arg.legend;
                      if (nonselected == null) {
                        nonselected = null;
                      }
                      if (title == null) {
                        title = "";
                      }
                      if (dims == null) {
                        dims = [400, 400];
                      }
                      if (xrange == null) {
                        xrange = 'auto';
                      }
                      if (yrange == null) {
                        yrange = 'auto';
                      }
                      if (xaxes == null) {
                        xaxes = true;
                      }
                      if (yaxes == null) {
                        yaxes = true;
                      }
                      if (xgrid == null) {
                        xgrid = true;
                      }
                      if (ygrid == null) {
                        ygrid = true;
                      }
                      if (tools == null) {
                        tools = true;
                      }
                      if (legend == null) {
                        legend = false;
                      }
                      sources = create_sources(data);
                      xdr = create_range(xrange, sources, ['x']);
                      ydr = create_range(yrange, sources, ['y']);
                      plot = Plot.Collection.create({
                        x_range: xdr,
                        y_range: ydr,
                        plot_width: dims[0],
                        plot_height: dims[1],
                        title: title
                      });
                      glyphs = create_glyphs(plot, glyphspecs, sources, nonselected);
                      plot.add_renderers((function() {
                        var _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = glyphs.length; _i < _len; _i++) {
                          g = glyphs[_i];
                          _results.push(g);
                        }
                        return _results;
                      })());
                      _ref = add_axes(plot, xaxes, yaxes, xdr, ydr), xaxes = _ref[0], yaxes = _ref[1];
                      add_grids(plot, xgrid, ygrid, xaxes, yaxes);
                      add_tools(plot, tools, glyphs, xdr, ydr);
                      add_legend(plot, legend, glyphs);
                      return plot;
                    };
                    show = function(plot, target_div) {
                      var div, myrender;
                      if (target_div == null) {
                        target_div = false;
                      }
                      div = $('<div class="plotdiv"></div>');
                      if (target_div) {
                        target_div = $(target_div);
                      } else {
                        target_div = $('body');
                      }
                      target_div.append(div);
                      myrender = function() {
                        var view;
                        view = new plot.default_view({
                          model: plot
                        });
                        window.pview = view;
                        div.append(view.$el);
                        return logger.info("added plot: " + (plot.get('title')));
                      };
                      return _.defer(myrender);
                    };
                    return {
                      "make_plot": make_plot,
                      "create_glyphs": create_glyphs,
                      "show": show
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=plotting.js.map
                */;
                (function() {
                  define('common/load_models',["require", "./base", "./logging"], function(require, base, Logging) {
                    var load_models, logger;
                    logger = Logging.logger;
                    return load_models = function(modelspecs) {
                      var Collections, attrs, coll, coll_attrs, model, newspecs, oldspecs, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m;
                      newspecs = [];
                      oldspecs = [];
                      Collections = require("./base").Collections;
                      logger.debug("load_models: start");
                      for (_i = 0, _len = modelspecs.length; _i < _len; _i++) {
                        model = modelspecs[_i];
                        coll = Collections(model['type']);
                        attrs = model['attributes'];
                        if (coll && coll.get(attrs['id'])) {
                          oldspecs.push([coll, attrs]);
                        } else {
                          newspecs.push([coll, attrs]);
                        }
                      }
                      for (_j = 0, _len1 = newspecs.length; _j < _len1; _j++) {
                        coll_attrs = newspecs[_j];
                        coll = coll_attrs[0], attrs = coll_attrs[1];
                        if (coll) {
                          coll.add(attrs, {
                            'silent': true,
                            'defer_initialization': true
                          });
                        }
                      }
                      logger.debug("load_models: starting deferred initializations");
                      for (_k = 0, _len2 = newspecs.length; _k < _len2; _k++) {
                        coll_attrs = newspecs[_k];
                        coll = coll_attrs[0], attrs = coll_attrs[1];
                        if (coll) {
                          coll.get(attrs['id']).initialize(attrs);
                        }
                      }
                      logger.debug("load_models: finished deferred initializations");
                      for (_l = 0, _len3 = newspecs.length; _l < _len3; _l++) {
                        coll_attrs = newspecs[_l];
                        coll = coll_attrs[0], attrs = coll_attrs[1];
                        if (coll) {
                          model = coll.get(attrs.id);
                          model.trigger('add', model, coll, {});
                        }
                      }
                      for (_m = 0, _len4 = oldspecs.length; _m < _len4; _m++) {
                        coll_attrs = oldspecs[_m];
                        coll = coll_attrs[0], attrs = coll_attrs[1];
                        if (coll) {
                          coll.get(attrs['id']).set(attrs);
                        }
                      }
                      logger.debug("load_models: finish");
                      return null;
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=load_models.js.map
                */;
                (function() {
                  define('common/bulk_save',["underscore", "jquery", "require", "./base", "./load_models"], function(_, $, require, base, load_models) {
                    var bulk_save;
                    return bulk_save = function(models) {
                      var Config, doc, jsondata, m, url, xhr;
                      Config = require("./base").Config;
                      doc = models[0].get('doc');
                      if (doc == null) {
                        throw new Error("Unset 'doc' in " + models[0]);
                      }
                      jsondata = (function() {
                        var _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = models.length; _i < _len; _i++) {
                          m = models[_i];
                          _results.push({
                            type: m.type,
                            attributes: _.clone(m.attributes)
                          });
                        }
                        return _results;
                      })();
                      jsondata = JSON.stringify(jsondata);
                      url = Config.prefix + "bokeh/bb/" + doc + "/bulkupsert";
                      xhr = $.ajax({
                        type: 'POST',
                        url: url,
                        contentType: "application/json",
                        data: jsondata,
                        header: {
                          client: "javascript"
                        }
                      });
                      xhr.done(function(data) {
                        return load_models(data.modelspecs);
                      });
                      return xhr;
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=bulk_save.js.map
                */;
                (function() {
                  define('common/random',[], function() {
                    var Random;
                    return Random = (function() {
                      function Random(seed) {
                        this.seed = seed;
                        this.multiplier = 1664525;
                        this.modulo = 4294967296;
                        this.offset = 1013904223;
                        if (!((this.seed != null) && (0 <= seed && seed < this.modulo))) {
                          this.seed = (new Date().valueOf() * new Date().getMilliseconds()) % this.modulo;
                        }
                      }
                
                      Random.prototype.seed = function(seed) {
                        return this.seed = seed;
                      };
                
                      Random.prototype.randn = function() {
                        return this.seed = (this.multiplier * this.seed + this.offset) % this.modulo;
                      };
                
                      Random.prototype.randf = function() {
                        return this.randn() / this.modulo;
                      };
                
                      Random.prototype.rand = function(n) {
                        return Math.floor(this.randf() * n);
                      };
                
                      Random.prototype.rand2 = function(min, max) {
                        return min + this.rand(max - min);
                      };
                
                      return Random;
                
                    })();
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=random.js.map
                */;
                (function() {
                  define('palettes/colorbrewer',[], function() {
                    var colorbrewer;
                    return colorbrewer = {
                      YlGn: {
                        3: [0xf7fcb9, 0xaddd8e, 0x31a354],
                        4: [0xffffcc, 0xc2e699, 0x78c679, 0x238443],
                        5: [0xffffcc, 0xc2e699, 0x78c679, 0x31a354, 0x006837],
                        6: [0xffffcc, 0xd9f0a3, 0xaddd8e, 0x78c679, 0x31a354, 0x006837],
                        7: [0xffffcc, 0xd9f0a3, 0xaddd8e, 0x78c679, 0x41ab5d, 0x238443, 0x005a32],
                        8: [0xffffe5, 0xf7fcb9, 0xd9f0a3, 0xaddd8e, 0x78c679, 0x41ab5d, 0x238443, 0x005a32],
                        9: [0xffffe5, 0xf7fcb9, 0xd9f0a3, 0xaddd8e, 0x78c679, 0x41ab5d, 0x238443, 0x006837, 0x004529]
                      },
                      YlGnBu: {
                        3: [0xedf8b1, 0x7fcdbb, 0x2c7fb8],
                        4: [0xffffcc, 0xa1dab4, 0x41b6c4, 0x225ea8],
                        5: [0xffffcc, 0xa1dab4, 0x41b6c4, 0x2c7fb8, 0x253494],
                        6: [0xffffcc, 0xc7e9b4, 0x7fcdbb, 0x41b6c4, 0x2c7fb8, 0x253494],
                        7: [0xffffcc, 0xc7e9b4, 0x7fcdbb, 0x41b6c4, 0x1d91c0, 0x225ea8, 0x0c2c84],
                        8: [0xffffd9, 0xedf8b1, 0xc7e9b4, 0x7fcdbb, 0x41b6c4, 0x1d91c0, 0x225ea8, 0x0c2c84],
                        9: [0xffffd9, 0xedf8b1, 0xc7e9b4, 0x7fcdbb, 0x41b6c4, 0x1d91c0, 0x225ea8, 0x253494, 0x081d58]
                      },
                      GnBu: {
                        3: [0xe0f3db, 0xa8ddb5, 0x43a2ca],
                        4: [0xf0f9e8, 0xbae4bc, 0x7bccc4, 0x2b8cbe],
                        5: [0xf0f9e8, 0xbae4bc, 0x7bccc4, 0x43a2ca, 0x0868ac],
                        6: [0xf0f9e8, 0xccebc5, 0xa8ddb5, 0x7bccc4, 0x43a2ca, 0x0868ac],
                        7: [0xf0f9e8, 0xccebc5, 0xa8ddb5, 0x7bccc4, 0x4eb3d3, 0x2b8cbe, 0x08589e],
                        8: [0xf7fcf0, 0xe0f3db, 0xccebc5, 0xa8ddb5, 0x7bccc4, 0x4eb3d3, 0x2b8cbe, 0x08589e],
                        9: [0xf7fcf0, 0xe0f3db, 0xccebc5, 0xa8ddb5, 0x7bccc4, 0x4eb3d3, 0x2b8cbe, 0x0868ac, 0x084081]
                      },
                      BuGn: {
                        3: [0xe5f5f9, 0x99d8c9, 0x2ca25f],
                        4: [0xedf8fb, 0xb2e2e2, 0x66c2a4, 0x238b45],
                        5: [0xedf8fb, 0xb2e2e2, 0x66c2a4, 0x2ca25f, 0x006d2c],
                        6: [0xedf8fb, 0xccece6, 0x99d8c9, 0x66c2a4, 0x2ca25f, 0x006d2c],
                        7: [0xedf8fb, 0xccece6, 0x99d8c9, 0x66c2a4, 0x41ae76, 0x238b45, 0x005824],
                        8: [0xf7fcfd, 0xe5f5f9, 0xccece6, 0x99d8c9, 0x66c2a4, 0x41ae76, 0x238b45, 0x005824],
                        9: [0xf7fcfd, 0xe5f5f9, 0xccece6, 0x99d8c9, 0x66c2a4, 0x41ae76, 0x238b45, 0x006d2c, 0x00441b]
                      },
                      PuBuGn: {
                        3: [0xece2f0, 0xa6bddb, 0x1c9099],
                        4: [0xf6eff7, 0xbdc9e1, 0x67a9cf, 0x02818a],
                        5: [0xf6eff7, 0xbdc9e1, 0x67a9cf, 0x1c9099, 0x016c59],
                        6: [0xf6eff7, 0xd0d1e6, 0xa6bddb, 0x67a9cf, 0x1c9099, 0x016c59],
                        7: [0xf6eff7, 0xd0d1e6, 0xa6bddb, 0x67a9cf, 0x3690c0, 0x02818a, 0x016450],
                        8: [0xfff7fb, 0xece2f0, 0xd0d1e6, 0xa6bddb, 0x67a9cf, 0x3690c0, 0x02818a, 0x016450],
                        9: [0xfff7fb, 0xece2f0, 0xd0d1e6, 0xa6bddb, 0x67a9cf, 0x3690c0, 0x02818a, 0x016c59, 0x014636]
                      },
                      PuBu: {
                        3: [0xece7f2, 0xa6bddb, 0x2b8cbe],
                        4: [0xf1eef6, 0xbdc9e1, 0x74a9cf, 0x0570b0],
                        5: [0xf1eef6, 0xbdc9e1, 0x74a9cf, 0x2b8cbe, 0x045a8d],
                        6: [0xf1eef6, 0xd0d1e6, 0xa6bddb, 0x74a9cf, 0x2b8cbe, 0x045a8d],
                        7: [0xf1eef6, 0xd0d1e6, 0xa6bddb, 0x74a9cf, 0x3690c0, 0x0570b0, 0x034e7b],
                        8: [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf, 0x3690c0, 0x0570b0, 0x034e7b],
                        9: [0xfff7fb, 0xece7f2, 0xd0d1e6, 0xa6bddb, 0x74a9cf, 0x3690c0, 0x0570b0, 0x045a8d, 0x023858]
                      },
                      BuPu: {
                        3: [0xe0ecf4, 0x9ebcda, 0x8856a7],
                        4: [0xedf8fb, 0xb3cde3, 0x8c96c6, 0x88419d],
                        5: [0xedf8fb, 0xb3cde3, 0x8c96c6, 0x8856a7, 0x810f7c],
                        6: [0xedf8fb, 0xbfd3e6, 0x9ebcda, 0x8c96c6, 0x8856a7, 0x810f7c],
                        7: [0xedf8fb, 0xbfd3e6, 0x9ebcda, 0x8c96c6, 0x8c6bb1, 0x88419d, 0x6e016b],
                        8: [0xf7fcfd, 0xe0ecf4, 0xbfd3e6, 0x9ebcda, 0x8c96c6, 0x8c6bb1, 0x88419d, 0x6e016b],
                        9: [0xf7fcfd, 0xe0ecf4, 0xbfd3e6, 0x9ebcda, 0x8c96c6, 0x8c6bb1, 0x88419d, 0x810f7c, 0x4d004b]
                      },
                      RdPu: {
                        3: [0xfde0dd, 0xfa9fb5, 0xc51b8a],
                        4: [0xfeebe2, 0xfbb4b9, 0xf768a1, 0xae017e],
                        5: [0xfeebe2, 0xfbb4b9, 0xf768a1, 0xc51b8a, 0x7a0177],
                        6: [0xfeebe2, 0xfcc5c0, 0xfa9fb5, 0xf768a1, 0xc51b8a, 0x7a0177],
                        7: [0xfeebe2, 0xfcc5c0, 0xfa9fb5, 0xf768a1, 0xdd3497, 0xae017e, 0x7a0177],
                        8: [0xfff7f3, 0xfde0dd, 0xfcc5c0, 0xfa9fb5, 0xf768a1, 0xdd3497, 0xae017e, 0x7a0177],
                        9: [0xfff7f3, 0xfde0dd, 0xfcc5c0, 0xfa9fb5, 0xf768a1, 0xdd3497, 0xae017e, 0x7a0177, 0x49006a]
                      },
                      PuRd: {
                        3: [0xe7e1ef, 0xc994c7, 0xdd1c77],
                        4: [0xf1eef6, 0xd7b5d8, 0xdf65b0, 0xce1256],
                        5: [0xf1eef6, 0xd7b5d8, 0xdf65b0, 0xdd1c77, 0x980043],
                        6: [0xf1eef6, 0xd4b9da, 0xc994c7, 0xdf65b0, 0xdd1c77, 0x980043],
                        7: [0xf1eef6, 0xd4b9da, 0xc994c7, 0xdf65b0, 0xe7298a, 0xce1256, 0x91003f],
                        8: [0xf7f4f9, 0xe7e1ef, 0xd4b9da, 0xc994c7, 0xdf65b0, 0xe7298a, 0xce1256, 0x91003f],
                        9: [0xf7f4f9, 0xe7e1ef, 0xd4b9da, 0xc994c7, 0xdf65b0, 0xe7298a, 0xce1256, 0x980043, 0x67001f]
                      },
                      OrRd: {
                        3: [0xfee8c8, 0xfdbb84, 0xe34a33],
                        4: [0xfef0d9, 0xfdcc8a, 0xfc8d59, 0xd7301f],
                        5: [0xfef0d9, 0xfdcc8a, 0xfc8d59, 0xe34a33, 0xb30000],
                        6: [0xfef0d9, 0xfdd49e, 0xfdbb84, 0xfc8d59, 0xe34a33, 0xb30000],
                        7: [0xfef0d9, 0xfdd49e, 0xfdbb84, 0xfc8d59, 0xef6548, 0xd7301f, 0x990000],
                        8: [0xfff7ec, 0xfee8c8, 0xfdd49e, 0xfdbb84, 0xfc8d59, 0xef6548, 0xd7301f, 0x990000],
                        9: [0xfff7ec, 0xfee8c8, 0xfdd49e, 0xfdbb84, 0xfc8d59, 0xef6548, 0xd7301f, 0xb30000, 0x7f0000]
                      },
                      YlOrRd: {
                        3: [0xffeda0, 0xfeb24c, 0xf03b20],
                        4: [0xffffb2, 0xfecc5c, 0xfd8d3c, 0xe31a1c],
                        5: [0xffffb2, 0xfecc5c, 0xfd8d3c, 0xf03b20, 0xbd0026],
                        6: [0xffffb2, 0xfed976, 0xfeb24c, 0xfd8d3c, 0xf03b20, 0xbd0026],
                        7: [0xffffb2, 0xfed976, 0xfeb24c, 0xfd8d3c, 0xfc4e2a, 0xe31a1c, 0xb10026],
                        8: [0xffffcc, 0xffeda0, 0xfed976, 0xfeb24c, 0xfd8d3c, 0xfc4e2a, 0xe31a1c, 0xb10026],
                        9: [0xffffcc, 0xffeda0, 0xfed976, 0xfeb24c, 0xfd8d3c, 0xfc4e2a, 0xe31a1c, 0xbd0026, 0x800026]
                      },
                      YlOrBr: {
                        3: [0xfff7bc, 0xfec44f, 0xd95f0e],
                        4: [0xffffd4, 0xfed98e, 0xfe9929, 0xcc4c02],
                        5: [0xffffd4, 0xfed98e, 0xfe9929, 0xd95f0e, 0x993404],
                        6: [0xffffd4, 0xfee391, 0xfec44f, 0xfe9929, 0xd95f0e, 0x993404],
                        7: [0xffffd4, 0xfee391, 0xfec44f, 0xfe9929, 0xec7014, 0xcc4c02, 0x8c2d04],
                        8: [0xffffe5, 0xfff7bc, 0xfee391, 0xfec44f, 0xfe9929, 0xec7014, 0xcc4c02, 0x8c2d04],
                        9: [0xffffe5, 0xfff7bc, 0xfee391, 0xfec44f, 0xfe9929, 0xec7014, 0xcc4c02, 0x993404, 0x662506]
                      },
                      Purples: {
                        3: [0xefedf5, 0xbcbddc, 0x756bb1],
                        4: [0xf2f0f7, 0xcbc9e2, 0x9e9ac8, 0x6a51a3],
                        5: [0xf2f0f7, 0xcbc9e2, 0x9e9ac8, 0x756bb1, 0x54278f],
                        6: [0xf2f0f7, 0xdadaeb, 0xbcbddc, 0x9e9ac8, 0x756bb1, 0x54278f],
                        7: [0xf2f0f7, 0xdadaeb, 0xbcbddc, 0x9e9ac8, 0x807dba, 0x6a51a3, 0x4a1486],
                        8: [0xfcfbfd, 0xefedf5, 0xdadaeb, 0xbcbddc, 0x9e9ac8, 0x807dba, 0x6a51a3, 0x4a1486],
                        9: [0xfcfbfd, 0xefedf5, 0xdadaeb, 0xbcbddc, 0x9e9ac8, 0x807dba, 0x6a51a3, 0x54278f, 0x3f007d]
                      },
                      Blues: {
                        3: [0xdeebf7, 0x9ecae1, 0x3182bd],
                        4: [0xeff3ff, 0xbdd7e7, 0x6baed6, 0x2171b5],
                        5: [0xeff3ff, 0xbdd7e7, 0x6baed6, 0x3182bd, 0x08519c],
                        6: [0xeff3ff, 0xc6dbef, 0x9ecae1, 0x6baed6, 0x3182bd, 0x08519c],
                        7: [0xeff3ff, 0xc6dbef, 0x9ecae1, 0x6baed6, 0x4292c6, 0x2171b5, 0x084594],
                        8: [0xf7fbff, 0xdeebf7, 0xc6dbef, 0x9ecae1, 0x6baed6, 0x4292c6, 0x2171b5, 0x084594],
                        9: [0xf7fbff, 0xdeebf7, 0xc6dbef, 0x9ecae1, 0x6baed6, 0x4292c6, 0x2171b5, 0x08519c, 0x08306b]
                      },
                      Greens: {
                        3: [0xe5f5e0, 0xa1d99b, 0x31a354],
                        4: [0xedf8e9, 0xbae4b3, 0x74c476, 0x238b45],
                        5: [0xedf8e9, 0xbae4b3, 0x74c476, 0x31a354, 0x006d2c],
                        6: [0xedf8e9, 0xc7e9c0, 0xa1d99b, 0x74c476, 0x31a354, 0x006d2c],
                        7: [0xedf8e9, 0xc7e9c0, 0xa1d99b, 0x74c476, 0x41ab5d, 0x238b45, 0x005a32],
                        8: [0xf7fcf5, 0xe5f5e0, 0xc7e9c0, 0xa1d99b, 0x74c476, 0x41ab5d, 0x238b45, 0x005a32],
                        9: [0xf7fcf5, 0xe5f5e0, 0xc7e9c0, 0xa1d99b, 0x74c476, 0x41ab5d, 0x238b45, 0x006d2c, 0x00441b]
                      },
                      Oranges: {
                        3: [0xfee6ce, 0xfdae6b, 0xe6550d],
                        4: [0xfeedde, 0xfdbe85, 0xfd8d3c, 0xd94701],
                        5: [0xfeedde, 0xfdbe85, 0xfd8d3c, 0xe6550d, 0xa63603],
                        6: [0xfeedde, 0xfdd0a2, 0xfdae6b, 0xfd8d3c, 0xe6550d, 0xa63603],
                        7: [0xfeedde, 0xfdd0a2, 0xfdae6b, 0xfd8d3c, 0xf16913, 0xd94801, 0x8c2d04],
                        8: [0xfff5eb, 0xfee6ce, 0xfdd0a2, 0xfdae6b, 0xfd8d3c, 0xf16913, 0xd94801, 0x8c2d04],
                        9: [0xfff5eb, 0xfee6ce, 0xfdd0a2, 0xfdae6b, 0xfd8d3c, 0xf16913, 0xd94801, 0xa63603, 0x7f2704]
                      },
                      Reds: {
                        3: [0xfee0d2, 0xfc9272, 0xde2d26],
                        4: [0xfee5d9, 0xfcae91, 0xfb6a4a, 0xcb181d],
                        5: [0xfee5d9, 0xfcae91, 0xfb6a4a, 0xde2d26, 0xa50f15],
                        6: [0xfee5d9, 0xfcbba1, 0xfc9272, 0xfb6a4a, 0xde2d26, 0xa50f15],
                        7: [0xfee5d9, 0xfcbba1, 0xfc9272, 0xfb6a4a, 0xef3b2c, 0xcb181d, 0x99000d],
                        8: [0xfff5f0, 0xfee0d2, 0xfcbba1, 0xfc9272, 0xfb6a4a, 0xef3b2c, 0xcb181d, 0x99000d],
                        9: [0xfff5f0, 0xfee0d2, 0xfcbba1, 0xfc9272, 0xfb6a4a, 0xef3b2c, 0xcb181d, 0xa50f15, 0x67000d]
                      },
                      Greys: {
                        3: [0xf0f0f0, 0xbdbdbd, 0x636363],
                        4: [0xf7f7f7, 0xcccccc, 0x969696, 0x525252],
                        5: [0xf7f7f7, 0xcccccc, 0x969696, 0x636363, 0x252525],
                        6: [0xf7f7f7, 0xd9d9d9, 0xbdbdbd, 0x969696, 0x636363, 0x252525],
                        7: [0xf7f7f7, 0xd9d9d9, 0xbdbdbd, 0x969696, 0x737373, 0x525252, 0x252525],
                        8: [0xffffff, 0xf0f0f0, 0xd9d9d9, 0xbdbdbd, 0x969696, 0x737373, 0x525252, 0x252525],
                        9: [0xffffff, 0xf0f0f0, 0xd9d9d9, 0xbdbdbd, 0x969696, 0x737373, 0x525252, 0x252525, 0x000000]
                      },
                      PuOr: {
                        3: [0xf1a340, 0xf7f7f7, 0x998ec3],
                        4: [0xe66101, 0xfdb863, 0xb2abd2, 0x5e3c99],
                        5: [0xe66101, 0xfdb863, 0xf7f7f7, 0xb2abd2, 0x5e3c99],
                        6: [0xb35806, 0xf1a340, 0xfee0b6, 0xd8daeb, 0x998ec3, 0x542788],
                        7: [0xb35806, 0xf1a340, 0xfee0b6, 0xf7f7f7, 0xd8daeb, 0x998ec3, 0x542788],
                        8: [0xb35806, 0xe08214, 0xfdb863, 0xfee0b6, 0xd8daeb, 0xb2abd2, 0x8073ac, 0x542788],
                        9: [0xb35806, 0xe08214, 0xfdb863, 0xfee0b6, 0xf7f7f7, 0xd8daeb, 0xb2abd2, 0x8073ac, 0x542788],
                        10: [0x7f3b08, 0xb35806, 0xe08214, 0xfdb863, 0xfee0b6, 0xd8daeb, 0xb2abd2, 0x8073ac, 0x542788, 0x2d004b],
                        11: [0x7f3b08, 0xb35806, 0xe08214, 0xfdb863, 0xfee0b6, 0xf7f7f7, 0xd8daeb, 0xb2abd2, 0x8073ac, 0x542788, 0x2d004b]
                      },
                      BrBG: {
                        3: [0xd8b365, 0xf5f5f5, 0x5ab4ac],
                        4: [0xa6611a, 0xdfc27d, 0x80cdc1, 0x018571],
                        5: [0xa6611a, 0xdfc27d, 0xf5f5f5, 0x80cdc1, 0x018571],
                        6: [0x8c510a, 0xd8b365, 0xf6e8c3, 0xc7eae5, 0x5ab4ac, 0x01665e],
                        7: [0x8c510a, 0xd8b365, 0xf6e8c3, 0xf5f5f5, 0xc7eae5, 0x5ab4ac, 0x01665e],
                        8: [0x8c510a, 0xbf812d, 0xdfc27d, 0xf6e8c3, 0xc7eae5, 0x80cdc1, 0x35978f, 0x01665e],
                        9: [0x8c510a, 0xbf812d, 0xdfc27d, 0xf6e8c3, 0xf5f5f5, 0xc7eae5, 0x80cdc1, 0x35978f, 0x01665e],
                        10: [0x543005, 0x8c510a, 0xbf812d, 0xdfc27d, 0xf6e8c3, 0xc7eae5, 0x80cdc1, 0x35978f, 0x01665e, 0x003c30],
                        11: [0x543005, 0x8c510a, 0xbf812d, 0xdfc27d, 0xf6e8c3, 0xf5f5f5, 0xc7eae5, 0x80cdc1, 0x35978f, 0x01665e, 0x003c30]
                      },
                      PRGn: {
                        3: [0xaf8dc3, 0xf7f7f7, 0x7fbf7b],
                        4: [0x7b3294, 0xc2a5cf, 0xa6dba0, 0x008837],
                        5: [0x7b3294, 0xc2a5cf, 0xf7f7f7, 0xa6dba0, 0x008837],
                        6: [0x762a83, 0xaf8dc3, 0xe7d4e8, 0xd9f0d3, 0x7fbf7b, 0x1b7837],
                        7: [0x762a83, 0xaf8dc3, 0xe7d4e8, 0xf7f7f7, 0xd9f0d3, 0x7fbf7b, 0x1b7837],
                        8: [0x762a83, 0x9970ab, 0xc2a5cf, 0xe7d4e8, 0xd9f0d3, 0xa6dba0, 0x5aae61, 0x1b7837],
                        9: [0x762a83, 0x9970ab, 0xc2a5cf, 0xe7d4e8, 0xf7f7f7, 0xd9f0d3, 0xa6dba0, 0x5aae61, 0x1b7837],
                        10: [0x40004b, 0x762a83, 0x9970ab, 0xc2a5cf, 0xe7d4e8, 0xd9f0d3, 0xa6dba0, 0x5aae61, 0x1b7837, 0x00441b],
                        11: [0x40004b, 0x762a83, 0x9970ab, 0xc2a5cf, 0xe7d4e8, 0xf7f7f7, 0xd9f0d3, 0xa6dba0, 0x5aae61, 0x1b7837, 0x00441b]
                      },
                      PiYG: {
                        3: [0xe9a3c9, 0xf7f7f7, 0xa1d76a],
                        4: [0xd01c8b, 0xf1b6da, 0xb8e186, 0x4dac26],
                        5: [0xd01c8b, 0xf1b6da, 0xf7f7f7, 0xb8e186, 0x4dac26],
                        6: [0xc51b7d, 0xe9a3c9, 0xfde0ef, 0xe6f5d0, 0xa1d76a, 0x4d9221],
                        7: [0xc51b7d, 0xe9a3c9, 0xfde0ef, 0xf7f7f7, 0xe6f5d0, 0xa1d76a, 0x4d9221],
                        8: [0xc51b7d, 0xde77ae, 0xf1b6da, 0xfde0ef, 0xe6f5d0, 0xb8e186, 0x7fbc41, 0x4d9221],
                        9: [0xc51b7d, 0xde77ae, 0xf1b6da, 0xfde0ef, 0xf7f7f7, 0xe6f5d0, 0xb8e186, 0x7fbc41, 0x4d9221],
                        10: [0x8e0152, 0xc51b7d, 0xde77ae, 0xf1b6da, 0xfde0ef, 0xe6f5d0, 0xb8e186, 0x7fbc41, 0x4d9221, 0x276419],
                        11: [0x8e0152, 0xc51b7d, 0xde77ae, 0xf1b6da, 0xfde0ef, 0xf7f7f7, 0xe6f5d0, 0xb8e186, 0x7fbc41, 0x4d9221, 0x276419]
                      },
                      RdBu: {
                        3: [0xef8a62, 0xf7f7f7, 0x67a9cf],
                        4: [0xca0020, 0xf4a582, 0x92c5de, 0x0571b0],
                        5: [0xca0020, 0xf4a582, 0xf7f7f7, 0x92c5de, 0x0571b0],
                        6: [0xb2182b, 0xef8a62, 0xfddbc7, 0xd1e5f0, 0x67a9cf, 0x2166ac],
                        7: [0xb2182b, 0xef8a62, 0xfddbc7, 0xf7f7f7, 0xd1e5f0, 0x67a9cf, 0x2166ac],
                        8: [0xb2182b, 0xd6604d, 0xf4a582, 0xfddbc7, 0xd1e5f0, 0x92c5de, 0x4393c3, 0x2166ac],
                        9: [0xb2182b, 0xd6604d, 0xf4a582, 0xfddbc7, 0xf7f7f7, 0xd1e5f0, 0x92c5de, 0x4393c3, 0x2166ac],
                        10: [0x67001f, 0xb2182b, 0xd6604d, 0xf4a582, 0xfddbc7, 0xd1e5f0, 0x92c5de, 0x4393c3, 0x2166ac, 0x053061],
                        11: [0x67001f, 0xb2182b, 0xd6604d, 0xf4a582, 0xfddbc7, 0xf7f7f7, 0xd1e5f0, 0x92c5de, 0x4393c3, 0x2166ac, 0x053061]
                      },
                      RdGy: {
                        3: [0xef8a62, 0xffffff, 0x999999],
                        4: [0xca0020, 0xf4a582, 0xbababa, 0x404040],
                        5: [0xca0020, 0xf4a582, 0xffffff, 0xbababa, 0x404040],
                        6: [0xb2182b, 0xef8a62, 0xfddbc7, 0xe0e0e0, 0x999999, 0x4d4d4d],
                        7: [0xb2182b, 0xef8a62, 0xfddbc7, 0xffffff, 0xe0e0e0, 0x999999, 0x4d4d4d],
                        8: [0xb2182b, 0xd6604d, 0xf4a582, 0xfddbc7, 0xe0e0e0, 0xbababa, 0x878787, 0x4d4d4d],
                        9: [0xb2182b, 0xd6604d, 0xf4a582, 0xfddbc7, 0xffffff, 0xe0e0e0, 0xbababa, 0x878787, 0x4d4d4d],
                        10: [0x67001f, 0xb2182b, 0xd6604d, 0xf4a582, 0xfddbc7, 0xe0e0e0, 0xbababa, 0x878787, 0x4d4d4d, 0x1a1a1a],
                        11: [0x67001f, 0xb2182b, 0xd6604d, 0xf4a582, 0xfddbc7, 0xffffff, 0xe0e0e0, 0xbababa, 0x878787, 0x4d4d4d, 0x1a1a1a]
                      },
                      RdYlBu: {
                        3: [0xfc8d59, 0xffffbf, 0x91bfdb],
                        4: [0xd7191c, 0xfdae61, 0xabd9e9, 0x2c7bb6],
                        5: [0xd7191c, 0xfdae61, 0xffffbf, 0xabd9e9, 0x2c7bb6],
                        6: [0xd73027, 0xfc8d59, 0xfee090, 0xe0f3f8, 0x91bfdb, 0x4575b4],
                        7: [0xd73027, 0xfc8d59, 0xfee090, 0xffffbf, 0xe0f3f8, 0x91bfdb, 0x4575b4],
                        8: [0xd73027, 0xf46d43, 0xfdae61, 0xfee090, 0xe0f3f8, 0xabd9e9, 0x74add1, 0x4575b4],
                        9: [0xd73027, 0xf46d43, 0xfdae61, 0xfee090, 0xffffbf, 0xe0f3f8, 0xabd9e9, 0x74add1, 0x4575b4],
                        10: [0xa50026, 0xd73027, 0xf46d43, 0xfdae61, 0xfee090, 0xe0f3f8, 0xabd9e9, 0x74add1, 0x4575b4, 0x313695],
                        11: [0xa50026, 0xd73027, 0xf46d43, 0xfdae61, 0xfee090, 0xffffbf, 0xe0f3f8, 0xabd9e9, 0x74add1, 0x4575b4, 0x313695]
                      },
                      Spectral: {
                        3: [0xfc8d59, 0xffffbf, 0x99d594],
                        4: [0xd7191c, 0xfdae61, 0xabdda4, 0x2b83ba],
                        5: [0xd7191c, 0xfdae61, 0xffffbf, 0xabdda4, 0x2b83ba],
                        6: [0xd53e4f, 0xfc8d59, 0xfee08b, 0xe6f598, 0x99d594, 0x3288bd],
                        7: [0xd53e4f, 0xfc8d59, 0xfee08b, 0xffffbf, 0xe6f598, 0x99d594, 0x3288bd],
                        8: [0xd53e4f, 0xf46d43, 0xfdae61, 0xfee08b, 0xe6f598, 0xabdda4, 0x66c2a5, 0x3288bd],
                        9: [0xd53e4f, 0xf46d43, 0xfdae61, 0xfee08b, 0xffffbf, 0xe6f598, 0xabdda4, 0x66c2a5, 0x3288bd],
                        10: [0x9e0142, 0xd53e4f, 0xf46d43, 0xfdae61, 0xfee08b, 0xe6f598, 0xabdda4, 0x66c2a5, 0x3288bd, 0x5e4fa2],
                        11: [0x9e0142, 0xd53e4f, 0xf46d43, 0xfdae61, 0xfee08b, 0xffffbf, 0xe6f598, 0xabdda4, 0x66c2a5, 0x3288bd, 0x5e4fa2]
                      },
                      RdYlGn: {
                        3: [0xfc8d59, 0xffffbf, 0x91cf60],
                        4: [0xd7191c, 0xfdae61, 0xa6d96a, 0x1a9641],
                        5: [0xd7191c, 0xfdae61, 0xffffbf, 0xa6d96a, 0x1a9641],
                        6: [0xd73027, 0xfc8d59, 0xfee08b, 0xd9ef8b, 0x91cf60, 0x1a9850],
                        7: [0xd73027, 0xfc8d59, 0xfee08b, 0xffffbf, 0xd9ef8b, 0x91cf60, 0x1a9850],
                        8: [0xd73027, 0xf46d43, 0xfdae61, 0xfee08b, 0xd9ef8b, 0xa6d96a, 0x66bd63, 0x1a9850],
                        9: [0xd73027, 0xf46d43, 0xfdae61, 0xfee08b, 0xffffbf, 0xd9ef8b, 0xa6d96a, 0x66bd63, 0x1a9850],
                        10: [0xa50026, 0xd73027, 0xf46d43, 0xfdae61, 0xfee08b, 0xd9ef8b, 0xa6d96a, 0x66bd63, 0x1a9850, 0x006837],
                        11: [0xa50026, 0xd73027, 0xf46d43, 0xfdae61, 0xfee08b, 0xffffbf, 0xd9ef8b, 0xa6d96a, 0x66bd63, 0x1a9850, 0x006837]
                      }
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=colorbrewer.js.map
                */;
                (function() {
                  define('palettes/palettes',["./colorbrewer"], function(colorbrewer) {
                    var all_palettes, items, name, num, pal;
                    all_palettes = {};
                    for (name in colorbrewer) {
                      items = colorbrewer[name];
                      for (num in items) {
                        pal = items[num];
                        all_palettes["" + name + "-" + num] = pal.reverse();
                      }
                    }
                    return {
                      "all_palettes": all_palettes
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=palettes.js.map
                */;
                (function() {
                  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
                
                  define('common/socket',["backbone", "underscore", "common/base", "common/load_models", "common/logging"], function(Backbone, _, base, load_models, Logging) {
                    var Config, WebSocketWrapper, logger, submodels;
                    Config = base.Config;
                    logger = Logging.logger;
                    WebSocketWrapper = (function() {
                      _.extend(WebSocketWrapper.prototype, Backbone.Events);
                
                      function WebSocketWrapper(ws_conn_string) {
                        this.onmessage = __bind(this.onmessage, this);
                        var error,
                          _this = this;
                        this.auth = {};
                        this.ws_conn_string = ws_conn_string;
                        this._connected = $.Deferred();
                        this.connected = this._connected.promise();
                        try {
                          if (window.MozWebSocket) {
                            this.s = new MozWebSocket(ws_conn_string);
                          } else {
                            this.s = new WebSocket(ws_conn_string);
                          }
                        } catch (_error) {
                          error = _error;
                          logger.error("websocket creation failed for connection string: " + ws_conn_string);
                          logger.error(" - " + error);
                        }
                        this.s.onopen = function() {
                          return _this._connected.resolve();
                        };
                        this.s.onmessage = this.onmessage;
                      }
                
                      WebSocketWrapper.prototype.onmessage = function(msg) {
                        var data, index, topic;
                        data = msg.data;
                        index = data.indexOf(":");
                        index = data.indexOf(":", index + 1);
                        topic = data.substring(0, index);
                        data = data.substring(index + 1);
                        this.trigger("msg:" + topic, data);
                        return null;
                      };
                
                      WebSocketWrapper.prototype.send = function(msg) {
                        var _this = this;
                        return $.when(this.connected).done(function() {
                          return _this.s.send(msg);
                        });
                      };
                
                      WebSocketWrapper.prototype.subscribe = function(topic, auth) {
                        var msg;
                        this.auth[topic] = auth;
                        msg = JSON.stringify({
                          msgtype: 'subscribe',
                          topic: topic,
                          auth: auth
                        });
                        return this.send(msg);
                      };
                
                      return WebSocketWrapper;
                
                    })();
                    submodels = function(wswrapper, topic, apikey) {
                      wswrapper.subscribe(topic, apikey);
                      return wswrapper.on("msg:" + topic, function(msg) {
                        var clientid, model, msgobj, ref, _i, _len, _ref;
                        msgobj = JSON.parse(msg);
                        if (msgobj['msgtype'] === 'modelpush') {
                          load_models(msgobj['modelspecs']);
                        } else if (msgobj['msgtype'] === 'modeldel') {
                          _ref = msgobj['modelspecs'];
                          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            ref = _ref[_i];
                            model = resolve_ref(ref['type'], ref['id']);
                            if (model) {
                              model.destroy({
                                'local': true
                              });
                            }
                          }
                        } else if (msgobj['msgtype'] === 'status' && msgobj['status'][0] === 'subscribesuccess') {
                          clientid = msgobj['status'][2];
                          Config.clientid = clientid;
                          $.ajaxSetup({
                            'headers': {
                              'Continuum-Clientid': clientid
                            }
                          });
                        } else {
                          log.warn("unknown msgtype '" + msgobj['msgtype'] + "' for message: " + msgobj);
                        }
                        return null;
                      });
                    };
                    return {
                      WebSocketWrapper: WebSocketWrapper,
                      submodels: submodels
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=socket.js.map
                */;
                (function() {
                  define('server/serverutils',["common/base", "common/socket", "common/load_models", "common/logging", "backbone", "common/has_properties"], function(base, socket, load_models, Logging, Backbone, HasProperties) {
                    var Deferreds, Promises, WebSocketWrapper, configure_server, exports, logger, submodels, utility;
                    logger = Logging.logger;
                    Deferreds = {};
                    Promises = {};
                    exports = {};
                    WebSocketWrapper = socket.WebSocketWrapper;
                    submodels = socket.submodels;
                    Deferreds._doc_loaded = $.Deferred();
                    Deferreds._doc_requested = $.Deferred();
                    Promises.doc_loaded = Deferreds._doc_loaded.promise();
                    Promises.doc_requested = Deferreds._doc_requested.promise();
                    Promises.doc_promises = {};
                    exports.wswrapper = null;
                    exports.plotcontext = null;
                    exports.plotcontextview = null;
                    exports.Promises = Promises;
                    utility = {
                      load_one_object_chain: function(docid, objid) {
                        var resp;
                        HasProperties.prototype.sync = Backbone.sync;
                        resp = utility.make_websocket();
                        resp = resp.then(function() {
                          var Config, url;
                          Config = require("common/base").Config;
                          url = "" + Config.prefix + "bokeh/objinfo/" + docid + "/" + objid;
                          logger.debug("load one object chain: " + url);
                          resp = $.get(url);
                          return resp;
                        });
                        resp.done(function(data) {
                          var all_models, apikey;
                          all_models = data['all_models'];
                          load_models(all_models);
                          apikey = data['apikey'];
                          return submodels(exports.wswrapper, "bokehplot:" + docid, apikey);
                        });
                        return resp;
                      },
                      load_user: function() {
                        var response;
                        response = $.get('/bokeh/userinfo/', {});
                        return response;
                      },
                      load_doc_by_title: function(title) {
                        var Config, response;
                        Config = require("common/base").Config;
                        response = $.get(Config.prefix + "bokeh/doc", {
                          title: title
                        }).done(function(data) {
                          var all_models, apikey, docid;
                          all_models = data['all_models'];
                          load_models(all_models);
                          apikey = data['apikey'];
                          docid = data['docid'];
                          return submodels(exports.wswrapper, "bokehplot:" + docid, apikey);
                        });
                        return response;
                      },
                      load_doc_static: function(docid, data) {
                        " loads data without making a websocket connection ";
                        var promise;
                        load_data(data['all_models']);
                        promise = jQuery.Deferred();
                        promise.resolve();
                        return promise;
                      },
                      load_doc: function(docid) {
                        var resp;
                        resp = utility.make_websocket();
                        resp = resp.then(function() {
                          var Config;
                          Config = require("common/base").Config;
                          return $.get(Config.prefix + ("bokeh/bokehinfo/" + docid + "/"), {});
                        });
                        resp.done(function(data) {
                          var all_models, apikey;
                          all_models = data['all_models'];
                          load_models(all_models);
                          apikey = data['apikey'];
                          return submodels(exports.wswrapper, "bokehplot:" + docid, apikey);
                        });
                        return resp;
                      },
                      make_websocket: function() {
                        var Config, resp;
                        if (exports.wswrapper != null) {
                          return exports._wswrapper_deferred;
                        } else {
                          Config = require("common/base").Config;
                          exports._wswrapper_deferred = $.get(Config.prefix + "bokeh/wsurl/");
                          resp = exports._wswrapper_deferred;
                          resp.done(function(data) {
                            var wswrapper;
                            Config = require("common/base").Config;
                            configure_server(data, null);
                            wswrapper = new WebSocketWrapper(Config.ws_conn_string);
                            return exports.wswrapper = wswrapper;
                          });
                          return resp;
                        }
                      },
                      render_plots: function(plot_context_ref, viewclass, viewoptions) {
                        var Collections, options, plotcontext, plotcontextview;
                        if (viewclass == null) {
                          viewclass = null;
                        }
                        if (viewoptions == null) {
                          viewoptions = {};
                        }
                        Collections = require("common/base").Collections;
                        plotcontext = Collections(plot_context_ref.type).get(plot_context_ref.id);
                        if (!viewclass) {
                          viewclass = plotcontext.default_view;
                        }
                        options = _.extend(viewoptions, {
                          model: plotcontext
                        });
                        plotcontextview = new viewclass(options);
                        plotcontext = plotcontext;
                        plotcontextview = plotcontextview;
                        plotcontextview.render();
                        exports.plotcontext = plotcontext;
                        return exports.plotcontextview = plotcontextview;
                      },
                      bokeh_connection: function(host, docid, protocol) {
                        if (_.isUndefined(protocol)) {
                          protocol = "https";
                        }
                        if (Promises.doc_requested.state() === "pending") {
                          Deferreds._doc_requested.resolve();
                          return $.get("" + protocol + "://" + host + "/bokeh/publicbokehinfo/" + docid, {}, function(data) {
                            logger.debug("instantiate_doc_single " + docid);
                            data = JSON.parse(data);
                            load_models(data['all_models']);
                            return Deferreds._doc_loaded.resolve(data);
                          });
                        }
                      }
                    };
                    configure_server = function(ws_conn_string, prefix) {
                      var Config;
                      Config = require("common/base").Config;
                      if (ws_conn_string) {
                        Config.ws_conn_string = ws_conn_string;
                        logger.debug("setting ws_conn_string to: " + Config.ws_conn_string);
                      }
                      if (prefix) {
                        Config.prefix = prefix;
                        logger.debug("setting prefix to " + Config.prefix);
                      }
                      return null;
                    };
                    exports.utility = utility;
                    exports.configure_server = configure_server;
                    return exports;
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=serverutils.js.map
                */;
                define('server/usercontext/userdocstemplate',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<div class="accordion">\n</div>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                define('server/usercontext/documentationtemplate',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<p>\n  <b>\n    You have no Plots. Follow the instructions below to create some.\n  </b>\n</p>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                define('server/usercontext/wrappertemplate',[],function(){
                  var template = function(__obj) {
                  var _safe = function(value) {
                    if (typeof value === 'undefined' && value == null)
                      value = '';
                    var result = new String(value);
                    result.ecoSafe = true;
                    return result;
                  };
                  return (function() {
                    var __out = [], __self = this, _print = function(value) {
                      if (typeof value !== 'undefined' && value != null)
                        __out.push(value.ecoSafe ? value : __self.escape(value));
                    }, _capture = function(callback) {
                      var out = __out, result;
                      __out = [];
                      callback.call(this);
                      result = __out.join('');
                      __out = out;
                      return _safe(result);
                    };
                    (function() {
                      _print(_safe('<div class="panel panel-default">\n  <div class="panel-heading">\n    <h4 class="panel-title">\n      <a class="bokehdoclabel" href="#'));
                    
                      _print(this.bodyid);
                    
                      _print(_safe('" data-toggle="collapse">\n        Document: '));
                    
                      _print(this.model.get('title'));
                    
                      _print(_safe(' <span class="bokehdelete glyphicon glyphicon-trash"></i>\n      </a>\n    </h4>\n  </div>\n  <div id="'));
                    
                      _print(this.bodyid);
                    
                      _print(_safe('" class="panel-collapse collapse">\n    <div class="panel-body plots"></div>\n  </div>\n</div>\n'));
                    
                    }).call(this);
                    
                    return __out.join('');
                  }).call((function() {
                    var obj = {
                      escape: function(value) {
                        return ('' + value)
                          .replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;')
                          .replace(/"/g, '&quot;');
                      },
                      safe: _safe
                    }, key;
                    for (key in __obj) obj[key] = __obj[key];
                    return obj;
                  })());
                };
                  return template;
                });
                
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('server/usercontext/usercontext',["underscore", "jquery", "common/base", "../serverutils", "common/continuum_view", "common/collection", "./userdocstemplate", "./documentationtemplate", "./wrappertemplate", "common/has_parent", "common/build_views", "common/load_models"], function(_, $, base, serverutils, ContinuumView, Collection, userdocstemplate, documentationtemplate, wrappertemplate, HasParent, build_views, load_models) {
                    var Doc, DocView, UserDocs, UserDocsView, exports, utility, _ref, _ref1, _ref2, _ref3;
                    exports = {};
                    utility = serverutils.utility;
                    DocView = (function(_super) {
                      __extends(DocView, _super);
                
                      function DocView() {
                        _ref = DocView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      DocView.prototype.template = wrappertemplate;
                
                      DocView.prototype.attributes = {
                        "class": 'panel-group'
                      };
                
                      DocView.prototype.events = {
                        "click .bokehdoclabel": "loaddoc",
                        "click .bokehdelete": "deldoc"
                      };
                
                      DocView.prototype.deldoc = function(e) {
                        e.preventDefault();
                        this.model.destroy();
                        return false;
                      };
                
                      DocView.prototype.loaddoc = function() {
                        return this.model.load();
                      };
                
                      DocView.prototype.initialize = function(options) {
                        DocView.__super__.initialize.call(this, options);
                        return this.render_init();
                      };
                
                      DocView.prototype.delegateEvents = function(events) {
                        DocView.__super__.delegateEvents.call(this, events);
                        return this.listenTo(this.model, 'loaded', this.render);
                      };
                
                      DocView.prototype.render_init = function() {
                        var html;
                        html = this.template({
                          model: this.model,
                          bodyid: _.uniqueId()
                        });
                        return this.$el.html(html);
                      };
                
                      DocView.prototype.render = function() {
                        var plot_context;
                        plot_context = this.model.get('plot_context');
                        this.plot_context_view = new plot_context.default_view({
                          model: plot_context
                        });
                        this.$el.find('.plots').append(this.plot_context_view.el);
                        return true;
                      };
                
                      return DocView;
                
                    })(ContinuumView);
                    UserDocsView = (function(_super) {
                      __extends(UserDocsView, _super);
                
                      function UserDocsView() {
                        _ref1 = UserDocsView.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      UserDocsView.prototype.initialize = function(options) {
                        this.docs = options.docs;
                        this.collection = options.collection;
                        this.views = {};
                        UserDocsView.__super__.initialize.call(this, options);
                        return this.render();
                      };
                
                      UserDocsView.prototype.attributes = {
                        "class": 'usercontext'
                      };
                
                      UserDocsView.prototype.events = {
                        'click .bokehrefresh': function() {
                          return this.collection.fetch({
                            update: true
                          });
                        }
                      };
                
                      UserDocsView.prototype.delegateEvents = function(events) {
                        var _this = this;
                        UserDocsView.__super__.delegateEvents.call(this, events);
                        this.listenTo(this.collection, 'add', this.render);
                        this.listenTo(this.collection, 'remove', this.render);
                        this.listenTo(this.collection, 'add', function(model, collection, options) {
                          return _this.listenTo(model, 'loaded', function() {
                            return _this.listenTo(model.get('plot_context'), 'change', function() {
                              return _this.trigger('show');
                            });
                          });
                        });
                        return this.listenTo(this.collection, 'remove', function(model, collection, options) {
                          return _this.stopListening(model);
                        });
                      };
                
                      UserDocsView.prototype.render_docs = function() {
                        this.$el.html(documentationtemplate());
                        return this.$el.append(this.docs);
                      };
                
                      UserDocsView.prototype.render = function() {
                        var html, model, models, _i, _len;
                        if (this.collection.models.length === 0 && this.docs) {
                          return this.render_docs();
                        }
                        html = userdocstemplate();
                        _.map(_.values(this.views), function(view) {
                          return view.$el.detach();
                        });
                        models = this.collection.models.slice().reverse();
                        build_views(this.views, models, {});
                        this.$el.html(html);
                        for (_i = 0, _len = models.length; _i < _len; _i++) {
                          model = models[_i];
                          this.$el.find(".accordion").append(this.views[model.id].el);
                        }
                        return this;
                      };
                
                      return UserDocsView;
                
                    })(ContinuumView);
                    Doc = (function(_super) {
                      __extends(Doc, _super);
                
                      function Doc() {
                        _ref2 = Doc.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      Doc.prototype.default_view = DocView;
                
                      Doc.prototype.idAttribute = 'docid';
                
                      Doc.prototype.defaults = function() {
                        return _.extend({}, Doc.__super__.defaults.call(this), {
                          docid: null,
                          title: null,
                          plot_context: null,
                          apikey: null
                        });
                      };
                
                      Doc.prototype.sync = function() {};
                
                      Doc.prototype.destroy = function(options) {
                        Doc.__super__.destroy.call(this, options);
                        return $.ajax({
                          url: "/bokeh/doc/" + (this.get('docid')) + "/",
                          type: 'delete'
                        });
                      };
                
                      Doc.prototype.load = function(use_title) {
                        var docid, resp, title,
                          _this = this;
                        if (this.loaded) {
                          return;
                        }
                        if (use_title) {
                          title = this.get('title');
                          resp = utility.load_doc_by_title(title);
                        } else {
                          docid = this.get('docid');
                          resp = utility.load_doc(docid);
                        }
                        return resp.done(function(data) {
                          _this.set('docid', data.docid);
                          _this.set('apikey', data['apikey']);
                          _this.set('plot_context', data['plot_context_ref']);
                          _this.trigger('loaded');
                          return _this.loaded = true;
                        });
                      };
                
                      return Doc;
                
                    })(HasParent);
                    UserDocs = (function(_super) {
                      __extends(UserDocs, _super);
                
                      function UserDocs() {
                        _ref3 = UserDocs.__super__.constructor.apply(this, arguments);
                        return _ref3;
                      }
                
                      UserDocs.prototype.model = Doc;
                
                      UserDocs.prototype.subscribe = function(wswrapper, username) {
                        wswrapper.subscribe("bokehuser:" + username, null);
                        return this.listenTo(wswrapper, "msg:bokehuser:" + username, function(msg) {
                          msg = JSON.parse(msg);
                          if (msg['msgtype'] === 'docchange') {
                            return this.fetch({
                              update: true
                            });
                          }
                        });
                      };
                
                      UserDocs.prototype.fetch = function(options) {
                        var resp, response, url,
                          _this = this;
                        if (_.isUndefined(options)) {
                          options = {};
                        }
                        url = base.Config.prefix + "bokeh/userinfo/";
                        resp = response = $.get(url, {});
                        resp.done(function(data) {
                          var docs;
                          docs = data['docs'];
                          if (options.update) {
                            return _this.set(docs, options);
                          } else {
                            return _this.reset(docs, options);
                          }
                        });
                        return resp;
                      };
                
                      return UserDocs;
                
                    })(Collection);
                    exports.UserDocs = UserDocs;
                    exports.UserDocsView = UserDocsView;
                    exports.Doc = Doc;
                    exports.DocView = DocView;
                    return exports;
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=usercontext.js.map
                */;
                (function() {
                  define('server/embed',["jquery", "./serverutils", "./usercontext/usercontext", "common/base", "common/has_properties", "common/load_models", "common/logging"], function($, serverutils, usercontext, base, HasProperties, load_models, Logging) {
                    var add_plot_server, add_plot_static, index, inject_css, inject_plot, logger, reload, server_page, _render, _render_all, _render_one;
                    index = base.index;
                    logger = Logging.logger;
                    reload = function() {
                      var Config, ping_url;
                      Config = require("common/base").Config;
                      ping_url = "" + Config.prefix + "bokeh/ping";
                      $.get(ping_url).success(function() {
                        logger.info('reloading');
                        return window.location.reload();
                      }).fail(_.delay((function() {
                        return reload();
                      }), 1000));
                      return null;
                    };
                    inject_css = function(url) {
                      var link;
                      link = $("<link href='" + url + "' rel='stylesheet' type='text/css'>");
                      return $('body').append(link);
                    };
                    add_plot_static = function(element, model_id, model_type, all_models) {
                      var model, view;
                      if (!(model_id in index)) {
                        load_models(all_models);
                        index[model_id] = view;
                      }
                      model = base.Collections(model_type).get(model_id);
                      view = new model.default_view({
                        model: model
                      });
                      return _.delay(function() {
                        return $(element).replaceWith(view.$el);
                      });
                    };
                    add_plot_server = function(element, doc_id, model_id) {
                      var resp;
                      resp = serverutils.utility.load_one_object_chain(doc_id, model_id);
                      return resp.done(function(data) {
                        var model, view, wswrapper;
                        model = base.Collections(data.type).get(model_id);
                        view = new model.default_view({
                          model: model
                        });
                        _.delay(function() {
                          return $(element).replaceWith(view.$el);
                        });
                        if (!(model_id in index)) {
                          index[model_id] = view;
                        }
                        wswrapper = serverutils.wswrapper;
                        wswrapper.subscribe("debug:debug", "");
                        return wswrapper.on('msg:debug:debug', function(msg) {
                          if (msg === 'reload') {
                            return reload();
                          }
                        });
                      });
                    };
                    inject_plot = function(element_id, all_models) {
                      var container, info, script;
                      script = $("#" + element_id);
                      if (script.length === 0) {
                        throw "Error injecting plot: could not find script tag with id: " + element_id;
                      }
                      if (script.length > 1) {
                        throw "Error injecting plot: found too many script tags with id: " + element_id;
                      }
                      if (!document.body.contains(script[0])) {
                        throw "Error injecting plot: autoload script tag may only be under <body>";
                      }
                      info = script.data();
                      Bokeh.set_log_level(info['bokehLoglevel']);
                      logger.info("Injecting plot for script tag with id: #" + element_id);
                      base.Config.prefix = info['bokehRootUrl'];
                      container = $('<div>', {
                        "class": 'bokeh-container'
                      });
                      container.insertBefore(script);
                      if (info.bokehData === "static") {
                        logger.info("  - using static data");
                        return add_plot_static(container, info["bokehModelid"], info["bokehModeltype"], all_models);
                      } else if (info.bokehData === "server") {
                        logger.info("  - using server data");
                        return add_plot_server(container, info["bokehDocid"], info["bokehModelid"]);
                      } else {
                        throw "Unknown bokehData value for inject_plot: " + info.bokehData;
                      }
                    };
                    server_page = function(title) {
                      HasProperties.prototype.sync = Backbone.sync;
                      return $(function() {
                        var resp;
                        resp = serverutils.utility.make_websocket();
                        return resp.then(function() {
                          var load, userdocs, wswrapper;
                          wswrapper = serverutils.wswrapper;
                          userdocs = new usercontext.UserDocs();
                          userdocs.subscribe(wswrapper, 'defaultuser');
                          load = userdocs.fetch();
                          load.done(function() {
                            if (title != null) {
                              return _render_one(userdocs, title);
                            } else {
                              return _render_all(userdocs);
                            }
                          });
                          logger.info('subscribing to debug');
                          wswrapper.subscribe("debug:debug", "");
                          return wswrapper.on('msg:debug:debug', function(msg) {
                            if (msg === 'reload') {
                              return reload();
                            }
                          });
                        });
                      });
                    };
                    _render_all = function(userdocs) {
                      var userdocsview;
                      userdocsview = new usercontext.UserDocsView({
                        collection: userdocs
                      });
                      return _render(userdocsview.el);
                    };
                    _render_one = function(userdocs, title) {
                      var doc, msg;
                      doc = userdocs.find(function(doc) {
                        return doc.get('title') === title;
                      });
                      if (doc != null) {
                        doc.on('loaded', function() {
                          var plot_context, plot_context_view;
                          plot_context = doc.get('plot_context');
                          plot_context_view = new plot_context.default_view({
                            model: plot_context
                          });
                          return _render(plot_context_view.el);
                        });
                        return doc.load();
                      } else {
                        msg = "Document '" + title + "' wasn't found on this server.";
                        _render(msg);
                        return logger.error(msg);
                      }
                    };
                    _render = function(html) {
                      return $('#PlotPane').append(html);
                    };
                    return {
                      "inject_css": inject_css,
                      "inject_plot": inject_plot,
                      "add_plot_server": add_plot_server,
                      "add_plot_static": add_plot_static,
                      "server_page": server_page
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=embed.js.map
                */;
                (function() {
                  var __hasProp = {}.hasOwnProperty,
                    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                
                  define('tool/gestures/poly_select_tool',["underscore", "common/collection", "renderer/overlay/poly_selection", "tool/gestures/select_tool"], function(_, Collection, PolySelection, SelectTool) {
                    var PolySelectTool, PolySelectToolView, PolySelectTools, _ref, _ref1, _ref2;
                    PolySelectToolView = (function(_super) {
                      __extends(PolySelectToolView, _super);
                
                      function PolySelectToolView() {
                        _ref = PolySelectToolView.__super__.constructor.apply(this, arguments);
                        return _ref;
                      }
                
                      PolySelectToolView.prototype.initialize = function(options) {
                        PolySelectToolView.__super__.initialize.call(this, options);
                        this.listenTo(this.model, 'change:active', this._active_change);
                        return this.data = null;
                      };
                
                      PolySelectToolView.prototype._active_change = function() {
                        if (!this.mget('active')) {
                          return this._clear_data();
                        }
                      };
                
                      PolySelectToolView.prototype._keyup = function(e) {
                        if (e.keyCode === 13) {
                          return this._clear_data();
                        }
                      };
                
                      PolySelectToolView.prototype._doubletap = function(e) {
                        return this._clear_data();
                      };
                
                      PolySelectToolView.prototype._clear_data = function() {
                        this.data = null;
                        return this.mget('overlay').set('data', null);
                      };
                
                      PolySelectToolView.prototype._tap = function(e) {
                        var append, canvas, new_data, overlay, vx, vy, _ref1;
                        canvas = this.plot_view.canvas;
                        vx = canvas.sx_to_vx(e.bokeh.sx);
                        vy = canvas.sy_to_vy(e.bokeh.sy);
                        if (this.data == null) {
                          this.data = {
                            vx: [vx],
                            vy: [vy]
                          };
                          return null;
                        }
                        this.data.vx.push(vx);
                        this.data.vy.push(vy);
                        overlay = this.mget('overlay');
                        new_data = {};
                        new_data.vx = _.clone(this.data.vx);
                        new_data.vy = _.clone(this.data.vy);
                        overlay.set('data', new_data);
                        append = (_ref1 = e.srcEvent.shiftKey) != null ? _ref1 : false;
                        return this._select(this.data.vx, this.data.vy, append);
                      };
                
                      PolySelectToolView.prototype._select = function(vx, vy, append) {
                        var ds, geometry, r, sm, _i, _len, _ref1;
                        geometry = {
                          type: 'poly',
                          vx: vx,
                          vy: vy
                        };
                        _ref1 = this.mget('renderers');
                        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                          r = _ref1[_i];
                          ds = r.get('data_source');
                          sm = ds.get('selection_manager');
                          sm.select(this, this.plot_view.renderers[r.id], geometry, true, append);
                        }
                        this._save_geometry(geometry, true, append);
                        return null;
                      };
                
                      return PolySelectToolView;
                
                    })(SelectTool.View);
                    PolySelectTool = (function(_super) {
                      __extends(PolySelectTool, _super);
                
                      function PolySelectTool() {
                        _ref1 = PolySelectTool.__super__.constructor.apply(this, arguments);
                        return _ref1;
                      }
                
                      PolySelectTool.prototype.default_view = PolySelectToolView;
                
                      PolySelectTool.prototype.type = "PolySelectTool";
                
                      PolySelectTool.prototype.tool_name = "Poly Select";
                
                      PolySelectTool.prototype.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAGdSURBVDiNjdO/axRBGMbxT8IiwSBBi4AiBBVRJE3UIqIIilrYLGuxMYo/AimsrNTCWkH/AbFR78Dc5dZiWW3SKQaVaKWlIFEiithooaiIZ7EbPM7b3D0wzLzzvvOdZ5iZviTNmnKN4gE2YSteYjW24A2+Yh/ux1G4uVij2cyXB0V8AYuYwBq8x5Ei/wEH8LNoHRVgWxyFr4v4RUvuScv4ESRpFhTQ/9SPmSTNdpbt1KZhXCsD7cZQj6AB7OqUCDCCTz2C3mF/maNnGOsRtB53y0BD/t1eN32T32pH0HY870ZI0mwMFZwvA73F+AqA4STNduCS3PlSpdbY0F4XFKAfJZA9mMO9OAonl+crtcZcpdaYP3ti4mqro0Py79AKOJqk2TwGMRVH4XTbHqtwpVJrVKv1ZGDZ0SIO4mGSZqNYh2m8wtM4Cr93MPur6E9jY7WenAvkz38pSbO9eIzrcRQe63TUFg3iDz7iIj73Yxa3i4LxOAovr0S4MzPbhzoOYy1GzkzGXwLcxC0sxFH4u4sTUyePN3EDKrXGAk4h/QvU5XGB9rRYawAAAABJRU5ErkJggg==";
                
                      PolySelectTool.prototype.event_type = "tap";
                
                      PolySelectTool.prototype.default_order = 11;
                
                      PolySelectTool.prototype.initialize = function(attrs, options) {
                        var plot_renderers;
                        PolySelectTool.__super__.initialize.call(this, attrs, options);
                        this.set('overlay', new PolySelection.Model);
                        plot_renderers = this.get('plot').get('renderers');
                        plot_renderers.push(this.get('overlay'));
                        return this.get('plot').set('renderers', plot_renderers);
                      };
                
                      return PolySelectTool;
                
                    })(SelectTool.Model);
                    PolySelectTools = (function(_super) {
                      __extends(PolySelectTools, _super);
                
                      function PolySelectTools() {
                        _ref2 = PolySelectTools.__super__.constructor.apply(this, arguments);
                        return _ref2;
                      }
                
                      PolySelectTools.prototype.model = PolySelectTool;
                
                      return PolySelectTools;
                
                    })(Collection);
                    return {
                      "Model": PolySelectTool,
                      "Collection": new PolySelectTools(),
                      "View": PolySelectToolView
                    };
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=poly_select_tool.js.map
                */;
                (function() {
                  define('main',['require','exports','module','common/base','common/logging','underscore','jquery','backbone','common/base','common/base','common/cartesian_frame','common/canvas','common/gmap_plot','common/geojs_plot','common/grid_plot','common/has_parent','common/has_properties','common/layout_box','common/plot','common/plotting','common/selection_manager','common/selector','common/tool_events','common/build_views','common/bulk_save','common/continuum_view','common/load_models','common/plot_context','common/plot_widget','common/random','common/svg_colors','mapper/linear_mapper','mapper/log_mapper','mapper/categorical_mapper','mapper/grid_mapper','mapper/linear_color_mapper','palettes/palettes','renderer/annotation/legend','renderer/annotation/span','renderer/annotation/tooltip','renderer/guide/categorical_axis','renderer/guide/datetime_axis','renderer/guide/grid','renderer/guide/linear_axis','renderer/guide/log_axis','renderer/overlay/box_selection','renderer/overlay/poly_selection','renderer/properties','server/embed','server/serverutils','source/column_data_source','ticking/abstract_ticker','ticking/adaptive_ticker','ticking/basic_ticker','ticking/basic_tick_formatter','ticking/log_ticker','ticking/log_tick_formatter','ticking/categorical_ticker','ticking/categorical_tick_formatter','ticking/composite_ticker','ticking/datetime_ticker','ticking/datetime_tick_formatter','ticking/days_ticker','ticking/months_ticker','ticking/single_interval_ticker','ticking/years_ticker','tool/actions/action_tool','tool/actions/preview_save_tool','tool/actions/reset_tool','tool/gestures/box_select_tool','tool/gestures/box_zoom_tool','tool/gestures/lasso_select_tool','tool/gestures/pan_tool','tool/gestures/poly_select_tool','tool/gestures/resize_tool','tool/gestures/select_tool','tool/gestures/tap_tool','tool/gestures/wheel_zoom_tool','tool/inspectors/inspect_tool','tool/inspectors/hover_tool','tool/inspectors/crosshair_tool','widget/hbox','widget/vbox','widget/textinput','widget/crossfilter'],function(require, exports, module) {
                    var Bokeh, logging, _oldJQ;
                    Bokeh = {};
                    Bokeh.require = require;
                    Bokeh.version = '0.6.1';
                    Bokeh.index = require("common/base").index;
                    logging = require("common/logging");
                    Bokeh.logger = logging.logger;
                    Bokeh.set_log_level = logging.set_log_level;
                    if (!window.Float64Array) {
                      Bokeh.logger.warn("Float64Array is not supported. Using generic Array instead.");
                      window.Float64Array = Array;
                    }
                    Bokeh._ = require("underscore");
                    Bokeh.$ = require("jquery");
                    Bokeh.Backbone = require("backbone");
                    _oldJQ = window.$;
                    window.jQuery.noConflict();
                    if (typeof $ === "undefined") {
                      window.$ = _oldJQ;
                    }
                    Bokeh.Collections = require("common/base").Collections;
                    Bokeh.Config = require("common/base").Config;
                    Bokeh.CartesianFrame = require("common/cartesian_frame");
                    Bokeh.Canvas = require("common/canvas");
                    Bokeh.GMapPlot = require("common/gmap_plot");
                    Bokeh.GeoJSPlot = require("common/geojs_plot");
                    Bokeh.GridPlot = require("common/grid_plot");
                    Bokeh.HasParent = require("common/has_parent");
                    Bokeh.HasProperties = require("common/has_properties");
                    Bokeh.LayoutBox = require("common/layout_box");
                    Bokeh.Plot = require("common/plot");
                    Bokeh.Plotting = require("common/plotting");
                    Bokeh.SelectionManager = require("common/selection_manager");
                    Bokeh.Selector = require("common/selector");
                    Bokeh.ToolEvents = require("common/tool_events");
                    Bokeh.build_views = require("common/build_views");
                    Bokeh.bulk_save = require("common/bulk_save");
                    Bokeh.ContinuumView = require("common/continuum_view");
                    Bokeh.load_models = require("common/load_models");
                    Bokeh.PlotContext = require("common/plot_context");
                    Bokeh.PlotWidget = require("common/plot_widget");
                    Bokeh.Random = require("common/random");
                    Bokeh.SVGColors = require("common/svg_colors");
                    Bokeh.LinearMapper = require("mapper/linear_mapper");
                    Bokeh.LogMapper = require("mapper/log_mapper");
                    Bokeh.CategoricalMapper = require("mapper/categorical_mapper");
                    Bokeh.GridMapper = require("mapper/grid_mapper");
                    Bokeh.LinearColorMapper = require("mapper/linear_color_mapper");
                    Bokeh.Palettes = require("palettes/palettes");
                    Bokeh.Legend = require("renderer/annotation/legend");
                    Bokeh.Span = require("renderer/annotation/span");
                    Bokeh.Tooltip = require("renderer/annotation/tooltip");
                    Bokeh.CategoricalAxis = require("renderer/guide/categorical_axis");
                    Bokeh.DatetimeAxis = require("renderer/guide/datetime_axis");
                    Bokeh.Grid = require("renderer/guide/grid");
                    Bokeh.LinearAxis = require("renderer/guide/linear_axis");
                    Bokeh.LogAxis = require("renderer/guide/log_axis");
                    Bokeh.BoxSelection = require("renderer/overlay/box_selection");
                    Bokeh.PolySelection = require("renderer/overlay/poly_selection");
                    Bokeh.Properties = require("renderer/properties");
                    Bokeh.embed = require("server/embed");
                    Bokeh.serverutils = require("server/serverutils");
                    Bokeh.ColumnDataSource = require("source/column_data_source");
                    Bokeh.AbstractTicker = require("ticking/abstract_ticker");
                    Bokeh.AdaptiveTicker = require("ticking/adaptive_ticker");
                    Bokeh.BasicTicker = require("ticking/basic_ticker");
                    Bokeh.BasicTickFormatter = require("ticking/basic_tick_formatter");
                    Bokeh.LogTicker = require("ticking/log_ticker");
                    Bokeh.LogTickFormatter = require("ticking/log_tick_formatter");
                    Bokeh.CategoricalTicker = require("ticking/categorical_ticker");
                    Bokeh.CategoricalTickFormatter = require("ticking/categorical_tick_formatter");
                    Bokeh.CompositeTicker = require("ticking/composite_ticker");
                    Bokeh.DatetimeTicker = require("ticking/datetime_ticker");
                    Bokeh.DatetimeTickFormatter = require("ticking/datetime_tick_formatter");
                    Bokeh.DaysTicker = require("ticking/days_ticker");
                    Bokeh.MonthsTicker = require("ticking/months_ticker");
                    Bokeh.SingleIntervalTicker = require("ticking/single_interval_ticker");
                    Bokeh.YearsTicker = require("ticking/years_ticker");
                    Bokeh.ActionTool = require("tool/actions/action_tool");
                    Bokeh.PreviewSaveTool = require("tool/actions/preview_save_tool");
                    Bokeh.ResetTool = require("tool/actions/reset_tool");
                    Bokeh.BoxSelectTool = require("tool/gestures/box_select_tool");
                    Bokeh.BoxZoomTool = require("tool/gestures/box_zoom_tool");
                    Bokeh.LassoSelectTool = require("tool/gestures/lasso_select_tool");
                    Bokeh.PanTool = require("tool/gestures/pan_tool");
                    Bokeh.PolySelectTool = require("tool/gestures/poly_select_tool");
                    Bokeh.ResizeTool = require("tool/gestures/resize_tool");
                    Bokeh.SelectTool = require("tool/gestures/select_tool");
                    Bokeh.TapTool = require("tool/gestures/tap_tool");
                    Bokeh.WheelZoomTool = require("tool/gestures/wheel_zoom_tool");
                    Bokeh.InspectTool = require("tool/inspectors/inspect_tool");
                    Bokeh.HoverTool = require("tool/inspectors/hover_tool");
                    Bokeh.CrosshairTool = require("tool/inspectors/crosshair_tool");
                    Bokeh.HBox = require("widget/hbox");
                    Bokeh.VBox = require("widget/vbox");
                    Bokeh.TextInput = require("widget/textinput");
                    Bokeh.CrossFilter = require("widget/crossfilter");
                    exports.Bokeh = Bokeh;
                    return Bokeh;
                  });
                
                }).call(this);
                
                /*
                //@ sourceMappingURL=main.js.map
                */;
                
                  //The modules for your project will be inlined above
                  //this snippet. Ask almond to synchronously require the
                  //module value for 'main' here and return it as the
                  //value to use for the public API for the built file.
                  return require('main');
                }));
                
                /* END /Users/bucci/anaconda/lib/python2.7/site-packages/bokeh/server/static/js/bokeh.js */
        </script>
        <script type="text/javascript">
            Bokeh.set_log_level("info");
        </script>

        <script type="text/javascript">
            $(function() {
                var modelid = "43d7427b-50e9-4627-aca6-3197d85650d1";
                var modeltype = "PlotContext";
                var elementid = "adce57a8-ee03-40b3-8be4-b7543adabc0b";
                Bokeh.logger.info("Realizing plot:")
                Bokeh.logger.info(" - modeltype: PlotContext");
                Bokeh.logger.info(" - modelid: 43d7427b-50e9-4627-aca6-3197d85650d1");
                Bokeh.logger.info(" - elementid: adce57a8-ee03-40b3-8be4-b7543adabc0b");
                var all_models = [{"attributes": {"doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "id": "e8ebbeac-f119-49ba-ab5f-71024b30b245", "tags": []}, "type": "CategoricalTickFormatter", "id": "e8ebbeac-f119-49ba-ab5f-71024b30b245"}, {"attributes": {"nonselection_glyph": {"type": "Rect", "id": "709b07c4-c00b-418d-a31f-a651ea743325"}, "data_source": {"type": "ColumnDataSource", "id": "8f4f2c93-ae5e-4e36-a319-573c1aaec334"}, "name": null, "server_data_source": null, "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "selection_glyph": null, "id": "cfdd8ab0-ba22-4a67-b454-c8d82a214bec", "glyph": {"type": "Rect", "id": "55d9a8b6-5250-4c16-8e28-7b1d4b74e2dd"}}, "type": "GlyphRenderer", "id": "cfdd8ab0-ba22-4a67-b454-c8d82a214bec"}, {"attributes": {"plot": {"type": "Plot", "id": "3b139fed-822c-481a-8305-19d023e04d46"}, "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "formatter": {"type": "CategoricalTickFormatter", "id": "e8ebbeac-f119-49ba-ab5f-71024b30b245"}, "ticker": {"type": "CategoricalTicker", "id": "595aec41-1460-4722-9384-d16e38f93261"}, "id": "4aaaed4f-1c04-43ca-928a-12161feb8ff7"}, "type": "CategoricalAxis", "id": "4aaaed4f-1c04-43ca-928a-12161feb8ff7"}, {"attributes": {"factors": ["0", "1", "2", "3", "4", "5", "6", "7"], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "tags": [], "id": "c2cdbb49-ca4c-4694-82fd-682ada41bb3b"}, "type": "FactorRange", "id": "c2cdbb49-ca4c-4694-82fd-682ada41bb3b"}, {"attributes": {"factors": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "tags": [], "id": "a45a9db0-e383-4aa4-97f4-48ef6eb20bf9"}, "type": "FactorRange", "id": "a45a9db0-e383-4aa4-97f4-48ef6eb20bf9"}, {"attributes": {"tooltips": {"id": "@id"}, "plot": {"type": "Plot", "id": "3b139fed-822c-481a-8305-19d023e04d46"}, "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "renderers": [], "id": "def05824-13bb-406a-9d0c-60b06e391423", "names": [], "always_active": true}, "type": "HoverTool", "id": "def05824-13bb-406a-9d0c-60b06e391423"}, {"attributes": {"doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "id": "b5ade0a5-a415-40d6-8a8d-a74baf081f6c", "tags": []}, "type": "CategoricalTickFormatter", "id": "b5ade0a5-a415-40d6-8a8d-a74baf081f6c"}, {"attributes": {"plot": {"type": "Plot", "id": "3b139fed-822c-481a-8305-19d023e04d46"}, "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "formatter": {"type": "CategoricalTickFormatter", "id": "b5ade0a5-a415-40d6-8a8d-a74baf081f6c"}, "ticker": {"type": "CategoricalTicker", "id": "071c59c2-fc9f-4461-b28e-0018ce4a7fa0"}, "id": "70832e83-a59d-48e7-927c-0c6a4a41fff9"}, "type": "CategoricalAxis", "id": "70832e83-a59d-48e7-927c-0c6a4a41fff9"}, {"attributes": {"tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "id": "071c59c2-fc9f-4461-b28e-0018ce4a7fa0", "num_minor_ticks": 5}, "type": "CategoricalTicker", "id": "071c59c2-fc9f-4461-b28e-0018ce4a7fa0"}, {"attributes": {"plot": {"type": "Plot", "id": "3b139fed-822c-481a-8305-19d023e04d46"}, "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "dimension": 1, "ticker": {"type": "CategoricalTicker", "id": "595aec41-1460-4722-9384-d16e38f93261"}, "id": "47528b9d-cfde-49d9-b8ec-205b02eaf9e9"}, "type": "Grid", "id": "47528b9d-cfde-49d9-b8ec-205b02eaf9e9"}, {"attributes": {"tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "id": "595aec41-1460-4722-9384-d16e38f93261", "num_minor_ticks": 5}, "type": "CategoricalTicker", "id": "595aec41-1460-4722-9384-d16e38f93261"}, {"attributes": {"plot": {"type": "Plot", "id": "3b139fed-822c-481a-8305-19d023e04d46"}, "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "dimension": 0, "ticker": {"type": "CategoricalTicker", "id": "071c59c2-fc9f-4461-b28e-0018ce4a7fa0"}, "id": "4a61fa17-e7a1-4063-8c42-bf47b84c722d"}, "type": "Grid", "id": "4a61fa17-e7a1-4063-8c42-bf47b84c722d"}, {"attributes": {"line_color": null, "line_alpha": {"units": "data", "value": 1.0}, "fill_color": {"units": "data", "field": "color"}, "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "fill_alpha": {"units": "data", "value": 1.0}, "height": {"units": "data", "value": 1}, "width": {"units": "data", "value": 1}, "y": {"units": "data", "field": "y"}, "x": {"units": "data", "field": "x"}, "id": "55d9a8b6-5250-4c16-8e28-7b1d4b74e2dd"}, "type": "Rect", "id": "55d9a8b6-5250-4c16-8e28-7b1d4b74e2dd"}, {"attributes": {"column_names": ["color", "y", "id", "x"], "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "selected": [], "discrete_ranges": {}, "cont_ranges": {}, "data": {"color": "#96fa00", "y": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95], "id": ["text_50", "text_51", "text_52", "text_53", "text_54", "text_55", "text_56", "text_57", "text_58", "text_59", "text_69", "text_68", "text_65", "text_64", "text_67", "text_66", "text_61", "text_60", "text_63", "text_62", "text_87", "text_86", "text_85", "text_84", "text_83", "text_82", "text_81", "text_80", "text_89", "text_88", "text_78", "text_79", "text_72", "text_73", "text_70", "text_71", "text_76", "text_77", "text_74", "text_75", "text_94", "text_95", "text_96", "text_90", "text_91", "text_92", "text_93", "text_18", "text_19", "text_14", "text_15", "text_16", "text_17", "text_10", "text_11", "text_12", "text_13", "text_29", "text_28", "text_21", "text_20", "text_23", "text_22", "text_25", "text_24", "text_27", "text_26", "text_8", "text_9", "text_6", "text_7", "text_4", "text_5", "text_2", "text_3", "text_1", "text_36", "text_37", "text_34", "text_35", "text_32", "text_33", "text_30", "text_31", "text_38", "text_39", "text_43", "text_42", "text_41", "text_40", "text_47", "text_46", "text_45", "text_44", "text_49", "text_48"], "x": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]}, "id": "8f4f2c93-ae5e-4e36-a319-573c1aaec334"}, "type": "ColumnDataSource", "id": "8f4f2c93-ae5e-4e36-a319-573c1aaec334"}, {"attributes": {"x_range": {"type": "FactorRange", "id": "c2cdbb49-ca4c-4694-82fd-682ada41bb3b"}, "right": [], "above": [{"type": "CategoricalAxis", "id": "70832e83-a59d-48e7-927c-0c6a4a41fff9"}], "data_sources": [], "toolbar_location": "above", "title": "Text test", "extra_y_ranges": {}, "plot_width": 300, "renderers": [{"type": "CategoricalAxis", "id": "70832e83-a59d-48e7-927c-0c6a4a41fff9"}, {"type": "Grid", "id": "4a61fa17-e7a1-4063-8c42-bf47b84c722d"}, {"type": "CategoricalAxis", "id": "4aaaed4f-1c04-43ca-928a-12161feb8ff7"}, {"type": "Grid", "id": "47528b9d-cfde-49d9-b8ec-205b02eaf9e9"}, {"type": "GlyphRenderer", "id": "cfdd8ab0-ba22-4a67-b454-c8d82a214bec"}], "extra_x_ranges": {}, "plot_height": 300, "tool_events": {"type": "ToolEvents", "id": "b813e54b-e3c9-44de-9cc2-7bd499e1fa88"}, "tools": [{"type": "HoverTool", "id": "def05824-13bb-406a-9d0c-60b06e391423"}], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "id": "3b139fed-822c-481a-8305-19d023e04d46", "y_range": {"type": "FactorRange", "id": "a45a9db0-e383-4aa4-97f4-48ef6eb20bf9"}, "below": [], "tags": [], "left": [{"type": "CategoricalAxis", "id": "4aaaed4f-1c04-43ca-928a-12161feb8ff7"}]}, "type": "Plot", "id": "3b139fed-822c-481a-8305-19d023e04d46"}, {"attributes": {"line_color": {"value": "#1f77b4"}, "angle_units": "deg", "fill_color": {"value": "#1f77b4"}, "height": {"units": "data", "value": 1}, "visible": null, "end_angle_units": "deg", "size_units": "screen", "line_join": "miter", "id": "709b07c4-c00b-418d-a31f-a651ea743325", "line_alpha": {"units": "data", "value": 0.1}, "angle": {"units": "data", "field": "angle"}, "dilate": false, "radius_units": "data", "width": {"units": "data", "value": 1}, "valign": null, "length_units": "screen", "tags": [], "start_angle_units": "deg", "line_cap": "butt", "line_dash": [], "line_width": {"units": "data", "field": "line_width"}, "name": null, "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "fill_alpha": {"units": "data", "value": 0.1}, "halign": null, "y": {"units": "data", "field": "y"}, "x": {"units": "data", "field": "x"}, "margin": null, "line_dash_offset": 0}, "type": "Rect", "id": "709b07c4-c00b-418d-a31f-a651ea743325"}, {"attributes": {"geometries": [], "tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "id": "b813e54b-e3c9-44de-9cc2-7bd499e1fa88"}, "type": "ToolEvents", "id": "b813e54b-e3c9-44de-9cc2-7bd499e1fa88"}, {"attributes": {"tags": [], "doc": "693a5fff-4b59-4634-9fc9-d8d090f44121", "id": "43d7427b-50e9-4627-aca6-3197d85650d1", "children": [{"type": "Plot", "id": "3b139fed-822c-481a-8305-19d023e04d46"}]}, "type": "PlotContext", "id": "43d7427b-50e9-4627-aca6-3197d85650d1"}];
                Bokeh.load_models(all_models);
                var model = Bokeh.Collections(modeltype).get(modelid);
                var view = new model.default_view({model: model, el: '#adce57a8-ee03-40b3-8be4-b7543adabc0b'});
                Bokeh.index[modelid] = view
            });
        </script>
    </head>
    <body>
        <div class="plotdiv" id="adce57a8-ee03-40b3-8be4-b7543adabc0b"></div>
    </body>
</html>